<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>学术出版道德</title>
    <url>/academic-ethics/</url>
    <content><![CDATA[
{% centerquote %}遵守学术道德，规范学术氛围。{% endcenterquote %}

<!--more-->

论文的发表对取得学术上的成功至关重要。然而，不合适的引用或重复使用已发表过的学术内容，不但会降低发表论文的可能性，还有可能影响到作者本人的学术事业前景。

[抄袭的定义](https://ori.hhs.gov/definition-misconduct)：美国科研诚信办公室（The Office of Research Integrity）把抄袭定义为“使用他人的学术见解、进程、结果或者文字而没有合适地归功于别人”。换句话说，抄袭就是错误地把别人的原创学术见解归功于自己 。抄袭行为的后果是非常严重的，降低一个研究者的可信度，导致学术文章被拒稿或撤稿，甚至导致研究者被所在的大学或者研究机构除名。

**两种最为常见的抄袭模式**：

1）一字不差的抄袭：从别人的著作完全一字不落的复制。如果直接复制了不同文献的内容，这种形式的抄袭将被认为是东拼西凑。

2）抄袭别人的学术见解：提到别人独特的学术见解而不明确指明该见解的文献来源。这里的学术见解包括理论、说明、数据、方法、观念或者新术语。值得注意的是，在这一点上，即使用自己的语言解释别人的学术见解不标明来源，仍算抄袭。

对于学术文献非常熟悉的同行评审可能会发现与已发表过的论文上的相似的数据或者文字，并且会将抄袭行为通报期刊。可以肯定的是，无论是容易辨认的抄袭方式和不常见的抄袭方式都是不被学术论文发表界容忍的。研究者们该如何避免被认定为抄袭但是仍然自如地进行文献引用呢？

1. **进行学术写作时都应该避免**，包括：

    - **不严谨的释义**：对他人的著作转述时仅仅进行了略微的改变，沿用他人的逻辑且保持了大多数或者全部的学术见解。 值得注意的是，他人的逻辑也是学术见解的一部分。
    - **抄袭其他文献**：没有引用已发表的、非学术文献的内容。任何对您论文有贡献的书籍、网页、博客、讲座和个人之间的交流（包括对还没发表的学术见解的描述），都应当与期刊论文一样被注释和引用。
    - **自我抄袭和重复发表**：少量（比如重复使用您已经发表的论文中研究方法部分的一个段落）或大量（比如在两个不同的期刊上发表相同的论文）重复使用您之前已经发表的文字。这也许是最容易被忽视的一种抄袭方式。尽管自我抄袭和重复发表不是剽窃他人原创学术见解，但是这种行为也是不道德的。特别是许多期刊都要求确认论文没有在别的期刊重复发表，这种做法有可能违反版权法。
1. 什么时候需要引用？
    - 一字不落的引用原文，即使是仅仅引用一个独特的两个字的短语，也应当放在双引号里面。只引用与论文相关的内容。当引用很独特且很难转述的短句的时候，双引号特别的有用。在双引号里面。只引用与论文相关的内容。当引用很独特且很难转述的短句的时候，双引号特别的有用。
    - 转述独特的学术见解、逻辑或其他信息时，无论文献的出处，都需要正确地转述和明确地指明文献出处，并清晰地将他人及自己的学术见解、论断和逻辑区分开来。
    - 论述您之前发表的著作或者论文。
    - 重提或者使用别人的图表（确定获得别人的同意以后）。
1. 什么时候不需要引用？
    - 在论文中第一次详细论述您自己的研究工作。
    - 论述常识－－那些大众常用的文献中的信息或在超过5篇论文中未经引用的就是常用的信息（例如，历史事件的日期或者常识性的实验方法）。值得注意的是，很多时候，学术领域的常识未必是大众都知道的常识。要是不确定某些信息是否是常识性的，以防万一，请尽量使用引用为好。
1. 在写作之前，在看文献的时候，要十分谨慎地记录所有参考文献的来源。在这里推荐大家使用管理文献引用的软件。
2. 在写作的时候，不要去直接参考您引用的文献，这样就可以避免无意识地复制行为。
3. 在写作以后，检查您的文稿和文献引用列表，保证所有合适的参考文献来源都被正确地引用。

> 参考文献：  
> 1. [学术出版道德之如何有效地避免抄袭 ](http://blog.sciencenet.cn/blog-3344631-1073489.html)

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>学术道德</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能</title>
    <url>/artificial-intelligence/</url>
    <content><![CDATA[
人工智能（Artificial Intelligence），英文缩写为AI。它是研究、开发用于模拟、延伸和扩展人的智能的理论、方法、技术及应用系统的一门新的技术科学。人工智能是计算机科学的一个分支，它企图了解智能的实质，并生产出一种新的能以人类智能相似的方式做出反应的智能机器。人工智能的研究领域也在不断扩大，包括专家系统、机器学习、进化计算、模糊逻辑、计算机视觉、自然语言处理、推荐系统等。

<!--more-->

人工智能研究的一个主要目标是使机器能够胜任一些通常需要人类智能才能完成的复杂工作。但不同的时代、不同的人对这种“复杂工作”的理解是不同的。简言之，人类智能由三个部分构成。如果所有三个部分都可以在一台机器上复制或近似复制，那么我们就拥有了一个人工智能系统。

- 通过多维数据源感知（Perception through a multi-dimensional data source）
- 对步骤1的数据中进行模式识别（Pattern recognition within the data set referred in step 1 above）
- 在给定的情境下做出决策（Decision making within the given context）

![人工智能框架图](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190418125816.png)

> [深入理解人工智能和机器学习](https://medium.com/swlh/artificial-intelligence-vs-machine-learning-is-it-confusing-3ace59aa0d19)

工程师Narasimha Prasanna HN撰写的技术博文“[what-is-artificial-general-intelligence](https://mp.weixin.qq.com/s/em1NisiFmXwLmwH7_UXwWw)”主要介绍人工智能的概念，当前人工智能的水平，以及什么是强人工智能，当前实现强人工智能的方向。

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>ArtificialIntelligence</tag>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>百度云盘下载工具</title>
    <url>/bdy/</url>
    <content><![CDATA[
{% centerquote %}为百度云盘配置快速下载器。{% endcenterquote %}

<!--more-->

<div id="IDM"></div>

# 直链提取

## 配置插件

JS插件适用于常见浏览器（Chrome 、 Firefox、Safari、Microsoft Edge、Opera 等）。插件的原理就是屏蔽掉百度云客户端的启动，直接获取下载地址。

1. 根据自己使用的浏览器（推荐使用Chrome）选择安装[Tampermonkey 插件](https://tampermonkey.net/?ext=dhdg&browser=chrome)。

1. 打开[百度网盘直链下载助手](https://www.baiduyun.wiki/install.html)，点击`安装最新版`即可安装启用。

## 配置IDM

IDM 详细配置方法，点击访问[下载安装和使用IDM](https://sli1989.github.io/windows-use/#idm)。

1. 然后进入`我的网盘`，选择目标文件，`下载助手`-`API下载`-`显示链接`（可能会显示多个链接，选一个就可以）。如果IDM正常配置，点击链接就会跳转到IDM下载页面。如果失效，右键选择`使用IDM下载`。

<div id="bdy-plugin"></div>

# 其他插件

- [网盘离线下载的 Firefox 扩展](http://www.appinn.com/baidupan-115-lixian-send-links/)，用来将下载链接快速发往百度盘或者 115 的离线下载，并不需要打开 百度盘/115 的网页端或者客户端。
- [BaiduPCS-Go](https://www.appinn.com/baidupcs-go/) 是一款开源的百度盘下载工具，命令行式操作，可以用来下载百度盘账号内的文件，支持获取下载直链、离线下载、多并发、秒传文件等功能，拥有 Win、macOS、Linux 客户端，以及支持在 Android 和 iOS 使用。

---
]]></content>
      <categories>
        <category>Software</category>
        <category>Baiduyun</category>
      </categories>
      <tags>
        <tag>百度云盘</tag>
      </tags>
  </entry>
  <entry>
    <title>台球基础教程</title>
    <url>/billiards-tutorial/</url>
    <content><![CDATA[
{% centerquote %}介绍台球基础，畅享台球人生。{% endcenterquote %}

<!--more-->

<div class="note info"><p>影像资料来源于【斯诺克台球 基础入门 台球视频教程 刘军】</p></div>

# 球杆

工欲善其事，必先利其器。

- 球杆重：出杆更易稳定，轻发力难度更高。球杆轻：出杆更难稳定，轻发力难度更低。
- 任何物体都有弹性，球杆也一样；弹性的好坏，是球杆好坏的重要标准。球杆弹性分两类：纵向弹性、横向弹性。
    - 横向弹性差，球杆更硬，出杆准度更容易稳定，但更难出旋转。横向弹性好，球杆更软，出杆准度更容易不稳定，但更易出旋转。
    - 纵向弹性更好，更容易打出发力透（这个需要后面才能解释）的球。纵向弹性更差，更不容易打出发力透的球。

# 击球流程

## 握杆

1. 拇指和食指在虎口处用轻力握住球杆；其余3个手指要虚握。
1. 握杆时**手腕要自然垂下**，既不要外翻，也不要内收。
1. **手肘到手腕必须与球杆成垂直状态**（避免力量损失），我们在做抽打动作时，是以手肘为中心，手腕像时钟的钟摆一样地前後摆动。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvbxdnn8j20dt0dtmxt.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvc3hqsrj20dt0dtwew.jpg)

需要根据主球离库边的远近、不同力度出杆等情况，握杆的位置可以偏前或偏后。

- 主球贴库时，要握接近杆的重心位置；
- 主球较远时，可以握杆靠近尾部的位置；
- 如需要大力击球时，握杆手亦可以往后握，以加大握杆和出杆的距离，便于发力。


## 架桥

标准的架桥位置是**距离母球大约15公分左右**，该手应当保持一定的弯度并有可调节性。我们可能因母球撞点的不同而调整架桥的形状、手指头的高度。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvcffqnqj20eg0a8aa8.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvcl5q7zj20dt0dt74s.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvcp144jj20f70cf0tb.jpg)

## 站位与身体姿势

1. 面对主球，手握球杆指向白球并尽量靠近，以不碰球为限。
1. 握杆手置于体侧，同时对下球点和主球将要走的位置进行确定。
1. 右脚站在目标线的连线上，左脚直接左上角30度开立，与肩同宽。
2. 站好脚位置后，上体向右侧转60度（胯部不动，右腿绷直，左腿呈弓形，留出持杆的位置）并向下弯身。同时伸出左手架杆，架杆手微曲。使肩部拉起，上体前倾，与台面接近，头微微抬起，下颌正中部位与手或球杆相贴，握杆的右手大臂保持和球杆在同一直线。双眼顺球杆方向平视，使面部之中线与球杆和后臂处在一个较为垂直的平面上。右手小臂和手腕放松，自然下垂。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvcuj1asj20f70cfjs2.jpg)
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvcyp5vuj20cg0fgt96.jpg)

<div class="note warning"><p>不可站的太近。</p></div>

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvd4mj3sj20eg0a8q35.jpg)

<div class="note info"><p>前手要抬起，支撑手跟台面无明显支撑力，没有台面依然可以支撑。</p></div>

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvdahtuej20dt0itdgz.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvq09mxcj20hs0a1dnw.jpg)

<div class="note info"><p>球杆尽量跟台面平行。</p></div>

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvqd72eyj20eg0a8aa9.jpg)


## 瞄准

假想的母球原则：可以利用三点一线的原理，

1. 在假想母球的位置上再放一颗母球②，然后运杆瞄准；
1. 瞄完后人不要动，把母球②拿走，再次瞄准并击球。

如此经过长期反复的训练后，初学者便能够较快地找到进球线路的感觉。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvqibblvj20dt0itdgi.jpg)

## 运杆

将杆头送到母球最近处停顿（确定瞄准击打母球点及目标球点），反复抽杆并对整体姿势进行最后的确认并作出微调。对握杆的位置及力度作出的调整。

- 用固定平稳的抽杆速度保持击球的节奏感；  
- 调整击球的方向找出入球点；  
- 调整击球的点位及力度感觉白球的方向和线路；  
- 确保整体姿势不会影响出杆；  
- 确保虎口、手腕、前臂能形成直线；  
- 确保握杆的手也包括肩部与球杆在同一直线上；  
- 完成姿势调整后除握杆的手外身体必需要保持固定状态；

它的要领是以弯曲的手肘为轴，然後将手腕像钟摆一样的前后摆动。切不可上下晃动或左右晃动。水平运杆，摆动的次数不要少于三次，要以缓慢的速度前后摆动，等到力道平顺之后才可以击球。这时肩膀与手肘或手腕不可以用力，要在轻松自然的状态下摆动。

握杆手手型。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvqibblvj20dt0itdgi.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvqtdzifj20dt0dt0t7.jpg)

## 出杆

前停-后摆-后停-出杆-送杆-再停：白球控制。要有自己的运杆节奏。击球的力度与击球前的运杆距离、速度有关。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvqz9wghj20dt0dtaam.jpg)

### 前停

停止抽杆后球杆停顿于靠近白球的位置。再次确认想打的母球击球点以及目标球的落袋线路（通过假想的母球原则），这样形成的瞬间记忆将会巩固母球的打点位置和进球角度。

要点：注意力集中于白球；感觉击球的厚薄度；感觉入球的线路；感觉白球的线路。

### 后摆

前停之后的最后一次抽杆。
要点：抽杆距离能短则短；抽杆的同时感觉击球的力度大小；确定抽杆的距离。

### 后停

出杆之前的停顿。
要点：注意力集中于目标球；停顿的时间永远不要比平时短；需要保持一贯的节奏感；完全放松整个后手；感受球杆的重量准备将其抛出。

### 出杆

虎口轻夹球杆直线向前抛出。

要点：

- 出杆击球要用球杆本身的重量，即是杆力；
- 出杆击球不能用暴力，也不能用手的力；
- 出杆务必做到绝对的直；
- 出杆时除握杆的手外身体其他任何部分必需要保持固定状态；
- 出杆时高度集中精神如有分神则应重新调整；
- 出杆前注意力应集中于目标球上，切勿转移到白球的走位以免影响准度。

### 送杆

击球后球杆保持向前直送延长皮头与白球的接触。

要点：送杆的长短是决定穿透力的因素之一；但并不是所有的击球都需要送杆；

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvr46ywnj20dt0dtaah.jpg)

<div class="note info"><p>当你以平稳的抽打动作撞击母球时，球杆尖必须从母球停止的位置上往前推出10公分左右。这种现象称为充分推击，在你的充分推击结束前，必须稳住架桥不能稍有晃动，这也是正确击球的要点。</p></div>

### 再停

完成所有击球动作之后身体保持静止状态。

要点：除非容易造成犯规否则应该保持身体静止看球；用以防止过早起身影响出杆；如此可以形成良好的击球习惯。

## 起身

# 力道

人不是机器，在力量控制上很难做到非常精确，所以需要采取一些技巧来辅助强化对力量控制的记忆。

划分好自己的力道等级，运杆到最后方停住时，线段C0C1的长度决定了力道的大小，力道训练中一般会平均划分为10个等级的力道（甚至更多），每2格的距离为1个斯诺克球的直径，力道P10为满力，力道1为最小力道；

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvraq1q5j20d405smx4.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvrx8p44j20hs0a1wml.jpg)

进行满力训练：在正确姿势和正确出杆的基础上，进行最大力道的训练和强化，练习过程中需要确保动作不变形，如果做不到不变形，请先练习基础。如图把手臂运到M1，即球杆运到P10的位置（此时皮头和白球打点的距离C0C1为5个球直径），然后尽全力击打，直到每次发力力量基本一致；那么如何判断每次发力一致，可以考虑采取推杆/拉杆（不采用stun，是因为stun对力道不敏感）打法，看每次推杆/拉杆后白球的运动距离是否一样，这个过程也可以同步训练推杆/拉杆。直至每次满力发力力道基本一致之后，改用stun follow/stun draw进行判断，这个过程也可以同步训练stun。

进行各力道训练：用上面的方法，进行P1-P9的各个力道的训练，建议先训练中等力道，如P4-P6，因为中等力道最常用，也需要练习到最稳定的状态。练习时依然是先用推拉杆练，然后用stun练习。

罗尼说道，力度的控制其实是右手抓杆的松紧力度不一样。这点读者可以在练**过程中慢慢体会。

完成上面的各力道训练之后，需要重点进行以下训练，非常重要，也是精准走位的基础：

- 白球与目标球摆成直球，距离5个球直径，分别使用不同的力道（如P1-P10）打出stun follow，且使得白球进袋之后白球向前跟进5个球直径的距离；然后记住对应每个力道的打点（建议只需记住减去精准定杆所需的部分，小距离的stun，精准定杆部分很少，可以忽略不计；根据笔者实践，这个场景下的打点是P6对应打点U0.5）。
- 白球与目标球摆成直球，距离10个球直径，分别使用不同的力道（如P1-P10）打出stun draw，且使得白球进袋之后白球向后回退5个球直径的距离；然后记住对应每个力道的打点（建议只需记住减去精准定杆所需的部分；根据笔者实践，这个场景下的打点是P6对应打点D1，其中的D0.5是用于对应10个球直径距离的精准定杆，其中D0.5是用于白球回退5个球直径的作用，所以就记住0.5即可，即P6要产生5个球直径的运动距离，打点是0.5；而P6要产生10个球直径的运动距离，打点大概是1，那么如果要多回退5个球直径的距离，实际打点大概是D1.5；注意：这个不是完全线性的）。

# 杆法

## 推杆

推杆，即击打白球，白球撞击目标球后，白球继续往前滚动的效果。从【定杆】一节看，中杆也可以打出推杆效果。

推杆效果的几种打法：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvs7h28gj203l03pq2s.jpg)

- 击打白球中点O以上的打点（如U1、U2、U3），利用球杆击打白球产生的向前旋转，和白球与目标球之间距离产生的向前滚动，达到推杆效果；
- 击打白球中点O，利用白球与目标球之间距离产生的向前滚动，达到推杆效果；
- 击打白球中点以下的打点（如D1、D2、D3），使得球杆击打白球产生的向后旋转，小于白球与目标球之间距离产生的向前滚动，达到推杆效果；（此种打法可以起刹车球的效果，是刹车球的打法之一）

即推杆时，需要把白球与目标球之间距离产生的向前滚动量考虑进去。

## 定杆

定杆是精准走位的基础。如果你无法打出精准的定杆，就无法做到精准走位。注意区别于定杆，中杆是击打白球的中点K1，定杆是击打后的效果，一般是需要击打中杆偏下一点的位置K2才有定杆效果。

![定杆](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvsf3t2kj20ew0d7jt7.jpg)

击打白球点K1时，白球一开始自身没有旋转，白球从A点运动到B点，由于在这个过程中台面对白球有向后（如图中向左）的滚动摩擦力，导致白球在B点时有向前的旋转（如图中的顺时针旋转）；于是白球撞击红球后，会继续向前滚动一段距离才停下来。击打白球点K2时，白球一开始就有向后的旋转（如图中的逆时针旋转），白球从A点运动到B点，台面摩擦力依然会导致白球的顺时针旋转；逆时针和顺时针的旋转如果刚好抵消，则打出了精准的定杆。

如何打出精准的定杆：

1. 稳定的姿势和稳定的出杆习惯。
1. 划分好自己的力道等级，运杆到最后方停住时，线段C0C1的长度决定了力道的大小，力道训练中一般会平均划分为10个等级的力道（甚至更多），每2格的距离为1个斯诺克球的直径，力道P10为满力（满力即：在使用正确的姿势和出杆方法的基础上，发自己所能发的最大的力量击球，且姿势和动作不变形），力道1为最小力道；选择一个中等力道进行定杆训练，如下图是手臂在M1位置时，球杆皮头在力道P6的位置，发力力量为满力的6成；需要强化从不同位置出杆的不同力道；职业选手中也有球员（如塞尔比）是基本每次出杆时都从P10位置出杆，但是打出不同力道的，在熟悉了上面的训练之后，体验这种出杆方法会更加容易。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvspk9w5j20hs0igajz.jpg)
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvstqqlgj20d405smxp.jpg)
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvrx8p44j20hs0a1wml.jpg)
1. 选择一个白球与目标球的固定距离（如5个斯诺克球直径的距离，或10个斯诺克球直径的距离）；
1. 将白球的中点往上每隔1个皮头直径做1个单位，大概往上可以划分出3个单位，往下可以划分出3个单位；
1. 将白球与目标球摆成直球，尝试寻找击打白球中点偏低一点的位置，使得用你习惯的中等力道和出杆习惯击打出去之后，白球正好精准的停住，即定杆；此时你需要记住，击打白球偏低一点的位置大概是几个皮头直径（按照笔者的中等力道及出杆习惯，白球与目标球距离是10个球直径时，点位是在白球中点偏下的0.5个皮头的位置，即中点O和点D1中间；熟悉了一个距离之后，需要进行不同距离的打点训练），以后用同样的力道和出杆方法，就可以重新打出精准的定杆了（当然不同球台的台面摩擦系数有所不同、空气湿度不同等因素也会有影响，因此到不熟悉的球台时，力道或打点需要略做微调）。

## 拉杆

拉杆，即击打白球，白球撞击目标球之后，白球往后回退的效果。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvs7h28gj203l03pq2s.jpg)

从【定杆】一节看，打中杆时，滚动过程中会产生向前旋转；打精准定杆需要打白球中点O偏下一点的位置，假设是偏下0.5个皮头距离的位置，表示为：D0.5（D：下方，0.5：0.5个皮头的距离）；那么要打出拉杆，至少需要在精准定杆的打点位置下方，才能打出拉杆效果。

拉杆时，第一步是找到精准定杆的白球打点，然后根据需要选择这个打点下发的点来击打。“向后滚动并向前滑动”是低杆的精髓。保持向前滑动的时间越长，向后滚动的效果就越明显。

## 斯登

“不懂斯登，你就不懂斯诺克”，可见斯登在斯诺克中的重要性，职业比赛中，球员也是大量用到斯登效果。

- stun（斯登，有时也叫蹬杆/登杆）：白球撞击目标球的时候没有任何旋转；运动时只有横向滑动。类似【定杆】，用于精准横向走位。
- stun follow：白球撞击目标球的时候有少许向前旋转；运动时横向滑动且带有少许向前旋转。类似【推杆】，用于精准横向向前走位。
- stun draw：白球撞击目标球的时候有少许向后旋转；运动时横向滑动且带有少许向后旋转。类似【拉杆】，用于精准横向向后走位。

体验stun：即控制白球在滑行阶段撞击目标球。在球杆击打完白球之后，白球一定先是进入滑行阶段，再进入滚动阶段。stun就是要求白球在滑行阶段的时候，撞击到目标球。而只要把力打透，就可以把这种滑行轻松打出来。

从上文可以看到，只要是这种滑行的撞击，即可理解为是stun。而一般情况下，在准度上，发力越小，准度越高（越不容易打偏或出塞）；发力越大，准度越低（越容易打偏或出塞）。所以，高水平的stun，是用小力打出同等效果的stun。而不是简单的发大力走小位。但stun也有另一个好处，即可以适当发力，以避免小力击打时台泥的脏东西或其他原因导致白球或目标球路线偏移。这之中的力道把握，需要在准度和安全性上寻找一个均衡点。

使用正确的出杆方法击打白球不同点位时，白球产生的旋转随着力度的增加的幅度变化是不一样的。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvs7h28gj203l03pq2s.jpg)

打点越偏离白球中点，越容易产生旋转，相同的力道变化所产生的白球旋转变化差值也不一样；例如：使用力道P3击打白球点U2时，白球撞击目标球后会向前再运动5个球直径的距离，那么，如果使用力道P4（增加1个力量等级）击打白球点U2时，白球撞击目标球后会向前再运动6.3个球直径的距离，白球多运动了1.3个球直径的距离；但是如果假设使用力道P6击打白球点U1时，白球撞击目标球后会向前再运动5个球直径的距离，那么，如果使用力道P7（增加1个力量等级），白球撞击目标球后会向前再运动5.9个球直径的距离，白球多运动了0.9个球直径的距离；即**打点越靠近白球中点，白球旋转对力道越不敏感，即白球的前后运动距离对力道越不敏感。

这也是为什么经常看到职业选手可以在很用力击打白球之后，白球却只会运动一点点距离的原因。

笔者根据自己的出杆习惯实践，白球离目标球5个球直径的距离，且是直球的情况下：

- 使用力道P6击打白球点U0.5（即白球中点向上0.5个皮头直径的位置），撞击目标球后，白球会向前跟进5个球直径的距离；（黄线）
- 使用力道P3击打白球点U1，撞击目标球后，白球会向前跟进5个球直径的距离；（红线）
- 如果要求撞击目标球后，白球向前跟进5个球直径，且跟进距离误差不得超过1，即白球向前跟进4-6个球直径，则红线力道范围必须在P2.4-P3.6（力道范围：3.6-2.4=1.2）之间，而黄线力道范围只需要在P4.7-P7.2（力道范围：7.2-4.7=2.5）之间即可；后者的力道允许范围更大，更不容易出错；

人的触觉没有视觉精准，很难在力道控制上做到精确，但容易在打点上做到精准，stun便是扬长避短的一个经典案例。同时也可以看到，与其花大力气去苦练力量的精确发力，不如先花苦功夫去练精准的白球打点（当然力量精确发力更可以锦上添花，有些球没有精确发力仅有精准打点也是不行的）。从图中也可以看出，选择比努力重要（请读者自己体会），这也是stun的魅力所在。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvutap23j20j90h3q3d.jpg)

职业球员精准的白球走位，很大程度上是因为打点精准（若打点精确，在力道控制上的要求就相对放宽，如图中黄线）；当可以在打点上做到精确后，就需要训练在力道控制上做到精准，以达到中小力道（中小力道准度更稳定，建议读者可以寻找自己准度最稳定的力道范围，然后多练**在这个力道范围上的stun打点）也可打出同样效果的stun（如图中红线）。所以，一般来讲，黄线的stun，是初水平的stun；红线的stun，是高水平的stun。可以看出，职业选手经常选用中小力道stun，这个选择对他们打点的精准性和力道控制的要求就更高了。

好的发力是很重要的，它可以使球杆在弹性上的效率更高，更容易打透，可选择的打点就更接近白球中点。即，**好的发力可以让你用更小的力道，打出同样的效果，而更小的力道意味着更高的准度**。所以力道练**，是值得下苦功夫训练的；力道练**，其实也是一种准度练**，也是高水平练**。

发力水平有所提高的标准是：用更小的力，击打更接近白球中点的打点，打出了同样效果的stun。（即：如图，当有一天笔者的U0.5的斜线，移到了U1的位置，则说明笔者的发力水平提高了。到这个时候，对打点的精准性要求，也就更高了。）

假设在图中划上U0.1或U0.2的线后会发现，即使力道变化很大，白球运动的范围也仅仅在4个球直径以内，这样就可以做到白球向前/向后（横向走位后面会说到如何控制和练习）的精准走位了，而你需要做的，就是在自己能够稳定一致出杆的情况下，熟悉各个力道，对应不同打点的白球运动距离，并进行记忆和强化训练。

与之前提到的【推杆】和【拉杆】类似，在进行stun follow和stun draw之前，需要把白球与目标球之间的距离考虑进去，选择打点时，先找到打点抵消这段距离产生的旋转，再在此打点基础上，选择打点。

问题：白球与目标球距离10个球直径，且是直球，要求使用stun draw击打目标球后，白球后退5个球直径的距离。

解答（按笔者的出杆习惯）：由于10个球直径的距离要打出精准定杆，力道P6对应的打点是D0.5，而在白球没有任何旋转的情况下，力道P6击打目标球回退5个球所需要的打点也是D0.5，所以正确的打法是使用力道P6，击打白球D1（D1=D0.5+D0.5）的位置。当然也可以采用其他力道进行推算正确的打点。一般会先熟悉中等及最稳定力道下的不同打点的不同走位距离。

当白球与目标球距离较小时（如5个球直径以下），一般可以不用考虑这段距离的影响，因为打stun时，出杆比较快，白球运动速度比较快，这段距离的运动时间短，白球所产生的向前旋转很少。

<div class="note info"><p>stun follow与stun draw，分别和【推杆】与【拉杆】有什么区别和联系？</p></div>

答：概念上，这两者似乎有严格界限，但实际中，这两者是平滑过渡的，没有明显界限。拿stun follow和推杆对比看，假设白球和目标球有一点点角度，stun follow打点是白球中点往上一点（如U0.5），白球撞击目标球后，有大部分横向滑动和小部分向前旋转；而推杆打点是白球中点往上比较多（如U2），白球撞击目标球后，有小部分横向滑动和大部分向前旋转；在上面的坐标系图中，斜率越低，越接近stun效果，斜率越高，越接近推拉杆效果。当然stun和推拉杆，在出杆发力上，也略有不同，如stun的延伸就没有推杆拉杆多（这也是为了降低白球运动对力道的敏感度），这点读者可以回顾【推杆】【拉杆】【斯登】等章节。如果你可以理解到stun和推杆拉杆是没有绝对界限，那说明你对其有了更深入的理解。

# 走位

要学习白球精准走位，首先得了解其原理。

正碰：物理学上，在一个绝对光滑平面（这样A在撞击B之前，不会产生向前旋转），两质量相同的刚性小球A、B，A速度为v，B静止，A沿着AB球心连线的方向撞击B，撞击后，A会静止，B速度会变为v，即A和B发生了速度交换。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvv0utehj20ez0bnjre.jpg)

但是桌球台面并不是光滑的，为了让白球撞击目标球时等价于绝对光滑平面的情况，我们需要确保白球撞击目标球时白球是没有向前向后旋转的，这也就是【定杆】中所讲的精准定杆需要击打白球中点偏下一点的目的，即确保白球撞击目标球时白球无旋转。

斜碰：如果两球是有一定角度，以精准定杆的打点击打（即白球从A1运动到A2后，在A2时，白球没有向前和向后旋转），则碰撞之后，目标球的运动方向是两球的球心连线方向BC1，而白球的运动方向是两球碰撞点的切线方向A2C3，两球运动方向成90度夹角C1BC2。运动速度和线段长度一致。这便是**目标球和白球的运动规律**。白球的精准走位，就是调整A2C3的白球运动方向和距离。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvv8slt5j20f00frdfu.jpg)

前面讨论stun时明白，白球打点越靠近白球中点，白球的前后运动距离对力道越不敏感（即越不容易发生变化）。同样的道理，图中角度a越小，白球朝A2C3方向的运动距离，对力道越不敏感（即：使用精准定杆击打时，角度a越小，白球要再A2C3方向运动更多的距离，就越困难）。我们正可以利用这点，来控制白球的横向走位。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvvk0v7pj20f00frtai.jpg)

那么如何调整A2C3的白球运动方向和距离呢？

假设角度a比较小，白球横向运动距离对力道不敏感，我们就可以利用这点来练精准的横向运动距离控制了。原理和【斯登】的白球精准前后走位一样，下图仅为示意，距离坐标图建议读者：**根据自己的出杆方式，描绘并记忆自己对应各小角度各力道的白球横向运动距离**。这点非常重要，也是精准走位的基础。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvvtyy2pj20hs0fstcx.jpg)
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvw3xenlj20hs0a5my3.jpg)

至此我们已经学会：**白球的精准前后走位、白球的精准左右走位。而白球的实际运动路线，是这两个分运动的合成。**

为方便说明如何调整A2C3的白球运动方向和距离，下面举例来说明。

问题：白球在A1位置，与篮球形成小角度a约18度，直线L1与L2距离为d1=10个球直径，L3与L4距离为d2=20个球直径，要求击打白球打进篮球后，使得白球运动到C3位置，C3距离L1为5个球直径，C3C2方向是底袋以方便下一步击打黑球进底袋，问击打白球的点位和力道如何求算，分别是多少？

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvwvblf7j20ly0cjjrl.jpg)

解答：按以下步骤进行推算（具体数值仅供参考）

1. 横向计算力道：根据角度a，和距离d2，并忽略d1（即先不考虑A1到A2的摩擦），在自己的白球精准左右走位表中，找到对应的力道，使得白球撞击篮球B后，白球运动到C2的位置，查的力道P6；（注意A2C2是白球在A1点时，打精准定杆时的运动方向）
1. 纵向再算打点：在力道P6固定的情况下，假设白球在A0点，击打篮球B后，白球回退到C1，以此为条件在自己的白球精准前后走位表中，找到对应的打点；前面我们实践过，10个球直径（d1）、力道P6的精准定杆打点是D0.5，以力道P6 stun draw 5个球直径（A2C1=C2C3=5个球直径）的打点是D0.5，所以这一步骤算出来的打点是D1=D0.5+D0.5。所以答案是：以P6的力道，击打白球的D1点位，白球打进篮球B后，白球即可到达C3点。（注意A2C3是白球在A1点时，打精准定杆的基础上，往下移动打点，进行击打的运动方向，往上移动打点击打后的运动方向与此类似）

对应于stun follow的计算也类似，读者可考虑下图如何解答（距离同上题）

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvx662ztj20hs0a5my6.jpg)

假设角度a比较大，那么就得老老实实用力道来控制了，这个难度比较高，有时还得用【刹车】的技巧来削减力道。暂不讲解。

# 加塞球

加塞有两种情况：左塞、右塞。加塞一般只有在白球碰到台面之后，塞才会起作用。

- 左塞：击打白球的左侧（中线的左侧区域均可），如图的L1、L2、L3等点位
- 右塞：击打白球的右侧（中线的右侧区域均可），如图的R1、R2、R3等点位

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvxm9o5sj203l03pq2s.jpg)

加塞最需要关注的是球杆的横向弹性和加塞打点；

- 球杆越软，加塞效果越明显，对准度影响越大；
- 球杆越硬，加塞效果越不明显，对准度影响越小；
- 加塞离白球中点越远，加塞效果越明显，对准度影响越大；
- 加塞离白球中点越近，加塞效果越不明显，对准度影响越小；

加塞需要考虑一个普遍的问题，即**修正**。所以加塞的步骤是（以右塞为例，左塞以此类推）：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvy4k57ej20920domy9.jpg)

<div class="note info"><p>注意，加塞是在打球【姿势】形成前，还未趴下时，判断击打方向时L0时，就想好的；而不是趴下后，再去调整白球的加塞打点。</p></div>

1. 找到要击打的方向R0；
1. 根据自身条件及球杆弹性的情况，击打方向朝右一点点角度（因为打右塞时，白球最终的运动会往左边偏一点）；
1. 以L0为所要击打方向（最终白球的运动方向是R0），摆好姿势进行击打；

至于修正的量（即上面步骤2中的角度），与球杆的横向弹性和个人发力有关，这里无法量化，只能读者在实际中建立起球感体会调整：球杆越软，加塞越多（偏离白球中心越多），需要修正的量就越多；反之越少。

由于白球加塞后的旋转，目标球被白球碰撞瞬间的接触点处，白球对目标球是向前的作用力，则为顺塞；反之为反塞；在已加塞了的白球撞击目标球的瞬间，顺塞会使得击打的球有更薄的效果，而反塞会使得击打的球有更厚的效果；利用这点，**顺塞可以把目标球打得更薄，反塞可以把目标球打得更厚**。

<div class="note info"><p>一般情况下，**如非必要，一定不要加塞**，对准度影响很大。即使必须加塞，打点也尽量不要偏离白球中点太远。</p></div>

# 绒毛效应

球桌的台布上的绒毛是从球桌底岸往顶岸梳的，因为这种结构，在球桌上运动的球，会有向顶岸运动的趋势（如图箭头的方向）。

- 这种趋势非常小，一般很难感知到，这种趋势会随白球在运动时的时长逐渐积累起对球运动的影响；
- 绒毛效应在45度的运动方向，效果最明显；球运动速度越慢，效果越明显；
- 不同球台或条件下的绒毛效应不一样，再新台打球需要关注一下其绒毛效应导致的偏差；

如图在下方中袋口放一个白球，用力道P1或P2，沿黑线L1方向将白球推进右上方底袋，会发现，白球的实际运动路线会沿着L2，这便是绒毛效应；

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvyms9r1j20hs0a575o.jpg)

## 对加塞球的作用

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwuvyskq7kj20hs0a540b.jpg)

在A点放置白球，用力道P1或P2等小力道，顺着绒毛的方向沿直线L1（记忆：左左右右）：

- 打左塞，白球会往白球的左边偏，即沿着L2方向运动；
- 打右塞，白球会往白球的右边偏，即沿着L3方向运动；

在B点放置白球，用力道P1或P2等小力道，逆着绒毛的方向沿直线M1（记忆：左右右左）：

- 打左塞，白球会往白球的右边偏，即沿着M2方向运动；
- 打右塞，白球会往白球左边偏，即沿着M3方向运动；

根据上面的规律，第一个图中的白球沿45度角击打时，只要加一点点左塞，便可以抵消一定的往右边的绒毛效应，从而打进右上角的底袋。

# 资源

## 书籍资源

在校学生可以进入图书馆超星数据库下载台球教程，按时间排序，下载最近几年的教程，进行了解。也可以网络搜索相关书籍的PDF版本。以下列举一些比较好的书籍：

- 大学台球教程，李德昌编著--主要介绍相关名词，历史等
- 台球（中映良品编著）--介绍了桌球历史、设备与规则，桌球的基本技术（握杆、姿势、架杆、瞄准、运杆、出杆、跟进），桌球实战技术（跟进球、定位球、缩杆球、回旋球、借助球、反弹球、倒顶球、侧旋球、薄球等）
- 台球入门与指导（膳书堂文化）--介绍了综合心理训练，台球器材，台球礼仪，台球入门（姿势、握杆、瞄准、基本打法）、台球中级技法（反弹球、倒顶球、借力球等），台球高级技法（解球等）
- [网络总结的文字教程](http://pan.baidu.com/s/1hsydyZi)（密码 yn51）
- [【奥沙利文杆法精解】不懂斯登，你就不懂斯诺克。](https://mp.weixin.qq.com/s/U9ym7KJPXklujS3Kc_zE7w)
- [【斯诺克图文教程】尼克·保罗教程](https://mp.weixin.qq.com/s/jbj_uP9fE7S_JTJ0lrt_UA)

## 视频资源

- WPBSA官方斯诺克基础教程
    - [全集](http://v.youku.com/v_show/id_XMjYwMjAxODQ4.html)
    - [握杆 站姿 手架](http://v.youku.com/v_show/id_XMjgwOTM1NDk2.html)
    - [后摆时的握杆 运杆](http://v.youku.com/v_show/id_XMjgwOTM1NjQw.html)
    - [主视眼 瞄准](http://v.youku.com/v_show/id_XMjgwOTM1NzQw.html)
    - [击球 摆臂 停顿 送杆](http://v.youku.com/v_show/id_XMjgwOTM1ODky.html)
    - [击球时机的选择](http://v.youku.com/v_show/id_XMjQ0OTUzMDg0.html)
    - [下球角](http://v.youku.com/v_show/id_XMjQ0OTQyOTQ4.html)
    - [旋转塞、曲线球](http://v.youku.com/v_show/id_XMjQ0OTU0MTg0.html)
    - [旋转增补](http://v.youku.com/v_show/id_XMjgwOTM2NDky.html)
    - [练习方法](http://v.youku.com/v_show/id_XMjQ0OTY1MTIw.html)
    - [手架拓展和架杆](http://v.youku.com/v_show/id_XMjgwOTM2OTY0.html)
    - [大结局](http://v.youku.com/v_show/id_XMjgwOTM3MTE2.html)
- 奥沙利文台球教程
    - [手架](http://v.youku.com/v_show/id_XMjQ4MjY0ODg=.html)
    - [握杆](http://v.youku.com/v_show/id_XMjA4MTQ2NA==.html)
    - [站姿](http://v.youku.com/v_show/id_XODAwOTg2Njg=.html)
    - [瞄准](http://v.youku.com/v_show/id_XODAwOTc5NjA=.html)
    - [出杆](http://v.youku.com/v_show/id_XMjQ4MjYyNzI=.html)
- 丁俊晖斯诺克讲堂
    - [丁俊晖斯诺克讲堂春节特辑（一）击球标准姿势示范](http://news.my147.com/show/52175.html)
    - [丁俊晖斯诺克讲堂春节特辑（二）小晖密授手架方法](http://news.my147.com/show/52189.html)
    - [丁俊晖斯诺克讲堂春节特辑（三）告诉你瞄准的秘密](http://news.my147.com/guonei/2014/01/52202.html)
    - [丁俊晖斯诺克讲堂春节特辑（四）轻松掌握各种杆法](http://news.my147.com/guonei/2014/01/52225.html)
    - [丁俊晖斯诺克讲堂春节特辑（五）扎杆的练习窍门](http://news.my147.com/show/52264.html)
    - [丁俊晖斯诺克讲堂春节特辑（六）架杆器的使用技巧](http://news.my147.com/show/52328.html)
    - [丁俊晖斯诺克讲堂春节特辑（七）如何打出单杆过百](http://news.my147.com/show/52337.html)
    - [丁俊晖斯诺克讲堂春节特辑（八）清彩球培养手感](http://news.my147.com/show/52349.html)
    - [丁俊晖斯诺克讲堂春节特辑（九）常用的开球方法](http://news.my147.com/show/52362.html)
    - [丁俊晖斯诺克讲堂春节特辑（十）定杆的练习方法](http://news.my147.com/show/52390.html)
- [【台球教学】从业余到高手的华丽蜕变|youtube](https://www.youtube.com/playlist?list=PLxhXDJLk9OWdHeeLemIDvO5SBNEPmhKhN)
- [台球一号](http://www.youku.com/playlist_show/id_5417104.html?page=2&mode=pic&ascending=1)
- [奥沙利文杆法精解](http://tieba.baidu.com/p/3678539694)
- [【希世至宝】球杆控制技巧 ---尼克.保罗 著 ](http://tieba.baidu.com/p/2427442422?see_lz=1)
- [【斯诺克视频教程】史蒂芬李教程](https://mp.weixin.qq.com/s/qKyRTWTdJnlHobmw_nYSmw)
- [【斯诺克视频教程】庞卫国教程（全）](https://mp.weixin.qq.com/s/bGeh0RFUnb97nU4mtIlvIQ)

# 训练方案

[新锐台球学院-分级训练](https://www.buole.com/billiards_grading/index)

---
]]></content>
      <categories>
        <category>Life</category>
        <category>Billiards</category>
      </categories>
      <tags>
        <tag>Billiards</tag>
      </tags>
  </entry>
  <entry>
    <title>比特币</title>
    <url>/bitcoin/</url>
    <content><![CDATA[

比特币（BitCoin）的概念最初由[中本聪在2008年提出](https://bitcoin.org/en/bitcoin-paper)，根据中本聪的思路设计发布的开源软件以及建构其上的P2P网络。比特币是一种P2P形式的数字货币。与大多数货币不同，比特币不依靠特定货币机构发行，它依据特定算法，通过大量的计算产生，比特币经济使用整个P2P网络中众多节点构成的分布式数据库来确认并记录所有的交易行为，并使用密码学的设计来确保货币流通各个环节安全性。比特币与其他虚拟货币最大的不同，是其总数量非常有限，具有极强的稀缺性。比特币可以用来兑现，可以兑换成大多数国家的货币。

<!--more-->

本文根据博文“[一个故事告诉你比特币的原理及运作机制](http://blog.codinglabs.org/articles/bitcoin-mechanism-make-easy.html)”和“[比特币入门教程](http://www.ruanyifeng.com/blog/2018/01/bitcoin-tutorial.html)”整理一下比特币提出的动机、解决了什么问题以及一些关键组件的目标和设计方案。

> [Bitcoin: A Peer-to-Peer Electronic Cash System](http://bitcoin.org/bitcoin.pdf)  
> [https://bitcoin.it](https://bitcoin.it/)  
> [云风的BLOG: Bitcoin 的基本原理](http://blog.codingnow.com/2011/05/bitcoin.html)  
> [易懂的比特币工作机理详解](http://www.btc123.com/data/docs/easy_understood_bitcoin_mechanism.pdf)  

# 比特币钱包

比特币暴涨，其他加密货币（cryptocurrency）也像雨后春笋一样冒出来，已经有1000多种了。

钱的本质，或者说货币的本质，就是它的可信性。它必须使人们相信，它是有价值的，然后才能成为钱，才能被收藏和支付。可信的东西是否就是钱？一样东西能否成为钱，只取决于人们是否相信它的价值，至于它是不是真的有价值，根本不重要。

比特币要解决的核心问题，就是创造一种可信的数字凭证。由于这种凭证可信，所以能够当做货币。比特币的技术基础是加密学，这也是这一类数字凭证被称为"加密货币"的原因。

- 它不会被轻易偷走。理解比特币必须理解非对称加密。公钥是公开的，任何人都可以获取。私钥是保密的，只有拥有者才能使用。他人使用你的公钥加密信息，然后发送给你，你用私钥解密，取出信息。反过来，你也可以用私钥加密信息，别人用你的公钥解开，从而证明这个信息确实是你发出的，且未被篡改，这叫做数字签名（更详细的介绍请看[《什么是数字签名》](http://www.ruanyifeng.com/blog/2011/08/what_is_a_digital_signature.html)）。由于支付的钱必须通过私钥取出，所以你是谁并不重要，重要的是谁拥有私钥。对于比特币来说，钱不是支付给个人的，而是支付给某一把私钥。这就是交易匿名性的根本原因，因为没有人知道，那些私钥背后的主人是谁。所以，比特币交易的第一件事，就是你必须拥有自己的公钥和私钥，而且一定要保护好私钥。
- 它无法伪造。每一个比特币都能追溯来源，而所有比特币都来源于矿工获得的奖励。矿工只有新建区块，才能获得奖励，这是很难的事情，所以无法伪造比特币。
- 它无法大批生成。原因跟上一条一样，比特币的发行速度是稳定的，现在每10分钟新增12.5个，然后每四年减半，最终停止增长。因此不会像纸币那样，政府滥发导致通货膨胀。


你去网上那些比特币交易所开户，它们会让你首先生成一个比特币钱包（wallet）。这个钱包不是用来存放比特币，而是存放你的公钥和私钥。

根据协议，公钥的长度是512位。因此协议又规定，要为公钥生成一个160位的指纹。所谓指纹，就是一个比较短的、易于传播的哈希值。这个字符串就叫做钱包的地址，它是唯一的，即每个钱包的地址肯定都是不一样的。你向别人收钱时，只要告诉对方你的钱包地址即可，对方向这个地址付款。

# 问题的提出

我们先从比特币产生的动机开始。

## 以物易物的比特村

话说在这个世界上，有一个叫比特村的小村庄，村庄共有几百户人家。这个村庄几乎与世隔绝，过着自给自足的生活。由于没有大规模贸易，比特村村民一直过着以物易物的生活，也就是说村民之间并没有使用统一的货币，互相间的贸易基本上就是老张家拿一袋面粉换老李家一只羊，王大嫂拿一筐野果换刘大婶两尺布。村民们一直就这么纯朴的生活着。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/01.png)

## 实物货币

终于有一天，村民觉得一直这样以物易物实在太不方便了，于是村子全员开会，讨论如何解决这个问题。有人提议，以便于分割且稀有的东西，例如黄金，作为一般等价物，把其它物品和黄金的对应关系编成一张表格，例如一克黄金对应一只羊，一克黄金对应一袋面粉等等，此时老张再也不用扛着一袋面粉气喘吁吁的去老李家换羊了，他只要从家里摸出一克金子，就可以去老李家牵回一只羊，而老李拿着这一克黄金可以从任何愿意出让面粉的人那里换回一袋面粉，当然也可以换取任何和一克黄金等值的物品。

此时比特村进入了实物货币时代。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/02.png)

## 符号货币

好景不长，过了一段时间，实物货币的弊端也出现了。因为比特村附近金矿并不多，开采和冶炼金子太费时费力了。而随着使用，金子总是不断会因为磨损、丢失或有人故意囤积而发生损耗。全村人又一次坐在了一起，开始商讨对策。此时有人说，其实大家也不必一定要真的用黄金啊，随便找张纸，写上“一克黄金”，只要全村人都认同这张纸就等于一克黄金，问题不就解决了。其他人纷纷表示认同，但同时也有了新的问题：真实的黄金是需要开采和冶炼的，金矿有限，开采和冶炼也需要成本，所以没有人可以短期凭空制造大量的黄金，可写字就不同了，只要我纸够笔够，随便像写多少写多少，那这就变成拼谁家里纸多了，搞不好到时一万张纸才能换一只羊（实际上这就发生了经济学上的通货膨胀）。

大家一想也是啊。不过此时又有人提出了解决方案：这个纸不是谁写都有效，我们只认村里德高望重的老村长写得，大家都认识老村长的字。老村长写一些纸，同时按照各家黄金存量发给大家等量的纸，例如老张家有二百克黄金，老村长就发给老张二百张写着“一克黄金”的纸，同时将老张家的黄金拿走作为抵押。就这样，老村长将村里所有黄金收归到自己的家里，并按各家上交的黄金数量发给等值的写有字的纸。此时村民就可以拿着这些纸当黄金进行贸易了，而且大家都认得老村长的字，其他人伪造不出来。另外，如果谁的纸磨损太严重，也可拿到老村长那里兑换新的等值的纸，另外老村长承诺任何人如果想要换成真黄金，只要拿纸回来，老村长就会把等值的黄金还给那人。因为老村长写得纸的黄金量和真实放在家里的黄金量是一样的，所以只要严格按照销毁多少纸新写多少纸的原则，每一张有效的纸总能换回相应的真黄金。

此时，比特村进入了符号货币（纸币）时代。而老村长就承担了政府和银行的角色。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/03.png)

## 中央系统虚拟货币

又过了几年，老村长由于每天都要核对大量的旧纸币，写新的纸币，还要把各种账目仔细做好记录。一来二去，老村长操劳过度不幸驾鹤西去了。

比特村再次召开全体大会，讨论应该怎么办。此时老村长的儿子二狗子自告奋勇接过了父亲的笔，承担起货币发行的责任。这个年轻的村长二狗子很聪明，他做了几天，发现好像也不用真的写那么多纸。完全可以这样：村民把纸币都交上来，销毁，但是二狗子会记录下每户上交的纸币数量。以后如果要进行付钱，例如老张要拿一克金子向老李换一只羊，就一起给二狗子打个电话，说明要将老张名下的一克金子划归老李名下，二狗子拿出账本，看看老张名下是否有一克金子，如果有就在老张的名下减掉一克，在老李的名下加上一克，这样就完成了支付，此时老李在电话中听到二狗子确认转账完成，就可以放心让老张把羊牵走了。

此时比特村进入了中央系统虚拟货币时代。每个村民都不需要用实物支付，支付过程变成了二狗子那边维护的账本上数字的变更。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/04.png)

## 分布式虚拟货币

这新上任的二狗子是聪明，不过这人有时候是聪明反被聪明误。有一天二狗子盯着这账本，心想这全村各户谁有多少钱就是我说的算，那我岂不是……。于是他头脑一热，私自从老张帐下划了十克金子到自己名下。

本以为天衣无缝，但没想到老张也有记账的习惯，有一天他正要付钱却被二狗子告知账户没钱了。老张核对了一下自己的账本，明明还有十克啊，于是拿着账本去找二狗子理论，这一核对发现了那笔未经老张同意的转账。

东窗事发！比特村炸开锅了。二狗子被弹劾是不可避免了，不过通过这件事，大家发现了账本集中在一个人手里的弊端：

* 这个体系完全依赖于账本持有人的个人信用，如果这个人不守规矩，随意篡改账本，那么整个货币系统就会崩溃
* 如果这个人家里失火或者账本失窃，同样也会为整个体系带来毁灭性的打击

正当人们不知所措时，村里一个叫中本聪的宅男科学家走上了台，告诉大家他已经设计了一套不依赖任何中央处理人的叫比特币的虚拟货币系统，可以解决上述问题。然后他缓缓讲述了自己的方案。

下面我们就来看看中本聪同学是如何设计这套系统的。

# 基础设施搭建

## 账簿公开机制

中本聪首先说明，要对现有账簿进行如下改造：

1.  账簿上不再记载每户村民的余额，而只记载每一笔交易。即记载每一笔交易的付款人、收款人和付款金额。只要账簿的初始状态确定，每一笔交易记录可靠并有时序，当前每个人持有多少钱是可以推算出来的。
2.  账簿由私有改为公开，只要任何村民需要，都可以获得当前完整的账簿，账簿上记录了从账簿创建开始到当前所有的交易记录。

此言一出，下面立刻炸锅了。第一条还无所谓，但是第二条简直无法接受，因为账簿可是记录了所有村民的交易，这样大家的隐私不全暴露了吗。

中本聪倒是不慌不忙，拿出了一对奇怪的东西。

## 身份与签名机制（公钥加密系统）

中本聪说，大家不要慌。在他的这套机制下，任何人都不使用真实身份交易，而是使用一个唯一的代号交易。

他展示了手里神奇的东西，说这两件东西分别叫保密印章和印章扫描器。后面他会给村里每一户发一个保密印章和一个印章扫描器。两者的作用如下：

* 保密印章可以在纸上盖一个章，每个印章盖出的章都隐含了一个全村唯一的一串字符，但是凭肉眼是看不出来的。也无法通过观察来制造出相应的印章。
* 印章扫描器可以扫描某个已经盖好的章，读出隐含的信息，并在液晶屏上显示出一串字符。

有了这两个神奇的东西，大家就可以在不暴露真实身份的情况下进行交易了，而印章隐含的那一串字符就是这户人家的代号。具体如何巧妙利用保密印章和印章扫描器进行交易，会在下文详述。

## 成立虚拟矿工组织（挖矿群体）

下一步，中本聪面向全村招募虚拟矿工，招募要求如下：

* 矿工以组为单位，一组可以是单独的一户，也可以是几户联合为一组
* 成为矿工不影响正常使用货币
* 矿工每天要花费一定时间从事比特币“挖矿”活动，但是不同于挖金矿，虚拟矿工不需要拿着工具去野外作业，在家里就可以完成工作
* 矿工有一定可能性获得报酬，在挖矿活动中付出的努力越多，获得报酬的可能性越大
* 矿工可以随时退出，也可以随时有新的矿工加进来

很快，大约有五分之一的村民加入比特币矿工组织，共分成了7个组。

## 建立初始账簿（创世块）

下面，中本聪宣布，先根据二狗子手里的账簿，把抵押的所有黄金按账簿记录的余额退还给每位村民，然后彻底销毁这本账簿。

然后，中本聪拿出一本新账簿，在账簿的第一页上记录了一些交易记录，特别的是，这些记录的付款人一栏全都是“系统”，而收款人分别是每个印章对应的隐含字符，代表初始时刻，系统为每一户默认分配了一定数量比特币，但是数量非常少，都只有几枚，甚至有些不幸的村户没有获得比特币。

接着中本聪说，由于目前市面上比特币非常少，大家可以先回到用黄金做货币的时代，由于我不是村长，我也没有权利强迫大家一定要承认比特币，大家可以自行决定要不要接受比特币。不过随着比特币的流动和矿工的活动，比特币会慢慢多起来。

# 支付与交易

做了这么多铺垫，终于说到重点了，下面说一下在这样一个体系下如何完成支付。以老张付给老李10个比特币为例。

## 付款人签署交易单

为了支付10个比特币，老张首先要询问老李的标识字符串，例如是“ABCDEFG”，同时老张也有一个标识字符串例如是“HIJKLMN”，然后老张写一张单子，内容为“HILKLMN支付10比特币给ABCDEFG”，然后用自己的保密印章改一个章，将这张单子交给老李。另外为了便于追溯这笔钱的来源，还要在单子里注明这笔钱的来源记在哪一页，例如这个单子里，老张的10比特币来自建立账簿时系统的赠送，记录在账簿第一页。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/05.png)

转出比特币的一方还必须提供以下数据：

- 上一笔交易的 Hash（你从哪里得到这些比特币）
- 本次交易双方的地址
- 支付方的公钥
- 支付方的私钥生成的数字签名

## 收款人确认单据签署人

验证这笔交易是否属实，需要三步：

- 第一步，找到上一笔交易，确认支付方的比特币来源。
- 第二步，算出支付方公钥的指纹，确认与支付方的地址一致，从而保证公钥属实。
- 第三步，使用公钥去解开数字签名，保证私钥属实。

老李拿到这个单子后，需要确认这个单子确实是来自“HIJKLMN”这个人（也就是老张）签署的，这个并不困难。因为单子上必须有保密章，老李拿出印章扫描器，扫一下章，如果液晶屏显示出的字符和付款人字符是一致的（这里是“HIJKLMN”），就可以确认单子确实是付款人签署的。这是因为根据保密印章的机制，没有其他人可以伪造印章，任何一个人只要扫描一下印章，都可以确认单子的付款人和盖章人是否一致。

## 收款人确认付款人余额

这个系统到目前还是很有问题。通过保密印章，收款人虽然可以确认付款人确实签署了这份单子，但是无法自行确认付款人是否有足够的余额支付。之前的中央虚拟货币系统中，二狗子负责检查付款人的余额，并通知收款人交易是否有效，现在把二狗子开了，谁来负责记账和确认每笔交易的有效性呢？

之前说过，中本聪设计的这个系统是分布式货币系统，不依赖任何中央人物，所以不会有一个或少数几个人负责这件事，最终承担这份工作的是之前所提到的矿工组织。老张、老李和全村其他任何使用比特币进行交易的村民都依赖矿工组织的工作才能完成交易。

# 矿工的工作

矿工的工作是整个系统的核心，也是最复杂性最高的地方。首先，所有的交易数据都会传送到矿工那里。矿工负责把这些交易写入区块链。下面逐步介绍矿工的工作内容和目的。

根据比特币协议，一个区块的大小最大是 1MB，而一笔交易大概是500字节左右，因此一个区块最多可以包含2000多笔交易。矿工负责把这2000多笔交易打包在一起，组成一个区块，然后计算这个区块的 Hash。计算 Hash 的过程叫做采矿，这需要大量的计算。矿工之间也在竞争，谁先算出 Hash，谁就能第一个添加新区块进入区块链，从而享受这个区块的全部收益，而其他矿工将一无所获。

## 矿工的工具

俗话说，工欲善其事，必先利其器。比特币矿工虽然不用铁撅、铁锨和探照灯等工具，不过也要有一些必备的东西。

初始账簿。每个组首先自己复制一份初始账簿，初始账簿只有一页，记录了系统的第一次赠送

空账簿纸。每个小组有若干账簿纸，每一页纸上仅有账簿结构，没有填内容，具体内容的书写规则后面讲述。下面是一张空账簿纸的样子，各个字段的意义后面会说到

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/06.png)

编码生成器（哈希函数）。中本聪又向矿工组织的每个组分发了若干编码生成器，这个东西很神奇，将一页账簿填好内容的账簿纸放入这个机器，机器会在账簿纸的“本账单编号”一栏自动打印一串由“0”和“1”组成的编号，共256个。最神奇的是，编号生成器有如下功能：

* 生成的编号仅与账簿纸上填入的内容有关，与填写人、字体、填写时间等因素均无关
* 内容相同的账簿纸生成的编号总是相同，但是如果内容哪怕只改一个字符，编号就会面目全非
* 编码生成器在打印编码时还需要将所有填入账簿纸的交易单放入，机器会扫描交易单和填入交易单的一致性，尤其是保密印章，如果发现保密印章和付款人不一致，会拒绝打印编码
* 将一张已打印的账簿纸放入，机器会判定编号是否是有效的机器打印，并且判定编号和内容是否一致，这个编号无法伪造
* 交易单收件箱。每个矿工小组需要在门口挂一个箱子用于收集交易单。
* 公告板。每个矿工小组同样需要一个公告板公示一些信息。

有了上面的工具，矿工组织就可以开工了！

## 收集交易单

中本聪规定，每笔交易的发起人，不但要将交易单给到收款人，还要同时复制若干份一模一样的交易单投递到每个矿工小组的收件箱里。

矿工小组的人定期到自己的收件箱里把收集到的交易单一并取出来。

## 填写账簿

此时小组的人拿出一张空的账簿纸，把这些交易填写到“交易清单”一栏，同时找到当前账簿最后一页，将最后一页的编号抄写到“上一张账单编号一栏”。
注意还有个“幸运数字”，可以随便填上一个数字，如12345。然后，将这样账簿纸放入编号生成器，打印好编号，一张账簿就算完成了。

如果你以为矿工的工作就这么简单，那就大错特错了，中本聪有个变态的规定：只有编号的前10个数均为0，这页账簿纸才算有效。

根据之前对编号生成器的描述，要修改编号，只能修改账簿纸的内容，而“交易清单”和“上一张账簿纸编号”是不能随便改的，那么只能改幸运数字了。于是为了生成有效的账簿纸，小组里的矿工就不断抄写账簿纸，但每张纸的幸运数字都不同，然后不断的重复将纸放入编码器，如果生成的编号不符合规定，这张纸就算废了，重复这个过程直到生成一串有效的编号。

我们知道，如果编号的每一个数字都是随机的，那么平均写1000多张幸运数字不同的纸才能获得一个有效的编号。

这就奇怪了，这些矿工为什么要拼命干这看似无意义的事情呢？还记得之前说过矿工有报酬吧，这就是矿工的动力了。中本聪规定：每一张账簿纸的交易清单第一条交易为“系统给这个小组支付50个比特币”。也就是说，如果你生成了一张有意义的账簿纸，并且被所有挖矿小组接受了，那么就意味着这条交易也被接受了，你的挖矿小组获得了50个比特币。

这就是矿工被叫做矿工的原因，也是为什么之前说随着交易和矿工的活动，比特币的数量会不断增多。例如下面是一个挖矿过程，这个小组的公共比特币帐号为“UVWXYZ”。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/07.png)

在幸运数字尝试到“533”时，系统生成了一页有效账簿。

## 确认账簿

当某挖矿小组幸运的生成了一张有意义的账簿，为了得到奖励，必须立刻请其它小组确认自己的工作。前面说过，当前村里有7个挖矿组，所以这个小组必须将有效账簿纸誊抄6份快马加鞭送到其他6个小组请求确认。

中本聪规定，当某个小组接到其他小组送来的账簿纸时，必须立即停下手里的挖矿工作进行账簿确认。

需要确认的信息有三个：

1.  账簿的编号有效
2.  账簿的前一页账簿有效
3.  交易清单有效

首先看第一个，这个确认比较简单。只要将送来的账簿纸放入编码生成器进行验证，如果验证通过，则编号有效。

第二部分需要将账簿页上的“上一页账簿纸编号”和这个小组目前保存的有效账簿最后一页编号比对，如果相同则确认，如果不同，需要顺着已有账簿向前比对，直到找到这个编号的页。如果没有找到指定的“上一页账簿纸编号”对应的页，这个小组会将此页丢掉。不予确认。

注意，由上面的机制可以保证，如果各个小组手里的账簿纸是相同的，那么他们都能按同样的顺序装订成相同的账簿。因为后面一张纸的编号总是依赖前面的纸的编号，编码生成器的机制保证了所有合法账簿纸的相对先后顺序在每个小组那里都是相同的（可能会有分支，但不会出现环，后面细讲）。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/08.png)

最后是如何确认交易清单有效，其实也就是要确认当前每笔交易的付款人有足够的余额支付这笔钱。由于交易信息里包含这笔钱是如何来的，还包含了记录来源交易的账单编号。例如，HIJKLMN要给ABCDEFG10个比特币，并注明了这10个比特币来自之前OPQRST支付给HIJKLMN的一笔交易，确认时首先要确认之前这笔交易是否存在，同时还要检查HIJKLMN在这之前没有将这10个比特币支付给别人。这一切确认后，这笔交易有效性就被确认了。

其中第一笔是系统奖励给生成这页账簿的小组的50个，这笔交易大家都默认承认，后面的只要按照上述方法追溯，就可以确认HIJKLMN是否当前真有10个比特币支付给ABCDEFG。

如果完成了所有了上述验证并全部通过，这个小组就认可了上述账簿纸有效，然后将这张账簿纸并入小组的主账簿，舍弃目前正在进行的工作，后面的挖矿工作会基于这本更新后的主账本进行。

## 账簿确认反馈

对于挖矿小组来说，当账簿纸送出去后，如果后面有收到其他小组送来的账簿纸，其“上一页账簿纸编号”为自己之前送出去的账簿纸，那么就表示他们的工作成功被其他小组认可了，因为已经有小组基于他们的账簿纸继续工作了。此时，可以粗略的说可以认为已经得到了50个比特币。

另外，任何一个小组当新生成有效账簿纸或确认了别的小组的账簿纸时，就将最新被这个小组承认的交易写到公告牌上，那么收款人只要发现相关交易被各个小组认可了，基本就可以认为这笔钱已经到了自己的账上，后面他就可以在付款时将钱的来源指向这笔交易了。

以上就是整个比特币的支付体系。下面我们来分析一下，这个体系为什么可以工作下去，以及这个体系可能面临的风险。

# 工作机制分析

虽然上面阐述了比特币的基本运作规则，但是村民们还是有不少疑问。所以中本聪同学专门开了个答疑会，解答常见问题。下面总结一下村民最集中关心的问题。

## 如果同时收到两份合法的账簿页怎么办？

注意在上面的运行机制中，各个挖矿小组是并行工作的，因此完全可能出现这样的情况：某小组收到两份不一样的账簿页，它们都基于当前这个小组的主账簿的最后一页，并且内容也都完全合法，怎么办？

关于这个问题，中本聪同学说，小组不应该以线性方式组织账簿，而应该以树状组织账簿，任何时刻，都以当前最长分支作为主账簿，但是保留其它分支。举个例子，某小组同时收到A、B两份账簿页，经核算都是合法的，此时小组应该将两页以分叉的形式组织起来，如下图所示：

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/09.png)

黑色表示当前账簿主干。此时，可以随便选择一个页作为当前主分支，例如选择A：

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/10.png)

此时如果有一个新的账簿页是基于A的，那么这个主干就延续下去：

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/11.png)

如果这个主干一直这么延续下去，表示大家基本都以A为主干，B就会被遗忘。但是也有可能忽然B变成更长了：

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/12.png)

那么我们就需要将B分支作为当前主干，基于这个分支进行后续工作。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/13.png)

从局部来看，虽然在某一时刻各个小组的账簿主干可能存在不一致，但大方向是一致的，那些偶尔由于不同步产生的小分支，会很快被淹没在历史中。

## 如果挖矿小组有人伪造账簿怎么办

关于这个问题，中本聪同学说，只要挖矿组织中大多数人是诚实的，这个系统就可靠，具体分几个方面给予答复。

首先，基于保密印章机制，没有人能伪造他人身份进行付款，因为编码生成器在打印编码时会核对所有交易单的保密印章，印章和付款人不一致会拒绝打印。

而且诚实的矿工也不会承认不合法的交易（如某笔交易付款方余额不够）。

所以只有一种可能的攻击行为，即在收款人确认收款后，从另一条分支上建立另外的交易单，取消之前的付款，而将同一笔钱再次付款给另一个人（即所谓的double-spending问题）。下面同样用一个例子说明这个问题。

先假设有一个攻击者拥有10个比特币，他准备将这笔钱同时支付给两名受害者A和B，并都得到承认。

第一步，攻击者准备从受害者A手里买10比特币的黄金，他签署交易单给受害者A，转10个比特币给受害者A。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/14.png)

第二步，这笔交易在最新的账簿页中被确认，并被各个挖矿小组公告出来。受害人A看到公告，确认比特币到账，给了攻击者10个比特币等值的黄金。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/15.png)

第三步，攻击者找到账簿，从包含刚才交易的账簿页的前一页做出一个分支，生成更多的账单页，超过刚才的分支。由于此时刚才攻击者制造的分支变成了主干分支，而包含受害者A得到钱的分支变成了旁支，因此挖矿组织不再承认刚才的转账，受害者A得到的10比特币被取消了。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/16.png)

第四步，攻击者可以再次签署交易单，将同一笔钱支付给受害者B。受害者B确认钱到账后，支付给攻击者等值黄金。

![](http://blog.codinglabs.org/uploads/pictures/bitcoin-mechanism-make-easy/17.png)

至此，攻击者将10个比特币花了两次，从两名受害者那里各购得等值黄金。攻击者还可以如法炮制，取消与受害者B的转账，将同一笔钱再支付给其他人……

关于这种攻击，中本聪给出的解决方案是，建议收款人不要在公告挂出时立即确认交易完成，而是应该再看一段时间，等待各个挖矿小组再挂出6张确认账簿，并且之前的账簿没有被取消，才确认钱已到账。

中本聪解释道，之前设定变态的编号规则，正是为了防御这一点。根据前面所述，生成有效账簿页不是那么简单的，要花费大量的人力反复试不同的幸运数字，而且过程完全是碰运气。如果某账簿页包含你收到钱的确认，并且在后面又延续了6个，那么攻击者想要在落后6页的情况下从另一个分支赶超当前主分支是非常困难的，除非攻击者拥有非常多的人力，超过其他所有诚实矿工的人力之和。

而且，如果攻击者有如此多人力，与其花这么大力气搞这种攻击，还不如做良民挖矿来的收益大。这就从动机上杜绝了攻击的形成。

## 比特币会一直增加下去，岂不是会严重通货膨胀

中本聪说，这一点我也想到了。前面忘了说了，我给矿工组织的操作细则手册会说明，刚开始我们协议每生成一页账簿，奖励小组50个比特币，后面，每当账簿增加21,000页，奖励就减半，例如当达到210,000页后，每生成一页账簿奖励25个比特币，420,000页后，每生成一页奖励12.5个，依次类推，等账簿达到6,930,000页后，新生成账簿页就没有奖励了。此时比特币全量约为21,000,000个，这就是比特币的总量，所以不会无限增加下去。

## 没有奖励后，就没人做矿工了，岂不是没人帮忙确认交易了

比特币协议规定，挖到新区块的矿工将获得奖励，一开始（2008年）是50个比特币，然后每4年减半，目前（2018年）是12.5个比特币。这也是比特币的供给增加机制，流通中新增的比特币都是这样诞生的。么到了2140年，矿工将得不到任何奖励，比特币的数量也将停止增加。到时，矿工的收益会由挖矿所得变为收取手续费。例如，你在转账时可以指定其中1%作为手续费支付给生成账簿页的小组，各个小组会挑选手续费高的交易单优先确认。

## 矿工如果越来越多，比特币生成速度会变快吗

不会。中本聪解释，虽然可以任意加入和退出矿工组织，导致矿工人数变化，每个矿工也会拿到一个编码生成器，不过我已经在编码生成器中加入了调控机制，当前工作的编码生成器越多，每个机器的效率就越低，保证新账簿页生成速率不变。

## 虽然每个人的代号是匿名的，但如果泄露了某个人的代号，账簿又是公开的，岂不是他的所有账目都查出来了

确实是这样的。例如你要和某人交易，必然要要到他的代号才能填写交易单。因为收款人一栏要填入那人的代号。不过中本聪说可以提供无限制的保密印章，建议每一次交易用不同的保密印章，这样查账簿就追查不到同一个人的所有账目了。

## 区块的扩容

《区块链入门教程》说过，比特币协议规定，平均10分钟诞生一个区块。区块的大小只有 1MB，最多只能包含2000多笔交易。也就是说，比特币网络每10分钟，最多只能处理2000多笔交易，换算一下，就是处理速度为3～5笔/秒。全世界的比特币交易这么多，可是区块链每秒最多只能处理5笔，这已经成为制约比特币发展的一个瓶颈。

很早就有人呼吁，改革比特币协议，提升处理速度。这件事在2017年8月有了一点眉目，当时区块链发生了一次分叉，诞生了一个新协议，称为 Bitcoin Cash（简称 BCH）。这种新货币其他方面都与比特币一致，就是每个区块的大小从 1MB 增加到了 8MB，因此处理速度提升了8倍，手续费也低得多。该协议是对原有区块链的分叉，因此当时持有比特币的人，等于一人获赠了一份同样数量的 BCH。

BCH 等于创造了一种新货币，还有人提议，原始比特币的区块大小提升到 2MB，这称为 SegWit2x 。这个建议原定于2017年11月实施，但是最后一刻由于缺乏共识，就被取消了，目前还在讨论中。

# 说明

本文用通俗比喻的方式讲解了比特币的运行机制。有几点需要说明：

1.  为了便于理解，我做了很多简化，因此有些机制细节和实际的比特币可能不完全相同。但总体思想和关键原理是一致的。
2.  由于很多计算机世界的东西（如公钥体系、网络传输）在现实世界中并没有特别好的对等物，所以故事里难免有一些生硬和不合常理的细节。
3.  本文描述的是比特币网络本身的技术原理和运作机制，当在如Mtgox这种买卖市场中进行比特币交易时，市场做了中间代理，并不遵从上述机制



---
]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>Bitcoin</tag>
      </tags>
  </entry>
  <entry>
    <title>区块链</title>
    <url>/blockchain/</url>
    <content><![CDATA[
区块链（英语：blockchain 或 block chain）是用分布式数据库识别、传播和记载信息的智能化对等网络, 也称为价值互联网。中本聪在2008年，于《比特币白皮书》中提出“区块链”概念，并在2009年创立了比特币社会网络，开发出第一个区块，即“创世区块”。本文根据阮一峰老师的[区块链入门教程](http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html)整理并解释一下区块链到底是什么，有何特别之处。

<!--more-->

> [区块链是什么，如何简单易懂地介绍区块链？](https://www.zhihu.com/question/37290469)

区块链就是一个数据库，记载了所有的交易，用作中央记账系统。每笔交易的核心，就是一句话，比如"张三向李四转移了1个比特币"。为了证明这句话可信，张三为它加上了数字签名。任何人都可以用张三的公钥，证明这确实是张三本人的行为。另一方面，其他人无法伪造张三的数字签名，所以不可能伪造这笔交易。矿工们收到这句话，首先验证数字签名的可信性，然后验证张三确实拥有这些比特币（每一笔交易都有上一笔交易的编号，用来查询比特币的来源）。验证通过以后，就着手把这句话写入区块链了。一旦写入区块链，所有人就都可以查询到，因此这笔比特币就被认为，从张三转移到了李四。区块链的作用就是把这句话永久保存下来了，让任何人都可以查看，并且任何人（包括张三本人在内）都无法再修改了。

- 首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。
- 其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。

分布式数据库并非新发明，但是，区块链有一个革命性特点。区块链没有管理员，它是彻底无中心的。每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，所有节点最后都会同步，保证区块链一致。

区块链奇妙的地方在于怎么才能保证数据是可信。区块链由一个个区块（block）组成。区块很像数据库的记录，每次写入数据，就是创建一个区块。每个区块包含区块头（Head）和区块体（Body）。区块头包含了当前区块的多项元信息，如Hash值。正是通过这种联动机制，区块链保证了自身的可靠性，数据一旦写入，就无法被篡改。

- 区块链的 Hash 长度是256位，这就是说，不管原始内容是什么，最后都会计算出一个256位的二进制数字。而且可以保证，只要原始内容不同，对应的 Hash 一定是不同的。
- 区块与 Hash 是一一对应的，每个区块的 Hash 都是针对"区块头"（Head）计算的。这意味着，如果当前区块的内容变了，或者上一个区块的 Hash 变了，一定会引起当前区块的 Hash 改变。

由于必须保证节点之间的同步，所以新区块的添加速度不能太快。你永远只能在最新区块的后面，生成下一个区块。区块链的设计是，平均每10分钟，全网才能生成一个新区块，一小时也就六个。也就是说，只有通过极其大量的计算，才能得到当前区块的有效 Hash，从而把新区块添加到区块链。由于计算量太大，所以快不起来。这个过程就叫做采矿（mining），计算 Hash 的机器就叫做矿机，操作矿机的人就叫做矿工。

- 区块头包含一个难度系数（difficulty），这个值决定了计算 Hash 的难度。
- 就算采矿很难，但也没法保证，正好十分钟产出一个区块。为了将产出速率恒定在十分钟，中本聪还设计了难度系数的动态调节机制。他规定，难度系数每两周（2016个区块）调整一次。如果这两周里面，区块的平均生成速度是9分钟，就意味着比法定速度快了10%，因此难度系数就要调高10%；如果平均生成速度是11分钟，就意味着比法定速度慢了10%，因此难度系数就要调低10%。
- 不是任意一个 Hash 都可以，Hash 的有效性跟目标值密切相关，只有小于目标值的 Hash 才是有效的，否则 Hash 无效，必须重算。由于目标值非常小，Hash 小于该值的机会极其渺茫，可能计算10亿次，才算中一次。这就是采矿如此之慢的根本原因。

如果两个人同时向区块链写入数据，也就是说，同时有两个区块加入，因为它们都连着前一个区块，就形成了分叉。这时应该采纳哪一个区块呢？现在的规则是，新节点总是采用最长的那条区块链。如果区块链有分叉，将看哪个分支在分叉点后面，先达到6个新区块（称为"六次确认"）。按照10分钟一个区块计算，一小时就可以确认。

区块链作为无人管理的分布式数据库，从2009年开始已经运行了8年，没有出现大的问题。这证明它是可行的。但是，为了保证数据的可靠性，区块链也有自己的代价。一是效率，数据写入区块链，最少要等待十分钟，所有节点都同步数据，则需要更多的时间；二是能耗，区块的生成需要矿工进行无数无意义的计算，这是非常耗费能源的。

目前，区块链最大的应用场景（可能也是唯一的应用场景），就是以比特币为代表的加密货币。


---
]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>Blockchain</tag>
      </tags>
  </entry>
  <entry>
    <title>CMD命令</title>
    <url>/cmd/</url>
    <content><![CDATA[
cmd是command的缩写。即命令提示符（CMD），是在OS / 2 ， Windows CE与Windows NT平台为基础的操作系统（包括Windows 2000和XP中， Vista中，和Server 2003 ）下的“MS-DOS 方式”。中文版Windows XP 中的命令提示符进一步提高了与DOS 下操作命令的兼容性，用户可以在命令提示符直接输入中文调用文件。

<!--more-->

# CMD命令

- 如果要切换的目录和当前目录在一个盘符下（比如都是C盘），

    > cd c:\windows\system

- 要切换到不同的盘符，如D盘，

    > 输入 cd /d 路径 回车  
    > 或者 输入 d: 回车

- 进入 E:/Program Files/PHP，

    > 输入 E: 回车  
    > 输入 CD "Program Files"/PHP 回车

- 当前盘符的根目录 ‘CD /’，进入上一层目录 ‘CD ..’，当前目录‘CD .’，显示目录下的文件及目录 ‘dir’

# 批处理文件

批处理文件（batch file）包含一系列 DOS命令，通常用于自动执行重复性任务。用户只需双击批处理文件便可执行任务，而无需重复输入相同指令。编写批处理文件非常简单，但难点在于确保一切按顺序执行。编写严谨的批处理文件可以极大程度地节省时间，在应对重复性工作时尤其有效。

> [批处理常用命令总结 - 批处理命令简介](http://xstarcd.github.io/wiki/windows/windows_cmd_summary_commands.html)  
> [批处理常用命令总结 - 批处理符号简介](http://xstarcd.github.io/wiki/windows/windows_cmd_summary_symbols.html)


Windows Batch 常用命令：

```
1 echo 和 @
回显命令
@                     #关闭单行回显
echo off              #从下一行开始关闭回显
@echo off             #从本行开始关闭回显。一般批处理第一行都是这个
echo on               #从下一行开始打开回显
echo                  #显示当前是 echo off 状态还是 echo on 状态
echo.                 #输出一个”回车换行”，空白行
                         #(同echo, echo; echo+ echo[ echo] echo/ echo)
2 errorlevel
echo %errorlevel%
每个命令运行结束，可以用这个命令行格式查看返回码
默认值为0，一般命令执行出错会设 errorlevel 为1
3 dir
显示文件夹内容
dir                  #显示当前目录中的文件和子目录
dir /a               #显示当前目录中的文件和子目录，包括隐藏文件和系统文件
dir c: /a:d          #显示 C 盘当前目录中的目录
dir c: /a:-d         #显示 C 盘根目录中的文件
dir c: /b/p         #/b只显示文件名，/p分页显示
dir *.exe /s         #显示当前目录和子目录里所有的.exe文件
4 cd
切换目录
cd                  #进入根目录
cd                   #显示当前目录
cd /d d:sdk         #可以同时更改盘符和目录
5 md
创建目录
md d:abc          #如果 d:a 不存在，将会自动创建中级目录
#如果命令扩展名被停用，则需要键入 mkdir abc。
6 rd
删除目录
rd abc               #删除当前目录里的 abc 子目录，要求为空目录
rd /s/q d:temp      #删除 d:temp 文件夹及其子文件夹和文件，/q安静模式
7 del
删除文件
del d:test.txt      #删除指定文件，不能是隐藏、系统、只读文件
del /q/a/f d:temp*.*
删除 d:temp 文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录
del /q/a/f/s d:temp*.*
删除 d:temp 及子文件夹里面的所有文件，包括隐藏、只读、系统文件，不包括子目录
8 ren
重命名命令
ren d:temp tmp      #支持对文件夹的重命名
9 cls
清屏
10 type
显示文件内容
type c:boot.ini     #显示指定文件的内容，程序文件一般会显示乱码
type *.txt           #显示当前目录里所有.txt文件的内容
11 copy
拷贝文件
copy c:test.txt d:test.bak
复制 c:test.txt 文件到 d: ，并重命名为 test.bak
copy con test.txt
从屏幕上等待输入，按 Ctrl+Z 结束输入，输入内容存为test.txt文件
con代表屏幕，prn代表打印机，nul代表空设备
copy 1.txt + 2.txt 3.txt
合并 1.txt 和 2.txt 的内容，保存为 3.txt 文件
如果不指定 3.txt ，则保存到 1.txt
copy test.txt +
复制文件到自己，实际上是修改了文件日期
12 title
设置cmd窗口的标题
title 新标题         #可以看到cmd窗口的标题栏变了
13 ver
显示系统版本
14 label 和 vol
设置卷标
vol                  #显示卷标
label                #显示卷标，同时提示输入新卷标
label c:system       #设置C盘的卷标为 system
15 pause
暂停命令
16 rem 和 ::
注释命令
注释行不执行操作
17 date 和 time
日期和时间
date           #显示当前日期，并提示输入新日期，按"回车"略过输入
date/t         #只显示当前日期，不提示输入新日期
time           #显示当前时间，并提示输入新时间，按"回车"略过输入
time/t         #只显示当前时间，不提示输入新时间
18 goto 和 :
跳转命令
:label         #行首为:表示该行是标签行，标签行不执行操作
goto label     #跳转到指定的标签那一行
19 find (外部命令)
查找命令
find "abc" c:test.txt
在 c:test.txt 文件里查找含 abc 字符串的行
如果找不到，将设 errorlevel 返回码为1
find /i “abc” c:test.txt
查找含 abc 的行，忽略大小写
find /c "abc" c:test.txt
显示含 abc 的行的行数
20 more (外部命令)
逐屏显示
more c:test.txt     #逐屏显示 c:test.txt 的文件内容
21 tree
显示目录结构
tree d:             #显示D盘的文件目录结构
22 &
顺序执行多条命令，而不管命令是否执行成功
23 &&
顺序执行多条命令，当碰到执行出错的命令后将不执行后面的命令
find "ok" c:test.txt && echo 成功
如果找到了"ok"字样，就显示"成功"，找不到就不显示
24 ||
顺序执行多条命令，当碰到执行正确的命令后将不执行后面的命令
find "ok" c:test.txt || echo 不成功
如果找不到"ok"字样，就显示"不成功"，找到了就不显示
25 |
管道命令
dir *.* /s/a | find /c ".exe"
管道命令表示先执行 dir 命令，对其输出的结果执行后面的 find 命令
该命令行结果：输出当前文件夹及所有子文件夹里的.exe文件的个数
type c:test.txt|more
这个和 more c:test.txt 的效果是一样的
26 > 和 >>
输出重定向命令
> 清除文件中原有的内容后再写入
>> 追加内容到文件末尾，而不会清除原有的内容
主要将本来显示在屏幕上的内容输出到指定文件中
指定文件如果不存在，则自动生成该文件
type c:test.txt >prn
屏幕上不显示文件内容，转向输出到打印机
echo hello world>con
在屏幕上显示hello world，实际上所有输出都是默认 >con 的
copy c:test.txt f: >nul
拷贝文件，并且不显示"文件复制成功"的提示信息，但如果f盘不存在，还是会显示出错信息
copy c:test.txt f: >nul 2>nul
不显示”文件复制成功”的提示信息，并且f盘不存在的话，也不显示错误提示信息
echo ^^W ^> ^W>c:test.txt
生成的文件内容为 ^W > W
^ 和 > 是控制命令，要把它们输出到文件，必须在前面加个 ^ 符号
27 <
从文件中获得输入信息，而不是从屏幕上
一般用于 date time label 等需要等待输入的命令
@echo off
echo 2005-05-01>temp.txt
date <temp.txt
del temp.txt
这样就可以不等待输入直接修改当前日期
28 %0 %1 %2 %3 %4 %5 %6 %7 %8 %9 %*
命令行传递给批处理的参数
%0 批处理文件本身
%1 第一个参数
%9 第九个参数
%* 从第一个参数开始的所有参数
批参数(%n)的替代已被增强。您可以使用以下语法:
     %~1          - 删除引号(")，扩充 %1
     %~f1         - 将 %1 扩充到一个完全合格的路径名
     %~d1         - 仅将 %1 扩充到一个驱动器号
     %~p1         - 仅将 %1 扩充到一个路径
     %~n1         - 仅将 %1 扩充到一个文件名
     %~x1         - 仅将 %1 扩充到一个文件扩展名
     %~s1         - 扩充的路径指含有短名
     %~a1         - 将 %1 扩充到文件属性
     %~t1         - 将 %1 扩充到文件的日期/时间
     %~z1         - 将 %1 扩充到文件的大小
     %~$PATH : 1 - 查找列在 PATH 环境变量的目录，并将 %1
                   扩充到找到的第一个完全合格的名称。如果环境
                   变量名未被定义，或者没有找到文件，此组合键会
                   扩充到空字符串
可以组合修定符来取得多重结果:
    %~dp1        - 只将 %1 扩展到驱动器号和路径
    %~nx1        - 只将 %1 扩展到文件名和扩展名
    %~dp$PATH:1 - 在列在 PATH 环境变量中的目录里查找 %1，
                   并扩展到找到的第一个文件的驱动器号和路径。
    %~ftza1      - 将 %1 扩展到类似 DIR 的输出行。
可以参照 call/? 或 for/? 看出每个参数的含意
echo load "%%1" "%%2">c:test.txt
生成的文件内容为 load "%1" "%2"
批处理文件里，用这个格式把命令行参数输出到文件
29 if
判断命令
if "%1"=="/a" echo 第一个参数是/a
if /i "%1" equ "/a" echo 第一个参数是/a
/i 表示不区分大小写，equ 和 == 是一样的，其它运算符参见 if/?
if exist c:test.bat echo 存在c:test.bat文件
if not exist c:windows (
     echo 不存在c:windows文件夹
     )
if exist c:test.bat (
     echo 存在c:test.bat
     ) else (
     echo 不存在c:test.bat
     )
30 setlocal 和 endlocal
设置”命令扩展名”和”延缓环境变量扩充”
SETLOCAL ENABLEEXTENSIONS             #启用"命令扩展名"
SETLOCAL DISABLEEXTENSIONS            #停用"命令扩展名"
SETLOCAL ENABLEDELAYEDEXPANSION       #启用"延缓环境变量扩充"
SETLOCAL DISABLEDELAYEDEXPANSION      #停用"延缓环境变量扩充"
ENDLOCAL                              #恢复到使用SETLOCAL语句以前的状态
“命令扩展名”默认为启用
“延缓环境变量扩充”默认为停用
批处理结束系统会自动恢复默认值
可以修改注册表以禁用"命令扩展名"，详见 cmd /? 。所以用到"命令扩展名"的程
序，建议在开头和结尾加上 SETLOCAL ENABLEEXTENSIONS 和 ENDLOCAL 语句，以确
保程序能在其它系统上正确运行
"延缓环境变量扩充"主要用于 if 和 for 的符合语句，在 set 的说明里有其实用例程
31 set
设置变量
引用变量可在变量名前后加 % ，即 %变量名%
set                     #显示目前所有可用的变量，包括系统变量和自定义的变量
echo %SystemDrive%      #显示系统盘盘符。系统变量可以直接引用
set p                   #显示所有以p开头的变量，要是一个也没有就设errorlevel=1
set p=aa1bb1aa2bb2      #设置变量p，并赋值为 = 后面的字符串，即aa1bb1aa2bb2
echo %p%                #显示变量p代表的字符串，即aa1bb1aa2bb2
echo %p:~6%             #显示变量p中第6个字符以后的所有字符，即aa2bb2
echo %p:~6,3%           #显示第6个字符以后的3个字符，即aa2
echo %p:~0,3%           #显示前3个字符，即aa1
echo %p:~-2%            #显示最后面的2个字符，即b2
echo %p:~0,-2%          #显示除了最后2个字符以外的其它字符，即aa1bb1aa2b
echo %p:aa=c%           #用c替换变量p中所有的aa，即显示c1bb1c2bb2
echo %p:aa=%            #将变量p中的所有aa字符串置换为空，即显示1bb12bb2
echo %p:*bb=c%          #第一个bb及其之前的所有字符被替换为c，即显示c1aa2bb2
set p=%p:*bb=c%         #设置变量p，赋值为 %p:*bb=c% ，即c1aa2bb2
set /a p=39             #设置p为数值型变量，值为39
set /a p=39/10          #支持运算符，有小数时用去尾法，39/10=3.9，去尾得3，p=3
set /a p=p/10           #用 /a 参数时，在 = 后面的变量可以不加%直接引用
set /a p=”1&0″          #”与”运算，要加引号。其它支持的运算符参见set/?
set p=                  #取消p变量
set /p p=请输入
屏幕上显示”请输入”，并会将输入的字符串赋值给变量p
注意这条可以用来取代 choice 命令
注意变量在 if 和 for 的复合语句里是一次性全部替换的，如
@echo off
set p=aaa
if %p%==aaa (
     echo %p%
     set p=bbb
     echo %p%
     )
结果将显示
aaa
aaa
因为在读取 if 语句时已经将所有 %p% 替换为aaa
这里的"替换"，在 /? 帮助里就是指"扩充"、"环境变量扩充"
可以启用”延缓环境变量扩充”，用 ! 来引用变量，即 !变量名!
@echo off
SETLOCAL ENABLEDELAYEDEXPANSION
set p=aaa
if %p%==aaa (
     echo %p%
     set p=bbb
     echo !p!
     )
ENDLOCAL
结果将显示
aaa
bbb
还有几个动态变量，运行 set 看不到
%CD%                   #代表当前目录的字符串
%DATE%                 #当前日期
%TIME%                 #当前时间
%RANDOM%               #随机整数，介于0~32767
%ERRORLEVEL%           #当前 ERRORLEVEL 值
%CMDEXTVERSION%        #当前命令处理器扩展名版本号
%CMDCMDLINE%           #调用命令处理器的原始命令行
可以用echo命令查看每个变量值，如 echo %time%
注意 %time% 精确到毫秒，在批处理需要延时处理时可以用到
32 start
批处理中调用外部程序的命令，否则等外部程序完成后才继续执行剩下的指令
33 call
批处理中调用另外一个批处理的命令，否则剩下的批处理指令将不会被执行
有时有的应用程序用start调用出错的，也可以call调用
34 choice (外部命令)
选择命令
让用户输入一个字符，从而选择运行不同的命令，返回码errorlevel为1234……
win98里是choice.com
win2000pro里没有，可以从win98里拷过来
win2003里是choice.exe
choice /N /C y /T 5 /D y>nul
延时5秒
35 assoc 和 ftype
文件关联
assoc 设置'文件扩展名'关联，关联到'文件类型'
ftype 设置'文件类型'关联，关联到'执行程序和参数'
当你双击一个.txt文件时，windows并不是根据.txt直接判断用 notepad.exe 打开
而是先判断.txt属于 txtfile '文件类型'
再调用 txtfile 关联的命令行 txtfile=%SystemRoot%system32NOTEPAD.EXE %1
可以在"文件夹选项"→"文件类型"里修改这2种关联
assoc            #显示所有'文件扩展名'关联
assoc .txt       #显示.txt代表的'文件类型'，结果显示 .txt=txtfile
assoc .doc       #显示.doc代表的'文件类型'，结果显示 .doc=Word.Document.8
assoc .exe       #显示.exe代表的'文件类型'，结果显示 .exe=exefile
ftype            #显示所有'文件类型'关联
ftype exefile    #显示exefile类型关联的命令行，结果显示 exefile="%1" %*
assoc .txt=Word.Document.8
设置.txt为word类型的文档，可以看到.txt文件的图标都变了
assoc .txt=txtfile
恢复.txt的正确关联
ftype exefile="%1" %*
恢复 exefile 的正确关联
如果该关联已经被破坏，可以运行 command.com ，再输入这条命令
36 pushd 和 popd
切换当前目录
@echo off
c: & cd & md mp3        #在 C: 建立 mp3 文件夹
md d:mp4                #在 D: 建立 mp4 文件夹
cd /d d:mp4             #更改当前目录为 d:mp4
pushd c:mp3             #保存当前目录，并切换当前目录为 c:mp3
popd                     #恢复当前目录为刚才保存的 d:mp4
37 for
循环命令
这个比较复杂，请对照 for/? 来看
for %%i in (c: d: e: f:) do echo %%i
依次调用小括号里的每个字符串，执行 do 后面的命令
注意%%i，在批处理中 for 语句调用参数用2个%
默认的字符串分隔符是"空格键"，"Tab键"，"回车键"
for %%i in (*.txt) do find "abc" %%i
对当前目录里所有的txt文件执行 find 命令
for /r . %%i in (*.txt) do find "abc" %%i
在当前目录和子目录里所有的.txt文件中搜索包含 abc 字符串的行
for /r . %%i in (.) do echo %%~pni
显示当前目录名和所有子目录名，包括路径，不包括盘符
for /r d:mp3 %%i in (*.mp3) do echo %%i>>d:mp3.txt
把 d:mp3 及其子目录里的mp3文件的文件名都存到 d:mp3.txt 里去
for /l %%i in (2,1,8) do echo %%i
生成2345678的一串数字，2是数字序列的开头，8是结尾，1表示每次加1
for /f %%i in ('set') do echo %%i
对 set 命令的输出结果循环调用，每行一个
for /f "eol=P" %%i in ('set') do echo %%i
取 set 命令的输出结果，忽略以 P 开头的那几行
for /f %%i in (d:mp3.txt) do echo %%i
显示 d:mp3.txt 里的每个文件名，每行一个，不支持带空格的名称
for /f "delims=" %%i in (d:mp3.txt) do echo %%i
显示 d:mp3.txt 里的每个文件名，每行一个，支持带空格的名称
for /f "skip=5 tokens=4" %%a in ('dir') do echo %%a
对 dir 命令的结果，跳过前面5行，余下的每行取第4列
每列之间的分隔符为默认的"空格"
可以注意到 dir 命令输出的前5行是没有文件名的
for /f "tokens=1,2,3 delims=- " %%a in ('date /t') do (
     echo %%a
     echo %%b
     echo %%c
     )
对 date /t 的输出结果，每行取1、2、3列
第一列对应指定的 %%a ，后面的 %%b 和 %%c 是派生出来的，对应其它列
分隔符指定为 - 和"空格"，注意 delims=- 后面有个"空格"
其中 tokens=1,2,3 若用 tokens=1-3 替换，效果是一样的
for /f "tokens=2* delims=- " %%a in ('date /t') do echo %%b
取第2列给 %%a ，其后的列都给 %%b
38 subst (外部命令)
映射磁盘。
subst z: serverd      #这样输入z:就可以访问serverd了
subst z: /d              #取消该映射
subst                    #显示目前所有的映时
39 xcopy (外部命令)
文件拷贝
xcopy d:mp3 e:mp3 /s/e/i/y
复制 d:mp3 文件夹、所有子文件夹和文件到 e: ，覆盖已有文件
加 /i 表示如果 e: 没有 mp3 文件夹就自动新建一个，否则会有询问

```

---
]]></content>
      <categories>
        <category>Programming</category>
        <category>CMD</category>
      </categories>
      <tags>
        <tag>CMD</tag>
      </tags>
  </entry>
  <entry>
    <title>凸优化</title>
    <url>/convex-optimization/</url>
    <content><![CDATA[
凸优化是指一种比较特殊的优化，是指求取最小值的目标函数为凸函数的一类优化问题。其中，目标函数为凸函数且定义域为凸集的优化问题称为无约束凸优化问题。而目标函数和不等式约束函数均为凸函数，等式约束函数为仿射函数，并且定义域为凸集的优化问题为约束优化问题。
<!--more-->

凸优化之所以如此重要，是因为：

- 其应用非常广泛，机器学习中很多优化问题都要通过凸优化来求解；
- 在非凸优化中，凸优化同样起到重要的作用，很多非凸优化问题，可以转化为凸优化问题来解决；
- 如上引用所述，凸优化问题可以看作是具有成熟求解方法的问题，而其他优化问题则未必。

标准优化问题

凸优化知识体系包括了[^Herbert002]：

[^Herbert002]: [凸优化](https://www.jianshu.com/p/fe2e7f0e89e5)

- 凸集，定义目标函数和约束函数的定义域。
- 凸函数，定义优化相关函数的凸性限制。
- 凸优化，中心内容的标准描述。
- 凸优化问题求解，核心内容。相关算法，梯度下降法、牛顿法、内点法等。
- [对偶问题](https://sli1989.github.io/lagrange-multiplier/)，将一般优化问题转化为凸优化问题的有效手段，求解凸优化问题的有效方法。

# 最速下降法

> [【最优化】一文搞懂最速下降法](https://zhuanlan.zhihu.com/p/32709034)

最速梯度下降法解决的问题是无约束优化问题，而所谓的无约束优化问题就是对目标函数的求解，没有任何的约束限制的优化问题。

# 牛顿法

> [【最优化】无约束优化方法-牛顿法](https://zhuanlan.zhihu.com/p/33544363)

牛顿法思想： 用目标函数的二阶泰勒展开近似该目标函数，通过求解这个二次函数的极小值来求解凸优化的搜索方向。

牛顿法推导：[凸优化(七)——牛顿法](https://www.jianshu.com/p/f00715396c7b)

我们可以看出，牛顿法和最速梯度的不同就是在于最速梯度下降法的迭代方向是梯度的负方向，迭代步长根据一维搜索得到。而牛顿法的迭代方向为上述推导的牛顿步径，迭代步长可以看为定值1。

牛顿法的优缺点：

- 优点是：对于二次正定函数，迭代一次即可以得到最优解，对于非二次函数，若函数二次性较强或迭代点已经进入最优点的较小邻域，则收敛速度也很快。
- 缺点：
    - 保证不了迭代方向是下降方向，这就是致命的！换句话说就是不一定迭代能够收敛，后面的阻尼牛顿法会解决这个问题，牛顿法就到此为止了。
    - 计算量相当复杂，除需计算梯度除外，还需要计算二阶偏导数矩阵和它的逆矩阵，计算量，存储量都很大，并且都以维数N的平方比增加，当N很大的时候，计算量的问题就更加突出。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>OptimizationAlgorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>烹饪技巧</title>
    <url>/cooking/</url>
    <content><![CDATA[
烹饪指的是膳食的艺术。对食品作加工处理，使食物更可口，更好看，更好闻。一个好的料理，色香味形俱佳，不但让人在食用时感到满足，而且能让食物的营养更容易被人体吸收。另外日语中有烹饪一义的“料理”一词也常在台湾被使用。

<!--more-->

## 食材处理

- [去虾线、去鱼皮、剥蟹腿、剥蒜皮](https://v.qq.com/x/page/h0882d7irc9.html)

## 技巧

> [有哪些很重要又被忽视的炒菜技巧？](https://www.zhihu.com/question/22467582)

- 同样的菜，用同样的原料，不同的人还是可以做出不同的味道，大概区别就在于一些窍门。

- 炖排骨汤滴两滴醋，炖别的汤别这么做。亲身实践，会影响味道，比如鸡汤。

- 生抽和老抽最好区分开，不要统一用酱油，有时菜颜色好不好看，就取决于这些上色的调料。

- 做炒鸡蛋，在打散蛋液时，加一小勺水淀粉或者水，鸡蛋下锅后小火烘一下，炒出来的鸡蛋会很蓬，很大一块。还有，炒蛋用猪油，比用别的任何油好吃。

- 熬鱼汤甩根猪大骨一起炖，会很鲜，而且腥味会淡很多。

- 熬咖喱加椰浆（这个技巧说了好多次了貌似），会非常好吃，把咖喱的味道提起来很多。

- 做了油辣子海椒，两颗核桃洗干净泡辣椒里，可以保持油辣椒的香味。

- 电饭锅煮饭，扔一两片绿茶一起煮，饭会很清香。

- 做水煮、家常、跳水、红烧等菜系，用混合油，即一半猪油一半菜油。质的飞跃。

- 炒鸡蛋，在鸡蛋下锅前滴一滴白酒搅拌均匀，会令鸡蛋更蓬松鲜香

- 做金蒜米的时候先把蒜末用热水烫过，洗去蒜中的粘液再下油锅炸制，蒜米会更松散不粘连

- 蒸鱼的时候，永远把鱼肚子下面用姜片或者一个瓷勺垫起来，保证蒸汽能从鱼肚下面通过同时蒸汽水不会接触到食材，接触到蒸汽水的蒸菜废了一半，吃过泡在蒸汽水里的螃蟹的人明白我在说什么。

- 做双皮奶请放奶油，我没有看过任何一本书上说不要加奶油，如果你能直接获得刚挤的新鲜牛奶，那不用加，如果是盒装奶，所有盒装奶都是脱脂的，区别在于多少，老老实实加奶油，就能获得第二层皮了

- 鸡蛋羹做的好不好，区别在于打散的鸡蛋有没有过筛过滤掉气泡和“脐带”

---
]]></content>
      <categories>
        <category>Life</category>
        <category>Cooking</category>
      </categories>
      <tags>
        <tag>Cooking</tag>
      </tags>
  </entry>
  <entry>
    <title>损失函数</title>
    <url>/cost-function/</url>
    <content><![CDATA[
机器学习中所有的算法都需要最大化或最小化一个函数，这个函数被称为“目标函数”。其中，我们一般把最小化的一类函数，称为“损失函数”。损失函数（loss function）是用来估量你模型的预测值f(x)与真实值Y的不一致程度，它是一个非负实值函数，通常使用L(Y, f(x))来表示，损失函数越小，模型的鲁棒性就越好。在一些优化函数的辅助下，损失函数逐渐学会减少预测值的误差。损失函数是机器学习优化中至关重要的一部分，是一种评估特定算法对给定数据建模程度的方法，是经验风险函数的核心部分，也是结构风险函数重要组成部分。

<!--more-->

模型的结构风险函数包括了经验风险项和正则项，如式$\eqref{Structural-risk-function}$所示。其中，前面的均值函数表示的是经验风险函数，L代表的是损失函数，后面的$\Phi$是正则化项（regularizer）或者叫惩罚项（penalty term），它可以是L1，也可以是L2，或者其他的正则函数。整个式子表示的意思是找到使目标函数最小时的θ值。

$$
\begin{equation}
\theta^* = \arg \min_\theta \frac{1}{N}{}\sum_{i=1}^{N} L(y_i, f(x_i; \theta)) + \lambda\  \Phi(\theta)
\end{equation}
\label{Structural-risk-function}
$$

损失函数大致可分为两类：分类问题的损失函数和回归问题的损失函数[^2016/03/26]。在实际应用中，选取损失函数会受到诸多因素的制约，比如是否有异常值、机器学习算法的选择、梯度下降的时间复杂度、求导的难易程度以及预测值的置信度等等。因此，不存在一种损失函数适用于处理所有类型的数据。

[^2016/03/26]: [机器学习-损失函数](http://www.csuldw.com/2016/03/26/2016-03-26-loss-function/)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190418134747.png)

# 回归问题

均方误差(MSE)是最常用的回归损失函数，计算方法是求预测值与真实值之间距离的平方和。它只考虑误差的平均大小，不考虑其方向。但由于经过平方，与真实值偏离较多的预测值会比偏离较少的预测值受到更为严重的惩罚。再加上 MSE 的数学特性很好，这使得计算梯度变得更容易。

平均绝对误差（MAE，也称L1损失）是另一种用于回归模型的损失函数。MAE是目标值和预测值之差的绝对值之和。其只衡量了预测值误差的平均模长，而不考虑方向，取值范围也是从0到正无穷（如果考虑方向，则是残差/误差的总和——平均偏差（MBE））。

- 和 MSE 一样，这种度量方法也是在不考虑方向的情况下衡量误差大小。但和 MSE 的不同之处在于，MAE 需要像线性规划这样更复杂的工具来计算梯度。
- 简单来说，MSE计算简便，但MAE对异常点有更好的鲁棒性（更加稳健）。MSE对误差取了平方（令e=真实值-预测值），因此若e>1，则MSE会进一步增大误差。如果数据中存在异常点，那么e值就会很大，而e²则会远大于|e|。因此，相对于使用MAE计算损失，使用MSE的模型会赋予异常点更大的权重。用RMSE计算损失的模型会以牺牲了其他样本的误差为代价，朝着减小异常点误差的方向更新。然而这就会降低模型的整体性能。如果训练数据被异常点所污染，那么MAE损失就更好用（比如，在训练数据中存在大量错误的反例和正例标记，但是在测试集中没有这个问题）。
- 直观上可以这样理解：如果我们最小化MSE来对所有的样本点只给出一个预测值，那么这个值一定是所有目标值的平均值。但如果是最小化MAE，那么这个值，则会是所有样本点目标值的中位数。众所周知，对异常值而言，中位数比均值更加鲁棒，因此MAE对于异常值也比MSE更稳定。
- 然而MAE存在一个严重的问题（特别是对于神经网络）：更新的梯度始终相同，也就是说，即使对于很小的损失值，梯度也很大。这样不利于模型的学习。为了解决这个缺陷，我们可以使用变化的学习率，在损失接近最小值时降低学习率。而MSE在这种情况下的表现就很好，即便使用固定的学习率也可以有效收敛。MSE损失的梯度随损失增大而增大，而损失趋于0时则会减小。这使得在训练结束时，使用MSE模型的结果会更精确。推荐大家读一下[这篇文章](http://rishy.github.io/ml/2015/07/28/l1-vs-l2-loss/)，文中比较了分别使用L1、L2损失的回归模型在有无异常值时的表现。总而言之，处理异常点时，L1损失函数更稳定，但它的导数不连续，因此求解效率较低。L2损失函数对异常点更敏感，但通过令其导数为0，可以得到更稳定的封闭解。

平均偏差误差（mean bias error）：与其它损失函数相比，这个函数在机器学习领域没有那么常见。它与 MAE 相似，唯一的区别是这个函数没有用绝对值。用这个函数需要注意的一点是，正负误差可以互相抵消。尽管在实际应用中没那么准确，但它可以确定模型存在正偏差还是负偏差。

Huber损失，平滑的平均绝对误差。Huber损失对数据中的异常点没有平方误差损失那么敏感。它在0也可微分。本质上，Huber损失是绝对误差，只是在误差很小时，就变为平方误差。误差降到多小时变为二次误差由超参数δ（delta）来控制。当Huber损失在[0-δ,0+δ]之间时，等价为MSE，而在[-∞,δ]和[δ,+∞]时为MAE。

- 使用MAE训练神经网络最大的一个问题就是不变的大梯度，这可能导致在使用梯度下降快要结束时，错过了最小点。而对于MSE，梯度会随着损失的减小而减小，使结果更加精确。在这种情况下，Huber损失就非常有用。它会由于梯度的减小而落在最小值附近。比起MSE，它对异常点更加鲁棒。因此，Huber损失结合了MSE和MAE的优点。但是，Huber损失的问题是我们可能需要不断调整超参数delta。

Log-cosh是另一种应用于回归问题中的，且比L2更平滑的的损失函数。它的计算方式是预测误差的双曲余弦的对数。优点：对于较小的x，log(cosh(x))近似等于(x^2)/2，对于较大的x，近似等于abs(x)-log(2)。这意味着‘logcosh’基本类似于均方误差，但不易受到异常点的影响。它具有Huber损失所有的优点，但不同于Huber损失的是，Log-cosh二阶处处可微。但Log-cosh损失也并非完美，其仍存在某些问题。比如误差很大的话，一阶梯度和Hessian会变成定值，这就导致XGBoost出现缺少分裂点的情况。(许多机器学习模型如XGBoost，就是采用牛顿法来寻找最优点。而牛顿法就需要求解二阶导数（Hessian）。因此对于诸如XGBoost这类机器学习框架，损失函数的二阶可微是很有必要的。)

当我们更关注区间预测而不仅是点预测时，分位数损失函数就很有用。使用最小二乘回归进行区间预测，基于的假设是残差（y-y_hat）是独立变量，且方差保持不变。如何选取合适的分位值取决于我们对正误差和反误差的重视程度。损失函数通过分位值（γ）对高估和低估给予不同的惩罚。

仿真对比的一些观察结果[^2018-06-21-3]：

- MAE损失模型的预测结果受脉冲噪声的影响较小，而MSE损失函数的预测结果受此影响略有偏移。
- Huber损失模型预测结果对所选超参数不敏感。
- 分位数损失模型在合适的置信水平下能给出很好的估计。

# 分类问题

Hinge Loss/多分类 SVM 损失：简言之，在一定的安全间隔内（通常是 1），正确类别的分数应高于所有错误类别的分数之和。因此 hinge loss 常用于最大间隔分类（maximum-margin classification），最常用的是支持向量机。尽管不可微，但它是一个凸函数，因此可以轻而易举地使用机器学习领域中常用的凸优化器。

交叉熵损失/负对数似然：这是分类问题中最常见的设置。随着预测概率偏离实际标签，交叉熵损失会逐渐增加。

[^2018-06-21-3]: [机器学习大牛最常用的5个回归损失函数，你知道几个？](https://www.jiqizhixin.com/articles/2018-06-21-3)
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>协方差矩阵</title>
    <url>/covariance/</url>
    <content><![CDATA[
在统计学与概率论中，协方差矩阵（也称离差矩阵、方差-协方差矩阵）是一个矩阵，其 i, j 位置的元素是第 i 个与第 j 个随机向量（即随机变量构成的向量）之间的协方差。这是从标量随机变量到高维度随机向量的自然推广。

<!--more-->

首先定义一个含有n个样本的集合$X=\{X_1,\ldots,X_n\}$，

- 均值：$\bar{X}=\frac{\sum_{i=1}^n  X_{i}}{n}$
- 标准差：$s=\sqrt{\frac{\sum_{i=1}^n (X_{i}-\bar{X})^2}{n-1}}$
- 方差：$s^2=\frac{\sum_{i=1}^n (X_{i}-\bar{X})^2}{n-1}$

均值描述的是样本集合的中间点，它告诉我们的信息是很有限的，而标准差给我们描述的则是样本集合的各个样本点到均值的距离之平均。标准差描述的就是这种“散布度”。之所以除以$n-1$而不是除以$n$，是因为这样能使我们以较小的样本集更好的逼近总体的标准差，即统计上所谓的“无偏估计”。

但我们应该注意到，标准差和方差一般是用来描述一维数据的，但现实生活我们常常遇到含有多维数据的数据集。协方差就是这样一种用来度量两个随机变量关系的统计量，我们可以仿照方差的定义：

$$var(X)=\frac{\sum_{i=1}^n (X_{i}-\bar{X})(X_{i}-\bar{X})}{n-1}$$

来度量各个维度偏离其均值的程度，标准差可以这么来定义：

$$cov(X,Y)=cov(Y,X)=var(X)=\frac{\sum_{i=1}^n (X_{i}-\bar{X})(Y_{i}-\bar{Y})}{n-1}$$

如果结果为正值，则说明两者是正相关的(从协方差可以引出“相关系数”的定义)。如果为0，也是就是统计上说的“相互独立”。

协方差也只能处理二维问题，那维数多了自然就需要计算多个协方差，比如$n$维的数据集就需要计算$\frac{n!}{(n-2)!* 2}$个协方差，那自然而然的我们会想到使用矩阵来组织这些数据。给出协方差矩阵的定义：

$$C_{n\times n}=(c_{i,j},c_{i,j}=cov(Dim_{i},Dim_{j}))$$

假设数据集有$\{x,y,z\}$三个维度，则协方差矩阵为

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190418135351.png)

可见，协方差矩阵是一个对称的矩阵，而且对角线是各个维度上的方差。协方差矩阵计算的是不同维度之间的协方差，而不是不同样本之间的。

# MATLAB 实现

```
% 方法一
MySample = fix(rand(10,3)*50)
dim1 = MySample(:,1);
dim2 = MySample(:,2);
dim3 = MySample(:,3);
sum( (dim1-mean(dim1)) .* (dim2-mean(dim2)) ) / ( size(MySample,1)-1 )
% 得到  74.5333
sum( (dim1-mean(dim1)) .* (dim3-mean(dim3)) ) / ( size(MySample,1)-1 )
% 得到  -10.0889
sum( (dim2-mean(dim2)) .* (dim3-mean(dim3)) ) / ( size(MySample,1)-1 )
% 得到  -106.4000
std(dim1)^2 % 得到   108.3222
std(dim2)^2 % 得到   260.6222
std(dim3)^2 % 得到   94.1778

% 方法二
% 先让样本矩阵中心化，即每一维度减去该维度的均值，使每一维度上的均值为0
% 然后直接用新的到的样本矩阵乘上它的转置，然后除以(N-1)即可。
X = MySample - repmat(mean(MySample),10,1);
% 中心化样本矩阵，使各维度均值为0
C = (X'*X)./(size(X,1)-1);

% 方法三
cov(MySample)
```

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>CovarianceMatrix</tag>
      </tags>
  </entry>
  <entry>
    <title>酒桌文化</title>
    <url>/culture-of-drinking/</url>
    <content><![CDATA[
中国是一个爱吃的国家，很多事情都是在酒桌上谈成的，很多怨恨也是在酒桌上产生的。正所谓成也酒桌，败也酒桌。请客吃饭很讲究礼仪，从邀请到酒桌，再到散场送客，都需要了解背后的潜规则。在中国，这饭该怎么吃？其实也不复杂，综合起来就是“三大纪律、八项注意”。

# 纪律一：守时

现在的城市都拥堵，除非你是桌上最大的老板、最大的领导，如果不是就别迟到。中国是个礼仪之邦，一般都会等人齐了才开饭，十几个人等你一个，等的越久，就越讨厌你，这样的事儿多了，干脆就不叫你。

另外东道主应该是第一个到场，其他人既不能去太早显得几个月没吃了，也不能比大领导来的晚。宁可提前到饭店玩手机，离约定时间早个五分钟进场，不能让所有人都欢迎你的到来。

# 纪律二：友尚往来

在哪里吃不重要，重要的是和什么人吃；吃什么不重要，关键是吃的开心；谁买单不重要，重要的是同级别的人应该轮流坐庄。

当然，有两种人永远不用买单：大领导和被求之人。一般的原则是：**谁喊吃饭谁买单，在谁的地盘上谁买单，谁钱多谁买单，不然这个圈子不如第一次就A了，或者自觉轮流坐庄**。也许某人和你吃饭他掏了十次钱，但你也必须回请个三四次，再或者你和东道主每次都为了买单拉拉扯扯，但是三四次强行把小单给买了。

# 纪律三：守纪律

别人端杯你端杯，别人干了你扭捏两下再装作不会喝酒慢慢干了，别人夹菜你夹菜，别人站起来你就站起来，大老板敬酒一圈后你再敬，别人安静你也安静，别人喝汤你也喝汤。但凡吃饭，都一定是有组织有目的有主有次的一场局部战争，子弹都是打那些显眼的人，好印象也总是给那些守纪律的人，这样下次别人才会喊你。

# 八大注意事项

## 谁买单，谁安排座次

基本上中国式的吃饭，都不要做第一个坐下去的人。

如果你位尊权重，如果你是甲方，如果别人有求于你，别人自然是把主位给你，即便如此，也得在东道主请求下再三推辞方可入座。

其他人只管站着等主人安排位置，或者直接把最次的上菜位先坐了，然后再被主人邀请到某个位置上。

你永远不知道来宾之间是什么关系，你如果硬是插在夫妻，情侣之间，你就看脸色吃饭吧。

## 谁买单，谁就有话语权

如果你只是一个列席的食客，不要比主人说话更多，除非你是小品相声打鼓说唱演员节目主持人什么的，而别人希望听你来一段，除此之外，就是看买单的表演了。

你如果不服，先把钱包拿出来把单买了。人家请客，总不能自己埋头苦吃把自己那一份吃回来吧？人家花了钱自己又不能多吃，你还和人抢着说话，有没有天理了？

## 夹菜这种事情，要慎重处理

你是个男的，不要给人随便夹菜，尤其是给女性。如果你是个女的，也许特讨厌别人用口水筷子给你夹菜，可以说自己在减肥，然后把硬塞给你的东西放骨碟里不吃。

现在人生活水平提高了，什么都吃过，不像困难时期家里打个牙祭生怕客人没吃好，一阵乱夹。

## 搞清楚状况，再行动

身边坐一异性，搞清楚她是一个人来还是两个人来，和桌上谁的关系如何再说话，不然会有麻烦。

桌上有大老板在，就别谈自己的小生意，就算你是大老板，也得看桌上有没有大领导和更大的老板再吹牛，你得明白，这是别人的饭局，不是你的演讲会，周围坐的也不是你的下属和员工。

## 人抬人高

这吃饭不是好声音，不是智力竞赛，不是急转弯，不是连连看，也不是爱消除……

PK起来并不精彩!大家是来找乐的，不是来拼命的，不是花钱花时间来听你吹牛的。

别人讲，你夸，再有人讲，你也夸，总之，把别人点赞点够了，自然别人也会过来找你点赞，你这时候需要的就是一点点谦虚，就可以深不可测了。

好戏都是在后头，除非你想让别人看你的戏演砸了。

如果您觉得这些太假，那就大可以不做声，只对发言人微笑一下，开席二十分钟后下位把每个人挨个敬一下，问别人怎么称呼，然后把对方级别扩大个1~5级（比如业务员喊某总），并且牢记对方名字及级别即可。

## 保守秘密

也许你会发现朋友的老婆也被邀请来吃饭，并且和某领导某总很熟的样子；也许你会发现领导在酒桌上喝多了称兄道弟，和你说些你不该知道的秘密；再或者某个夜总会的妈咪在场，你不能轻佻地过去打招呼揭老底，再或者是某熟人带的是情人出场，你都必须保持缄默，如果你还想和他们一起吃饭，并且顺利打入他们的另一个圈子。

哦，忘记说了，往往熟人、老乡、同学或者同事关系，会在酒桌上被人多灌几杯。旧日糗事也不要再提，除非你真是来踢馆的。

## 不要随便劝酒和醉酒

等级不够就没资格劝酒，劝酒都是在熟人和同级别的人之间，你一小跑龙套的逼着领导干了，你是找干。

另外开车的，不喝酒的，酒量小的，异性的，说不喝，你就不能劝，消除尴尬的方法只有一个“我干了，您随意”。

额，你要知道，一人醉驾，全桌遭殃啊！如果你有酒后多话多动症，请严格控制您的酒量，切记。

## 点单和买单都需要智慧

别人请客，就别点菜，真要自己点，就问问服务员有什么特色菜然后挑个便宜的点了，然后让给女士或者东道主。

自己请客，那务必得有一两道印象深刻的“狠菜”，免得别人嫌菜档次不高格调不高就不和你玩了。

该你买单，就自觉趁上厕所偷偷买了，不该你买单，你就可以装傻趴桌上睡觉。别每次都装作掏钱包手卡兜里不动还空喊不行动，只需要说声“谢谢某总，下次我请”就行了。

认识人最快是在酒桌上，得罪人最快也是在酒桌上，且吃且饮且珍惜。

转自 [卿本佳人](http://jiaren.org/2017/06/01/qianguize-chifan/)

---
]]></content>
      <categories>
        <category>Life</category>
        <category>Etiquette</category>
      </categories>
      <tags>
        <tag>酒桌文化</tag>
        <tag>礼仪</tag>
      </tags>
  </entry>
  <entry>
    <title>数据处理</title>
    <url>/data-process/</url>
    <content><![CDATA[
如果把重点放在数据的处理方式上，那么长期共存的方式大概有两种：  

- 特征学习(feature learning)，又叫表示学习(representation learning)或者表征学习 。特征学习是从数据中自动抽取特征或者表示的方法，这个学习过程是模型自主的。
- 特征工程(feature engineering)，主要指对于数据的人为处理提取，有时候也代指“洗数据” 。特征工程的过程是人为的对数据进行处理，得到我们认为的、适合后续模型使用的样式。

<!--more-->

综上，机器学习模型对于数据的处理可以被大致归类到两个方向[^iChtc]：  

[^iChtc]: [人工智能是如何处理数据的？](https://mp.weixin.qq.com/s/iChtcYb7M-KQiMeiE6EYwA)

- 表示学习：模型自动对输入数据进行学习，得到更有利于使用的特征(可能同时做出了预测)。代表的算法大致包括： 深度学习，包括大部分常见的模型如cnn/rnn/dbn，也包括迁移学习等某些无监督学习算法，如主成分分析(PCA)通过对数据转化而使得输入数据更有意义，某些树模型可以自动的学习到数据中的特征并同时作出预测。
- 特征工程：模型依赖人为处理的数据特征，而模型的主要任务是预测，比如简单的线性回归期待良好的输入数据(如离散化后的数据) 。

这个不是一个严谨的科学划分，是一种直观的理解。如果所使用的模型拥有对于数据的简化、特征表示和抽取能力，我们都可以认为它是有表示学习的特性。狭义的特征工程指的是处理缺失值、特征选择、维度压缩等各种预处理手段，而从更大的角度看主要目的是提高数据的表示能力。对于数据的人为提炼使其有了更好的表达，这其实是人工的表示学习。

传统的机器学习方法主要依赖人工特征处理与提取，而深度学习依赖模型自身去学习数据的表示。

深度学习的层层网络可以从数据中自动学习到有用的、高度抽象的特征，而最终目的是为了帮助分类层做出良好的预测。深度学习的一大特点是其对数据的分布式表示(distributed representation)(也和稀疏性表示等其他特性有关)，最直观的例子可以是`nlp`中的`word2vec`，每个单词不再是割裂的而互相有了关联。类似的，不少网络中的参数共享就是分布式表示，不仅降低了参数量需求也提高对于数据的描述能力。仅看分类层的话，深度学习和其他的机器学习似乎没有天壤之别，但正因为有了种种良好的表示学习能力使其有了过人之处。

在数据量不够的时候，自动特征抽取的方法往往不如人为的特征工程。当使用者对于数据和问题有深刻的理解时，人工的特征工程往往效果更好。同时也值得注意，表示学习的另一好处是高度抽象化的特征往往可以被应用于相关的领域上，这也是我们常说的迁移学习(transfer learning)的思路。比如有了大量猫的图片以后，不仅可以用于预测一个物体是不是猫，也可以用于将抽取到的特征再运用于其他类似的领域从而节省数据开销。

从某个角度来看，表示学习有“嵌入式的特征选择”(embedded feature selection)的特性，其表示学习嵌入到了模型中。举个简单的例子，决策树模型在训练过程中可以同时学习到不同特征的重要性，而这个过程是建模的一部分，是一种嵌入式的特征选择。

首先对于模型选择有一定的帮助：当我们数据量不大，且对于数据非常理解时，人为的特征处理也就是特征工程是合适的。比如去掉无关数据、选择适合的数据、合并数据、对数据做离散化等。 当数据量较大或者我们的人为先验理解很有限时，可以尝试表示学习，如依赖一气呵成的深度学习，效果往往不错。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Feature</tag>
      </tags>
  </entry>
  <entry>
    <title>数据集划分</title>
    <url>/dataset-division/</url>
    <content><![CDATA[
在有监督的机器学习中，经常会说到训练集（train)、验证集（validation）和测试集（test）。如果我们自己已经有了一个大的标注数据集，想要完成一个有监督模型的测试，那么通常使用均匀随机抽样的方式，将数据集划分为训练集、验证集、测试集，这三个集合不能有交集，常见的比例是8:1:1[^8020_or_9010]，当然比例是人为的。从这个角度来看，三个集合都是同分布的。

[^8020_or_9010]: [Can someone recommend what is the best percent of divided the training data and testing data](https://www.researchgate.net/post/can_someone_recommend_what_is_the_best_percent_of_divided_the_training_data_and_testing_data_in_neural_network_7525_or_8020_or_9010)

<!--more-->

> When training multilayer networks, the general practice is to first divide the data into three subsets. The first subset is the training set, which is used for computing the gradient and updating the network weights and biases. The second subset is the validation set. The error on the validation set is monitored during the training process. The validation error normally decreases during the initial phase of training, as does the training set error[^divide-data-for-optimal-neural-network-trainin]. there is no fix criteria to recommend what is the best percent of divided the training data and testing data. Its only depend on the complexity of your situation (Application) how many independent parameter you have chosen. There is no fix criteria as such.

[^divide-data-for-optimal-neural-network-trainin]: [Divide Data for Optimal Neural Network Training](https://cn.mathworks.com/help/nnet/ug/divide-data-for-optimal-neural-network-training.html)

> 如果是做比赛，官方只提供了一个标注的数据集（作为训练集）以及一个没有标注的测试集，那么我们做模型的时候，通常会人工从训练集中划分一个验证集出来。这时候我们通常不再划分一个测试集，可能的原因有两个：1、比赛方基本都很抠，训练集的样本本来就少；2、我们也没法保证要提交的测试集是否跟训练集完全同分布，因此再划分一个跟训练集同分布的测试集就没多大意义了。

> [训练集、验证集和测试集的意义](http://kexue.fm/archives/4638/)

# 训练集

有了模型后，训练集就是用来训练参数的，说准确点，一般是用来梯度下降的。

# 验证集

验证集基本是在每个epoch完成后，用来测试一下当前模型的准确率。验证集和训练集，应该是不交叠的。这样选择模型的时候，才可以避免被数据交叠的因素干扰。

这就需要区分一下模型的各种参数了。事实上，对于一个模型来说，其参数可以分为普通参数和超参数。不同超参数组合，就对应着不同的潜在模型。验证集上跑的，实际上却是一个模型集合。验证集的存在，是为了从这一堆可能的模型中，帮你表现最好的那个。总之就是按照验证集的效果，来选超参数，从而决定最终模型。因此，怎么设定验证集，划分多少数据做验证，其实是每个研究者需要独立作出的决策，不应该强行设定为一致。

在不引入强化学习的前提下，那么普通参数就是可以被梯度下降所更新的，也就是训练集所更新的参数。另外，还有超参数的概念，比如网络层数、网络节点数、迭代次数、学习率等等，这些参数不在梯度下降的更新范围内。尽管现在已经有一些算法可以用来搜索模型的超参数，但多数情况下我们还是自己人工根据验证集来调。

那也就是说，从狭义来讲，验证集没有参与梯度下降的过程，也就是说是没有经过训练的；但从广义上来看，验证集却参与了一个“人工调参”的过程，我们根据验证集的结果调节了迭代数、调节了学习率等等，使得结果在验证集上最优。因此，我们也可以认为，验证集也参与了训练。

# 测试集

那么就很明显了，我们还需要一个完全没有经过训练的集合，那就是测试集，我们既不用测试集梯度下降，也不用它来控制超参数，只是在模型最终训练完成后，用来测试一下最后准确率。

<div class="note info"><p>比较模型效能数值结果时，你只能拿不同的模型，在同样的测试集上面比。只有在同样的测试集上，两个（或以上）模型的对比才有效。</p></div>


# 模型对比

一般来说，如果你要强调自己的模型优于其他人，那么就要保证是在同样的训练集上训练出来。

不要考虑对方声称达到了多高准确率。把他提供给你的数据全集，自行切分。之后复现对方的模型，重新跑。之后把你的模型，和复现的对方模型在同样的测试集上做对比，就可以了。

> 由于某篇文章未提供代码与具体数据切分说明，带来可重复性问题，我们不得不独立复现了其模型，并在测试集完全一致的情况下，进行了比对。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>TrainingSet</tag>
        <tag>ValidationSet</tag>
        <tag>TestSet</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习</title>
    <url>/deep-learning-1/</url>
    <content><![CDATA[
机器学习中提到了人工神经网络 (ANN)，它也可以分为两个类型：第一类是浅层的网络。如早期的感知机，它只有一个输入层和输出层组成。另外，上面提到的推断统计类型的机器学习方法从广义上说基本都可以归到这一类。第二类就是深层的网络，即深度神经网络，可以成为深度学习网络。它除了输出层和输出层之外，还有一个或多个隐层，并且通过学习算法，在隐层实现了对数据的抽象表达，如同人的认知系统。我们暂且对机器学习、深度学习的关系做一个简单粗暴的总结，那就是：机器学习中的人工神经网络是深度学习的起源，基于神经网络芯片的、大数据的、多层次的学习叫深度学习。

<!--more-->

**深度学习**（英语：deep learning）是[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")拉出的分支，它试图使用包含复杂结构或由多重非[线性变换](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2 "线性变换")构成的多个处理层对数据进行高层抽象的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95 "算法")。深度学习是[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")中一种基于对数据进行[表征学习](https://zh.wikipedia.org/wiki/%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0 "表征学习")的方法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域[等](https://zh.wikipedia.org/wiki/%E5%B0%BA%E5%BA%A6%E4%B8%8D%E8%AE%8A%E7%89%B9%E5%BE%B5%E8%BD%89%E6%8F%9B "尺度不变特征转换")。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。

如果更系统一点，可以把当今流行的深度神经网络分为应对具有空间性分布数据的CNN（卷积神经网络，Convolutional Neural Network）和应对具有时间性分布数据的RNN（递归神经网络（又称循环神经网络），Recursive Neural Network）。CNN往往应用于图像识别，RNN往往应用于语音识别和自然语言处理。语音和语言是一种按时间分布的数据，也就是说下一句的意义和上一句有关联，这跟RNN网络可以记住历史信息的特性有关系。

- [机器学习与深度学习资料汇总](https://github.com/ty4z2008/Qix)
- [Awesome Deep Learning](https://github.com/ChristosChristofidis/awesome-deep-learning)
- [Qix仓库](https://github.com/ty4z2008/Qix)提供了[机器学习(Machine Learning)&深度学习(Deep Learning)资料(Chapter 1)](https://github.com/ty4z2008/Qix/blob/master/dl.md)，[机器学习(Machine Learning)&深度学习(Deep Learning)资料](https://github.com/ty4z2008/Qix/blob/master/dl2.md)
- [DeepLearningBook读书笔记](https://github.com/exacity/simplified-deeplearning)
- [Deep Learning Mindmap / Cheatsheet](https://github.com/dformoso/deeplearning-mindmap)
- [零基础入门深度学习](https://www.zybuluo.com/hanbingtao/note/433855)
- [A Primer on Deep Learning](https://www.opendatascience.com/blog/change-a-primer-on-deep-learning/)  描述了深度学习与无监督学习，神经网络之间的关系与区别

# 逻辑框架

> [CNN(卷积神经网络)、RNN(循环神经网络)、DNN(深度神经网络)的内部网络结构有什么区别](https://www.zhihu.com/question/34681168)

[THE NEURAL NETWORK ZOO](http://www.asimovinstitute.org/neural-network-zoo/)展示了最流行的神经网络变体：

![A chart of neural networks](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190418135637.png)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190418135915.png)

神经网络有一个独特的能力，被称作「泛逼近函数」（Universal Approximation function），所以神经网络的拓扑和结构变体是很多样化的。这本身就是一个很大的话题，[Michael Nielsen 在文章中做了详细的描述](http://neuralnetworksanddeeplearning.com/chap4.html)。读完这个我们可以相信：神经网络可以模拟任何函数，不管它是多么的复杂。上面提到的神经网络也被称为前馈神经网络（FFNN），因为信息流是单向、无环的。现在我们已经理解了感知机和前馈神经网络的基本知识，我们可以想象，数百个输入连接到数个这样的隐藏层会形成一个复杂的神经网络，通常被称为深度神经网络或者深度前馈神经网络（DFF）。

- **线性回归 (+ 非线性激励) → 神经网络**

    * 有线性映射关系的数据，找到映射关系，非常简单，只能描述简单的映射关系
    * 大部分关系是非线性的，所以改进方法就是加一个非线性激励，某种程度是一个 NORMALIZE，但是是非线性的，对参数有更强的描述能力
    * +非线性激励，描述稍微复杂的映射关系，形成神经网络
    * 神经网络输入是 1 维信息，普通网络之间进行的是代数运算，然后经过非线性激励，形成新的神经网络

- **神经网络 (+时域递归) → RNN**

    * 神经网络处理一维信息，然而一维信息很可能是有前后的时间联系的，如人的语音，前面说的话与后面是有联系的，RNN 学习前后关系
    * 相当于某一刻的输出同时也作为下一刻的输入，所以这一刻的输入不仅是这一刻的输入+上一刻输出的信息

- **RNN (+记忆GATE) → LSTM**

    * RNN 只考虑前一刻信息，Tn 时刻只考虑 Tn-1 的，那么 Tn-2，就是  Tn-2 → Tn-1 → Tn  逐层衰减，信息也会越来越弱
    * 如果很久之前的记忆很重要，要把它记下来，就相当于有一个记忆方程，那么就可以用 LSTM，实现长记忆短记忆
    * Gate 来分析哪一部分存储，哪一部分进行传递
    * **应用：** 语句生成 → 自动翻译智能对话

- **神经网络 (+卷积核) → CNN**

    * 基本的代数运算用卷积核来代替。一维到二维甚至是三维的转化，相当于一个空间上的扩展
    * **应用：** 图片分类 → 目标分类(人脸识别/物品识别/场景识别/文字识别)、目标检测(安防/自动驾驶)
    * 深度，宽度，递归的变化  
          增加深度(网络层数)，E.g.OverFeat-accurate，VGG  
          增加宽度(filter数)，E.g.zf-big，OverFeat-accurate  
          递归的变化，可以跳过下一层，传到后面几层
    * 结构与性能
    * 特定问题的具体结构  
          比如说人脸识别，我们知道人脸有大体结构，用 CNN 来做识别时，可以让不同位置的像素不共享参数，眼睛有处理眼睛部分的卷积核，鼻子有处理鼻子部分的卷积核，它们之间不共享参数，这样的话参数会很多，但这样训练的结果可能会更好一些，专门对眼睛/鼻子进行训练

- **LSTM 卷积化(LSTM + CNN)**

    * **应用：** 产生理解图片的语言 → 图片描述/标注 → 看图说话，时域的图片 → 视频分类 → 视频搜索
    * NLP 方向比较成熟的只有语音识别，语义挖掘方面还是目前的热点

- **外部反馈 → 增强学习**

    * 模仿人类学习的模型
    * CNN 能理解，把它放在游戏中，做决策，给出反馈，让它学会决策的能力
    * **应用：** 围棋，德州扑克，自动游戏，路径规划

- **生成网络 + 判别网络 → 对抗网络**

    * 生成网络学会怎么生成数据，如输入有表情图片，学习怎么输出没有表情的图片，实际生成质量不是很好
    * 判别网络判断生成网络生成的图片是不是真的
    * 两者结合生成网络生成的图片越来越逼真，判别网络鉴别图片的能力也越来越强
    * **作用：** 生成数据，相当于无监督学习

<div id="cnn"></div>

# 卷积神经网络CNN

> [自 2012 年以来所有获得 ImageNet 竞赛冠军的 CNN 模型](https://adeshpande3.github.io/The-9-Deep-Learning-Papers-You-Need-To-Know-About.html)  
> [一文看懂卷积神经网络](https://mp.weixin.qq.com/s/7PcfqlbF_AvO4Odo1nOA_Q)  
> [图解CNN：通过100张图一步步理解CNN](https://blog.csdn.net/v_JULY_v/article/details/79434745)


CNN 由三种不同的层组成，即「卷积层」、「池化层」、「密集层或全连接层」。我们之前的神经网络都是典型的全连接层神经网络。如果想了解更多卷积和池化层的知识，可以阅读 [Andrej Karpathy 的解释](https://cs231n.github.io/convolutional-networks/)。

卷积神经网络采用的四种基本组件[^6ff66296b456]：Pooling、Dropouts、Batch Normalization、Data Augmentation 。

[^6ff66296b456]: [卷积神经网络中的四种基本组件](https://towardsdatascience.com/components-of-convolutional-neural-networks-6ff66296b456)

- Pooling是一种矢量，对图像的每个局部区域进行标量变换，就像卷积操作一样。Pooling的想法看起来可能适得其反，因为它会导致信息的丢失，但它在实践中证明是非常有效的。
- Dropouts是一种抑制过度拟合的技巧。 它可以随机地将一些激活值设置为0，从而避免过度拟合。
- 批量标准化（Batch Normalization）的工作原理是将每一批图像都标准化，从而得到零均值和单位方差，避免出现梯度消失。
- 随机扭曲训练图像，使用水平切除，垂直切除，旋转，增白，移位和其他扭曲的手段。这将使covnets学会如何处理这种扭曲，因此，他们将能够在现实世界中很好地工作。

<div id="rnn"></div>

# 递归神经网络RNN

> [循环神经网络RNN以及LSTM的推导和实现](http://blog.csdn.net/kymowind/article/details/75145775)  
> [RNN模型](http://blog.csdn.net/dream_catcher_10/article/details/48462815)  
> [详解循环神经网络(Recurrent Neural Network)](http://blog.csdn.net/aliceyangxi1987/article/details/73421556)

<div id="lstm"></div>

## LSTM

> [Alex Graves](https://www.cs.toronto.edu/~graves/)
> [RNN以及LSTM的介绍和公式梳理](http://blog.csdn.net/dark_scope/article/details/47056361)  
> [零基础入门深度学习(6) - 长短时记忆网络(LSTM)](https://zybuluo.com/hanbingtao/note/581764)  
> [循环神经网络RNN以及LSTM的推导和实现](https://blog.csdn.net/kymowind/article/details/75145775)  
> [LSTM模型理论总结（产生、发展和性能等）](https://blog.csdn.net/shincling/article/details/49362161)  
> [LSTM的公式推导详解](http://blog.csdn.net/u010754290/article/details/47167979)  
> [LSTM(without Peephole)参数更新公式推导 ](http://www.luolei.info/2015/10/30/lstm/)  
> [RNN以及LSTM的介绍和公式梳理](https://blog.csdn.net/Dark_Scope/article/details/47056361)  
> [Understanding LSTM Networks](http://colah.github.io/posts/2015-08-Understanding-LSTMs/)（[中文](https://yunaitong.cn/understanding-lstm-networks.html)）   
> [Exploring LSTMs](http://blog.echen.me/2017/05/30/exploring-lstms/)（[中文](https://mp.weixin.qq.com/s/lpyzzVDsvp9Gk0Ov2h7XTQ)）   
> [Chapter 10.1: DeepNLP — LSTM (Long Short Term Memory) Networks with Math](https://medium.com/deep-math-machine-learning-ai/chapter-10-1-deepnlp-lstm-long-short-term-memory-networks-with-math-21477f8e4235)  
> [A Beginner’s Guide to Recurrent Networks and LSTMs](https://deeplearning4j.org/lstm.html#long)  


长短期记忆递归神经网络LSTM是为了缓解RNN的梯度弥散问题而提出的一种变种模型，之所以能够缓解这个问题，是因为在原始的RNN中，梯度的传递是乘法的过程，如果梯度很小，那么从T时刻传递到后面的梯度只会越来越小，甚至消失，在优化空间中相当于一部分参数进行更新，而另外一部分参数几乎不变，那么问题的较优解也就很难收敛到。而LSTM通过推导会发现，梯度是以一种累加的方式进行反向传递的，从而一定程度上客服了累乘导致的梯度弥散的问题。


### LSTM的时序应用

> [A Guide For Time Series Prediction Using Recurrent Neural Networks (LSTMs)](https://blog.statsbot.co/time-series-prediction-using-recurrent-neural-networks-lstms-807fa6ca7f)  
> [LSTM的时序应用](https://zhuanlan.zhihu.com/p/27042867)  
> [Python中利用LSTM模型进行时间序列预测分析](http://www.cnblogs.com/arkenstone/p/5794063.html)  
> [Time Series Forecasting with the Long Short-Term Memory Network in Python](https://machinelearningmastery.com/time-series-forecasting-long-short-term-memory-network-python/)  
> [Long short-term memory (LSTM) layer in MATLAB R2017B](https://cn.mathworks.com/help/nnet/ref/nnet.cnn.layer.lstmlayer.html?requestedDomain=true&nocookie=true)  
> [深度学习-LSTM网络-代码-示例](http://blog.csdn.net/u012609509/article/details/51910405)   
> LSTM简单例子(MATLAB code)：[1](http://blog.csdn.net/u010866505/article/details/74910525)，[2](http://blog.csdn.net/dulingtingzi/article/details/51612586)


# CNN+RNN

> [卷积网络循环网络结合-CNN+RNN](https://mp.weixin.qq.com/s/TZWGIX7YnpIHmBofcTC9_Q)

相同点：

- 都是传统神经网络的扩展；
- 前向计算产生结果，反向计算进行模型的更新；
- 每层神经网络横向可以多个神经元共存，纵向可以有多层神经网络连接。

不同点：

- CNN进行空间扩展，神经元与特征卷积；RNN进行时间扩展，神经元与多个时间输出计算；
- RNN可以用于描述时间上连续状态的输出，有记忆功能；CNN则用于静态输出；
- CNN高级结构可以达到100+深度；RNN的深度有限。

组合的意义：

- 大量信息同时具有时间空间特性：视频，图文结合，真实的场景对话；
- 带有图像的对话，文本表达更具体；
- 视频相对图片描述的内容更完整。

组合方式：

- CNN特征提取，用于RNN语句生成->图片标注
- RNN特征提取用于CNN内容分类->视频分类
- CNN特征提取用于对话问答->图片问答

# 生成对抗网络GAN

> [生成对抗网络（GANs ）为什么这么火？盘点它诞生以来的主要技术进展](https://www.leiphone.com/news/201612/Cdcb1X9tm1zsGSWD.html)

GAN是“生成对抗网络”（Generative Adversarial Networks）的简称，由2014年还在蒙特利尔读博士的Ian Goodfellow引入深度学习领域。2016年，GAN热潮席卷AI领域顶级会议，从ICLR到NIPS，大量高质量论文被发表和探讨。Yann LeCun曾评价GAN是“20年来机器学习领域最酷的想法”。

# 训练

[深度神经网络训练的必知技巧](http://blog.csdn.net/u013709270/article/details/70949304)主要介绍8种实现细节的技巧或tricks：数据增广、图像预处理、网络初始化、训练过程中的技巧、激活函数的选择、不同正则化方法、来自于数据的洞察、集成多个深度网络的方法。

# 实现

* [Which GPU(s) to Get for Deep Learning: My Experience and Advice for Using GPUs in Deep Learning](http://timdettmers.com/2014/08/14/which-gpu-for-deep-learning/)   文章建议用GPU实现深度学习，并提供了GPU选择的参考意见


# 开源的项目

> [深度学习](https://www.jianshu.com/p/051feb5da15e)

* [开源的框架及工具](https://github.com/aymericdamien/TopDeepLearning)
    * [Tensorflow](https://www.tensorflow.org/)
        * 计算的过程抽象成了图形化的数据流，方便在不同的设备上进行部署
        * 来源于google实验室，在实际项目中验证过。
        * [源代码](https://github.com/tensorflow/tensorflow)
        * [应用实例1](https://github.com/pkmital/tensorflow_tutorials)
        * [应用实例2](https://github.com/nlintz/TensorFlow-Tutorials)
    * [Torch](http://torch.ch/)
        * 采用LuaJIT实现，提供了C接口
        * 支持IOS和Android
        * [源代码](https://github.com/torch/torch7)
    * [Theano](http://deeplearning.net/software/theano/)
        * 一个python库，方便多维度的数学计算，在学术研究中经常使用
        * Montreal大学的深度学习课程就用到了它
        * [在深度学习上的应用案例](http://www.deeplearning.net/tutorial/)
        * [详细介绍](http://arxiv.org/pdf/1605.02688.pdf)
        * [源代码](https://github.com/Theano/Theano/)
    * [Deprecation](https://github.com/rasmusbergpalm/DeepLearnToolbox)
        * Matlab实现
        * 目前已停止维护，如果需要用Matlab做项目的话，可以参考。
        * [源代码](https://github.com/rasmusbergpalm/DeepLearnToolbox)

* 其他应用
    * [面部关键点识别问题](https://github.com/cowpig/deep_keypoints)
        * 深度神经网络在计算机视觉上的应用
        * python实现
        * 算法中使用的样本数据
    * [Kaggle](https://www.kaggle.com/c/facial-keypoints-detection/details/deep-learning-tutorial)

# Q&A

1. 深度学习大多数都是用gpu做，我看文献说速度可能会差10倍。如果是只用cpu来实现是否可行？

    * 只用CPU来实现深度学习是可以的，只是需要的时间特别的长，对CPU的要求也很高，笔记本电脑和普通的台式机的都不太适合，一般都是推荐用大型的服务器或者云服务。
    * 深度学习相比SVM来说，需要更多层的计算，运算量比较大。 一般来说，用GPU来实现深度学习，速度会比cpu高5倍，而且数据量越大，GPU的优势越明显，最大能达到10倍的差距，所以，大量的文献资料是建议用GPU来进行处理的，毕竟现在GPU的性能也越来越高，而且并行计算的能力也越来越好。
    * 至于在实际应用中，是否只用CPU来实现，这个还是要具体问题具体分析了，没有一个统一的标准答案。主要根据以下几个方面来考虑，问题域应用的硬件环境，要处理的数据量的多少，结果的准确性要求，输入到输出的时间限制。如果数据量大，需要快速有结果的话，不建议只用CPU来实现。(ps,学术研究的话，不建议只用CPU实现，因为算法的计算量摆在那里的，在论文中说是只用CPU实现的话，估计论文不太好发。实在是要只用CPU实现的话，可以考虑结合分布式的并行计算，云计算，云存储之类的技术。）

1. 深度学习是否也要事先定义一些特征呢？我看到有的文章是不需要定义特征的，深度学习方法可以自学习一些特征来进行。而有一些文章却自己定义了一些特征，如果自己定义特征，深度学习方法和普通机器学习方法有差别吗？而且如何选特征选多少特征会比较合适呢？

    * 深度学习实质是构建具有很多隐层的机器学习模型，再通过海量的数据来进行训练，得出更有用的特征，再根据这些特征进行分类或者预测。所以，不需要事先定义特征。但是，如果训练的数据量小的话，其自学习到的特征便不准确，导致最后的分类结果出现很大的误差。所以，理论上来说，深度学习算法是不需要自定义的特征的，但是在某些环境中，加入自定义的特征能更好的提高算法的精确度。
    * 普通的机器学习方法是浅层学习，而深度学习的不同在于：1）强调了模型结构的深度，通常有5层、6层，甚至10多层的隐层节点；2）明确突出了特征学习的重要性，也就是说，通过逐层特征变换，将样本在原空间的特征表示变换到一个新特征空间，从而使分类或预测更加容易。但是，与自己定义特征的方法相比，深度学习利用大数据来自学习特征，更能够刻画数据的内在信息，特征提取也更加的客观。
    * 深度学习的训练过程如下：
        * 1）使用自下上升非监督学习（就是从底层开始，一层一层的往顶层训练）：
            * 采用无标定数据（有标定数据也可）分层训练各层参数，这一步可以看作是一个无监督训练过程，是和传统神经网络区别最大的部分（这个过程可以看作是feature learning过程）：

            * 具体的，先用无标定数据训练第一层，训练时先学习第一层的参数（这一层可以看作是得到一个使得输出和输入差别最小的三层神经网络的隐层），由于模型capacity的限制以及稀疏性约束，使得得到的模型能够学习到数据本身的结构，从而得到比输入更具有表示能力的特征；在学习得到第n-1层后，将n-1层的输出作为第n层的输入，训练第n层，由此分别得到各层的参数；

        * 2）自顶向下的监督学习（就是通过带标签的数据去训练，误差自顶向下传输，对网络进行微调）：
            * 基于第一步得到的各层参数进一步fine-tune整个多层模型的参数，这一步是一个有监督训练过程；第一步类似神经网络的随机初始化初值过程，由于DL的第一步不是随机初始化，而是通过学习输入数据的结构得到的，因而这个初值更接近全局最优，从而能够取得更好的效果；所以deep learning效果好很大程度上归功于第一步的feature learning过程。

    * 如何选特征，选多少特征这个需要具体问题具体分析。任何一种方法，特征越多，给出的参考信息就越多，准确性会得到提升。但特征多意味着计算复杂，探索的空间大，可以用来训练的数据在每个特征上就会稀疏，都会带来各种问题，并不一定特征越多越好。

1. 对服务器和样本量有什么要求？对训练集的数目有要求吗？如果像题2那样可以自己定义特征的话，特征的数目和训练集的数目有什么有什么要求吗？

    * 服务器的要求：
        * GPU：GTX 680 或者GTX 960(这是穷人配置)；GTX 980 (表现最佳，强烈推荐)
        * CPU配置：Intel系列，高端的即可，做好多核
        * 内存：越大越好，至少要和GPU的内存一样大
    * 训练的数目问题，深度学习的应用主要是大数据，解决的是普通的机器学习算法处理大数据时的特征提取问题，结果准确性，结果生成速度等问题，如果数据量太少的话，深度学习算法反而在性能上还比不上普通的机器学习算法。所以，训练的数据越多越好。至于特征的数目，这个要具体问题具体分析了，目前没有统一的标准和理论依据，只能凭经验或者在试验中不断调整测试。

1. 深度学习的几种模型如（AutoEncoder，Sparse Coding，Restricted Boltzmann Machine，Deep BeliefNetworks，Convolutional Neural Networks）在解决实际问题的时候是否有倾向性的解决某一类问题？比如说更倾向解决分类问题还是预测连续值的问题？或者说在效能上有什么差别（如时间或者空间，或者准确度上）？

    * AutoEncoder自动编码器，可用于分类问题；
    * Sparse Coding稀疏编码算法是一种无监督学习方法；主要应用于图像处理和语音信号处理
    * Restricted Boltzmann Machine (RBM)限制波尔兹曼机，受限制玻尔兹曼机在降维、分类、协同过滤、特征学习和主题建模中得到了应用。
    * Deep Belief Networks深信度网络，主要应用于图像识别和语音处理领域
    * Convolutional Neural Networks，CNNs是受早期的延时神经网络（TDNN）的影响。延时神经网络通过在时间维度上共享权值降低学习复杂度，适用于语音和时间序列信号的处理。
    * 深度学习算法在计算上比普通机器学习算法更复杂，因而对时间和机器资源的要求更高，相应地，也取得了比普通机器学习算法更好的计算效果。

1. 目前深度学习方法都用于处理图形，或者一些生物分子的结构还有序列上面，那么这个方法是否能够直接适用于表达谱这种数据呢，比如用表达谱作特征区分疾病和正常样本？我认为表达谱数据的特点是含有很大部分的噪音，不一定所有基因表达都与所研究的疾病相关。如果用这种给出的训练样本有噪音的情况，深度学习方法能不能自动学习而去除噪音的影响？

    * 能直接应用于表达谱，但是深度学习对于有大量噪声的数据的效果不是很好。
    * 用深度学习在生物学上的应用主要有两个难点，1）分析的数据集很难获取。2）计算量非常大，需要很好的硬件支持。
    * D-GEX： 深度学习在表达谱上的应用的一个开源案例
        * [项目源码](https://github.com/uci-cbcl/D-GEX)
        * [论文](http://biorxiv.org/content/biorxiv/early/2015/12/15/034421.full.pdf)
    * 其他参考
        * [Deep modeling of gene expression regulation in an Erythropoiesis  
            model](http://deeplearning.net/wp-content/uploads/2013/03/icml_paper.pdf)
        * [List of deep learning implementations in biology](https://followthedata.wordpress.com/2015/12/21/list-of-deep-learning-implementations-in-biology/)

1. 深度学习方法层数选择以及每一层所用的模型有什么技巧吗？

    * 不同的算法，以及处理问题不同，不能一概而论。现在处于各自摸索阶段，在选择上没有什么理论的依据。

1. [深度学习做股票预测靠谱吗？](https://www.zhihu.com/question/54542998/answer/226949686)
    - 所谓的深度学习不过是基于历史数据进行拟合的归纳法罢了，如果把深度学习用来做股票预测，长期的是expected亏钱的，因为市场在变，规律在变，历史可能重演，但是又不尽相同。
    - Deep learning能做一切数据挖掘有关的事情，区别在于你能不能结合自身的经验去建立一个较优的模型，让learning更加的“高效”，这种“高效”包含但不限于：学习时间、学习误差率、学习鲁棒性、学习所耗费的资源等。
    - Deep learning处理的数据前期至少要求是相对全面的，不全面的数据、甚至如果有重要的数据有所隐藏，对于任何学习模型来讲基本都是灾难的。
    - Deep learning所谓的模型，对于目前而言，受限于基础理论，建立模型的过程是渐进的、甚至是需要人工的，所以“调参”的手段是有很大的“主观成分”在里面的。
    - Deep learning是统计学和机器学习两门科学的交叉科学，它的宗旨是通过统计学习方法运用机器学习的运算(实现)思路，让机器帮我们去计算各种事件出现的概率，协助我们去分类大数据、预测新的样本为【某个特定分类】的概率等等。但是，仅仅是“概率”，既然是“概率”必然也就只是可能性而已。

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>DeepLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习之时间序列预测</title>
    <url>/deep-learning-prediction/</url>
    <content><![CDATA[
**深度学习**（英语：deep learning）是[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")拉出的分支，它试图使用包含复杂结构或由多重非[线性变换](https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E5%8F%98%E6%8D%A2 "线性变换")构成的多个处理层对数据进行高层抽象的[算法](https://zh.wikipedia.org/wiki/%E7%AE%97%E6%B3%95 "算法")。深度学习是[机器学习](https://zh.wikipedia.org/wiki/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0 "机器学习")中一种基于对数据进行[表征学习](https://zh.wikipedia.org/wiki/%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0 "表征学习")的方法。观测值（例如一幅图像）可以使用多种方式来表示，如每个像素强度值的向量，或者更抽象地表示成一系列边、特定形状的区域[等](https://zh.wikipedia.org/wiki/%E5%B0%BA%E5%BA%A6%E4%B8%8D%E8%AE%8A%E7%89%B9%E5%BE%B5%E8%BD%89%E6%8F%9B "尺度不变特征转换")。而使用某些特定的表示方法更容易从实例中学习任务（例如，人脸识别或面部表情识别）。

<!--more-->

深度学习的好处是用[非监督式](https://zh.wikipedia.org/wiki/%E9%9D%9E%E7%9B%A3%E7%9D%A3%E5%BC%8F%E5%AD%B8%E7%BF%92 "非监督式学习")或[半监督式](https://zh.wikipedia.org/w/index.php?title=%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%BC%8F%E5%AD%A6%E4%B9%A0&action=edit&redlink=1)（英语：[Semi-supervised learning](https://en.wikipedia.org/wiki/Semi-supervised_learning "en:Semi-supervised learning")）的[特征学习](https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E5%AD%A6%E4%B9%A0 "特征学习")和分层[特征提取](https://zh.wikipedia.org/wiki/%E7%89%B9%E5%BE%81%E6%8F%90%E5%8F%96 "特征提取")高效算法来替代手工获取[特征](https://zh.wikipedia.org/w/index.php?title=%E7%89%B9%E5%BE%81_(%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0)&action=edit&redlink=1)（英语：[Feature (machine learning)](https://en.wikipedia.org/wiki/Feature_(machine_learning) "en:Feature (machine learning)")）。

[表征学习](https://zh.wikipedia.org/wiki/%E8%A1%A8%E5%BE%81%E5%AD%A6%E4%B9%A0 "表征学习")的目标是寻求更好的表示方法并创建更好的模型来从大规模未标记数据中学习这些表示方法。表达方式类似[神经科学](https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E7%A7%91%E5%AD%A6 "神经科学")的进步，并松散地创建在类似[神经系统](https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E7%B3%BB%E7%BB%9F "神经系统")中的信息处理和通信模式的理解上，如[神经编码](https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E7%BC%96%E7%A0%81 "神经编码")，试图定义拉动神经元的反应之间的关系以及[大脑](https://zh.wikipedia.org/wiki/%E5%A4%A7%E8%84%91 "大脑")中的神经元的电活动之间的关系。

至今已有数种深度学习框架，如[深度神经网络](https://zh.wikipedia.org/wiki/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0#.E6.B7.B1.E5.BA.A6.E7.A5.9E.E7.BB.8F.E7.BD.91.E7.BB.9C "深度学习")、[卷积神经网络](https://zh.wikipedia.org/wiki/%E5%8D%B7%E7%A7%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C "卷积神经网络")和[深度置信网络](https://zh.wikipedia.org/w/index.php?title=%E6%B7%B1%E5%BA%A6%E7%BD%AE%E4%BF%A1%E7%BD%91%E7%BB%9C&action=edit&redlink=1)（英语：[Deep belief network](https://en.wikipedia.org/wiki/Deep_belief_network "en:Deep belief network")）和[递归神经网络](https://zh.wikipedia.org/wiki/%E9%80%92%E5%BD%92%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C "递归神经网络")已被应用[计算机视觉](https://zh.wikipedia.org/wiki/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89 "计算机视觉")、[语音识别](https://zh.wikipedia.org/wiki/%E8%AF%AD%E9%9F%B3%E8%AF%86%E5%88%AB "语音识别")、[自然语言处理](https://zh.wikipedia.org/wiki/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86 "自然语言处理")、音频识别与[生物信息学](https://zh.wikipedia.org/wiki/%E7%94%9F%E7%89%A9%E4%BF%A1%E6%81%AF%E5%AD%A6 "生物信息学")等领域并获取了极好的效果。另外，“深度学习”已成为类似术语，或者说是[神经网络](https://zh.wikipedia.org/wiki/%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C "神经网络")的品牌重塑。


# 简介

* **_[一页纸介绍深度学习](http://blog.sciencenet.cn/blog-4099-785174.html)_**
* 深度学习的前世今生
    * **_[简化版](http://haohanw.blogspot.com/2015/01/long-way-to-go.html)_**
    * **_[完整版](http://arxiv.org/pdf/1510.04781v2.pdf)_**
* 所有参考资料集锦
    * [资料链接1](https://github.com/ChristosChristofidis/awesome-deep-learning) :包含课程，文献，论坛，视频，在线免费教材，框架结构等。
    * [资料链接2](https://github.com/HFTrader/DeepLearningBook/blob/master/DeepLearningPapers.md)：主要是pdf格式的可供下载的论文。

# 时间序列预测

You can do time-series prediction with neural nets, but it can get pretty tricky.

1) The obvious choice is a recurrent neural network (RNN). However, these can be really difficult to train, and I would not recommend RNNs if this is your first time using neural nets. Recently there has been some interesting work on easing the training of RNNs (e.g. Hessian-free optimization), but again - it's probably not for beginners ;-) Alternatively, you could try a scheme where you use a standard neural net (i.e. not a RNN), and try to predict the next frame of data from the previous? That might work.

2) This question is too general, there is no categorical right answer. Yes, you can use unsupervised feature learning as part of your solution (e.g. pre-training your model), but if your end goal is time-series prediction you will need to do some supervised learning too.

There has been some work on adapting deep learning methods for sequential data. A lot of this work has focused on developing "modules" which can be stacked in a way analogous to stacking restricted boltzmann machines (RBMs) or autoencoders to form a deep neural network. I'll highlight a few below:

* [Conditional RBMs](http://www.cs.toronto.edu/~hinton/absps/fcrbm_icml.pdf): Probably one of the most successful applications of deep learning for time series. Taylor develops a RBM like model that adds temporal interactions between visible units and apply it to modeling motion capture data. Essentially you end up with something like a linear dynamical system with some non-linearity added by the hidden units.
* [Temporal RBMs](http://www.cs.utoronto.ca/~ilya/pubs/ilya_sutskever_phd_thesis.pdf): In his thesis (section 3) Ilya Sutskever develops several RBM like models with temporal interactions between units. He also presents some interesting results showing training recurrent neural networks with SGD can perform as well or better than more complex methods, like Martens' Hessian-free algorithm, using good initialization and a slightly modified equation for momentum.
* [Recursive Autoencoders](http://www.socher.org/index.php/Main/ParsingNaturalScenesAndNaturalLanguageWithRecursiveNeuralNetworks): Lastly I'll mention the work of Richard Socher on using recursive autoencoders for parsing. Although this isn't time series, it is definitely related.

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>DeepLearning</tag>
        <tag>TimeSeriesPrediction</tag>
      </tags>
  </entry>
  <entry>
    <title>降维算法</title>
    <url>/dimension-reduction/</url>
    <content><![CDATA[
机器学习领域中所谓的降维就是指采用某种映射方法，将原高维空间中的数据点映射到低维度的空间中。降维的本质是学习一个映射函数 f : x->y，其中x是原始数据点的表达，目前最多使用向量表达形式。 y是数据点映射后的低维向量表达，通常y的维度小于x的维度（当然提高维度也是可以的）。f可能是显式的或隐式的、线性的或非线性的。

<!--more-->

目前大部分降维算法处理向量表达的数据，也有一些降维算法处理高阶张量表达的数据。之所以使用降维后的数据表示是因为在原始的高维空间中，包含有冗余信息以及噪音信息，在实际应用例如图像识别中造成了误差，降低了准确率；而通过降维,我们希望减少冗余信息所造成的误差,提高识别（或其他应用）的精度。又或者希望通过降维算法来寻找数据内部的本质结构特征。

> 参考链接：
> - [四大机器学习降维方法](http://blog.csdn.net/xbinworld/article/details/6773885)
> - [模式识别：PCA主分量分析与Fisher线性判别分析](http://blog.csdn.net/liyuefeilong/article/details/45126255)

# 主成分分析PCA

Principal Component Analysis(PCA)是最常用的线性降维方法，它的目标是通过某种线性投影，将高维的数据映射到低维的空间中表示，并期望在所投影的维度上数据的方差最大，以此使用较少的数据维度，同时保留住较多的原数据点的特性。

通俗的理解，如果把所有的点都映射到一起，那么几乎所有的信息（如点和点之间的距离关系）都丢失了，而如果映射后方差尽可能的大，那么数据点则会分散开来，以此来保留更多的信息。可以证明，PCA是丢失原始数据信息最少的一种线性降维方式。（实际上就是最接近原始数据，但是PCA并不试图去探索数据内在结构）

# 线性判别分析LDA

Linear Discriminant Analysis (也有叫做Fisher Linear Discriminant)是一种有监督的（supervised）线性降维算法。与PCA保持数据信息不同，LDA是为了使得降维后的数据点尽可能地容易被区分！

# 局部线性嵌入LLE

Locally linear embedding（LLE）是一种非线性降维算法，它能够使降维后的数据较好地保持原有流形结构。LLE可以说是流形学习方法最经典的工作之一。很多后续的流形学习、降维方法都与LLE有密切联系。

# 拉普拉斯特征映射

其实不是说每一个算法都比前面的好，而是每一个算法都是从不同角度去看问题，因此解决问题的思路是不一样的。这些降维算法的思想都很简单，却在有些方面很有效。这些方法事实上是后面一些新的算法的思路来源。

拉普拉斯特征映射（Laplacian Eigenmaps）看问题的角度和LLE有些相似，也是用局部的角度去构建数据之间的关系。它的直观思想是希望相互间有关系的点（在图中相连的点）在降维后的空间中尽可能的靠近。Laplacian Eigenmaps可以反映出数据内在的流形结构。

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>DimensionalityReductionAlgorithms</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习中的相似性度量</title>
    <url>/distance/</url>
    <content><![CDATA[
在做分类时常常需要估算不同样本之间的相似性度量(Similarity Measurement)，这时通常采用的方法就是计算样本间的“距离”(Distance)。采用什么样的方法计算距离是很讲究，甚至关系到分类的正确与否。

<!--more-->

> [常见的距离算法和相似度计算方法-Python](https://zhuanlan.zhihu.com/p/138107999)

机器学习两种距离——欧式距离和马氏距离。

# 欧氏距离

欧氏距离（Euclidean distance）也称欧几里得度量、欧几里得度量，是一个通常采用的距离定义，它是在m维空间中两个点之间的真实距离。在二维和三维空间中的欧氏距离的就是两点之间的距离。


两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的欧氏距离：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswfw5gb43j304w02b3y9.jpg)


缺点：就大部分统计问题而言，欧氏距离是不能令人满意的。（每个坐标对欧氏距离的贡献是同等的。当坐标表示测量值时，它们往往带有大小不等的随机波动，在这种情况下，合理的方法是对坐标加权，使变化较大的坐标比变化较小的坐标有较小的权系数，这就产生了各种距离。当各个分量为不同性质的量时，“距离”的大小与指标的单位有关。它将样品的不同属性（即各指标或各变量）之间的差别等同看待，这一点有时不能满足实际要求。没有考虑到总体变异对距离远近的影响。

Matlab计算距离主要使用pdist函数。若X是一个M×N的矩阵，则pdist(X)将X矩阵M行的每一行作为一个N维向量，然后计算这M个向量两两间的距离。

```
例子：计算向量(0,0)、(1,0)、(0,2)两两间的欧式距离
X = [0 0 ; 1 0 ; 0 2]
D = pdist(X,'euclidean')
结果：
D =
    1.0000    2.0000    2.2361
```

# 标准化欧氏距离

标准化欧氏距离 (Standardized Euclidean distance )，标准化欧氏距离是针对简单欧氏距离的缺点而作的一种改进方案。标准欧氏距离的思路：既然数据各维分量的分布不一样，好吧！那我先将各个分量都“标准化”到均值、方差相等吧。均值和方差标准化到多少呢？

假设样本集X的均值(mean)为m，标准差(standard deviation)为s，那么X的“标准化变量”表示为：而且标准化变量的数学期望为0，方差为1。因此样本集的标准化过程(standardization)用公式描述就是：  

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswfx9cyllj302d0160fi.jpg)

经过简单的推导就可以得到两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的标准化欧氏距离的公式：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg069h3qj304r02ba9t.jpg)

如果将方差的倒数看成是一个权重，这个公式可以看成是一种加权欧氏距离(Weighted Euclidean distance)。

```
例子：计算向量(0,0)、(1,0)、(0,2)两两间的标准化欧氏距离 (假设两个分量的标准差分别为0.5和1)
X = [0 0 ; 1 0 ; 0 2]
D = pdist(X, 'seuclidean',[0.5,1])
结果：
D =
    2.0000    2.0000    2.8284
```

# 马氏距离

马氏距离(Mahalanobis distance)是由印度统计学家马哈拉诺比斯提出的，表示数据的协方差距离。为两个服从同一分布并且其协方差矩阵为Σ的随机变量与的差异程度：如果协方差矩阵为单位矩阵，那么马氏距离就简化为欧氏距离，如果协方差矩阵为对角阵，则其也可称为正规化的欧氏距离。它是一种有效的计算两个未知样本集的相似度的方法。在绝大多数情况下，马氏距离是可以顺利计算的，但是马氏距离的计算是不稳定的，不稳定的来源是协方差矩阵，这也是马氏距离与欧式距离的最大差异之处。

有M个样本向量X1~Xm，协方差矩阵记为S，均值记为向量μ，则其中样本向量X到u的马氏距离表示为：  
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg0qqy03j305r0160r6.jpg)  
而其中向量Xi与Xj之间的马氏距离定义为：  
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg0qqy03j305r0160r6.jpg)  
若协方差矩阵是单位矩阵（各个样本向量之间独立同分布），则公式就成了欧氏距离。若协方差矩阵是对角矩阵，公式变成了标准化欧氏距离。


优点：它不受量纲的影响，两点之间的马氏距离与原始数据的测量单位无关。（它考虑到各种特性之间的联系（例如：一条关于身高的信息会带来一条关于体重的信息，因为两者是有关联的）并且是尺度无关的(scale-invariant)，即独立于测量尺度）；由标准化数据和中心化数据(即原始数据与均值之差）计算出的二点之间的马氏距离相同。马氏距离还可以排除变量之间的相关性的干扰。  

缺点：夸大了变化微小的变量的作用。受协方差矩阵不稳定的影响，马氏距离并不总是能顺利计算出。

```
两个样本：
His1 = {3,4,5,6}
His2 = {2,2,8,4}

它们的均值为：
U = {2.5, 3, 6.5, 5}
协方差矩阵为：
S =
| 0.25   0.50   -0.75   0.50  |
| 0.50   1.00   -1.50   1.00  |  
|-0.75  -1.50    2.25  -1.50  |
| 0.50   1.00   -1.50   1.00  |
其中S(i,j)={[His1(i)-u(i)]*[His1(j)-u(j)]+[His2(i)-u(i)]*[His2(j)-u(j)]}/2

下一步就是求出逆矩阵S^(-1)
马氏距离 D=sqrt{[His1-His2] * S^(-1) * [(His1-His2)的转置列向量]}
```

```
Matlab计算(1 2)，( 1 3)，( 2 2)，( 3 1)两两之间的马氏距离
X = [1 2; 1 3; 2 2; 3 1]
Y = pdist(X,'mahalanobis')
结果：
Y =
    2.3452    2.0000    2.3452    1.2247    2.4495    1.2247
```

```
%欧氏距离和马氏距离的计算  
x=[1 2;1 3;2 2;3 1];  
[mx,nx]=size(x);  
Dis=ones(mx,nx);%产生全1的矩阵  
C=cov(x);%计算协方差  
for i=1:mx  
    for j=1:nx  
        D(i,j)=((x(i,:)-x(j,:))*inv(C)*(x(i,:)-x(j,:))')^0.5;  
    end  
end  

Y=pdist(x,'mahal')  
y=squareform(Y)  
```

# 曼哈顿距离

曼哈顿距离(Manhattan Distance)，从名字就可以猜出这种距离的计算方法了。想象你在曼哈顿要从一个十字路口开车到另外一个十字路口，驾驶距离是两点间的直线距离吗？显然不是，除非你能穿越大楼。实际驾驶距离就是这个“曼哈顿距离”。而这也是曼哈顿距离名称的来源， 曼哈顿距离也称为城市街区距离(City Block distance)。

两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的曼哈顿距离  
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg1qsjnfj304c01q0pl.jpg)


```
例子：计算向量(0,0)、(1,0)、(0,2)两两间的曼哈顿距离
X = [0 0 ; 1 0 ; 0 2]
D = pdist(X, 'cityblock')
结果：
D =
     1     2     3
```

# 切比雪夫距离

切比雪夫距离 ( Chebyshev Distance )，国际象棋玩过么？国王走一步能够移动到相邻的8个方格中的任意一个。那么国王从格子(x1,y1)走到格子(x2,y2)最少需要多少步？自己走走试试。有一种类似的一种距离度量方法叫切比雪夫距离。

两个n维向量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的切比雪夫距离  
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg28289uj304h0160my.jpg)  
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg2gzd82j306101qdfl.jpg)

```
例子：计算向量(0,0)、(1,0)、(0,2)两两间的切比雪夫距离
X = [0 0 ; 1 0 ; 0 2]
D = pdist(X, 'chebychev')
结果：
D =
     1     2     2
```

# 闵可夫斯基距离

闵可夫斯基距离(Minkowski Distance)，闵氏距离不是一种距离，而是一组距离的定义。

两个n维变量a(x11,x12,…,x1n)与 b(x21,x22,…,x2n)间的闵可夫斯基距离定义为：
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg2wv89oj304p02b741.jpg)

其中p是一个变参数。当p=1时，就是曼哈顿距离。当p=2时，就是欧氏距离。当p→∞时，就是切比雪夫距离。根据变参数的不同，闵氏距离可以表示一类的距离。

闵氏距离，包括曼哈顿距离、欧氏距离和切比雪夫距离都存在明显的缺点。举个例子：二维样本(身高,体重)，其中身高范围是150~190，体重范围是50~60，有三个样本：a(180,50)，b(190,50)，c(180,60)。那么a与b之间的闵氏距离（无论是曼哈顿距离、欧氏距离或切比雪夫距离）等于a与c之间的闵氏距离，但是身高的10cm真的等价于体重的10kg么？因此用闵氏距离来衡量这些样本间的相似度很有问题。简单说来，闵氏距离的缺点主要有两个：(1)将各个分量的量纲(scale)，也就是“单位”当作相同的看待了。(2)没有考虑各个分量的分布（期望，方差等)可能是不同的。

```
例子：计算向量(0,0)、(1,0)、(0,2)两两间的闵氏距离（以变参数为2的欧氏距离为例）
X = [0 0 ; 1 0 ; 0 2]
D = pdist(X,'minkowski',2)
结果：
D =
    1.0000    2.0000    2.2361
```

# 夹角余弦

夹角余弦(Cosine)，几何中夹角余弦可用来衡量两个向量方向的差异，机器学习中借用这一概念来衡量样本向量之间的差异。

两个n维样本点a(x11,x12,…,x1n)和b(x21,x22,…,x2n)的夹角余弦

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg3s3327j306f01qa9t.jpg)

夹角余弦取值范围为[-1,1]。夹角余弦越大表示两个向量的夹角越小，夹角余弦越小表示两向量的夹角越大。当两个向量的方向重合时夹角余弦取最大值1，当两个向量的方向完全相反夹角余弦取最小值-1。

```
例子：计算(1,0)、( 1,1.732)、( -1,0)两两间的夹角余弦
X = [1 0 ; 1 1.732 ; -1 0]
D = 1- pdist(X, 'cosine')  % Matlab中的pdist(X, 'cosine')得到的是1减夹角余弦的值
结果：
D =
    0.5000   -1.0000   -0.5000
```

# 汉明距离

汉明距离(Hamming distance)，两个等长字符串s1与s2之间的汉明距离定义为将其中一个变为另外一个所需要作的最小替换次数。例如字符串“1111”与“1001”之间的汉明距离为2。

```
Matlab中2个向量之间的汉明距离的定义为2个向量不同的分量所占的百分比。
例子：计算向量(0,0)、(1,0)、(0,2)两两间的汉明距离
X = [0 0 ; 1 0 ; 0 2];
D = PDIST(X, 'hamming')
结果：
D =
    0.5000    0.5000    1.0000
```

# 杰卡德相似系数

两个集合A和B的交集元素在A，B的并集中所占的比例，称为两个集合的杰卡德相似系数(Jaccard similarity coefficient)，用符号J(A,B)表示。杰卡德相似系数是衡量两个集合的相似度一种指标。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg4gwlkvj303a0160kw.jpg)

与杰卡德相似系数相反的概念是杰卡德距离(Jaccard distance)。杰卡德距离可用如下公式表示。杰卡德距离用两个集合中不同元素占所有元素的比例来衡量两个集合的区分度。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg4q5botj3082016741.jpg)

可将杰卡德相似系数用在衡量样本的相似度上。样本A与样本B是两个n维向量，而且所有维度的取值都是0或1。例如：A(0111)和B(1011)。我们将样本看成是一个集合，1表示集合包含该元素，0表示集合不包含该元素。那么样本A与B的杰卡德相似系数可以表示为：

p ：样本A与B都是1的维度的个数
q ：样本A是1，样本B是0的维度的个数
r ：样本A是0，样本B是1的维度的个数
s ：样本A与B都是0的维度的个数

这里p+q+r可理解为A与B的并集的元素个数，而p是A与B的交集的元素个数。

而样本A与B的杰卡德距离表示为：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg557ap0j302m0160fk.jpg)

```
Matlab的pdist函数定义的杰卡德距离跟我这里的定义有一些差别，Matlab中将其定义为不同的维度的个数占“非全零维度”的比例。

例子：计算(1,1,0)、(1,-1,0)、(-1,1,0)两两之间的杰卡德距离
X = [1 1 0; 1 -1 0; -1 1 0]
D = pdist( X , 'jaccard')
结果
D =
0.5000    0.5000    1.0000
```

# 相关距离

相关系数 ( Correlation coefficient )与相关距离(Correlation distance)

相关系数是衡量随机变量X与Y相关程度的一种方法，相关系数的取值范围是[-1,1]。相关系数的绝对值越大，则表明X与Y相关度越高。当X与Y线性相关时，相关系数取值为1（正线性相关）或-1（负线性相关）。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg5mvfoxj308t01qq2p.jpg)

相关距离

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg5xy1erj302t00l0h3.jpg)


```
Matlab计算(1, 2 ,3 ,4 )与( 3 ,8 ,7 ,6 )之间的相关系数与相关距离

X = [1 2 3 4 ; 3 8 7 6]
C = corrcoef( X' )   %将返回相关系数矩阵
D = pdist( X , 'correlation')
结果：
C =
    1.0000    0.4781

    0.4781    1.0000
D =
0.5219
      其中0.4781就是相关系数，0.5219是相关距离。
```

信息熵(Information Entropy)，信息熵是衡量分布的混乱程度或分散程度的一种度量。分布越分散(或者说分布越平均)，信息熵就越大。分布越有序（或者说分布越集中），信息熵就越小。信息熵越大表明样本集S分类越分散，信息熵越小则表明样本集X分类越集中。。当S中n个分类出现的概率一样大时（都是1/n），信息熵取最大值log2(n)。当X只有一个分类时，信息熵取最小值0。计算给定的样本集X的信息熵的公式：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fswg698g7uj305i01q741.jpg)

参数的含义：n：样本集X的分类数。pi：X中第i类元素出现的概率

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>SimilarityMeasurement</tag>
      </tags>
  </entry>
  <entry>
    <title>如何查询论文是否被SCI/EI收录</title>
    <url>/ei-sci/</url>
    <content><![CDATA[
大家所熟知的国际著名汤森路透集团（现更名为科睿唯安）最早推出了的三大著名期刊引文索引数据库，分别为科学引文索引(SCIE)，社会科学引文索引(SSCI)和艺术与人文引文索引(A&HCI)。2008年底，该集团推出了两类“会议录”索引数据库，即科学技术会议录索引(CPCI-S)和社会与人文科学会议录索引(CPCI-SSH)。2011年，汤森路透又推出了两类图书引文索引数据库，即科学图书引文索引(BKCI-S)和社会与人文图书引文索引(BKCI-SSH)。这些数据库组成了Web of Science 核心引文数据库，使得其核心数据库涵盖了各学科领域的杂志、会议录、图书索引。

<!--more-->

2015年11月科睿唯安（原汤森路透）推出一种新的期刊引文索引数据库——新兴资源引文索引(Emerging Sources Citation Index, ESCI)。其目的是要满足客户(包括投资人、评估人、合作伙伴)在以下三方面的需求：1)提供更多的期刊数据以支持科研评价和分析；2)更多地收录那些已产生地区性影响力的本地期刊；3)更早地让那些新兴领域及其发展趋势得到推广。ESCI的推出使得SCI期刊收录过程由原来的一步变为两步，所有新的期刊都需要先满足SCI期刊收录的第一级标准，先被ESCI数据库收录，然后等满足了SCI期刊收录的更高标准后才被SCI数据库收录。换言之，被ESCI收录意味着期刊正式加入SCI预备队！


专著：所谓“专著”，指“国内外科学专家所撰写的学术著作。从内容来说是对某一知识领域所做的探索，是新的学术研究成果。它是属于一(学)派一家之言，并以本专业的研究人员及专家学者为主要读者对象的。”

编著：所谓“编著”，指把现成的文字材料经过选择加工而写的著作。编著与专著相比，不强调创造性，而强调采用最新的研究成果，采用科学的体例编撰成书，它有一定的理论性、学术性，但更强调应用性。

国内也有一些期刊评价体系，有自己的“核心期刊”列表。比较知名的有：

- 中国科学引文数据库cscd
- 中文核心期刊要目总览(北大核心期刊) (PKU)
- 中国科技论文统计源期刊(科技核心期刊) (ISTIC)

SCI（期刊）和ISTP（会议）都是属于ISI数据库，因此仅仅通过“UT WOS” 信息不能区分是SCI或ISTP检索。

# EI 检索

工程索引（EI）是由美国工程师学会联合会于1884年创办的历史上最悠久的一部大型综合性检索工具。EI在全球的学术界、工程界、信息界中享有盛誉，是科技界共同认可的重要检索工具。本文介绍一些如何查询SCI/EI收录的方法。

EI 检索一般在 [Engineering Village](http://www.engineeringvillage2.org/)上进行查询。进行搜索在Datebase选项后可能有两个数据库：Compendex (即EI网络版)和Inspec (英国科学文摘)。

compendex（computerized engineering index）包括核心库（即原来的光盘版）和外围库（即原来的PageOne），两部分的主要区别在与：核心部分检索包含全部论文信息，并对其进行了分类和识别，以利于美国官方使用，其中受控词（controlled terms）、分类码（classification codes）和主题词（main heading）存在与否是区分核心库与外围库的标识。

当你的数据库显示是compendex时，恭喜你，你的文章被EI收录。当你的数据库显示是Inspec时，表示未被EI收录，但是，未被EI收录可能被SCI收录！即Inspec数据库收录的文章虽然可能不是EI检索，但可能是SCI检索！有时候一篇文章会既被inspec，也被compendex收录。

# SCI 检索


SCI (Science Citation Index) 是美国科学信息研究所(ISI)建立的科技期刊文献检索系统，被SCI收录的期刊分为核心与外围两个范围。核心部分包括期刊3000多种，涵盖了全世界范围内各学科领域内的最优秀的科技期刊；外围部分包括核心部分在内，有期刊5000多种。外围部分的期刊虽然也是非常优秀的科技期刊，但与核心部分相比，学术水平相对低一些。

SCI 检索有两种办法：

- 一是直接去 Thomson Reuters 的网页看它的[期刊列表](http://science.thomsonreuters.com/mjl/)，在search terms下输入想要查询的内容(在出现的期刊名字下面有一个“Coverage”，点开它就可以看到索引情况)。
另外，在网页的下端有收录期刊列表选项注意有Science Citation Index 和 Science Citation Index Expanded(国内习惯称之为核心和扩展）可以更详细的查出关心的期刊是核心还是扩展。
- 另一种办法是直接查文章是不是被SCI收录。这时是去 [Web of Knowledge ](http://isiknowledge.com/)，这时要注意选择网页上面的“Web of Science Core Collection (1986-present)”数据库, 这样搜出来的才是表示被SCI收录的文章。

查询的时候，注意在EI数据库里一般是将姓名写全（Qiaokang Liang），而在SCI里姓写全而名只用了第一个字母( Liang QK )。

# 索引号

- 以前索引号是UT：ISI或者UT：ISTP，现在统一为UT：WOS（web of science）。进入[Web of Knowledge](http://www.webofknowledge.com/)搜索论文， 然后进入条目详情，点击“查看更多数据字段”即可看到“入藏号（Accession Number）: WOS:000443131300072”字段。
- 进入[Engineering Village](https://www.engineeringvillage.com/search/quick.url)搜索论文， 然后进入条目详情，点击左侧的“Detailed”字段，即可看到“Accession number: 11147376”字段。

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>文献检索</tag>
        <tag>科研经验</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习中的信息论</title>
    <url>/entropy-method/</url>
    <content><![CDATA[
信息论是应用数学的一个分支，主要研究的是对一个信号包含信息的多少进行量化。它最初被发明是用来研究在一个含有噪声的信道上用离散的字母表来发送消息，例如通过无线电传输来通信。，一般在机器学习中，我们可以将信息论应用在连续型变量上，并使用信息论的一些关键思想来描述概率分布或者量化概率分布之间的相似性。

<!--more-->

在信息论中，熵是对不确定性的一种度量。信息量越大，不确定性就越小，熵也就越小；信息量越小，不确定性越大，熵也越大。根据熵的特性，可以通过计算熵值来判断一个事件的随机性及无序程度，也可以用熵值来判断某个指标的离散程度，指标的离散程度越大，该指标对综合评价的影响（权重）越大。比如样本数据在某指标下取值都相等，则该指标对总体评价的影响为0，权值为0.

> [从香农熵到手推KL散度：一文带你纵览机器学习中的信息论](https://medium.com/swlh/shannon-entropy-in-the-context-of-machine-learning-and-ai-24aee2709e32)

# 熵

Entropy来源于希腊语，原意：内向，即：一个系统不受外部干扰时往内部稳定状态发展的特性。熵是热力学的一个物理概念，定义的其实是一个热力学的系统变化的趋势

$$\Delta S = \frac{Q}{T} = \frac{热量}{温度} \tag{1-1}$$

- 广义的定义：熵是描述一个系统的无序程度的变量；同样的表述还有，熵是系统混乱度的度量，一切自发的不可逆过程都是从有序到无序的变化过程，向熵增的方向进行。熵越大说明系统越混乱，携带的信息越少，熵越小说明系统越有序，携带的信息越多。

- 信息论中，熵是接受的每条消息中包含的信息的平均值。又被称为信息熵、信源熵、平均自信息量。

1923年，德国科学家普朗克来中国讲学用到entropy这个词，胡刚复教授看到这个公式，创造了“熵”字，因为“火”和热量有关，定义式又是热量比温度，相当自洽。

# 自信息

香农熵的基本概念就是所谓的一个事件背后的自信息（self-information），有时候也叫做不确定性。自信息的直觉解释如下，当某个事件（随机变量）的一个不可能的结果出现时，我们就认为它提供了大量的信息。相反地，当观察到一个经常出现的结果时，我们就认为它具有或提供少量的信息。将自信息与一个事件的意外性联系起来是很有帮助的。

# 信息熵

在机器学习中，通常要把与随机事件相关信息的期望值进行量化，此外还要量化不同概率分布之间的相似性。在这两种情况下，香农熵都被用来衡量概率分布中的信息内容。

香农熵是以信息论之父 Claude Shannon 的名字命名的，也称为信息熵或微分熵（连续）。信息熵则借鉴了热力学中熵的概念 (注意：信息熵的符号与热力学熵应该是相反的)，用于描述平均而言事件信息量大小。1948年，由克劳德·爱尔伍德·香农将热力学中的熵引入信息论，所以也叫做：香农熵。

比如天气情况，假设可能有【阴、晴、雨、雪】四种情况，使用概率符号表示 $\mathbf P = [p_1,p_2,p_3,p_4]$，接下来自然而然的思考：那么，什么条件（情况）会影响这些值呢？假设有以下三种描述，或者说条件

- 今天是晴天，所以明天可能也是晴天
- 天气预报说明天下雨
- 9月12日苹果公司举行发布会

那么这三个描述中，很明显，第二条的信息量更大，因为它可以使得不确定事件发生在$p_3$的概率更大。类似的，第三条对判断毫无帮助，信息量为0。注意，信息量不等于信息熵，如果是这样，那么直接用概率来衡量就可以了，不需要在重新定义一个概念。

所以数学上，信息熵是事件所包含的信息量的期望（均值）[^/answer/49929786]。它不是针对每条信息，而是针对整个不确定性结果集而言，信息熵越大，信源的分布越随机，事件不确定性就越大。单条信息只能从某种程度上影响结果集概率的分布.

[^/answer/49929786]: [信息熵是什么？](https://www.zhihu.com/question/22178202/answer/49929786)

在概率论和统计学中，数学期望(mean)（或均值，亦简称期望）是试验中每次可能结果的概率乘以其结果的总和。根据上面期望的定义，我们可以设想信息熵的公式大概是这样的一个格式：

$$信息熵=\sum  每种可能事件的概率 * 每种可能事件包含的信息量$$

那么每种可能事件包含的信息量跟什么有关呢？答案是跟这一事件的不确定性有关，即与事件发生的概率有关，概率越大，信息量越小。试想，如果上面的概率修改一下，令小明得100分的概率是1，那么你预测小明会考100分这句话就没有信息量了，因为不管怎么样他肯定都会是100分。

我们已经有了 $\mathbf P = [p_1,p_2,p_3,p_4]$ 来表示天气情况，那么用计算机来存储每天的天气，那该如何编码呢？常见的做法是，4个不同的信息，只需要2bit就能做到，<code>00</code> <code>01</code> <code>11</code> <code>10</code> 。

使用一个公式来计算记录<strong>n天数据</strong>需要的<strong>存储空间</strong>：

$$
S_n = n \times \sum_{i = 1}^4{\left(P_i \times F(P_i) \right) } \tag{2-1}
$$

> $P_i$ 表示第i个事件发生的概率；$F(P_i)$ 表示存储空间的存储因子（每种可能事件包含的信息量的计算采用不确定性函数）.

如何确定这个函数 $F(P_i)$ 的形式？考虑这个函数需要满足条件：<strong>概率大的事件对应小的存储空间，说人话，就是成反比</strong>，你的数学功底不错的话，脑海中第一反应出来满足这个条件最直观是<strong>反比例函数</strong>，说人话， $\frac{1}{P_i}$ 。之后我们发现这个公式中有个除法非常讨厌，我们想着去掉它，脑海中第一反应出来的满足这个条件的一定是<strong>取对数</strong>，至于为什么取对数，那说道就很多，取对数是指数的<strong>逆操作</strong>，

- 对数操作可以让原本不符合正态分布的模型符合正态分布，比如随着模型自变量的增加，因变量的方差也增大的模型取对数后会更加稳定
- 取对数操作可以rescale（原谅我，这里思前想后还是感觉一个英文单词更加生动）其实本质来说都是因为第一点。说人话版本，人不喜欢乘法，对数可以把乘法变加法

那么我们结束清楚之后，就很容易就可以定义出（
采用这个函数，一方面保证了信息量是概率P的单调递降函数；另一方面保证了两个独立事件所产生的不确定性应等于各自不确定性之和，即可加性。）

$$F(P_i) = \log_a ({\frac{1}{P_i}}) \tag{2-2}$$

> a作为底数，可以取2（处理2bit数据），10（万金油），e（处理正态分布相关的数据）

结合对信息熵的定义（第一节最后的粗体字）然后把（2-2）带入（2-1），就会发现，哦！看着有点眼熟啊

$$H(P) = \sum_i {P(i)log_a {\frac{1}{P(i)}}} = - \sum_i {P(i)log_a {P(i)}} \tag{2-3}$$

$$H(U) = -\sum_{i=1}^{n} P_i logP_i$$

总结就发现，信息熵其实从某种意义上反映了信息量存储下来需要多少存储空间。总结为：根据真实分布，我们能够找到一个最优策略，以最小的代价消除系统的不确定性（比如编码），而这个代价的大小就是信息熵。


# 熵值法

> [熵值法确定权重的步骤及适用范围](https://hujichn.github.io/2016/08/10/%E7%86%B5%E5%80%BC%E6%B3%95%E7%A1%AE%E5%AE%9A%E6%9D%83%E9%87%8D%E7%9A%84%E6%AD%A5%E9%AA%A4%E5%8F%8A%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4/#fn1)  
> [【评价算法】01. 熵权法确定权重](https://zhuanlan.zhihu.com/p/28067337)

日常工作中经常需要确定各个指标的权重，利用熵值法确定权重属于客观赋权法，从数据出发，仅依赖于数据本身的离散性，避免过强的主观性。

根据信息熵的定义，对于某项指标，我们可以用熵值来判断某个指标的离散程度，其熵值越小，指标的离散程度越大，该指标对综合评价的影响(即权重)越大。如果某项指标的值全部相等，那么该指标在综合评价中不起作用。

熵值法的计算步骤:

1. **确定指标体系**：首先需要确定评价的指标体系，例如下图是网站经营评价的两级指标体系。
  ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190418141132.png)

1. **清洗指标极值**：即剔除各指标中极大或者极小的值，一般用比较合理的上下线替换这些极值，目的是减少极值数据对该指标的熵的影响。 原则：剔除占样本总数不到1-2%但指标值贡献率超过20-30%以上的极值样本。 我们这里样本本来也不多，也没有贡献率特别大的，所以没有做处理。

1. **归一化指标处理**：由于各项指标的计量单位并不统一，因此在用它们计算综合指标前，先要进行标准化处理，即把指标的绝对值转化为相对值，从而解决各项不同质指标值的同质化问题。另外，正向指标和负向指标数值代表的含义不同（正向指标数值越高越好，负向指标数值越低越好），因此，对于正向负向指标需要采用不同的算法进行数据标准化处理：将各个指标同度量化，即将指标的实际值转化为不受量纲影响的指标评价值。常用的方法有：
    - 临界值法:如果原始的第$i$个人的第$j$个指标是$x_{ij}$，那么归一化后是$x_{ij}’$。若指标是正向的选第一个公式； 若指标是负向的选第二个公式。$\min x_j$是第$j$个指标的最小值，类似地，$\max x_j$是第$j$个指标的最大值。

      $$x_{ij}’ = \frac{x_{ij}-\min x_j}{\max x_j - \min x_j}$$
      $$x_{ij}’ = \frac{\max x_j-x_{ij}}{\max x_j - \min x_j}$$

    - Z-score法: $x_{ij}’ = \frac{x_{ij}-\bar{x_j}}{S}$

1. **计算指标熵和权**：

    - 计算指标熵要先计算第$i$个人的第$j$个指标值的比重 $y_{ij} = \frac{x_{ij}’}{\sum_{i=1}^m {x_{ij}’}}$
    - 计算第j项指标的信息熵的公式为 $e_j = -K\sum_{i=1}^m y_{ij} \ln y_{ij}$ (式中$K$为常数，$K=\frac{1}{\ln m}$，我觉得乘以这个主要是为了使得$e_j$小于等于1，这样后面求得的权重才是正数)
    - 某项指标的信息效用价值取决于该指标的信息熵$e_j$与1之间的差值，它的值直接影响权重的大小，信息效用值越大，对评价的重要性就越大，权重也就越大。直接影响权重的大小，信息效用值越大，对评价的重要性就越大，权重也就越大。值直接影响权重的大小，信息效用值越大，对评价的重要性就越大，权重也就越大。直接影响权重的大小，信息效用值越大，对评价的重要性就越大，权重也就越大。$d_j = 1 - e_j$
    - 第$j$项指标的权重为$w_j = \frac{d_j}{\sum_j d_j}$

1. **指标加权计算得分**：最后一步就是利用加权求和公式计算样本的评价值了，$U = \sum_j 100* y_{ij}w_j$，$U$为综合评价值，$w_j$为第j个指标的权重。

## Matlab实现

```
load shang_datas

Ind=[1 1 1 1 2]; %指定各指标的正向or负向

[S,W]=shang(X,Ind)
```

```
function [s,w]=shang(x,ind)
%实现用熵值法求各指标(列）的权重及各数据行的得分
%x为原始数据矩阵, 一行代表一个样本, 每列对应一个指标
%ind指示向量，指示各列正向指标还是负向指标，1表示正向指标，2表示负向指标
%s返回各行（样本）得分，w返回各列权重
[n,m]=size(x); % n个样本, m个指标
%%数据的归一化处理
for i=1:m
    if ind(i)==1 %正向指标归一化
        X(:,i)=guiyi(x(:,i),1,0.002,0.996);    %若归一化到[0,1], 0会出问题
    else %负向指标归一化
        X(:,i)=guiyi(x(:,i),2,0.002,0.996);
    end
end
%%计算第j个指标下，第i个样本占该指标的比重p(i,j)
for i=1:n
    for j=1:m
        p(i,j)=X(i,j)/sum(X(:,j));
    end
end
%%计算第j个指标的熵值e(j)
k=1/log(n);
for j=1:m
    e(j)=-k*sum(p(:,j).*log(p(:,j)));
end
d=ones(1,m)-e; %计算信息熵冗余度
w=d./sum(d); %求权值w
s=100*w*p'; %求综合得分
```

```
function y=guiyi(x,type,ymin,ymax)
%实现正向或负向指标归一化，返回归一化后的数据矩阵
%x为原始数据矩阵, 一行代表一个样本, 每列对应一个指标
%type设定正向指标1,负向指标2
%ymin,ymax为归一化的区间端点
[n,m]=size(x);
y=zeros(n,m);
xmin=min(x);
xmax=max(x);
switch type
    case 1
        for j=1:m
            y(:,j)=(ymax-ymin)*(x(:,j)-xmin(j))/(xmax(j)-xmin(j))+ymin;
        end
    case 2
        for j=1:m
            y(:,j)=(ymax-ymin)*(xmax(j)-x(:,j))/(xmax(j)-xmin(j))+ymin;
        end
end

```

## 熵值法的优缺点及适用范围

优点

- 熵值法能深刻反映出指标的区分能力，进而确定权重
- 是一种客观赋权法，有理论依据，相对主观赋权具有较高的可信度和精确度
- 算法简单，实践起来比较方便，不需要借助其他分析软件

缺点

- 智能程度不够高。和多元回归和主成分等统计方法不同，它不能考虑指标与指标之间横向的影响（如：相关性）
- 若无业务经验的指导，权重可能失真
- 对样本的依赖性比较大，随着建模样本变化，权重会有一定的波动

适用范围

结合上面的实例，我们看到：体育成绩离散程度更大，导致其最后权重也更大，但是从通常评判的角度看，聪明程度往往与数学成绩关系更为密切。这就说明单单使用熵值法权重失真是经常发生的，要结合一定专家打分法才能发挥熵值法的优势，像确定指标体系中的示意图那样，构建两级评价体系，上层可能需要结合专家经验来构建，而底层的指标分的比较细，权重比较难确定，这种情况下采用熵值法比较合适。

另外，确定权重前需要确定指标对目标得分的影响方向，对非线性的指标要进行预处理或者剔除。还要注意处理好极值。

# 交叉熵

> [【直观详解】信息熵、交叉熵和相对熵](https://charlesliuyx.github.io/2017/09/11/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E6%81%AF%E7%86%B5%E3%80%81%E4%BA%A4%E5%8F%89%E7%86%B5%E5%92%8C%E7%9B%B8%E5%AF%B9%E7%86%B5/)

交叉熵是一个用来比较两个概率分布 p 和 q 的数学工具。它和熵是类似的，我们计算 log(q) 在概率 p 下的期望，而不是反过来。

# 相对熵

> [浅谈KL散度](http://www.cnblogs.com/hxsyl/p/4910218.html)  
> [相对熵（互熵，交叉熵，鉴别信息，Kullback熵，Kullback-Leible散度即KL散度）的深入理解](http://blog.csdn.net/wonengguwozai/article/details/52817294)  
> [如何理解K-L散度（相对熵）](http://www.jianshu.com/p/43318a3dc715)  
> [关于相对熵（KL距离）的理解](https://www.zybuluo.com/a335031/note/43211)

与交叉熵紧密相关，KL 散度是另一个在机器学习中用来衡量相似度的量。相对熵又称互熵，交叉熵，鉴别信息，Kullback熵，Kullback-Leible散度（即KL散度）等。

交叉熵衡量的是用编码方案 q 对服从 p 的事件进行编码时所需 bit 数的平均值，而 KL 散度给出的是使用编码方案 q 而不是最优编码方案 p 时带来的额外 bit 数。从这里我们可以看到，在机器学习中，p 是固定的，交叉熵和 KL 散度之间只相差一个常数可加项，所以从优化的目标来考虑，二者是等价的。而从理论角度而言，考虑 KL 散度仍然是有意义的，KL 散度的一个属性就是，当 p 和 q 相等的时候，它的值为 0。

KL 散度有很多有用的性质，最重要的是它是非负的。在李弘毅的讲解中，KL 散度可以从极大似然估计中推导而出。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>InformationTheory</tag>
      </tags>
  </entry>
  <entry>
    <title>信号特征提取</title>
    <url>/feature-extraction/</url>
    <content><![CDATA[
In [machine learning](https://en.wikipedia.org/wiki/Machine_learning "Machine learning"), [pattern recognition](https://en.wikipedia.org/wiki/Pattern_recognition "Pattern recognition") and in [image processing](https://en.wikipedia.org/wiki/Image_processing "Image processing"), **feature extraction** starts from an initial set of measured data and builds derived values ([features](https://en.wikipedia.org/wiki/Feature_(machine_learning) "Feature (machine learning)")) intended to be informative and non-redundant, facilitating the subsequent learning and generalization steps, and in some cases leading to better human interpretations. Feature extraction is related to [dimensionality reduction](https://en.wikipedia.org/wiki/Dimensionality_reduction "Dimensionality reduction").

<!--more-->

When the input data to an [algorithm](https://en.wikipedia.org/wiki/Algorithm "Algorithm") is too large to be processed and it is suspected to be redundant (e.g. the same measurement in both feet and meters, or the repetitiveness of images presented as [pixels](https://en.wikipedia.org/wiki/Raster_image "Raster image")), then it can be transformed into a reduced set of [features](https://en.wikipedia.org/wiki/Feature_(machine_learning) "Feature (machine learning)") (also named a [feature vector](https://en.wikipedia.org/wiki/Feature_vector "Feature vector")). Determining a subset of the initial features is called _feature selection_.<sup id="cite_ref-alpaydin_1-0" class="reference">[[1]](https://en.wikipedia.org/wiki/Feature_extraction#cite_note-alpaydin-1)</sup> The selected features are expected to contain the relevant information from the input data, so that the desired task can be performed by using this reduced representation instead of the complete initial data.

# 原始信号

```
x=x1;
fs=15360;
N=length(x);
t=(0:N-1)/fs;

figure
plot(t,x);
title('sig1波形图');
xlabel('时间 ');
ylabel('振幅 ');
```

# 时域信号

```

N=length(x);
p1=mean(x); %均值 1/N*sum(x)
p2=sqrt(sum((x-p1).^2)/N); %均方根值
p3=(sum(sqrt(abs((x-p1))))/N).^2; %方根幅值
p4=mean(abs((x-p1))); %绝对平均值
p5=sum((x-p1).^3)/N; %偏斜度
p6=sum((x-p1).^4)/N; %峭度
p7=sum((x-p1).^2)/N; %方差
p8=max(abs((x-p1)));%峰值 最大值
p9=min((x-p1));%最小值
p10=p8-p9;%峰峰值

% val返回有量纲指标
val=[p1; p2; p3; p4; p5; p6; p7; p8; p9; p10];

%以上都是有量纲统计量，以下是无量纲统计量
f1=p2./p4; %波形指标 f1=p2/(sum(x)/N);
f2=p8./p2; %峰值指标 E[MAX(X)]=P8? 峰值/有效值
f3=p8./p4; %脉冲指标
f4=p8./p3; %裕度指标
f5=p5./(p2.^3); %偏斜度指标
f6=p6./(p2.^4); %峭度指标,峭度/标准差四次方
% f6=kurtosis(x);%峭度指标

% factor返回无量纲指标
factor=[f1; f2; f3; f4; f5; f6];

valfactor=[val;factor];
```


# 频域信号

```
fre_line_num=max(size(y));
p1 = mean(y);
% 均值频率 特征1,反映频域振动能量的大小；
p2 = sum((y-p1).^2)/fre_line_num;
% 标准差 特征2，表示频谱的分散或者集中程度；
p3 = sum((y-p1).^3)/(fre_line_num*sqrt(p2^3));
% 特征3，表示频谱的分散或者集中程度；
p4 = sum((y-p1).^4)/(fre_line_num*p2^2);
% 特征4，表示频谱的分散或者集中程度；
meanf = sum(f.*y)/sum(y);
p5 = meanf;
% 频率中心 特征5，反映主频带位置的变化；
sigma = sqrt(sum((f-meanf).^2.*y)/fre_line_num);
p6 = sigma;
% 特征6，表示频谱的分散或者集中程度；
p7 = sqrt(sum(f.^2.*y)/sum(y));
% 均方根频率 特征7，反映主频带位置的变化；
p8 = sqrt(sum(f.^4.*y)/sum(f.^2.*y));
% 特征8，反映主频带位置的变化；
p9 = sum(f.^2.*y)/sqrt(sum(y)*sum(f.^4.*y));
% 特征9，反映主频带位置的变化；
p10 = sigma/meanf;
% 特征10，表示频谱的分散或者集中程度；
p11 = sum((f-meanf).^3.*y)/(sigma.^3*fre_line_num);
% 特征11，表示频谱的分散或者集中程度；
p12 = sum((f-meanf).^4.*y)/(sigma.^4*fre_line_num);
% 特征12，表示频谱的分散或者集中程度；
p13 = sum(sqrt(abs(f-meanf)).*y)/(sqrt(sigma)*fre_line_num);
% 特征13，表示频谱的分散或者集中程度；
fac=[p1;p2;p3;p4;p5;p6;p7;p8;p9;p10;p11;p12;p13];
```

# 3维频谱-FFT

```
load V200.txt;
load V250.txt;
load V300.txt;
load V400.txt;

sample_point=6144;%采样点数为6144点
filenum=4;
yumatrix=[V200,V250,V300,V400];
rotate_speed=[406 531 719 906];

%求频谱
for k=1:1:filenum
    temp_value(:,k)=fft(yumatrix(:,k))/sample_point;
    for l=1:1:sample_point/2
        frequency_value(l,k)=2*abs(temp_value(l,k));
    end
end

for k=1:1:filenum
    sample_frequency(k)=3200;%计算采样频率
    f(k)=sample_frequency(k)/sample_point;%画图的频率
    beipin(k)=rotate_speed(k)/60;
    b(k)=f(k)/beipin(k);
    for l=1:1:sample_point/2
        z(l,k)=rotate_speed(k);
    end
end
for m=1:1:filenum
    for n=1:1:200
        final_f(n,m)=n*b(m);
        final_value(n,m)=frequency_value(n,m);
        final_z(n,m)=z(n,m);
    end
end

figure
plot3(final_f,final_z,final_value);
xlabel('倍频');
ylabel('转速（rpm)');
zlabel('幅值（um)');
grid on;
```

# hilbert包络

```
% hilbert包络
y_hilbert_1=hilbert(x_input);
y_hilbert_2=abs(y_hilbert_1); % 包络信号
```

# FFT频谱/解调

```
N=length(x_input);
fs=15360;
f=(0:N/2-1)*fs/N; % f=(0:N-1)*fs/N等价，为什么？

% 功率谱,解调频谱图
p=abs(fft(x_input-mean(x_input)),N)*2/N;
% p=abs(fft(x_input),N)*2/N;
% p=yfft.*conj(yfft)/N;

figure
plot(f,p(l:N/2),'k-');
xlabel('频率 f/Hz');
ylabel('幅值 P/W'); % (m/s2)



```

# 小波系数分解与重构

```
m=6;
[c_11,l_11]=wavedec(y_11,m,'db6');

% 对第六层低频系数进行重构——
a_11=wrcoef('a',c_11,l_11,'db6',6);

% 对分解的1-m层的高频系数（细节信号）进行重构
    for i=1:m
        d_11(m+1-i)=wrcoef('d',c_11,l_11,'db6',m+1-i);

        subplot(m+2,1,i+2)
        plot(d_11(m+1-i))
        ylabel(['d',num2str(m+1-i)])
    end
```

```
% 分解
wpt=wpdec(xdatac,3,'db1','shannon');
% 重构
s330=wprcoef(wpt,[3,0]);
s331=wprcoef(wpt,[3,1]);
s332=wprcoef(wpt,[3,2]);
s333=wprcoef(wpt,[3,3]);
s334=wprcoef(wpt,[3,4]);
s335=wprcoef(wpt,[3,5]);
s336=wprcoef(wpt,[3,6]);
s337=wprcoef(wpt,[3,7]);
```

```
% 小波包分解，重构轴承振动信号，Hilbert包络，FFT进行频谱分析
%采样频率
fs=12000;
%计算其自相关序列
xdatac=xcorr(xdata);
[t,d]=wpdec(xdatac,3,'db5');% Wavelet packet decomposition 1-D

%求每组系数>>>>>阈值=均值+标准方差
thr0=mean([3,0])+std([3,0]);
thr1=mean([3,1])+std([3,1]);
thr2=mean([3,2])+std([3,2]);
thr3=mean([3,3])+std([3,3]);
thr4=mean([3,4])+std([3,4]);
thr5=mean([3,5])+std([3,5]);
thr6=mean([3,6])+std([3,6]);
thr7=mean([3,7])+std([3,7]);
%THR=[thr0,thr1,thr2,thr3,thr4,thr5,thr6,thr7];

%消噪
xd0=wpdencmp([3,0],'s',3,'db5','threshold',thr0,0);
xd1=wpdencmp([3,1],'s',3,'db5','threshold',thr1,0);
xd2=wpdencmp([3,2],'s',3,'db5','threshold',thr2,0);
xd3=wpdencmp([3,3],'s',3,'db5','threshold',thr3,0);
xd4=wpdencmp([3,4],'s',3,'db5','threshold',thr4,0);
xd5=wpdencmp([3,5],'s',3,'db5','threshold',thr5,0);
xd6=wpdencmp([3,6],'s',3,'db5','threshold',thr6,0);
xd7=wpdencmp([3,7],'s',3,'db5','threshold',thr7,0);
%XD=wpdencmp([t,d],'s',3,'db5','threshold',THR,0);%用一个公式代替

%计算每组系数的能量
p0=sum(xd0^2);
p1=sum(xd1^2);
p2=sum(xd2^2);
p3=sum(xd3^2);
p4=sum(xd4^2);
p5=sum(xd5^2);
p6=sum(xd6^2);
p7=sum(xd7^2);
%找到最大的能量所对应的序数
pmax=max(p0,p1,p2,p3,p4,p5,p6,p7);
if pmax==p0 xdmax=xd0;
elseif pmax==p1 xdmax=xd1;
elseif pmax==p2 xdmax=xd2;
elseif pmax==p3 xdmax=xd3;
elseif pmax==p4 xdmax=xd4;
elseif pmax==p5 xdmax=xd5;
elseif pmax==p6 xdmax=xd6;
else xdmax=xd7;
end
%计算其自相关序列
rce=xcorr(xdmax);
%hilbert包络&FFT频谱分析

```

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>FeatureExtraction</tag>
      </tags>
  </entry>
  <entry>
    <title>高斯白噪声</title>
    <url>/gaussian-white-noise/</url>
    <content><![CDATA[
去噪都通过增加高斯白噪声，为什么？这样有意义吗？这样训练好的模型，可以去除真实场景下的噪声吗？

<!--more-->

# Why Gaussian noise

[Bihan Wen](https://www.zhihu.com/question/67938028/answer/259014596)通过以下三个子问题来说明：

- 为什么要做仿真噪音synthetic noise的实验？
- 在所有的synthetic noise里，为什么大家都用高斯白噪声，而不太常用其他distribution的噪声？
- 基于synthetic noise，比如高斯噪音的算法，可以适用于真实噪音吗？

**问题一：Why synthetic noise？**

先说结论：相对于real noise，用synthetic noise的好处是**便于分析问题/设计算法，便于量化和评价算法效果**。

便于对降噪问题的分析/算法的设计：降噪的本质是对数据本身的重建，以起到排除污染（corruption）的作用。这里面涉及到需要对(1)数据，(2)污染（噪音）的模型和分析。数据的模型就是我们一般常用的那些，比如稀疏表达(sparse coding），统计（probabilistic），低秩（low-rankness），collaborative filtering之类的。这些都是基于一定的数学假设。说穿了，事实上没不存在对数据100%精确的model，或者所谓的true model。再来说噪音模型，我们一般把noise这种污染定义为一个additive或者multiplicative的随机变量。那么这个随机变量的随机分布是什么？如果知道了这个，我们就可以设计出对应的合理的算法。

那么如果是real noise，他是什么分布呢？没有人知道，因为real就意味着未知。噪音可以是unstructured的，也可以是structured的。real的数据里面的噪音，可以是consistent的，也可以是变动的。甚至一幅图，一个视频里的real noise在不同位置都是不一样的。那这种情况下的问题分析就是极难的，或者说这个问题本身就是untrackable的，not well defined的。

所以科研或者工程设计里面，都会对这类问题做出合理的假设，比如这里的：噪音是高斯白噪声。基于这个假设再来分析问题。

便于量化和评价算法效果：评价一个降噪算法的效果，需要采用一定的评价标准（metric）。我们一般把评价标准分为客观（objective）和主观（subjective）的：

客观标准很好理解：给我一个数学计算方式，算出这个降噪过后的数据，到底有多好。这样做清晰明了，一般没有什么好争议的。常见的这样的metric有Peak Signal-to-Noise Ratio （PSNR），Mean Square Error（MSE），Structured Similarity（SSIM），等等。你经常可以在降噪论文里面看到这三个家伙的身影。他们这些metric的绝对数值的高低，直观地反应方法效果的好坏。

虽然我知道也有一些工作，试着propose一些不需要ground truth的objective quality metric，但最常用的这类经典metric无一例外地需要图片的无噪音真实值（ground truth）作为参考。如果你是使用仿真噪音，你自然是有ground truth的。但如果是真实噪音，你确一般不知道ground truth是什么。

所以一般对于真实噪音的降噪实验，我们都只好算法一些subjective的metric：让人眼来辨认降噪出来的图效果是否好。这不同的人，可能对图的喜好也会不一样，这样就经常会产生评价的个体差异，产生争议。就算想要组织一大批人来做测试，成本会很高，不利于科研的高效性。

**问题二：Why Gaussian noise？**

先说结论：相比于其他的synthetic noise distribution，高斯噪音确实有他的合理性。在真实噪音的噪音源特别复杂的时候，高斯噪音可能算是最好的对真实噪音的模拟。

其实不光是深度学习的降噪算法，传统方法（好吧，自从有了深度学习以后，什么sparse coding，GMM，low-rank，collaborative filtering都变成传统方法了...）也大多喜欢用高斯白噪声来做仿真实验。那么大家不约而同地都玩儿高斯噪音可能有背后的原因。我觉得这个可能才是题主最关心的问题。

解释一：

**高斯白噪声是情况最恶劣的噪声**：在通信系统中，不由信道引起的噪声在一般情况下会用加性噪声进行建模。即y(t) = x(t) + n(t)。其中x(t)是信号，n(t)是噪声，y(t)是最终接受到的由噪声的信号。加性噪声的模型指的是，噪声和信号相对独立，不管有没有信号，都会有噪声存在。香农信息论中用熵表示信息的不确定程度。根据限功率最大熵定理：如果平均功率受限，那么当信源符合高斯分布时，信源的熵最大（噪声的不确定性最大，对信源的干扰最大）。即如果假定功率受限，高斯白噪声是最干扰信息的噪声。

解释二：

那这里的答案就是，采用高斯噪音，是为了更好地模拟未知的真实噪音：在真实环境中，噪音往往不是由单一源头造成的，而是很多不同来源的噪音复合体。假设，我们把真实噪音看成非常多不同概率分布的随机变量的加合，并且每一个随机变量都是独立的，那么根据Central Limit Theorem，他们的normalized sum就随着噪音源数量的上升，趋近于一个高斯分布。

基于这种假设来看，采用合成的高斯噪音，是在处理这种复杂，且不知道噪音分布为何的情况下，一个既简单又不差的近似仿真。


**问题三：Can it work for real noise？**

先说结论：在高斯噪音试验下效果的算法，不一定在真实噪音下效果也同样地好。这个要看真实噪音具体长啥样，还要看算法本身的设计是否对噪音分布有一定的鲁棒性。

在搞清楚了问题一和二之后，相信问题三应该就很好理解了：因为Gaussian noise只是对real noise的一个近似和仿真，没有任何的保证说，设计的算法在处理real noise的时候就一定要表现得同样得好。但由于问题二我们讲了，Gaussian noise test有一定的合理性，所以这类算法在real noise的情况下都会有一定的降噪功用。

最近有一些新的数据库，包括了真实噪音图片以及他们捕捉到的ground truth。我认为这类数据库将会带来一波专注于真实噪音除去的工作。

最后再来说说深度学习，在降噪问题上的特殊性：

深度学习之类算法，模型本身是高度data-driven，而不是rule-based的。换句话说，深度学习算法的设计，或者说网络结构的设计，并不强烈依赖于噪音的概率分布。这对于降噪算法的generalization是很好的。

然而这并不是说，深度学习的降噪算法，是对所有噪音类型通吃的。深度学习算法一般需要supervised training。这样在训练数据上的选择，确实往往依赖于噪音的概率分布：如果我们要做Gaussian noise removal，那训练数据就应该是添加了Gaussian noise的结果。那么如果我们要做真实噪音的denoising，要怎么准备训练数据？你的训练数据的噪音分布，和你的测试数据是一样的吗？这些都没有保证，或者说不一定说是consistent的。

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>GaussianNoise</tag>
      </tags>
  </entry>
  <entry>
    <title>如何制作高质量的图文摘要</title>
    <url>/graphical-abstract/</url>
    <content><![CDATA[
一些期刊对于稿件的要求还包括了Graphical Abstract，即[图文摘要](http://www.letpub.com.cn/index.php?page=graphical_abstract "图文摘要修改制作")，用来清晰、简洁地展示研究工作最主要的信息，与论文标题同样重要。尤其是一些影响力大的顶级期刊，大部分都会要求作者提供。

<!--more-->

有的作者对于论文写作还能从容应对，但制作一张美观且符合审稿人和读者口味的Graphical Abstract却着实被难住了。一旦期刊要求他附加提供一张图文摘要的时候，其内心是崩溃的。

关于制作图文摘要的注意事项，我们在此提供以下6点建议供你参考：

# 不言自明最重要

因为你的研究工作通常已经比较复杂了，如果Graphical Abstract再绘制得十分繁琐，必然会流失一部分读者的阅读兴趣。一旦让读者不需要反复思考太多就能理解你想要呈现的是什么，从而决定进一步阅读你的论文，那么你的Graphical Abstract就是成功的。提供一个清晰、直接的图片展示，尽力做到一目了然。

# 内容少而精

Graphical Abstract一定是对研究论文提炼出的最重要、最精华的部分。文本摘要和图文摘要之间的区别是，Graphical Abstract应该只着重强调论文的某一个方面，而不是对整体研究的概括总结。你的研究论文可能有一个独特的创新点和主题，或者包含一些漂亮的研究结果（数据）和实验方法等。这时，你应该只关注其中一个着重点来构思Graphical Abstract，忽略其它次要的内容。所以在开始制作图片之前，重新审视你的论文，确定什么是最值得展示给读者的信息，是最重要的一步。

# 确定视觉元素内容和展示方式

首先选择你需要展示的视觉元素（例如细胞，蛋白质，化学结构式，动物，仪器耗材，实验结果图……）以及用来描述它们的文本元素。如果一个概念可以在视觉上呈现，那么显然比用文字描述效果更好。当绘制草图时，考虑清楚你需要用到的元素，由于Graphical Abstract空间有限，用尽可能少的元素信息来表达你的意图，然后再进一步压缩、简化一下已有的要点内容，直到无法删减为止。同时确定以哪一种最好的顺序排列（从左到右或从上到下组织）。此外，避免有太多的视觉元素分散排列，可以为一些图片或文本添加边框，并且相互之间保持合适的距离。尽量不要用太多不同的颜色，也不要使用过于鲜艳的颜色。

# 展示关键性的文字

Graphical Abstract中不适宜添加较多的文字，读者一般会通过一些特定的关键词和数据对论文的内容和结论做出预先判断。你可以策略性地将这些可能的关键词插入在图片中，引起读者的兴趣。图中的所有文字应该是同一种字体，并且使用常见的字体，比如Times New Roman, Arial, Helvetica等等。

# 根据期刊要求制图

将纸上绘制的草图移动到平面设计软件（通常使用PS、AI、PPT等工具）之前，先阅读你提交论文杂志的投稿指南，了解有关目标期刊对Graphical Abstract的字体类型和大小、线宽、颜色、图片尺寸的信息。不同期刊对图文摘要的要求不一定完全相同，包括提交文件的格式（PDF，TIFF或PNG）等，事先知晓以免因格式问题被返修。期刊要求的图片是长方形的还是方形的？这可能会影响你的布局，所以在你的平面设计软件中把画布大小设为期刊要求的尺寸之后再动手绘制。

# 多借鉴优秀案例

在构思过程中如感到无所适从，可以借鉴一些成功的案例，看得多了自然而然就会做了。虽然你的Graphical Abstract必须是原创且独一无二的，但还是要多阅读并借鉴一下别人论文中的示例，尤其是一些高影响力的期刊论文，还有你要投稿的目标期刊。这可以帮助你了解Graphical Abstract应当如何对内容进行安排和取舍。除此之外，制作完成后给同行评价一下，记录他们从中获得和遗漏的信息与细节，以便做出相应调整。

爱思唯尔出版社提供了一些优秀的[Graphical Abstract案例](https://www.elsevier.com/authors/journal-authors/graphical-abstract)，细胞出版社也举了几个对Graphical Abstract进行[修改完善的例子](http://www.cell.com/pb/assets/raw/shared/figureguidelines/GA_guide.pdf)。


总而言之，一张制作精美、创意清晰的Graphical Abstract能够快速吸引读者、期刊编辑、审稿人的注意力，让他们在第一时间轻松地理解你的研究意图和结果，从而有更大机会让其愿意深入阅读你的研究成果，同时也会显著提高论文被接收的几率。

> 本文来自[LetPub中文官网](http://www.letpub.com.cn/index.php?page=graphical_abstract_preparation)

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>科研经验</tag>
        <tag>图文摘要</tag>
      </tags>
  </entry>
  <entry>
    <title>如何做一个好的presentation</title>
    <url>/how-to-presentation/</url>
    <content><![CDATA[
当今科研界的竞争越来越激烈，对从事科研工作的人员的要求也越来越高。他们不仅要有冷板凳坐十年的定力，还需要有好的做presentation的技能，这样才能把自己优秀的工作展现给别人。开题报告、毕业答辩、应聘教职、参加学术会议等等，我们都离不开presentation。Presentation是个人综合能力的体现，会不会做presentation将会影响你的一生。

<!--more-->

一个好的演讲与演讲者的身份、台风、口才，内容的逻辑性、深刻性、趣味性和视觉辅助的恰当性等有关。每个要素对每个发言人和不同场合的重要性都不一样，需要动态平衡。TED的总体趋势是用故事方式包装研究，跟读者分享这些研究的结果跟我们的生活日常有什么样的联系，会产生什么样的影响。

# 架构

从内容结构上看，一个好的presentation必须要cover到以下几个方面，并且在各个部分之间合理分配时间[^p/29434085]:

1. Research Question: 最最重要的一个部分，没有之一。一个连研究问题都没说清楚的Presentation多半会让听众全程一头雾水。
1. Significance: 吊胃口环节，以前的研究有如此如此的gap，现有的文献没有解决这般这般的疑问，那么我的这个研究的重要性就呼之欲出了。
1. Literature review: 我研究的主题绝不是平地起大楼，而是受到了诸多学者的关注和讨论。你看谁谁谁曾经发现了什么研究结果，以及哪些哪些学者曾作出了什么推论和假设，然而，都还不到位和有欠缺。我的研究就是为了推动这个topic的literature, 弥补这些欠缺。
1. Hypotheses：立靶子环节， 如果是定量研究那么就需要列出重要的研究假设，这是你整个研究的target.
1. Data collection and methodology: sample是什么，哪里收集的数据，使用了什么数据收集方法（这里要去繁就简，不影响观众听明白的内容一律跳过）
1. Analysis: 展示分析结果，如果是定量研究多用数字和表格，如果是定性多用quote或observation notes.
1. Findings : 总结analysis results说明什么。
1. Limitation：这个研究有哪些不足。
1. Conclusion：回顾研究问题，研究的创新性，以及有什么重要的发现和结论。

# 技巧

那么，如何才能做一个好的presentation？我总结以下4点[^id=1075140]。我归纳这主要是因为academic presentation有这么几个challenge[^p/29434085]：

[^id=1075140]: [如何做一个好的presentation？](http://blog.sciencenet.cn/home.php?mod=space&uid=3158962&do=blog&id=1075140)

[^p/29434085]: [国际学术会议的正确打开方式（操作篇）](https://zhuanlan.zhihu.com/p/29434085)

1. 在有限的时间里面要把可能做了一两年甚至更久的庞大项目讲清楚， 研究者拥有的信息往往浩如烟海，一不小心就可能没完没了地讲起了数据收集中的某个小细节，而听众需要看到是这个项目完整的一个缩影。如何站在观众角度，站在对该项目毫无了解的角度把故事讲清楚，这是挑战研究者同理心和角色转化的一个过程。
1. 在一个oral presentation里面所有的词汇和语句却都需要使用的非常正式、规范、和准确。同样要表达一个意思，到了学术报告里面就必须使用特定的词语来描述。两个变量的关系到底是 “related” 还是“causal”, significance level是0.05还是0.01, 你用的检验方法是linear regression还是 content analysis, 最终结论说明hypothesis 是completely
supported 还是partially supported…这些具体的表述都需要做到精准、专业、到位。（一次我的一个同学把semi-structured interview 说成了half-structured interview, presentation结束之后害羞滴锤了一晚上大腿----意思本来是差不多的意思，可是在专业上只有前一种的用法。）
1. 你present的时候台下做的都是业内同行，而且说不定有泰斗级人物，面对同行们的提问如何能不卑不亢地回答，得体从容地回应每一个学者提出的问题甚至质疑，这也是一大挑战。（以及如何恰当地回应silly question甚至rude question..）

一、讲一个story而不是results。干巴巴的讲results，每一个results之间毫无link可言，这种简单的叠加很槽糕。没人会care你的results，听众care的是你的story，你的results怎么回答了你的scientific question。把这个story讲的如何如何吸引人，这是你重点要去做的。怎么才能吸引到听众，让听众跟着你的思路走？就靠logic，这一点是好的presentation必不可少的。讲每张slide前可以提出与上张slide咬合的问题，自问自答也是不错的方式。

1. 单张slide的内容要有logic。每张slide基本上要回答4个问题:为什么这样做？怎么做的？得到什么结果？结果说明什么？4个问题之间层层递进，尽量用简练的语言回答，不要拖泥带水。

2. 前后slides的内容要有logic。前张slide的内容讲完之后要为后一张slide埋下伏笔，不能两张slides之间没有link。比如说：前一张slide讲的是某个蛋白存在磷酸化修饰，后面可讲这个蛋白的磷酸化位点在哪里？前后内容紧紧咬着，不能毫不相干，让听众断篇。

3. 整体slides的内容要前后呼应。通常在一项研究中会取得一些results，也会需要next。你提出的next要与你课题的results相呼应；你提出的question要与你课题的significance相呼应。Slides的内容在整体上是可以捋出一条线的，可以被拎起来，而不是碎片拼图。

二、带着自信和感染力去做presentation。我们在做presentation的时候都会紧张，一旦紧张起来，自信就会缺失，这时候你讲的内容就很难让听众trust，你也就失去了做presentation的意义。如何带着自信的光环去做你的presentation？这需要你充分地准备。

1.了解你presentation的听众。他们主要是研究生还是教授？他们的研究方向是什么？可能会提出什么样的问题？虽然有些问题不可预知，但还是要有一定的准备。

2.模拟一个现场。你需要架起投影仪，给自己营造氛围，可以请实验室成员当观众，试讲时做到三个单词：Clear、Loud、Slow。

3.给自己心理暗示。上台之前深呼吸，暗示自己：我是最好的，我可以做好这次presentation。讲的时候目光要面对听众，不能看着天花板或投影仪，这都无法让听众受到感染。

三、注意避免一些常见问题。一些常见的小问题，看似没有什么大的影响，也会让你的presentation大打折扣。

1.Acknowledgment必不可少。Acknowledgment能够体现你作为一个科研人的修养和品德。如有可能，在这个环节你要详细到每个被致谢的人到底为你的课题做了些什么？这也说明你真正记住了别人的help，而不是泛泛一提就结束了。

2.注意slides的格式。每张slide的字号、背景颜色、标题的位置都要适合并统一。还有内容紧凑，尽量精简slides上的文字，以高像素的图片为主，容易让听众抓住关键信息。背景是我们引入科学问题的台阶，能够让听众大致了解到这个领域的研究现状，参考文献是必须引用的，要注意参考文献的格式。在引用文献时要尊重作者，文献的格式要完整，包括作者、年份、题目、杂志，说不定下面的听众就是你引用文献的作者。另外，文献格式的完整也可以让有兴趣的听众迅速找到相关文献，给别人带来方便。

3.合理分配你的时间。对于有时间要求的presentation来说，过早或推迟结束presentation都不是最佳的。掌控你presentation的时间，做到exact才能体现你作为一个speaker的高水准。

四、回答问题注意礼仪和策略。“Any questions？” 这大概是presentation最具挑战性的环节，也是体现speaker学术水平的时候。

1. 在回答问题时，先说一句“good question”，对提问者表示感谢。不要展示“Any questions ?”之类的slide，最好展示“conclusion”或是“model”的这张，以便大家有更多时间记住、消化主要内容。
2. 注意倾听和理解问题，不要急于回答，等人问完之后思考片刻后再答。一方面，可以调动你大脑中的信息储备；另一方面，让人你觉得你是思考过这个问题的，对提问者也是一种尊重。
3. 切忌没有听懂问题就瞎答一通，漫无目的的瞎扯，让听众认为你思维不清晰。也不该轻易附和提问者，以免显得缺乏主见。

如何在演讲时清晰表达自己的研究成果：

1. 减少文字数量
2. 多使用图片
3. 控制引入新信息的节奏
4. 尽量使用大字体，字体大小至少应为 24 号。
5. 考虑在各行或各段之间增加空行（10 pt 空行比较合适）

# 人才答辩提纲

给出一个参考“人才答辩提纲”，供相关人才汇报答辩候选人参考[^1163039]。

[^1163039]: [人才帽子“汇报答辩”内容建议](http://blog.sciencenet.cn/blog-673617-1163039.html)

第一部分（一张片子）：片头为“xxx人才答辩汇报”；给出一个能总结候选人“研究特色”的标题；然后依次为答辩人；单位；学科；答辩日期。其中“研究特色”标题在我见过的“人才答辩汇报”的PPT中只有一所名牌大学引进人才的一份，我觉得很有新意，值得提倡。因为，在相关人才答辩组织机构提供的“模板”中一般没有这个设计，属于自由裁量决定。然而用一个“标题”概括候选人的研究方向要新颖，文字简练。如果研究方向比较散，提出一个恰当标题需要下点功夫。如果以我三个研究方向（大陆地壳、油气藏、环境评价）的成果为例，我选择一个比较综合的标题为：“地质（涉及深部地质和油气藏地质）与环境过程的磁响应研究”。

第二部分（一张片子）：汇报提纲。一般国家级人才（即引进人才）帽子涉及四部分：1、教育与科研经历；2、主要成果及同行评价（或成果影响力）；3、未来（下一步）科研设想（计划）4、依托单位科研平台状况（包括支撑条件与团队），具体按管理部门的要求设计。显然，重点是第2部分。

第三部分（由若干片子组成）：属于提纲的第一部分内容：教育和科学研究经历。教育经历属于客观内容，由大学本科和研究生教育两部分组成。通常在介绍研究生教育经历时会涉及导师和他们的资历和头衔，但是在列出导师头衔时要权衡利弊。因为有的评审专家很反感渲染导师的头衔，所以我建议简单介绍。不要让人感觉你在“傍大牛”。科学研究经历重点应该是“博士后”经历及国内外访问合作研究经历等，这些也属于“如实陈述”内容。在陈述海外访问与合作研究经历时可以适度介绍合作机构与对象的资历。如果能被国际牛人邀请访问和合作研究属于申请人水平影响力的客观表现，将会增加公正的评审专家对候选人硬实力的印象分。

第四部分（由若干片子组成）：属于提纲的第二部分内容，也是最重要的关键内容。这部分内容大概要占据整个汇报的80%左右份额。它是在事实基础上充分发挥答辩人的“总结概括”和口语表达能力的重头戏。除了在PPT上下功夫外，还要让评委们听到一些“内容新颖”，“赏心悦目”的内容，口语表达很需要下点功夫。

这部分内容由：主要成果及创新点和同行评价（影响力）三部分组成，但是每部分内容都要认真思考，组织语言文字。由于PPT上主要以成果的图表为主，不宜呈现过多文字，答辩人需要用另外的文件准备“口头答辩”文稿，或记在心中。答辩属于口头表达，要注意口语与书面语（PPT上面的文字）之间的区别。整个PPT版面制作要下功夫，除了内容，版面要尽量做到：彩色鲜艳大方，背景与内容文字图表对比清晰，版面赏心悦目，这会增加答辩人的印象分。据说针对某些重要人才汇报PPT，有人会请专业美图人员修饰PPT。

主要成果及创新点介绍：一般答辩人在汇报成果时往往容易“平铺直述”介绍自己取得的成果，简述成果发表在什么主流刊物（包括列出期刊的IF值）等。忽视介绍这个方向成果的意义。即 “为什么值得研究？”，因此，需要首先简介这方面内容。如果是应用方向（面向国民经济）成果通常用“行业重大需求或面临的挑战”表述。如果属于基础科学研究方向则用“XXX方向的科学难题”，“XXX方向的重大科学问题”等。为了显示你选择研究方向的重大意义，可以附上少量同行重要文献。总之，这部分内容需要彰显答辩人在科研选题过程中的优势和特色及科研创新能力。在口语表达过程中力求避免两种极端表述：一是过于抬高自己，例如有人渲染自己成果具有“奠基性”，“开创了，，”，属于“世界级成果”等，当然如果属实也无可厚非。我主张用稍微谦和中性一点词汇，例如“提出了，，”，“发现了，，”，“阐明了，，”，“确立了，，”。另一种是过于“谦虚”，让评委看不出成果的特色和创新。

具体成果介绍：每项（方向）成果建议列出一个能够高度概括成果内容的“标题”。例如我的“磁学”研究领域三个应用方向：“大陆地壳磁性结构”、“油气藏烃微渗漏的磁效应”和“磁学手段用于环境污染评价”的研究成果的题目分别为：“阐明了中国东部某些地区大陆下地壳的磁性结构与深部地球动力学关系”；“确立了XXX油气藏烃微渗漏的磁效应”；“提出了武汉市东湖地区城市化过程的污染环境磁响应”。

每个方向成果主要展示若干篇代表性学术论文、专利或奖励，重要代表作可以选择展示首页。然而，有人告诉我，现在有的评审专家对论文有点“审美疲劳”。所以，我主张要突出介绍成果本身，介绍成果发表的杂志点到为止，杂志毕竟是发表成果的载体。一些“惊世骇俗”成果发表在一般刊物的案例并不鲜见。当然，有的专家很看重杂志，甚至影响因子。总之评审专家中风格多样，“众口难调”，需要候选人平衡各方面情况做出恰当选择。

成果影响力（同行评价）：主要由同行论文引用，尤其是论文中正面“表扬”的相关内容及候选人在国际学术舞台上的表现。例如重要学术会大会特邀报告。俗话说，“空口无凭，数据说话”，因此出示代表性著作还是必要。这部分内容很重要，是判断候选人国际影响力的重要依据。正如美国斯坦福大学化学系主任说的：“我们评价一个教授的水平不是看他为系里拿了多少项目和经费，而是他在国际同行中的影响和地位”。有人认为，这部分内容要做“夸大渲染”。其实，这取决于评审专家的“喜好”，例如有人宣称取得了“世界级成果”，有专家就追问“何为世界级成果”。所以我主张这部分内容既不能平庸表述，但也不能过度夸大，也需要在基本事实基础上在“褒奖”文字或口头表达时做出平衡。

有人告诉我，美国有的大学教师在申请“冠名教授”时，对于那些应用型学科（应该占据大多数学科）在介绍成果的影响力时，不能只介绍论文及其引用情况，也要注重“工业界评价”，我很赞同。正如芬兰赫尔辛基大学大气科学系Tuukka Petaja教授说：“基础研究和应用转化就像是中国传统阴阳学中的循环链条，都不可或缺。基础研究是用金钱生产知识的过程，而从应用研究到技术创新并服务于社会则是知识创造金钱的过程”。因此，工业界评价是我国大学应用学科应当重视的评价举措，这将大大促进科技成果转化，为国家国民经济发展做出贡献。

第五部分（1-2张片子）：未来（或下一步）科学研究设想（或计划）。有人对这一部分内容不太重视，有点“敷衍塞责”，认为无关紧要。然而，对于一些“人才引进项目”这一部分也值得重视。因为，国家或单位希望看到一个负责任的，“货真价实”的学者。评审专家想知道，引进的人才是否做好了充分准备。“有备而来”的候选人会让评审专家认为是一个有责任心的学者，而不是一个只瞄准招聘广告中国家和单位提供的“高待遇”。

为此，这一部分内容也要认真考虑和撰写：一般包括“计划目标”；“实施措施”；“预期成果”。其中后两项内容尽量具体点，不要太空洞。例如计划利用自己及相关单位的科研平台，组织具有一定实力的科研团队，争取某些关键技术突破，在某些领域推广应用等。对于应用技术研发性质，如果已经获得相关企事业单位“意向合作”计划可以大大提高评审专家对候选人科研能力和诚信的印象分。

第六部分（1-2张片子）：所在（用人）单位科研平台状况及相关支撑条件。这部分主要介绍所在单位能够提供候选人开展科学技术研究的硬软件条件，包括人力资源方面的团队情况和计算分析测试平台等。这部分内容也不要太抽象，它体现了引进单位的严肃认真态度以及对引进人才是否真正重视。从组织上关心引进人才 。
]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>Presentation</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 使用指南</title>
    <url>/git/</url>
    <content><![CDATA[
Git 是一个开源的分布式版本控制软件。自诞生以来，Git 就以其开源、简单、快捷、分布式、高效等特点，应付了类似 Linux 内核源代码等各种复杂的项目开发需求。如今，Git 已经非常成熟，被广泛接受与使用，越来越多的项目都迁移到 Git 仓库中进行管理。目前常用Git服务商：GitHub & Bitbucket & GitLab & Coding 。

<!--more-->

# Git

Git 进行代码版本管理时，有两种操作方式：图形界面GUI和 命令行Command。

<div id="gitdownload"></div>

- 命令行Command（Git Bash）：没有平台限制，Windows、Linux（Unix、Mac OS X）下都支持，通过 gid add dir/files 添加文件，没有文件数限制。[官网下载](https://git-scm.com/downloads)
- 图形界面GUI（Git GUI）：方便操作，推荐[GitKraken](https://www.gitkraken.com/)。

Git 使用四种主要的协议来传输数据：本地传输，SSH 协议，Git 协议和 HTTPS 协议。更多内容点击查看[服务器上的 Git - 协议](https://git-scm.com/book/zh/v1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%8A%E7%9A%84-Git-%E5%8D%8F%E8%AE%AE)。

- 推荐使用SSH 协议。

- https认证连接需要输入用户名密码。如果想避免交互式输入用户密码，可以将配置`git remote`：
  
  ```bash
  git remote add origin  https://用户名:密码@github.com/用户名/repository项目名.git
  git push -u origin master
  ```
  
  - 已经配置过的可以通过修改本地项目目录下的`.git/config`文件里的 [remote "origin"] 项下的 url 值，也可以通过git remote set-url origin 指令进行修改：
    
    ```bash
    git remote set-url origin  https://用户名:密码@github.com/用户名/repository项目名.git
    git remote add origin  https://用户名:密码@github.com/用户名/repository项目名.git
    git push -u origin master
    ```
  
  - 某些情况下使用https认证进行连接时会出现403错误。

<div id="gitbash"></div>

# Git Bash

> [Git 命令详解](https://github.com/geeeeeeeeek/git-recipes/wiki)  
> [Git 入门](https://wiki.shileizcc.com/display/GIT/Git)

[最浅显易懂的Git教程](http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000)面向初学者，实用性超强，掌握了这些东西，你就可以通过Git轻松地完成你的工作。

## SSH 协议

> 参考链接：[多个git账号之间的切换](http://memoryboxes.github.io/blog/2014/12/07/duo-ge-gitzhang-hao-zhi-jian-de-qie-huan/)，[Git的多账号如何处理？](https://gist.github.com/suziewong/4378434)，[gitlab/github 多账户下设置 ssh keys](gitlab/github 多账户下设置 ssh keys)。

不同网站可以使用同一个邮箱，这时候不用担心密钥的问题，因为这些网站 `push pull` 认证的唯一性的是邮箱。使用同一个邮箱，如果你不进行配置用户名和邮箱的话，则会使用全局的用户名和邮箱。<font color=blue>为了方便配置，用户名、姓名和邮箱都设置一致</font> 。

> [GitHub Pages + Hexo 搭建博客从入门到进阶](http://munen.cc/tech/hexo-init.html#2-与-GitHub-建立联系)

打开  【设置】-->【应用】-->【可选功能】-->【已安装功能】,查看 是否安装OpenSSH 服务器和 OpenSSH 客户端。以 管理员模式 运行命令行窗口，执行 net start sshd 命令。重新打开 cmd ，输入 ssh localhost 即可。

### 相同邮箱账户

1. 创建账户，设置用户名。

2. 打开`Git Bash`
   
   ```bash
   $ cd ~/.ssh    //转到C:/Users/Administrator/.ssh
   ```

3. 备份旧的数据并删除（跳过）
   
   ```bash
   # Lists the files in your .ssh directory, if they exist
   $ ls -al ~/.ssh
   $ mkdir key_backup
   $ cp id_rsa* key_backup
   $ rm id_rsa*
   ```

4. 生成新的SSH Key
   
   ```bash
   ssh-keygen -t rsa -C "im.sai.li@outlook.com"
   # 填写注册email地址，然后一直“回车”ok
   # 当然如果你想选择使用密码功能，那么在提示输入密码passphrase时输入你自己的密码。
   ```

5. 复制生成的密钥
   
   ```bash
   clip < ~/.ssh/id_rsa.pub
   或 用文本编辑工具打开id_rsa.pub文件
   ```

6. 登陆系统添加SSH公钥，直接粘贴到key文本框中， 点击 `add key`。`title`可以随便命名，然后点击`add`。

7. 配置完成之后生成一个`.gitconfig`配置文件。
   
   ```bash
   $ git config --global user.name "sli1989"
   $ git config --global user.email "im.sai.li@outlook.com"
   $ git config --list # 查看配置
   ```
   
   <div id="git-ssh-test"></div>

8. 测试连接是否成功。提示：`Hi xx You have successfully authenticated, but GitHub does not provid。e shell access. `说明你连接成功了。（[Using SSH over the HTTPS port](https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port)）
   
   ```bash
   $ ssh -T git@github.com
   $ ssh -T git@gitlab.com
   $ ssh -T git@git.coding.net
   ```

9. 在github中找到 Settings--personal acess token--generate new token，设置全部权限，然后复制API token。
   
   ```bash
   # keep it secret! Changing your password will generate a new token
   $ git config --global github.user xx # github用户名
   $ git config --global github.token xx # 右键粘贴API token。
   ```

### 不同邮箱账户

如果你的项目邮箱不一致，用config文件管理它们，然后需要在项目根目录下进行单独配置。[git配置多个SSH Key](https://www.awaimai.com/2200.html)

1. 生成另一个账号的ssh密匙并复制。将里面的内容添加到后台。同平台的第一个的`SSH Key`中也要记得添加？
   
   ```bash
   $ ssh-keygen -t rsa -C "second_email" -f "wendu"
   %　重命名为wendu
   
   $ clip < ~/.ssh/wendu.pub
   ```

2. 为了让SSH识别新的私钥，需将其添加到`SSH agent`中：
   
   ```bash
   ssh-agent bash
   ssh-add ~/.ssh/id_rsa
   ssh-add ~/.ssh/wendu
   ```

3. 生成`touch ~/.ssh/config`并打开`vi ~/.ssh/config`，编辑`config`：
   
   ```bash
   # 配置ssh账户
   Host github.com
   HostName github.com
   PreferredAuthentications publickey
   IdentityFile ~/.ssh/id_rsa
   
   Host gitlab.com
   HostName gitlab.com
   PreferredAuthentications publickey
   IdentityFile ~/.ssh/id_rsa
   
   Host coding.net
   HostName github.com
   PreferredAuthentications publickey
   IdentityFile ~/.ssh/id_rsa
   
   # 建一个别名，新建的帐号使用这个别名做克隆和更新。
   # 比如，将Host替换成gmail.github.com，那么原地址是：git@github.com:test/Mywork.git，
   # 替换后应该是：git@gmail.github.com:test/Mywork.git.
   Host qq.coding.net
   HostName coding.net
   PreferredAuthentications publickey
   IdentityFile ~/.ssh/wendu
   ```

4. 2个账号，2个邮箱，自然不能使用之前设置的全局用户名和邮箱了。在项目根目录下进行单独配置。
   
   ```bash
   $ git init
   
   #1.取消global  
   git config --global --unset user.name  
   git config --global --unset user.email  
   
   #2.设置每个项目repo的自己的user.email  
   $ git config user.name "wendu"
   $ git config user.email "second_email"
   ```

5. 测试连接。
   
   ```bash
   $ ssh -T git@git.coding.net
   $ ssh -T git@qq.coding.net
   # 之后输入 `yes` 并回车，就完成了。
   ```

## git remote

为了便于管理，Git要求每个远程主机都必须指定一个主机名。`git remote`命令就用于管理主机名。

```bash
# 列出所有远程主机
$ git remote
# 参看远程主机的网址
$ git remote -v
# 添加远程主机
$ git remote add <主机名> <网址>
# 删除远程主机
$ git remote rm <主机名>
# 用于远程主机的改名
$ git remote rename <原主机名> <新主机名>
```

克隆版本库的时候，所使用的远程主机自动被Git命名为`origin`。如果想用其他的主机名，需要用`git clone`命令的`-o`选项指定。

```bash
$ git clone -o jQuery https://github.com/jquery/jquery.git
```

## git fetch

一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到`git fetch`命令。默认情况下，`git fetch`取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。所取回的更新，在本地主机上要用"远程主机名/分支名"的形式读取。比如`origin`主机的`master`，就要用`origin/master`读取。

```bash
# 取回origin主机的master分支。
$ git fetch origin master
```

## git pull

`git pull`命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。

```bash
# 如果当前分支只有一个追踪分支，连远程主机名都可以省略。
$ git pull

# 远程分支是与当前分支合并
$ git pull origin next
# 实质上，这等同于先做git fetch，再做git merge。
$ git fetch origin
$ git merge origin/next

# 取回origin主机的next分支，与本地的master分支合并
$ git pull origin next:master
```

## git stash

> [Git 工具 - 储藏（Stashing）](https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E5%82%A8%E8%97%8F%EF%BC%88Stashing%EF%BC%89)

储藏可以获取你工作目录的中间状态，也就是你修改过的被追踪的文件和暂存的变更，并将它保存到一个未完结变更的堆栈中，随时可以重新应用。你也可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。

```BASH
$ git status
$ git stash

$ git status

$ git checkout otherbranch

# 默认使用最近的储藏并尝试应用它
$ git stash apply

$ git stash list
$ git stash apply stash@{2}

# apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上
# 移除
$ git stash list
$ git stash drop stash@{0}

# 重新应用被暂存的变更
$ git stash apply --index
```

## 仓库克隆

1. 选择别人的远程仓库或者[自建远程仓库](https://github.com/new)。

2. 建立本地仓库。
   
   - 我们可以直接将服务器文件夹同步到本地：
     
     ```bash
     # 把整个项目保存在本地仓库中
     $ git clone git@gitlab.com:sli1989/sli1989.gitlab.io.git
     $ cd sli1989.gitlab.io
     
     # 同步github上的项目到本地
     $ git fetch origin # 缓存区
     $ git merge origin/master # 合并分支
     ```
     
       默认 clone 的是这个仓库的 master 分支。如果最新的代码不在 master 分支上，可以使用checkout命令来把远程分支取到本地：
     
     ```bash
     $ git branch -r #查看远程分支
     # git branch -a #查看所有分支
     
     $ git checkout origin/other-branch
     $ git checkout -t origin/other-branch
     # 使用-t参数，它默认会在本地建立一个和远程分支名字一样的分支折叠展开复制代码
     
     $ git fetch origin other-branch:other-branch
     # 通过fetch命令来建立的本地分支不是一个track branch，而且成功后不会自动切换到该分支上
     ```
     
       不要在本地采用如下方法，这样建立的branch是以master为基础建立的，再pull下来的话，会和master的内容进行合并，有可能会发生冲突：
     
     ```bash
     $ git branch other-branch
     $ git checkout other-branch
     $ git pull origin other-branch:other-branch
     ```
   
   - 也可以自建本地仓库。在本地**创建一个相同的项目**，或者在目标文件夹中右键选择`git bash here`，进入命令行。
     
     ```bash
     $ cd {本地路径}     # 路径切换，如：cd e:/workspace
     $ mkdir hello-world # 新建hello-world文件夹
     $ cd hello-world
     ```

3. 连接远程github项目（只需第一次设置）：
   
   ```bash
   $ git remote add origin git@gitlab.com:sli1989/sli1989.gitlab.io.git
   ```
   
    如有错误提示：fatal: remote origin already exists，执行
   
   ```bash
   $ git remote rm origin
   $ git remote add origin git@github.com:sli1989/sli1989.github.io.git
   ```

## 添加文件

1. 进入文件夹并初始化
   
   ```bash
   $ cd hello-world    # 打开这个文件夹
   # 若右键选择`git bash here`则以此目录作为当前目录进入命令行状态。
   
   $ git checkout master
   $ git init  # 初始化
   ```

2. 新建文件
   
   ```bash
   # （跳过）Touch 命令主要就是用来修改文件的访问时间和修改时间
   $ touch README.md
   
   $ git add README.md
   $ git add .
   ```

## 删除文件

1. 查看本地分支下的文件
   
   ```bash
   $ ls
   ```

2. 先查看有哪些文件可以删除,但是不真执行删除
   
   ```bash
   $ git rm -r -n */src/\*
   ```

3. 删除命令
   
   ```bash
   $ git rm test.txt
   # 或
   $ git rm raindow -r -f # 删除raindow文件夹及其下所有的文件
   # 或
   $ git rm -r --cached test.txt
   # 如果只想从版本库中删除,但是本地仍旧保留的话,加上 cached 参数
   ```

4. 告诉你哪些文件被删除了（跳过）
   
   ```bash
   $ git status
   ```

5. 如果误删，恢复到最新版本
   
   ```bash
   $ git checkout -- test.txt
   ```

## 忽略设置

把不需要提交的文件放在忽略的文件夹中。在项目根目录下，和`.git` 同级目录下，新建一个`.gitignore`文件

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26ls1exh2j209k0cugly.jpg)

## Git commit

提交到版本控制仓库，必须填写注释信息。

```bash
$ git commit -m 'first commit'
$ git commit -a -m “add new file”

# 查看已经提交的文件和缓存区中有什么文件
$ git status
# 查看本地仓库修改了的内容
$ git diff
```

commit log 里面的 `#XX` 会显示成指向对应 Issue 的链接，对应地 Issue 里面也会出现这条 Issue 被哪个 `commit` 引用的提示。也可以使用 `user/repo#45` 引用其他仓库的 Issue 的链接。类似 `close/closes/closed/fix/fixes/fixed/resolve/resolves/resolved #XX `这样的，还会自动帮你把那条 Issue 给 close 掉。

> 参考链接：[Git 工具 - 重写历史](https://git-scm.com/book/zh/v1/Git-%E5%B7%A5%E5%85%B7-%E9%87%8D%E5%86%99%E5%8E%86%E5%8F%B2)，[用git Rebase -i来修改commit历史史](http://jitanghu.me/blog/modify-git-commit-history-by-git-rebase-i.html)。

- 合并多个commit
  
  ```bash
  $ git checkout -b new-feature master
  
  $ git commit ...
  $ git commit ...
  
  $ git checkout new-feature
  
  # 从HEAD版本开始往过去数3个版本
  $ git rebase -i HEAD~3
  # 要合并的版本之前的版本号，不需要合并的 commit
  $ git rebase -i bca36d
  
  # 进入到 vi 的编辑模式
  # 输入s，除了第一个 commit 前方的命令改成 squash 或 s，ctrl+c 退出编辑模式
  # 输入 :wq 以保存并退出
  
  # 如果有冲突，需要修改，修改的时候要注意，保留最新的历史，不然我们的修改就丢弃了。
  # 修改以后要记得敲下面的命令：
  $ git add .  
  $ git rebase --continue  
  
  # 放弃这次压缩的话
  $ git rebase --abort  
  
  # 如果没有冲突，或者冲突已经解决，则会出现编辑窗口
  
  # 修改成新的 commit message
  # 输入 :wq 以保存并退出
  
  $ git checkout master
  $ git merge new-feature
  ```

- 修改commit说明
  
  - 修改最近一次提交说明。`$ git commit --amend`：这会把你带入文本编辑器，里面包含了你最近一次提交说明，供你修改。当你保存并退出编辑器，这个编辑器会写入一个新的提交，里面包含了那个说明，并且让它成为你的新的最近一次提交。
  
  - 修改多个提交说明。使用rebase工具来衍合一系列的提交到它们原来所在的HEAD上而不是移到新的上。必须通过告诉命令衍合到哪次提交，来指明你需要重写的提交的回溯深度。

## git push

`git push`命令用于将本地分支的更新，推送到远程主机。所有本地操作都需要同步到远程仓库。

```bash
$ git push <远程主机名> <本地分支名>:<远程分支名>

$ git push -u origin master  

# 如果省略远程分支名，则表示将本地分支推送与之存在"追踪关系"的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。
$ git push origin master
# 如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。
$ git push origin
# 如果当前分支只有一个追踪分支，那么主机名都可以省略。
$ git push
# 如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。
$ git push -u origin master
# 将本地的所有分支都推送到远程主机
$ git push --all origin
# 如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用--force选项。
$ git push --force origin

# 默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。
# Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。
$ git config --global push.default matching
# 或者
$ git config --global push.default simple

# 如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。
$ git push origin :master
# 等同于
$ git push origin --delete master
```

- 如有错误提示：`error:failed to push som refs to...`，执行
  
  ```bash
  $ git pull origin master
  $ git push origin master
  ```

- 如有错误提示：`modified: xxx(modified content, untracked content)`，删除目录下面的`.git`目录。重新`git add .`即可

如果需要推送到多个远程仓库:

- 添加一个远程仓库`git remote add mirror git@github.com:theme-next/hexo-theme-next.git`，利用 `git push -u origin master`和`git push -u mirror master`分别进行推送。

- 添加一个远程仓库`git remote set-url --add github https://git.oschina.net/zxbetter/test.git`，利用`git push`进行推送。

- 修改文件目录中的`.git/config`配置文件，这种方法其实和方法二是一样的。如果报错，先分别将本地版本推送到远程仓库，然后再把全部URL都加入。然后第一次提交时需要执行`git push -u origin master`，再往后就只需要执行`git push`就能把修改提交到上述三个远端仓库了。
  
  ```bash
  [remote "origin"]
      url = git@github.com:sli1989/sli1989.github.io.git
      url = git@git.coding.net:sli1989/sli1989.git
      url = git@gitlab.com:sli1989/sli1989.gitlab.io.git
      fetch = +refs/heads/*:refs/remotes/origin/*
  [branch "master"]
      remote = origin
      merge = refs/heads/master
  ```

方法二和三在 push 的时候比较方便。但是在 pull 的时候只能从方法三中的第一个 url 地址拉取代码。而方法一则不存在这种问题（可能要解决冲突）。所以，如果只进行 push 操作，推荐方法二和三，如果也要进行 pull 操作，推荐方法一。~~在 Git 2.0 将会更改默认的`push`动作为『只 push 当前 branch 到远端仓库』。如果想继续使用`git push both`命令需要手动设置一下`git push`的默认动作`git config --global push.default matching`。~~

## 撤销更改

> [回滚错误的修改](https://github.com/geeeeeeeeek/git-recipes/wiki/2.6-%E5%9B%9E%E6%BB%9A%E9%94%99%E8%AF%AF%E7%9A%84%E4%BF%AE%E6%94%B9)  
> [Git 的 4 个阶段的撤销更改](www.fengerzh.com/git-reset/)

了解清楚如何检查各种修改之后，我们开始尝试各种撤销操作。

- 已修改，未暂存：`git checkout .`或者`git reset --hard`
- 已暂存，未提交：`git reset`+`git checkout .`或者`git reset --hard`
- 已提交，未推送：`git reset --hard origin/master`
- 已推送：`git reset --hard HEAD^` + `git push -f`

撤销已推送的一般步骤如下：

1. 先`git log` 查看commit历史记录，找到`commit-id`。

2. 本地代码库回滚：
   
   ```bash
   git checkout the_branch
   git revert <commit>
   # 针对历史中任何一个提交，回滚到commit-id，它没有移除后面的提交
   git reset --hard commit-id
   # 从当前提交向前回溯，回滚到commit-id，将commit-id之后提交的commit都去除
   git reset --hard HEAD^
   # 删除最后1次的提交记录
   git reset --hard HEAD~3
   # 将最近3次的提交回滚
   ```

3. 远程代码库回滚：
   
   ```bash
   git add .
   git commit -m "recovery theme"
   
   git push -f origin master
   # 删除远程 the_branch
   git push origin :the_branch
   ```

对于 gitlab，可以进入当前仓库的设置中的 `Protected branches` 一项，将当前 branch 的 protected 临时去掉，等这次 push 完成，再重新设置回 protected 。

## 分支管理

分支通俗说明，点击查看[Git 分支 - 远程分支](https://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E8%BF%9C%E7%A8%8B%E5%88%86%E6%94%AF)，[Git 分支 - 何谓分支](https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E4%BD%95%E8%B0%93%E5%88%86%E6%94%AF)。

设置默认分支。WEB项目页`setting-brances`修改，设置了GitHub默认分支后，本地克隆后版本库的默认分支也将改变。

- 查看分支
  
  ```bash
  $ git branch -r # 查看远程分支
  $ git branch -a  # 查看所有分支
  ```

- 切换分支
  
  ```bash
  $ git checkout master
  ```

- 新建分支
  
  ```bash
  $ git branch
  # 完成新分支的创建
  $ git checkout -b branchname
  # 同时完成新分支的创建和分支切换。
  
  $ git checkout -b newBrach oldBrach
  # 在oldBrach的基础上，复制创建一个新分支。
  
  # 获取tag的代码
  $ git tag
  $ git checkout -b branch_name tag_name
  ```

- 分支推送
  
  ```bash
  $ git add hello1
  $ git commit -m "add hello1"
  $ git push -u origin branchname
  ```

- 把远程某各分支拉去到本地的branchname下，如果没有branchname，则会在本地新建branchname
  
  ```bash
  $ git fetch origin branchname:branchname
  ```

- 获取远程分支remoteName 到本地新分支localName，并跳到localName分支
  
  ```bash
  $ git checkout origin/remoteName -b localName
  ```

- 查看远程分支列表
  
  ```bash
  $ git ls-remote
  $ git ls-remote git@github.com:username/name.git
  ```

- 删除本地分支，如果错误信息显示不能删除当前工作分支，需先切换到其他分支。
  
  ```bash
  $ git branch -d branchname （删除merge了的分支）
  $ git branch -D branchname （删除分支（不管它有没有merge））
  # Git在删除分支时为避免数据丢失，默认禁止删除尚未合并的分支。参数-D则可强制删除尚未合并的分支。
  ```

- 删除远程分支
  
  ```bash
  $ git push --delete origin branchname
  或者 $ git push origin :branchname
  ```

- 删除HEAD分支
  
  ```bash
  $ git push origin --delete HEAD
  ```

- 强制更新 Github上 的分支
  
  ```bash
  git push origin +master # 方法一，使用+强制更新
  git push -f origin HEAD^:master # 方法二，使用-f参数
  ```

<div id="git-merge"></div>

## 分支合并

> [Merge、Rebase 的选择](https://github.com/geeeeeeeeek/git-recipes/wiki/5.1-%E4%BB%A3%E7%A0%81%E5%90%88%E5%B9%B6%EF%BC%9AMerge%E3%80%81Rebase-%E7%9A%84%E9%80%89%E6%8B%A9)  
> [Git 工具 - 高级合并](https://git-scm.com/book/zh/v2/Git-%E5%B7%A5%E5%85%B7-%E9%AB%98%E7%BA%A7%E5%90%88%E5%B9%B6)  
> [图解4种git合并分支方法](http://yanhaijing.com/git/2017/07/14/four-method-for-git-merge/)  
> [Git 分支 - 分支的新建与合并](https://git-scm.com/book/zh/v1/Git-%E5%88%86%E6%94%AF-%E5%88%86%E6%94%AF%E7%9A%84%E6%96%B0%E5%BB%BA%E4%B8%8E%E5%90%88%E5%B9%B6)

实际上在很多情况下，Pull Request所含提交有可能造成合并冲突，那样的话 GitHub 不再、也不能提供自动合并功能，就必须采用手工合并的方式。

- 编辑文件解决冲突，再 add 冲突文件，再 commit。
- 对于一些二进制文件，或者不同版本的第三方库引起的冲突。这时候不可能去手工编辑来解决冲突了，必须在两个版本的库中进行一个选择。

```bash
# 在新分支上面合并
# 创建分支
$ git checkout -b newbranch master
$ git pull git://github.com/mygoare/lehuo.git master

# $ git status
# $ git diff
# 在合并过程中有冲突的时候， git 会把修改记录直接保存在文件中，让开发者判断文件如何解决合并。
# HEAD，即本地的代码
# ==以下则是来自远程的更改
# 用编辑器修改相应文件，把不需要的内容删除即可

# 把修改提交到newbranch分支上
$ git add .
$ git status
$ git commit -m "merge mygoare's code"

# 再合并到master分支上
$ git checkout master
$ git merge newbranch
$ git push
$ git branch -D newbranch
```

如果`git pull`之后出现`Please enter a commit to explain why this merge is necessary`，如果要输入解释的话就需要:

1. 按键盘字母 `i` 进入`insert`模式
2. 修改最上面那行黄色合并信息，可以不修改
3. 按键盘左上角`Esc`
4. 输入`:wq`，按回车键即可

```bash
# Fork 后的项目
$ git clone https://lei-shilei@bitbucket.org/lei-shilei/scrapy-51job-jobs.git
$ cd scrapy-51job-jobs
# 源项目地址
$ git remote add updates https://MarsStone@bitbucket.org/MarsStone/scrapy-51job-jobs.git
$ git remote update updates
$ git rebase updates/master

# 在合并过程中有冲突的时候， git 会把修改记录直接保存在文件中，让开发者判断文件如何解决合并。

# 重新提交commit
$ git add filename
$ git commit -m "add edit filename"
# 自动跳转到随机生成的分之下，分支名称为 56f5e47

$ git checkout master
$ git merge 56f5e47
# 手工合并冲突
$ git add . && git commit -m "add *" && git push
```

从一个分支合并特定的commits到另一个分支：

- 合并某个分支上的单个commit
  
  ```bash
  $ git checkout master  
  $ git cherry-pick 62ecb3  
  ```

- 合并某个分支上的一系列commits，假设你需要合并feature分支的commit76cada ~62ecb3 到master分支。
  
  ```bash
  $ git checkout -b newbranch 62ecb3  
  $ git rebase --onto master 76cada^   
  ```

## 更新 fork 的项目

```bash
# clone 自己的 fork 分支到本地
git clone git@github.com:sli1989/hexo-theme-next.git
cd <fold>
# 将原来的仓库指定为 upstream
git remote add upstream git@github.com:theme-next/hexo-theme-next.git
# fetch 源分支的新版本到本地
git fetch upstream
# 合并两个版本的代码
git merge upstream/master
# 将合并后的代码 push
git push origin branchname
```

## Pull Request

1. 先要fork别人仓库；
2. 克隆fork的仓库到本机上并建立连接：
   - `git clone git@github.com:sli1989/hexo-theme-next.git`
   - `git remote add origin git@github.com:sli1989/hexo-theme-next.git`
3. 新建一个新分支，作为Pull Request的源分支：`git checkout -b pitch`
4. 编辑代码并commit：`git commit -a -m "Further complement in README & fix pic_url"`
5. push到自己的仓库中：`git push -u origin pitch`
6. 用WEB浏览fork出来的仓库页面，点右上角的【Pull Request】按钮，发起一个Pull Request。弹出的表单自动设置自己的仓库为源仓库，并设置指定源分支、目标仓库和目标分支。

管理PR：

- Just edit files in «Files changed» tab. But in this case u can't to edit new files, only files which shown in «Files changed» tab.

- Use Git to Add and push.
  
  ```bash
  # Add the other user as a remote
  $ git remote add otheruser https://github.com/otheruser/yourrepo.git
  # Fetch
  $ git fetch otheruser
  # Create a branch from their repo
  $ git checkout -b otheruser-master otheruser/master
  # Now make some changes and commit. Push to their repo
  $ git push otheruser HEAD:master
  
  # Merge them in if you're good to go:
  $ git checkout master
  $ git merge otheruser/master
  ```

- Use Git in my forked repo.
  
  ```bash
  $ git checkout -b newmaster mirror
  $ git pull git://github.com/ifmos/hexo-theme-next.git master
  $ git remote add ifmos https://github.com/ifmos/hexo-theme-next.git
  # make some changes and commit
  $ git add _config.yml
  # git add -A
  # git diffs
  $ git status
  $ git commit -m "update style"
  $ git push ifmos HEAD:master
  ```

测试PR：

- 可以直接本地建立分支进行git pull：
  
  ```bash
  git checkout -b zhuzhuyule-addLeftMode master
  git pull git://github.com/zhuzhuyule/hexo-theme-next.git addLeftMode
  
  git checkout master
  git merge --no-ff zhuzhuyule-addLeftMode
  git push origin master
  ```

- `git am`命令用于将一个 patch 文件，合并进入当前代码。Github 对每个 PR 会自动生成一个 patch 文件。我们下载该文件，合并进本地代码，就可以在本地查看效果了。后面网址里面的`/cbeust/testng`是目标仓库，`pull/17`表示该仓库收到的第17个 PR。
  
  ```bash
  $ curl -L http://github.com/cbeust/testng/pull/17.patch | git am
  ```
  
    如果 PR 只包含一个 commit，那么也可以直接下载这个 commit 的 patch 文件。网址里面的`/sclasen/jcommander`是代码变更所在的那个仓库。
  
  ```bash
  $ curl https://github.com/sclasen/jcommander/commit/bd770141029f49bcfa2e0d6e6e6282b531e69179.patch | git am
  ```

- 另一种方法是为 PR 创建一个远程分支，追踪提交者的仓库。
  
  ```bash
  # 创建远程仓库，指向 PR 提交者的仓库
  $ git remote add nullin git://github.com/nullin/testng.git
  
  # 从该远程仓库拉取代码
  $ git fetch nullin
  
  # 将该仓库的某个分支合并到当前分支
  $ git merge kneath/error-page
  
  # 推送到自己的仓库
  $ git push origin master
  ```
  
    有时，PR 里面包含好几个 commit，但是你只想合并其中的一个或几个。这时可以使用`cherry-pick`命令，挑出你感兴趣的 commit。
  
  ```bash
  # 建立远程分支，追踪提交者的仓库
  $ git remote add nullin git://github.com/nullin/testng.git
  
  # 从该远程仓库拉取代码
  $ git fetch nullin
  
  # 只将感兴趣的 commit 加入当前代码
  $ git cherry-pick commit1
  $ git cherry-pick commit2
  
  # 推送到自己的仓库
  $ git push origin master
  ```

<div id="git-submodule"></div>
## 子模块管理

> [使用Git Submodule管理子模块](https://segmentfault.com/a/1190000003076028)  
> [git submodule 使用小结](http://blog.gezhiqiang.com/2017/03/08/git-submodule/)

- 添加子模块：`git submodule add <repository> [<path>]`（`git submodule add https://github.com/sli1989/hexo-theme-next.git themes/next`），添加后会多一个`.gitmodules`文件，文件的内容只是保存子模块的引用信息，包括路径和repo地址。

- 删除子模块：
  
  ```bash
  # 首先我们反初始化
  # git submodule deinit themes/next
  
  $ rm -rf themes/next
  # 这时，子模块文件被删除，同时 .gitmodules 文件中的相关信息被删除
  
  $ cd .git
  $ vim config # 删掉submodule信息
  
  $ cd modules
  $ rm -rf * # 千万别敲错了，或者可以到文件夹手动删除
  # $ rm -rf .git/modules/themes/next
  
  $ cd ../..
  
  $ git rm --cached themes/next
  $ rm ./gitmodules
  
  # 或者直接全部删除
  # git submodule deinit --force themes/next
  ```

- 本地修改更新子模块。默认下 submodule 的 HEAD 处于游离状态，在修改子项目的时候，要用 `git checkout master` 将当前的子模块分支切换到 `master`，然后才能做修改和提交。子项目一旦产生变动，有新的commit id，父项目必需产生一个提交，更新对子项目commit id的引用。子模块被提交后父项目会检测到，正常提交即可！
  
  ```bash
  # 首先，我们进入子模块
  cd thems/next
  # 检出master分支
  git checkout master
  
  # 然后做修改
  vim some-file.py
  
  $ cd hexo
  $ git status
  
  # modified:   xx/xxxx/xxxx (new commits)
  
  # add的时候注意再最后不要加 / 斜杠，否则会出现很棘手问题
  
  $ git add xx/xxxx/xxxx
  $ git commit -m "Get something done"
  $ git push origin master
  ```
  
    如果你不慎忘记切换到 master 分支，又做了提交，可以用 cherry-pick 命令挽救。
  
  ```bash
  git checkout master
  # 记住Warning的 change-id
  
  git cherry-pick change-id
  git push
  ```

- 直接从远程仓库更新子模块。使用CI部署时，本地子模块文件`themes/next`必须存在，同时需要更新子模块的commit信息。
  
  - 在父项目的目录下直接运行`git submodule foreach --recursive git pull origin master`，一次全部更新所有的 submodule。
  - 或者在子模块的目录下面更新`git pull`，使用和git单独的一个项目是一样的。建议大家`git pull` 之后，立即执行 `git status`，如果发现子模块有修改，立即执行 `git submodule update`。更复杂一些，如果你的 submodule 又依赖了 submodule，那么很可能你需要在 `git pull` 和 `git submodule update` 之后，再分别到每个 submodule 中再执行一次 `git submodule update`，这里可以使用 `git submodule foreach` 命令来实现： `git submodule foreach git submodule update`。

- 当clone项目时有子模块存在时，第一次是不会clone出子模块的，需要执行一些命令：
  
  ```bash
  $ git clone git@gitlab.com:sli1989/sli1989.gitlab.io.git
  $ cd sli1989.gitlab.io
  
  # 初始化子模块 只在首次检出仓库时运行一次就行
  $ git submodule init
  # 将子模块的文件check出来 每次更新或切换分支后都需要运行一下
  $ git submodule update
  # $ git submodule update --init
  # 现在所有子模块已经把被checkout到本地，是不是很棒！
  
  # 也可以直接采用
  $ git clone <repository> --recursive
  $ git submodule update --init --recursive
  ```

## 里程碑管理

里程碑即tag，其管理和分支管理非常类似。里程碑和分支一样也是以引用的形式存在的，保存在`.git/refs/tags/`路径下。引用可能指向一个提交，但也可能是其他类型（Tag对象）。

* 轻量级里程碑：用`git tag <tagname> [<commit>]` 命令创建，引用直接指向一个提交对象`<commit>`。
* 带说明的里程碑：用`git tag -a <tagname> [<commit>]` 命令创建，并且在创建时需要提供创建里程碑的说明。Git会创建一个tag对象保存里程碑说明、里程碑的指向、创建里程碑的用户等信息，里程碑引用指向该Tag对象。
* 带签名的里程碑：用`git tag -s <tagname> [<commit>]` 命令创建。是在带说明的里程碑的基础上引入了PGP签名，保证了所创建的里程碑的完整性和不可拒绝性。

下面演示一下里程碑的创建和管理。

1. 先在本地创建一个新提交。
   
   ```bash
   $ touch hello1
   $ git add hello1
   $ git commit -m "add hello1 for mark."
   ```

2. 本地创建里程碑`mytag1`、`mytag2`和`mytag3`。
   
   ```bash
   $ git tag -m "Tag on initial commit" mytag1 HEAD^
   $ git tag -m "Tag on new commit"     mytag2
   $ git tag mytag3
   ```

3. 查看新建立的里程碑。
   
   ```bash
   $ git tag -l -n1
   mytag1          Tag on initial commit
   mytag2          Tag on new commit
   mytag3          add hello1 for mark.
   ```

4. 将本地里程碑推送到GitHub远程版本库。
   
   ```bash
   $ git push origin refs/tags/*
   Counting objects: 6, done.
   Delta compression using up to 2 threads.
   Compressing objects: 100% (4/4), done.
   Writing objects: 100% (5/5), 548 bytes, done.
   Total 5 (delta 0), reused 0 (delta 0)
   To git@github.com:sli1989/sli1989.github.io.git
    * [new tag]         mytag1 -> mytag1
    * [new tag]         mytag2 -> mytag2
    * [new tag]         mytag3 -> mytag3
   ```

5. 删除本地里程碑。
   
   ```bash
   $ git tag -d mytag3
   Deleted tag 'mytag3' (was c71231c)
   ```

6. 删除GitHub远程版本库中的里程碑。
   
   ```bash
   $ git push origin :mytag3
   To git@github.com:sli1989/sli1989.github.io.git
     [deleted]         mytag3
   ```

## 永久删除文件与历史记录

1. 从仓库总清除文件
   
   ```bash
   git filter-branch --force --index-filter 'git rm --cached --ignore-unmatch path-of-remove-file' --prune-empty --tag-name-filter cat -- --all
   # path-of-remove-file是你要删除的文件的相对目录(相对于git repo的根目录),可以使用通配符*匹配文件进行批量删除
   # 如果执行上述命令后出现的提示信息中有unchanged字样,说明repo中没有找到path-of-remove-file,请仔细检查路径和文件名是否正确
   ```

2. 本地同步到服务器
   
   ```bash
   git push origin master --force
   ```

3. 回收磁盘空间
   
   ```bash
   rm -rf .git/refs/original/
   du -sh .git
   git reflog expire --expire=now --all
   git gc --prune=now
   u -sh .git/*
   git gc --aggressive --prune=now
   du -sh .git
   ```

如何删除这些历史记录，形成一个全新的仓库，并且保持代码不变呢？

```
$ git checkout --orphan latest_branch
$ git add -A
$ git commit -am "init"
$ git branch -D master
$ git branch -m master
$ git push -f origin master
```

# Git GUI

> 参考链接 [Git可视化极简易教程 —— Git GUI使用方法](http://www.cnblogs.com/iruxu/p/gitgui.html)。

Git GUI提供了Git可视化操作，避免命令行输入。

> 参考文献[GitHub Desktop下载及使用](http://www.cnblogs.com/schaepher/p/4823181.html)，[Github Desktop的使用教程](http://www.jianshu.com/p/6063974849db)。

<div id="gitKraken"></div>

- [GitKraken](https://www.gitkraken.com/)（推荐使用），这款工具操作比较方便，对没有太多git使用经验的新手比较友好，学习成本相对较低。尤其喜欢的一点就是它的分支和提交非常清晰。
- [Github Desktop](https://desktop.github.com/)不好用，其图形化界面功能有限。

## Github Desktop

如果[Git bash 配置](#gitbash)好了，不需要Git GUI 权限校验。第一次才配置。如果不使用git bash 配置，需要单独配置Git GUI 。
    1. 在目标文件夹右键，启动`GIT GUI`。
    1. 【Step1-创建密钥】SHOW SSH KEY
      ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lst94qlj20e2078mxi.jpg)
    1. 【Step2-添加密钥】登陆github系统。点击右上角的 Settings--->SSH and GPG keys ---> NEW SSH KEY，直接粘贴到key文本框中， 点击 add key。title可以随便命名，然后点击add。
      ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26ltk35fkj20sn0fs0u1.jpg)
      ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lvaxkgwj21ha0at75c.jpg)

### 仓库克隆

- 选择目标文件夹，选中后点击右键，选择`Git GUI Here`，选择“克隆已经存在的仓库”。

- 填写Source Location（源地址）和Target Directory

- 点击clone后，会提示下输入你github的用户名和密码，出现下面的界面，克隆完成。

### 账号保存

如果不做设置的话，每次提交的时候，都会询问你填写密码。

1. （可跳过）【Step3.1-添加环境变量】我的电脑 - 属性 - 高级系统设置 - 环境变量 - 新建变量，变量名HOME，变量值 %USERPROFILE%

2. 【Step3.2-创建账号文件】windows的管理员账号文件夹`C:/Users/Administrator`。新建一个名为`_netrc`的文件，填写你要保存的服务器地址及账号密码，保存。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lvpmbh7j20qa09kjsv.jpg)
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lwyfgaqj207305zmx2.jpg)

### 本地同步到服务器

1. 修改属性配置-改为utf-8。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqrb7l7v4jj30p70h7wew.jpg)
2. 修改本地仓库内容。
3. 点击RECAN，获取改动文件。
4. 选择Stage Changed。
5. 提交（Git commit）。提交的时候是要求必须要写备注的。提交则代表此前被添加ADD的文件已确认被提交到Git库了。需要注意的是，如果你改变代码的缩进（尽管没有修改内容），默认状态下会被识别为整个代码全部变更。
6. 上传（Git push）。上传至远端服务器。

### 服务器同步到本地仓库

1. 先来设置与远程地址的关联，Git remote：填写SSH地址与项目名。下面有3个选项：第一个：立刻获取最新改动（所以如果是本地克隆远程一个项目，也可以这样操作）。第二个：本地新建的项目，初始化远程仓库并发布过去。第三个：什么也不做。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lw5mf29j20mn0etmy9.jpg)
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lxgki69j20af07pdg0.jpg)

2. 获取仓库的最新改动Git fetch。选择从远程仓库哪个分支中获取更新，如果没有则只有主支。提示成功则改动的已经被存放到临时区了，你一会还需要进行合并操作，如果没有任何改动，则列表中是空的。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fib9nh43dqj20wo0ipjsf.jpg)
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lxxsmbaj20gs07sdfz.jpg)

3. 合并（Git merge）。不管你本地有没有代码，fetch之后呢，是都要merge的。选择合并 - 本地合并，然后选择本地的分支（如果你没有创建分支，则只有1个主支master）
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lykajw4j20ml0eoaba.jpg)

4. 冲突处理（Conflict）。合并的过程中可能会出现一些红色的文件与一堆叹号，只是有冲突的文件。在GUI界面正文区，正文区右键可以选择，Use local version（使用本地版本）或Use remote version（使用远程版本）。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lzhne1dj20mw0mxdjx.jpg)

# Git Pages

Git Pages有以下几个优点：

* 轻量级的博客系统，没有麻烦的配置
* 使用标记语言，比如[Markdown](http://markdown.tw/)
* 无需自己搭建服务器
* 可以绑定自己的域名

<div id="github-pages"></div>

[Github](http://github.com/)是一个通过Git进行版本控制的软件源代码托管服务，由GitHub公司（曾称Logical Awesome）的开发者Chris Wanstrath、PJ Hyett和Tom Preston-Werner使用Ruby on Rails编写而成。与GitHub建立好链接之后，就可以方便的使用它提供的Pages服务，[Github Pages](http://pages.github.com/)分两种，一种是你的GitHub用户名建立的`username.github.io`这样的用户&组织页（站），另一种是依附项目的pages。Hexo deploy可以部署到很多平台，具体可以[参考这个链接](https://hexo.io/docs/deployment.html)。

<div id="gitlab-pages"></div>

[Gitlab](https://pages.gitlab.io/)也是一个开源项目托管服务网站，Gitlab pages和Github pages的基本功能都一样，它支持**无限的private项目**。Gitlab pages和Github pages的基本功能都一样。使用GitLab Pages部署Hexo博客只需要把博客源代码push到repo，然后配置好GitLab Continuous Integration(GitLab CI)，就会自动渲染和部署Hexo博客。但是Gitlab pages有一些限制：**不能把www子域名重定向到根域名**，会同时存在两个版本的网站，这点非常不利于seo。

<div id="coding-pages"></div>

Coding.net 是一个面向开发者的云端开发平台，提供git/svn 代码托管，代码质量分析，在线WebIDE，项目管理，开发协作，冒泡社区，提供个人和企业公有云及企业私有云的服务。最近`Coding Pages`进行了改版，在托管的个人pages中添加`Hosted by coding pages`字样可以去掉等待页面，完成抓取工作，也可以用DNS做国内外分流，顺便解决访问速度慢的问题。

## 新建仓库

> 参考：[GitLab Pages搭建Hexo博客](https://www.ouyangsong.com/2017/05/28/gitlab-pages-hexo-cloudflare-ssl-markdown/)，[Example Hexo site using GitLab Pages](https://gitlab.com/pages/hexo)

1. [首次Git bash 配置](#gitbash)。

2. 建立仓库。
   
   - [Github](https://github.com)完成注册后，创建与你的用户名相对应的**公开仓库**，格式必须是`username.github.io`。
   - 在[Gitlab](https://gitlab.com/)完成注册。创建与你的用户名相对应的**私密/公开仓库**，格式必须是`username.gitlab.io`。
   - 在[Coding](https://coding.net/register?key=b5af402b-08a4-400f-8212-71975243bbce)完成注册。点击`创建新项目`，填写相关信息，可以选择**私密/公开仓库**。`项目名称`里填上你的用户名（项目名称必须与coding的用户名一致？）可以创建任意名字的**私密/公开仓库**。进入项目页面，点击左侧栏的`代码`面板 ，选择 `Pages 服务`一项可以看到部署 Pages 的设置（公开项目点击 `Pages` 选项卡即可）。填写您欲部署的分支（默认为 `coding-pages` ），点击`立即开启`，稍等片刻即可完成部署并通过 `{user_name}.coding.me` 访问您的网站。

## 博客建立

详细内容查看[HEXO博客](#hexo-blog)的建立与调试。

<div id="hexo-deploy"></div>

## 博客部署

调试完成后，即可[博客部署](https://hexo.io/zh-cn/docs/deployment.html)。可分为本地部署和在线部署。在未采用在线部署的时候，更新博客后总需要自己手动 `hexo g -d`，占用时间；使用在线部署之后（如[Git Hooks](#git-hooks)，[Travis CI](#travis-ci)和[Gitlab CI](#gitlab-ci)），只需要执行 `git push`，剩下的静态页面构建过程就由服务器完成。

### 本地部署

Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。

1. 在本地项目根目录中右键`git bash`，[测试连接](#git-ssh-test)，首次推送设置，以后不需要：
   
   ```bash
   $ git init
   $ ssh -T git@github.com
   $ git remote add origin git@github.com:sli1989/sli1989.github.io.git
   
   $ ssh -T git@git.coding.net
   $ git remote add origin git@git.coding.net:sli1989/sli1989.git
   ```

2. 配置HEXO部署环境。
   
   ```bash
   $ npm install hexo-deployer-git --save
   ```

3. 修改站点配置文件中部署参数。一个正确的部署配置中至少要有 type 参数，可同时使用多个 deployer。YAML依靠缩进来确定元素间的从属关系。因此，**请确保每个deployer的缩进长度相同，并且使用空格缩进**。
   
   ```yml
   deploy:
   - type: git
     repo: 'git@git.coding.net:sli1989/sli1989.git'
     branch: master
   - type: git
     repo: 'git@github.com:sli1989/sli1989.github.io.git'
     branch: master
   ```
   
    或者
   
   ```yml
   # deploy沿着左边界写
   # type和repo左边空格是2个，多一个少一个都不行
   # git与type后面的:中间要有一个空格
   # github和coding要与repo后边的:对齐
   deploy:
     type: git
     repo:
         github: git@github.com:sli1989/sli1989.github.io.git
         coding: git@git.coding.net:sli1989/sli1989.git
     branch: master
   ```

1. 对于coding pages，需要在`source/`需要创建一个空白文件`Staticfile`，因为 `coding.net`需要这个文件来作为以静态文件部署的标志。
   
   ```bash
   cd source/
   touch Staticfile  #名字必须是Staticfile
   ```

2. Hexo 提供了快速方便的一键部署功能，执行命令 `hexo clean && hexo g -d` ，就可以在 `username.coding.me` 或者`username.github.io`看到你的博客了。

<div id="git-hooks"></div>

### Git Hooks

[通过配置 Git Hooks 实现自动部署 Hexo](https://tsanie.us/2018/01/15/setting-git-hooks)

<div id="travis-ci"></div>

### Travis CI

持续集成，Continuous integration，简称CI。

Travis CI 是一个基于 Github 仓库的持续集成工具，使用一个GitHub Page分支来管理所有博客的源代码，然后由CI编译发布到master主分支。

[wafer.li的博文](https://wafer.li/Hexo/Hexo%20%E9%9B%86%E6%88%90%20Travis%20CI%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%8D%9A%E6%96%87/)详细介绍了配置步骤[^hexo-ci-1] [^hexo-ci-2]。

[^hexo-ci-1]: [CI-自动构建](https://peterxugo.github.io/2017/05/27/hexo%E5%86%99%E5%8D%9A%E5%AE%A2/)

[^hexo-ci-2]:[Hexo + GitHub + Travis CI + VPS 自动部署](https://changkun.us/archives/2017/06/232/)

<div class="note warning"><p>未测试</p></div>

1. 首先使用GitHub账号登入在Travis CI，并在Travis中开启GItHub Page的持续集成。

2. 然后设定自动构建过程的配置文件，在本地的blog的git库的顶级目录中新加文件`.travis.yml`。

3. 通过 GItHub 新增加一个 Personal access token（记得复制），从而使得CI能够push代码。

4. 最后，我们在本地代码中新建分支`source_code`，在该分支下执行提交代码。
   
   ```bash
   git add . -A
   git commit -m "test CI"
   git push
   ```

`~/hexo/.travis.yml`文件内容参考：

> 配置文件中的`${pandoc}`是pandoc的下载地址，配置在CI的变量中，后面会具体讲如何设置该变量，同样的`${token},${GH_REF}`同理。`after_script`中的`user.name`，`user.email`，需要改成你自己的git用户名和邮箱，global中的`- GH_REF: github.com/peterxugo/peterxugo.github.io.git`需要换成自己的仓库地址。

```yml
language: node_js
node_js: stable
cache:
  - pandoc
  - hexo-cli
  - hexo-renderer-pandoc
install:
  - wget ${pandoc}
  - sudo dpkg -i pandoc*.deb
  - npm install -g hexo-cli
  - npm install hexo-renderer-pandoc --save
script:
  - hexo clean
  - hexo g
after_script:
  - cd ./public
  - git init
  - git config user.name "peterxu"
  - git config user.email "peterxugo@gmail.com"
  - git add .
  - git commit -m "Update"
  - git push --force --quiet "https://${token}@${GH_REF}" master:master
branches:
  only:
    - source_code
env:
 global:
   - GH_REF: github.com/peterxugo/peterxugo.github.io.git
```

```yml
sudo: required
dist: trusty
group: edge
language: node_js
node_js: stable
python:
  - "3.4"
branches:
  only:
  - master
cache:
  apt: true
  yarn: true
  directories:
  - node_modules
addons:
  ssh_known_hosts:
  - changkun.us:38438
before_install:
  - openssl aes-256-cbc -K $encrypted_3277e6996e70_key -iv $encrypted_3277e6996e70_iv -in .travis/travis.enc -out ~/.ssh/id_rsa -d
  - chmod 600 ~/.ssh/id_rsa
  - git config --global user.name "Changkun Ou"
  - git config --global user.email "hi@changkun.us"
  - sudo apt-get -qq update
  - sudo apt-get install -y pandoc
  - sudo apt-get -y install python3-pip python-dev
  - sudo pip3 install -U setuptools
  - sudo pip3 install -U virtualenvwrapper
  - python3 -V
  - pip3 -V
  install:
  - pip3 install -r requirements.txt
  - npm install hexo-cli -g
  - yarn
  - git clone https://github.com/changkun/hexo-theme-next themes/hexo-theme-next
  - cp config/site_config.yml _config.yml
  - cp config/theme_config.yml themes/hexo-theme-next/_config.yml
script:
  - make repair
  - make g
  - make mini
after_success:
  - make dep
```

<div id="gitlab-ci"></div>

### Gitlab CI

使用Gitlab自动部署，你只需要在项目的根目录下添加一个`.gitlab-ci.yml`文件，用来指导服务器如何处理你提交的源文件。然后把博客源代码push到repo，就会自动渲染和部署Hexo博客。也可以配置将其推送到 github 和 coding，，也可以直接到gitlab上去写markdown源文件。

1. 先按照[Hexo-BLOG](#hexo-blog)搭建和调试本地博客，确保无误后新建（也可以直接改名）目录名为`sli1989.gitlab.io`
2. 将文件`scaffolds`, `source`, `themes`, `.gitignor`,  `.gitlab-ci.yml`, `_config.yml`, `package.json`复制，同时要将`themes/next/`目录下的`.git`文件夹删除，也删除博客目录的`.git`文件夹再重新配置。
3. 配置`.gitlab-ci.yml`文件，可以分别进行[https链接](#gitlab-ci-https)和[ssh链接](#gitlab-ci-ssh)。

实际上 Hexo 的文章更改时间就是 markdown 文件的最后修改时间。由于 CI 在构建的时候，总是重新 clone repo，这就造成了所有文件的最后修改时间都是最新的 clone 时间；实际上，这并不是 CI 的问题，而是 git 的问题，git 由于分布式的原因，并不会保留文件的最后修改时间；不过，作为一个博客系统来说，我们可以采用 git 的最后 commit 时间来替代，这样子就能恢复文件的修改时间了。

[博文](https://wafer.li/Hexo/%E8%A7%A3%E5%86%B3%20Travis%20CI%20%E6%80%BB%E6%98%AF%E6%9B%B4%E6%96%B0%E6%97%A7%E5%8D%9A%E5%AE%A2%E7%9A%84%E9%97%AE%E9%A2%98/)解决了 CI 总是更新旧博客的问题。不同的是，GITLAB的[GIT_DEPTH](https://docs.gitlab.com/ce/ci/yaml/README.html#shallow-cloning)是人工设置。

```yml
#  an experimental feature
variables:
  GIT_DEPTH: "1000000"

before_script:
  - export TZ='Asia/Shanghai'
  - git config --global user.name "sli1989"
  - git config --global user.email "im.sai.li@outlook.com"
  # Restore last modified time
  - "git ls-files -z | while read -d '' path; do touch -d \"$(git log -1 --format=\"@%ct\" \"$path\")\" \"$path\"; done"
```

<div id="gitlab-ci-https"></div>

#### HTTPS链接

以下`.gitlab-ci.yml`配置[^n0trace.com]使用Pandoc渲染器，插件的使用跟[Hexo-BLOG](#hexo-blog)本地调试一致，需要什么添加什么。

[^n0trace.com]: [用gitlab-ci持续集成部署hexo博客](https://blog.n0trace.com/2017/07/15/%E7%94%A8gitlab-ci%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/index.html)

这里比较重要的：

- 如果您的密码中包含[:@]等符号，请您对密码做`urlencode`处理，如`@=%40`。
- github仓库的地址设置：`https://github.access.token@github.com/github.username/github.usernam.github.io.git`，`github.access.token`第一次生成时才能看到，之后只能通过`git config --list`查看复制（参考[使用hexo+gitlab+ci+github Pages 持续集成写博客](http://blog.frenlee.com/2016/11/hexo-gitlab-ci/)）。
- 对于Coding pages的推送，HTTPS 方式 push 大文件可能引发错误。可以执行 `git config http.postBuffer 524288000` 设置更大的限制值。

<div class="note success"><p>Success</p></div>

```yml
before_script:
  - apt-get update -qq && apt-get install -y -qq pandoc

image: node:6.10.2

pages:
  cache:
    paths:
    - node_modules/
  script:
  - npm install hexo-cli -g
  - npm install
  - npm uninstall hexo-filter-auto-spacing --save
  - npm uninstall hexo-renderer-marked --save
  - npm install hexo-renderer-pandoc --save
  - npm install hexo-generator-feed --save
  - npm install hexo-generator-sitemap --save
  - npm install hexo-generator-baidu-sitemap --save
  - npm install hexo-generator-searchdb --save
  - npm install hexo-generator-topindex --save
  - npm install hexo-symbols-count-time --save
  - ./node_modules/hexo/bin/hexo generate
  - cd ./public
  - git init
  - git config --global user.name "sli1989"
  - git config --global user.email "im.sai.li@outlook.com"
  - git config --global push.default simple
  - git add .
  - git commit -m "gitlab-auto-deploy"
  - git push --force --quiet --set-upstream https://github_access_token@github.com/username/username.github.io.git master # replace github_access_token
  - git config http.postBuffer 524288000
  - git push --force --quiet --set-upstream https://username:password@git.coding.net/username/reponame.git master # replace username & password

  artifacts:
    paths:
    - public
  only:
  - master
```

<div id="gitlab-ci-ssh"></div>

#### SSH链接

[官方配置](https://gitlab.com/pages/hexo)推荐使用的是SSL链接，[用gitlab-ci持续集成部署hexo博客](https://blog.n0trace.com/2017/07/15/%E7%94%A8gitlab-ci%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E9%83%A8%E7%BD%B2hexo%E5%8D%9A%E5%AE%A2/index.html)和[GitLabCI通过ssh进行自动部署](https://zacksleo.github.io/2017/04/14/GitLabCI%E9%80%9A%E8%BF%87ssh%E8%BF%9B%E8%A1%8C%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/index.html)介绍了使用过程。

<div class="note success"><p>Success</p></div>

1. 生成部署公钥。与账户 SSH 公钥生成一样，但不能重复使用。打开命令行终端输入 `$ ssh-keygen -t rsa -C "im.sai.li@outlook.com" -f ~/.ssh/deploy_rsa`，连续点击 Enter 键即可。

2. 添加部署公钥。用文本编辑器打开`deploy_rsa.pub`文件，复制全部内容。
   
   - 登录 Coding.net，进入**目标项目**，点击『设置 -> 部署公钥 ->[新建部署公钥](https://sli1989.coding.net/user/account/setting/keys)』，将复制的内容填写到『公钥内容』一栏，公钥名称自定义为`gitlab-deploy`。点击『添加』，**勾选** 部署公钥设置里的『授予推送权限』，然后输入账户密码即可成功添加部署公钥。
   - 登录 github，进入**目标项目**，点击『设置 -> 部署公钥 ->[ 新建部署公钥](https://github.com/sli1989/sli1989.github.io/settings/keys)』，将复制的内容填写到『公钥内容』一栏，公钥名称自定义为`gitlab-deploy`。点击『添加』，**勾选** 部署公钥设置里的『授予推送权限』，然后输入账户密码即可成功添加部署公钥。

3. 添加部署密匙。进入[Gitlab项目页面](https://gitlab.com/sli1989/sli1989.gitlab.io/settings/ci_cd)，`SETTINGS-CI/CD-Secret variables`，复制密匙`\Administrator\.ssh\deploy_rsa`内容，名称自定义为`DEPLOY_PRIVATE_KEY`并记住。

4. 设置`.gitlab-ci.yml`：
   
   ```yml
   # variables:
     # GIT_DEPTH: "1000000"
   // 注意替换 DEPLOY_PRIVATE_KEY
   before_script:
     - export TZ='Asia/Shanghai'
     - git config --global user.name "sli1989"
     - git config --global user.email "im.sai.li@outlook.com"
     # Restore last modified time
     - "git ls-files -z | while read -d '' path; do touch -d \"$(git log -1 --format=\"@%ct\" \"$path\")\" \"$path\"; done"
     # Install ssh-agent if not already installed, it is required by Docker.
     # (change apt-get to yum if you use a CentOS-based image)
     - 'which ssh-agent || ( apt-get update -y && apt-get install openssh-client -y )'
     # Run ssh-agent (inside the build environment)
     - eval $(ssh-agent -s)
     # Add the SSH key stored in SSH_PRIVATE_KEY variable to the agent store
     - ssh-add <(echo "$DEPLOY_PRIVATE_KEY")
     # For Docker builds disable host key checking. Be aware that by adding that
     # you are suspectible to man-in-the-middle attacks.
     # WARNING: Use this only with the Docker executor, if you use it with shell
     # you will overwrite your user's SSH config.
     - mkdir -p ~/.ssh
     - '[[ -f /.dockerenv ]] && echo -e "Host *\n\tStrictHostKeyChecking no\n\n" > ~/.ssh/config'
     # In order to properly check the server's host key, assuming you created the
     # SSH_SERVER_HOSTKEYS variable previously, uncomment the following two lines
     # instead.
     # - mkdir -p ~/.ssh
     # - '[[ -f /.dockerenv ]] && echo "$SSH_SERVER_HOSTKEYS" > ~/.ssh/known_hosts'
   
     # install pandoc
     # - apt-get update -qq && apt-get install -y -qq pandoc
     # - wget https://github.com/jgm/pandoc/releases/download/2.7/pandoc-2.7-1-amd64.deb
     - wget https://github.com/jgm/pandoc/releases/download/1.19.2.1/pandoc-1.19.2.1-1-amd64.deb
     - dpkg -i ./pandoc-1.19.2.1-1-amd64.deb
   
   image: node:10.15.0
   
   pages:
     cache:
       paths:
       - node_modules/
     script:
     - npm install -g hexo-cli
     - npm install
     - npm uninstall hexo-filter-auto-spacing --save
     - npm uninstall hexo-renderer-marked --save
     - npm install hexo-renderer-pandoc --save
     - npm install hexo-generator-feed --save
     - npm install hexo-generator-topindex --save
     - npm install hexo-generator-sitemap --save
     - npm install hexo-generator-baidu-sitemap --save
     - npm install hexo-generator-searchdb --save
     - npm install hexo-symbols-count-time --save
     - hexo clean
     - hexo generate
     - git config --global user.name "sli1989"
     - git config --global user.email "im.sai.li@outlook.com"
     - hexo deploy
   
     artifacts:
       paths:
         - public
     only:
       - master
   ```

1. 在本地项目根目录中右键`git bash`，[测试连接](#git-ssh-test)，首次推送设置，以后不需要：
   
   ```bash
   $ git init
   $ ssh -T git@gitlab.com
   $ git remote add origin git@gitlab.com:sli1989/sli1989.gitlab.io.git
   ```

2. 推送本地修改，也可以直接使用Atom安装`Git-Control`插件，实现Git操作，点击查看[Atom使用指南](https://sli1989.github.io/markdown-user-guide/#atom)和[Markdown语法](https://sli1989.github.io/markdown-user-guide/#markdowngrammar)。
   
   ```bash
   $ git add .
   $ git commit -m "update post"
   $ git push -u origin master
   ```

3. 然后可以在博客仓库的Pipelines中查看到Hexo渲染和部署的过程，可以在`Pipelines`中查看构建失败的原因。构建成功后，可以访问 `https://sli1989.gitlab.io/`查看搭建效果。

<div id="hexo-sync"></div>

## 博客备份

如果我想在另外一台设备上面写博客，必须将整个项目拷贝过来，完成之后要保持两台设备的内容是一致的。在这种情况下一般会将整个项目都托管到 Github/Coding 上面。但是这又会导致另外一个问题，每次有改动的时候不但要部署博客，还要提交项目的代码，这又增加了操作的步骤。

CI自动部署解决这种烦恼，让所有工作交给服务器。因此推荐使用自动部署的方式进行备份，如[Git Hooks](#git-hooks)，[Travis CI](#travis-ci)和[Gitlab CI](#gitlab-ci)。

### 上传

`hexo g` 命令就是根据`_config.yml`，`source`目录文件以及`themes`目录下文件生成博客文件的。同样当我们运行`hexo clean`命令时，`public`目录被删除了。因此，需要备份的文件就是`scaffolds, source, themes, .gitignor,  .gitlab-ci.yml, _config.yml, package.json`，这个就是用于多终端同步关键的部分。

1. 配置`.gitignore`文件。
   
   ```diff
   .DS_Store
   Thumbs.db
   db.json
   *.log
   node_modules/
   public/
   .deploy*/
   ```

2. 同步到远程仓库的`Hexo`分支。这样你的Github项目中就会多出一个`Hexo`分支。
   
   ```bash
   git add . #添加目录下所有文件
   git commit -m "Blog Source Hexo"
   git branch hexo
   git checkout hexo
   git remote add origin git@github.com:sli1989/sli1989.github.io.git
   git push origin hexo
   ```

### 下载

1. 在B电脑上新建`hexo`文件夹。拉下远程仓库文件
   
   ```bash
   git init
   git clone origin hexo git@github.com:sli1989/sli1989.github.io.git
   ```
   
    或者
   
   ```bash
   git init
   git remote add origin git@github.com:sli1989/sli1989.github.io.git
   git checkout -b hexo
   git pull origin hexo
   ```

2. 然后进行[博客配置](#hexo-init)，安装插件。
   
   ```bash
   # 安装必要的所需组件，不用再init；否则之前的hexo配置参数会重置
   
   $ npm install -g hexo-cli
   $ npm install hexo --save
   
   # 安装依赖库
   $ npm install
   
   # 安装部署相关配置
   $ npm install hexo-deployer-git
   ```

3. 然后写文章，部署博客，同时更新Hexo分支。
   
   ```bash
   hexo new post "new blog name"  
   # 新建一个.md文件，并编辑完成自己的博客内容
   
   git add . #添加目录下所有文件
   git commit -m "UPDATE Blog Source Hexo"
   git push origin hexo  # 更新Hexo分支
   hexo d -g
   ```

4. 在不同的终端已经做完以上第一次配置后，以后只需执行以下命令进行更新即可。
   
   ```bash
   git pull origin hexo  
   # 先pull完成本地与远端的融合
   
   git add .
   git commit -m "xx"
   git push origin hexo
   hexo d -g
   ```

<div id="hexo-blog"></div>

# Hexo BLOG

> 参考链接：[手把手教你使用Hexo + Github Pages搭建个人独立博客](https://linghucong.js.org/2016/04/15/2016-04-15-hexo-github-pages-blog/)，[小白独立搭建博客--Github Pages和Hexo简明教程](https://my.oschina.net/ryaneLee/blog/638440)，[Hexo+Github搭建个人博客(二)——配置&主题](http://www.jianshu.com/p/f1cc7fdc869e)。

To work locally with this project, you'll have to follow the steps below: Read more at Hexo's [documentation](https://hexo.io/docs/).

<div id="hexo-init"></div>

## 博客初始化

1. 下载安装[Node.js](https://nodejs.org/en/download/)。

2. 下载安装[Git](#gitdownload)，进行[Git Bash 配置](#gitbash)。

3. 博客环境配置：所有必备的应用程序安装完成后，根据自己喜好选择存放目录，右键点击`Git Bash Here`，进入Git命令框，执行以下操作。
   
   ```bash
   # 安装 Hexo
   $ npm install -g hexo-cli
   
   # 文件夹取名为hexo
   $ hexo init hexo
   # 注意init会把之前的hexo配置参数会重置
   # 会自动安装依赖库 如果没有 手动安装
   # $ npm install
   ```

4. 博客环境配置完成后，可以在站点配置文件`~/blog/_config.yml`中配置大部分的参数（如何[配置](https://hexo.io/zh-cn/docs/configuration.html)）。要记得把URL换成你的博客地址（`http://username.github.io`或自定义域名）。
   
   > - [package.json](https://hexo.io/zh-cn/docs/setup.html#package-json)是应用程序的信息。[EJS](http://embeddedjs.com/), [Stylus](http://learnboost.github.io/stylus/) 和 [Markdown](http://daringfireball.net/projects/markdown/) renderer 已默认安装，您可以自由移除。
   > - 当您新建文章时，Hexo 会根据 [模版scaffolds](https://hexo.io/zh-cn/docs/writing.html) 文件夹来建立文件。
   > - 资源文件夹`source`是存放用户资源的地方。
   > - 除 `_posts` 文件夹之外，开头命名为 `_` (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。
   > - Markdown 和 HTML 文件会被解析并放到 `public` 文件夹，而其他文件会被拷贝过去。
   > - [主题themes](https://hexo.io/zh-cn/docs/themes.html) 文件夹。Hexo 会根据主题来生成静态页面。

5. 主题选择。进入[Hexo的官网主题专栏](https://hexo.io/themes/)，挑选喜欢的主题，复制它的github地址，进入`/themes`目录，右键`Git Bash`，在命令行输入。下载完成后，打开站点配置文件`~/blog/_config.yml`，修改参数为：`theme: next`，然后编辑主题配置文件`~/blog/themes/next/_config.yml`进行[NexT主题设置](http://theme-next.iissnan.com/getting-started.html)。
   
   ```bash
   git clone https://github.com/theme-next/hexo-theme-next themes/next
   ```

<div id="hexo-debug"></div>

## 博客调试

支持本地预览调试。输入以下命令，然后打开浏览器，进入 `http://localhost:4000/` 即可进行博客预览。

```bash
$ hexo clean // 每次调试时建议使用
$ hexo g # 或者hexo generate
$ hexo s # 或者hexo server
```

推荐使用F12，改到自己想要的样式，然后 Copy 到`custom.styl`文件即可。使用方法可以参考[操作流程图](http://yangbingdong.com/2017/build-blog-hexo-advanced/#%E5%AE%9A%E4%BD%8D%E5%85%83%E7%B4%A0)和[自定义页面样式](http://www.cduyzh.com/hexo-settings-3/)

<div id="hexo-next-update"></div>

## HEXO升级

更新升级可以享受很多新功能，不用自己去修改文件了。

1. 升级`Node.js`： `npm install n -g`+`n latest`

2. 升级`hexo`: `npm update -g hexo`或者安装指定版本`npm install hexo@3.7.0`

3. 升级`插件`: `npm update`

## NEXT升级

目前升级 NexT 主题的时候并不是非常的流畅。目前 NexT 将会使用 Hexo 的 [Data Files](https://hexo.io/docs/data-files.html) ，将所有的主题配置放置在站点的 `source/_data/next.yml` 文件中。原先放置在 站点配置文件`~/blog/_config.yml`中的选项可以迁移到新的位置，同时，主题配置文件`~/blog/themes/next/_config.yml`可以不用做任何修改。若后续版本有配置相关的改动时，你仅需在 `next.yml` 中做相应调整即可。

```bash
rm -r themes/next
git clone https://github.com/theme-next/hexo-theme-next themes/next
rm -fr ./themes/next/.git/
```

备份恢复个性化设置：

- 手动备份修改的主题文件；
- 利用[SED命令](https://github.com/sli1989/HEXO-NEXT-CUSTOM/blob/master/FixNext/fixNext.sh)自动修改新主题文件；
- 使用子模块更新方法：源码仓库中可以看到`themes/next`目录后有个`@xxxxxx`，指向子模块的一个提交，点击可以跳转到`sli1989/hexo-theme-next`仓库。

### 子模块更新

1. 进入NexT项目源码页面，点击`fork`，这样就将最新的主题源码fork成为自己的项目。
   
   ```bash
   $ cd hexo_blog
   $ git rm -r --cached themes/next/
   $ git submodule add git@github.com:sli1989/hexo-theme-next.git themes/next/
   # $ git add .
   # $ git commit -m 'add theme next as a submodule'
   # $ git push -u origin master
   ```

2. 导入子项目后，站点根目录会多出`.gitmodules`文件，其内容如下：
   
   ```~/hexo/.gitmodules
   [submodule "themes/next"]
       path = themes/next
       url = https://github.com/sli1989/hexo-theme-next.git
   ```

3. 本地部署。
    a. 为了方便与源项目代码进行同步，设置远程仓库。
   
   ```bash
   $ cd themes/next
   $ git remote add upsteam https://github.com/theme-next/hexo-theme-next
   
   # 查看当前的远程仓库
   $ git remote -v
   ```
   
    a. 如果发现远程仓库有更新，进行拉取与合并，以及[合并冲突处理](#git-merge)。建议使用rebase命令更新`sli1989/hexo-theme-next.git`。
   
   ```bash
   $ git fetch upstream
   $ git merge upstream/master
   # 等价于 $ git pull
   
   # 手动解决合并冲突
   $ vim conflict_files
   
   # $ git submodule update
   
   # 解决冲突完毕    
   # 建议使用rebase命令    
   $ git add .                            
   $ git commit 'merge upstream updates'
   $ git push -u origin master
   ```

4. CI部署。yml的子模块自动更新script未测试通过（[Using Git submodules with GitLab CI](https://docs.gitlab.com/ce/ci/git_submodules.html)），目前通过本地更新子模块长传Gitlab进行部署。

    ```bash
    # git submodule update --remote --recursive
    cd themes/next
    git checkout master
    git fetch --all
    git reset --hard origin/master
    git pull
    cd ../../
    # gitlab推送
    git add .
    git commit -m "update next"
    git push -u origin master
    ```
    
    ```diff ~/hexo/.gitlab-ci.yml
    + variables:
    +   GIT_SUBMODULE_STRATEGY: recursive
    
    pages:
      script:
    +   - git submodule init
    +   - git submodule update
    +   # - git submodule update --init
    ```

## NEXT个性化

> 感谢以下博文：
> 
> - [打造个性超赞博客Hexo+NexT+GithubPages的超深度优化](https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#%E6%9B%B4%E6%96%B0%E6%8F%90%E7%A4%BA%EF%BC%88%E5%8F%AF%E4%BB%A5%E6%9C%80%E5%90%8E%E7%9C%8B%EF%BC%89)
> - [Hexo Configuration](http://www.jiaxm.me/2017-07-day/Hexo/#%E8%B0%83%E6%95%B4b2t%E6%A0%B7%E5%BC%8F)
> - [hexo的next主题个性化配置教程](https://segmentfault.com/a/1190000009544924)
> - [hexo高阶教程：next主题优化之加入网易云音乐、网易云跟帖、炫酷动态背景、自定义样式，打造属于你自己的定制化博客](https://segmentfault.com/a/1190000009009697#articleHeader21)
> - [为Hexo Next主题添加哈林摇特效（五）](http://www.iamlj.com/2016/08/add-special-effect-harlem-shake-for-hexo/)  
> - [Hexo+Next主题优化](http://www.dragonstyle.win/2017/11/07/Hexo-Next%E4%B8%BB%E9%A2%98%E4%BC%98%E5%8C%96/)

Hexo 安装主题的方式非常简单，只需要将主题文件拷贝至站点目录的 themes 目录下， 然后修改下配置文件即可。在 `_config.yml` 中可以修改大部份的[配置](https://hexo.io/zh-cn/docs/configuration.html)。

- encrypt the content of a post：[hexo-encrypt](https://github.com/edolphin-ydf/hexo-encrypt)
- Enhanced code highlighting using highlight.js for Hexo ： [hexo-filter-highlight](https://github.com/Jamling/hexo-filter-highlight)
- ~~[hexo-renderer-marked](https://github.com/hexojs/hexo-renderer-marked)： Hexo的文章内容默认是不支持emoji表情的。Add support for [Markdown](http://daringfireball.net/projects/markdown/). This plugin uses [marked](https://github.com/chjj/marked) as render engine. [配置方法](http://yangfch3.com/2016/05/08/hexo-experiences/hexo-renderer-marked-it.txt)。~~
- Embed aplayer in Hexo posts/pages：[hexo-tag-aplayer](https://github.com/grzhan/hexo-tag-aplayer)
- ~~一个为Hexo编写的网易云音乐标签插件：[hexo-tag-cloudmusic](https://github.com/qinyuanpei/hexo-tag-cloudmusic)~~
- ~~A Flask Music Project：[163music-APlayer-you-get-docker](https://github.com/YUX-IO/163music-APlayer-you-get-docker)~~

<div id="hexo-avatar"></div>

### 点击侧栏头像回到首页

1. 设置`~/hexo/themes/next/_config.yml`中的头像`avatar: /uploads/avatar.gif`

2. 修改如下代码：
   
   ```diff
   +        <a href="/" class="site-author-image" rel="start" style="border:none">
             <img class="site-author-image" itemprop="image"
                  src="{{ url_for( theme.avatar | default(theme.images + '/avatar.gif') ) }}"
                  alt="{{ theme.author }}" />
   +        </a>
   ```

<div id="hexo-custom"></div>

### 自定义样式

[NexT v6.0.2](https://github.com/theme-next/hexo-theme-next/releases/tag/v6.0.2) 引入了[个性化文件设置](https://github.com/theme-next/hexo-theme-next/blob/master/_config.yml#L24)，所有个性化变量、样式等都可以通过`styles: source/_data/styles.styl`进行添加，使用的时候，只需要添加`~/hexo/source/_data`里面的文件即可。

`~/hexo/source/_data/styles.styl`或 `~/hexo/themes/next/source/css/_custom/custom.styl`涉及的个性化内容：

- 修改正文顶部与标题行间距，添加如下：
  
  ```styl
  .posts-expand .post-meta {
      margin: 10px 0 10px 0;
  }
  ```

- 调整一级标题和正文的间距，添加
  
  ```styl
  .post-body h1 {
    margin: 0 0 15px 0;
  }
  ```

- 调整段落下部间距，添加：
  
  ```styl
  .post-body p {
    margin-bottom: 0.8em;
  }
  ```

- 修改块引用样式。参考[CSS-blockquote引用样式](http://gohom.win/2015/11/10/css-blockquote/)，添加：
  
  ```styl
  // 块引用 样式； 首行不缩进
  blockquote {
    margin-bottom: 0.8em;
    line-height: $line-height-code-block;
    font-size: 14px;
    font-family: "Microsoft YaHei", Menlo, "PingFang SC", monospace;
    border-left: 4px solid #42B983;
   p {
  //  text-indent: -2em;
    display: inline;
   }}
  ```

- 修改行内代码颜色，添加：
  
  ```styl
  code { color: #ec7f00; }
  ```

- 将文章内链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。部分链接会出现bug，原因不明。添加：
  
  ```styl
  .post-body p a {
    color: #0593d3;
    border-bottom: none;
    &:hover {
      //color: #0477ab;
      text-decoration: underline;
    }
  }
  ```
  
  ```styl
  // 文章超链接样式
  .post-body a {
      color: rgb(80, 115, 184);
      border-bottom: none;
      text-decoration: underline;
  }
  // 菜单超链接字体大小
  .menu .menu-item a {
      font-size: 15px;
  }
  // 菜单超链接样式
  .menu .menu-item a:hover {
      border-bottom-color: rgba(161, 102, 171, 0);
  }
  // 超链接样式
  a {
      color: rgb(80, 115, 184);
      border-bottom-color: rgb(80, 115, 184);
  }
  a:hover {
      color: rgb(161, 102, 171);
      border-bottom-color: rgb(161, 102, 171);
  }
  // 侧栏超链接样式（友链的样式）
  .sidebar a {
      color: #ccc;
      border-bottom: none;
  }
  ```

- 段落缩进。**不建议使用缩进，有序列表格式乱套**，添加：
  
  ```styl
  // 设置段落首行缩进，调整段落下部间距
  .post-body p {
    text-indent: 2em;
    margin-bottom: 0.8em;
  }
  ```
  
    对于不需要缩进的段落，采用特定标志 `ooNoIndent00` 添加在段落的最前面，js 预处理去掉该标志，并设置不缩进。在`~/hexo/themes/next/source/js`中添加文件`custom.js`并添加：
  
  ```~/hexo/themes/next/source/js/custom.js
  // 特定段落(标志 ooNoIndent00)不缩进
  $('p:contains("ooNoIndent00")').each(function() {
      var str = $(this).text();
      if (str.match("^ooNoIndent00")) {
          var text = $(this).html();
          $(this).css('text-indent', '0em');
          $(this).html(text.replace('ooNoIndent00', ''));
      }
  });
  ```

`~/hexo/source/_data/styles.styl`或 `~/hexo/themes/next/source/css/_variables/custom.styl` 涉及的个性化内容：

- 修改全局字体大小，添加：
  
  ```styl
  $font-size-base = 16px; // 默认是 16px 大小
  $font-family-headings = Georgia, sans // 标题，修改成你期望的字体族
  $font-family-base = "Microsoft YaHei", Verdana, sans-serif // 修改成你期望的字体族
  ```

- 更改全站外链颜色，添加：
  
  ```styl
  // Global link color.
  $link-color = #4078c0
  ```

- 使图片默认居中：
  
  ```styl
  - .post-body img {margin: 0; }
  + .post-body img {margin: 0 auto;}
  ```

### 设置静态背景图像

设置背景图片，且不随页面滚动。

1. 将背景图文件`background.jpg`置于`/themes/next/source/images/`文件夹内。或者使用自动更新背景图片：`https://source.unsplash.com/random/1600x900`

2. 修改如下代码：
   
   ```styl
   // Custom styles.
   body {
     background: url(/images/background.jpg);
     // background: url(https://source.unsplash.com/random/1600x900);
     background-attachment: fixed;
     background-repeat: no-repeat;
     background-position:50% 50%;
   }
   ```

3. 修改不透明度。
   
   ```styl
   .main-inner {
       margin-top: 60px;
       padding: 60px 60px 60px 60px;
       background: #fff;
       opacity: 0.8;
       min-height: 500px;
   }
   ```

<div id="hexo-topindex"></div>

### 博文置顶

1. 环境配置：
   
   - 如果安装[hexo-generator-topindex](https://www.npmjs.com/package/hexo-generator-topindex)插件，可跳过修改`hero-generator-index` 插件的js代码。
     
     ```bash
     $ npm install hexo-generator-topindex --save
     ```
   
   - 手动修改 `hero-generator-index` 插件，修改如下代码：
     
     ```diff
     'use strict';
     var pagination = require('hexo-pagination');
     module.exports = function(locals){
       var config = this.config;
       var posts = locals.posts;
         posts.data = posts.data.sort(function(a, b) {
             if(a.top && b.top) { // 两篇文章top都有定义
                 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排
                 else return b.top - a.top; // 否则按照top值降序排
             }
             else if(a.top && !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233）
                 return -1;
             }
             else if(!a.top && b.top) {
                 return 1;
             }
             else return b.date - a.date; // 都没定义按照文章日期降序排
         });
       var paginationDir = config.pagination_dir || 'page';
       return pagination('', posts, {
         perPage: config.index_generator.per_page,
         layout: ['index', 'archive'],
         format: paginationDir + '/%d/',
         data: {
           __index: true
         }
       });
     };
     ```

2. 然后[博客文件头](#hexo-file-header)中添加 top 值，数值越大文章越靠前，如
   
   ```diff
   title: 解决Charles乱码问题
   date: 2017-05-22 22:45:48
   tags: 技巧
   categories: 技巧
   copyright: true
   + top: 100
   ```

3. 为了方便记忆top数，修改置顶规则。使得top数值越小，文章越靠前。
   
   - 本地修改：将`~/hexo/node_modules/hexo-generator-index/lib/generator.js`代码中`return b.top - a.top;` 替换成 `return a.top - b.top;`即可。
   
   - 在线CI部署：
     
     ```yml
     pages:
       cache:
         paths:
         - node_modules/
       script:
       - npm install -g hexo-cli
       - npm install
       - npm install hexo-generator-topindex --save
       - sed 's/b.top - a.top/a.top - b.top/' -i node_modules/hexo-generator-topindex/lib/generator.js
     ```

<div id="hexo-order"></div>

### 博文排序

目前文章按创建日期（即 `Front-matter` 中的 `date`）排序。

- 基于插件`hexo-generator-index`，
  
  1. 修改如下代码：
     
     ```diff
     - order_by: '-date'
     + order_by: '-updated'
     ```
  
  2. 这样的话就只按`updated`排序了，因此所有文章的 `Front-matter` 中都必须要有`updated`，已发布的文章可以手动修改或者找方法批量将 `data`换成`updated`，对于将来的文章，将`~/hexo/scaffolds/post.md` 在date后加入一行
     `updated: {{ date }}`。

- 在插件[hexo-generator-topindex](https://github.com/amlove2/hexo-generator-topindex)或者[hexo-generator-index-pin-top](https://github.com/netcan/hexo-generator-index-pin-top)[^netcan666]的基础上，将`~/hexo/node_modules/hexo-generator-index/lib/generator.js`代码中 `a.date`, `b.date` 分别改为 `a.updated`, `b.updated`即可。
  
  ```yml
  pages:
    cache:
      paths:
      - node_modules/
    script:
    - npm install -g hexo-cli
    - npm install
    - npm install hexo-generator-topindex --save
    - sed 's/a.date/a.updated/' -i node_modules/hexo-generator-topindex/lib/generator.js
    - sed 's/b.date/b.updated/' -i node_modules/hexo-generator-topindex/lib/generator.js
  ```

[^netcan666]: [解决Hexo置顶问题](http://www.netcan666.com/2015/11/22/%E8%A7%A3%E5%86%B3Hexo%E7%BD%AE%E9%A1%B6%E9%97%AE%E9%A2%98/)

<div id="hexo-heading"></div>

### 博文标题序号

虽然`toc.number`提供了目录的标题序号，但文章内部的标题却没有添加。使用[hexo-heading-index](https://github.com/r12f/hexo-heading-index)可以解决这个问题。

```bash
$ npm install hexo-heading-index@latest --save
```

站点配置文件中添加如下代码，同时关闭主题配置文件`toc.number`：

```yml
heading_index:
  enable: true
  index_styles: "{1} {1} {1} {1} {1} {1}"
  connector: "."
  global_prefix: ""
  global_suffix: ". "
```

```yml
toc:
  number: false
```

其中对于每一个序号的样式定义，我们放在了index_styles中，它由1-6个序号样式用空格连接组成，每个样式如下：

```
<前缀>{序号类型[:样式:序号宽度]}<后缀>

<全局前缀 (global_prefix)><h1序号>[<连接符 (connector)><h2序号><连接符 (connector)>...<h6序号>]<全局后缀 (global_suffix)>
```

对于默认设置有如下解释：在指定全局前缀为空，全局后缀为`.`，连接符为`.`，每一级的标题序号都使用同样的序号类型：`1`，没有前缀和后缀，默认样式和序号宽度。生成序号`1.2.3.4.`。

比如生成序列号`0x00 0x01:`：

```
heading_index:
  enable: true
  index_styles: "0x{0:X:2} 0x{0:X:2} 0x{0:X:2} 0x{0:X:2} 0x{0:X:2} 0x{0:X:2}"
  connector: " "
  global_prefix: ""
  global_suffix: ": "
```

<div id="hexo-emoji"></div>

### 配置emoji表情

<div class="note warning"><p>未测试</p></div>

- 使用CI自动配置博客，参考[让 Hexo NexT 支持 emoji 表情](https://novnan.github.io/Hexo/emojis-for-hexo-next/)。
  
  1. `$ npm install hexo-filter-github-emojis --save`
  
  2. 站点配置文件中添加如下代码：默认配置下是使用图片表情，如果需要使用 Unicode 表情，可以将上面配置中的` unicode` 设置为 `true`。
     
     ```yml
     githubEmojis:
       enable: true
       className: github-emoji
       unicode: false
       styles:
       localEmojis:
     ```
  
  3. hexo NexT 使用 `FancyBox` 这个图片插件导致渲染错误。修改如下代码：
     
     ```diff
           algolia: {
           applicationID: '{{ theme.algolia.applicationID }}',
           apiKey: '{{ theme.algolia.apiKey }}',
           indexName: '{{ theme.algolia.indexName }}',
           hits: {{ theme.algolia_search.hits | json_encode }},
           labels: {{ theme.algolia_search.labels | json_encode }}
     -    }
     +    },
     +    emojis: {
     +      className: '{{ config.githubEmojis.className | default('github-emoji') }}'
         }
       };
     </script>
     ```
  
  4. 修改如下代码：
     
     ```diff
     $('.content img')
       .not('[hidden]')
     -  .not('.group-picture img, .post-gallery img')
     +  .not('.group-picture img, .post-gallery img, img.' + CONFIG.emojis.className)
       .each(function () {
         var $image = $(this);
         var imageTitle = $image.attr('title');
         var $imageWrapLink = $image.parent('a');
     
         if ($imageWrapLink.size() < 1) {
             var imageLink = ($image.attr('data-original')) ? this.getAttribute('data-original') : this.getAttribute('src');
           $imageWrapLink = $image.wrap('<a href="' + imageLink + '"></a>').parent('a');
         }
     
         $imageWrapLink.addClass('fancybox fancybox.image');
         $imageWrapLink.attr('rel', 'group');
     
         if (imageTitle) {
           $imageWrapLink.append('<p class="image-caption">' + imageTitle + '</p>');
     
           //make sure img title tag will show correctly in fancybox
           $imageWrapLink.attr('title', imageTitle);
         }
       });
     
     $('.fancybox').fancybox({
       helpers: {
         overlay: {
           locked: false
         }
       }
     });
     ```
  
  5. 替换 `hexo-renderer-stylus` 插件，
     
     ```bash
     $ npm un hexo-renderer-stylus --save
     $ npm install hexo-renderer-stylus-plus --save
     ```
  
  6. 添加如下代码：
     
     ```styl
     // Github emojis class name
     // --------------------------------------------------
     
     get_emoji_class() {
       emoji_class = hexo-site-config('githubEmojis.className')
       return emoji_class ? emoji_class : 'github-emoji'
     }
     
     $github-emojis-class-name   = get_emoji_class()
     ```
  
  7. 最后在自定义样式文件中添加：
     
     ```styl
     img.{$github-emojis-class-name} {
       display: inline;
       height: 1.7em;
       width: 1.7em;
       vertical-align: -0.4em;
       border: none !important;
     }
     ```

- 使用本地配置博客，参考[如何使用 emoji](https://reuixiy.github.io/technology/computer/computer-aided-art/2017/06/09/hexo-next-optimization.html#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-emoji)。

### 配置Sitemap

Sitemap 的提交主要的目的，是要避免搜索引擎的爬虫没有完整的收录整个网页的内容，所以提交 Sitemap 是能够补足搜索引擎的不足，进而加速网页的收录速度，达到搜寻引擎友好的目的。**注意path前面是二个空格缩进**。

```bash
$ npm install hexo-generator-sitemap --save
```

将其配置到站点配置文件中。

```yml
sitemap:
  path: sitemap.xml
  #path 表示 Sitemap 的路径. 默认为 sitemap.xml.
```

对于国内用户还需要安装插件 `hexo-generator-baidu-sitemap`。

```bash
$ npm install hexo-generator-baidu-sitemap --save
```

将其配置到站点配置文件中。

```yml
baidusitemap:
  path: baidusitemap.xml
```

<div id="hexo-addmenu"></div>

### 添加菜单页

1. 在主题配置的`_config`文件下找到`menu`，添加`menu`的内容。然后在主题的配置文件添加`menu_icon`字段设置对应的icon。
2. 在`Hexo/source`文件夹下面新建名字为`photo` 的文件夹，里面添加一个`index.md`文件（命令行：`hexo new page "photo"`）。
3. 自己到[FontAwsome官网](http://fontawesome.io/icons/)图标集中选择自己喜欢的icon，然后记住名字，保存在主题配置文件`~/blog/themes/next/_config.yml`中的`menu_icon`字段中就可以啦，不需要加上前面的"icon-"。
4. 如果想要中文的名字，并且想要个性化定制我们的页面，可以在主题的`/themes/next/languages/zh-CN`文件下的`zh-CN`（中文）语言包下增加相应的`menu`字段。注意冒号后面留空。
5. 在写文章的时候，在头部信息添加相应的字段，就在tags页面和categories中显示相应的分类。

<div id="hexo-hit"></div>

### 添加阅读榜

> [基于Firestore的文章阅读排行（热榜）功能](https://www.liaofuzhan.com/posts/781439527.html)

参考[博客](http://thief.one/2017/03/03/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E6%95%99%E7%A8%8B/)，首先我们可以使用leancloud来统计页面阅读数量，以及储存这些信息，然后通过leancloud提供的api编写js脚本来获取阅读数量信息，并展示在页面上。

<div class="note warning"><p>[Valine评论与自定义页面API访问冲突](https://github.com/xCss/Valine/issues/50)，需要强制刷新加载。为了实现阅读量的展示，目前（2019年5月6日）的解决方案只有利用[最新的Valine评论](https://github.com/theme-next/hexo-theme-next/pull/345)开启浏览量设置`visitor: true`并关闭`leancloud_visitors`。</p></div>

1. 添加[menu菜单](#hexo-addmenu)，并设置中英文和图标。

2. 添加如下代码：
   
   ```diff
   ---
   comments: false
   ---
   
   {% centerquote %}阅读榜Top 30{% endcenterquote %}
   
   <p align="justfly" id="hits"><br></font></p>
   
   <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
   
   <script>AV.initialize("leancloud_visitors_id", "leancloud_visitors_key");</script>
   
   <script type="text/javascript">
     var num=30
     var time=0
     var title=""
     var url=""
     var query = new AV.Query('Counter');
     query.notEqualTo('id',0);
     query.descending('time');
     query.limit(num);
     query.find().then(function (todo) {
       for (var i=0;i<num;i++){
         var result=todo[i].attributes;
         time=result.time;
         title=result.title;
         url=result.url;  
         var content="<p>"+"<font color='#e20404'>"+"热度"+time+"℃"+"："+"<a href='"+"https://sli1989.github.io"+url+"'>"+title+"</font>"+"</a>"+"</p>";
         //document.write("<a href='"+"https://sli1989.github.io"+url+"'>"+title+"</a>"+"    Readtimes:"+time+"<br>");
         document.getElementById("hits").innerHTML+=content
       }
     }, function (error) {
       console.log("error");
     });
   </script>
   ```

<div class="note info"><p>[阅读量 api.leancloud.cn 解析失败](https://blog.csdn.net/XcantloadX/article/details/78301853)的解决方法</p></div>

### 配置评论系统

<div id="valine"></div>

[Valine评论系统](https://valine.js.org)：基于LeanCloud的极简的评论系统，[快速开始](https://valine.js.org/#/quickstart)，[评论系统从Disqus迁移到Valine](https://jayshao.com/disqus-to-valine/#5a4446d58d6d810062ca9482)。（[LeanCloud切换国际版](https://www.liaofuzhan.com/posts/554801533.html)）

- Valine-Admin 添加了[后台管理功能](https://github.com/zhaojun1998/Valine-Admin)。如有需要，可以使用 Github Action 来实现应用实例的定时自动部署及唤醒：[优雅解决LeanCloud流控问题](https://cloud.tencent.com/developer/article/1628950)，[leancloud-auto-deploy](https://github.com/lmm214/leancloud-auto-deploy/blob/master/.github/workflows/auto-deploy.yml)。

- 我们可以和[添加阅读榜](#hexo-hit)一样，添加评论区进行查看。因为不同 leancloud 版本库造成初始化失效问题。[Valine评论与自定义页面API访问冲突](https://github.com/xCss/Valine/issues/50)，请设置所有源设置为`<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>`。但是文章基于LeanCloud的阅读量失效，需要等待仓库更新。
  
  ```diff
  ---
  title: Comments
  comments: false
  ---
  
  {% centerquote %}留言板{% endcenterquote %}
  
  <p align="justfly" id="heheda"><br></font></p>
  
  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script>AV.initialize("leancloud_visitors_id", "leancloud_visitors_key");</script>
  
  <script type="text/javascript">
    var num=50
    var query = new AV.Query('Comment');
    query.notEqualTo('id',0);
    query.descending('createdAt')
    query.limit(num);
    query.find().then(function (todo) {
      for (var i=0;i<num;i++){
        var result=todo[i].attributes;
        title=result.comment;
        url=result.url;  
          nick=result.nick;  
        var updatedAt = todo[i].updatedAt;
        var content="<blockquote>"+"<font size=2>"+"<a href='"+"https://sli1989.github.io"+url+"#comments"+"'>"+"<font color='#9932CC'>"+nick+"</font>"+"</a>"+" commented on "+updatedAt+"："+"<br>"+title+"</font>"+"<blockquote>";
        document.getElementById("heheda").innerHTML+=content
      }
    }, function (error) {
      console.log("error");
    });
  </script>
  ```

- 最后在主题配置文件中开启即可：
  
  ```yml
  # Valine.
  # You can get your appid and appkey from https://leancloud.cn
  # more info please open https://github.com/xCss/Valine
  valine:
    enable: true
    appid:  # your leancloud application appid
    appkey:  # your leancloud application appkey
    notify: false # mail notifier , https://github.com/xCss/Valine/wiki
    verify: false # Verification code
    placeholder: Comment input placeholder
  ```

### 配置音视频播放器

详细音视频插入方式，点击查看[音乐外链播放器](https://sli1989.github.io/music/#musicplayer)和[视频播放器](https://sli1989.github.io/music/#videoplayer)配置。

#### 侧边栏音乐播放器

由于Next.Pisces主题无法调整侧边栏大小，网易云播放器外观受限，使用网易云播放器需要使用Next.Mist主题。网易云播放器为`iframe`结构，还是偶尔会提示“资源未加载”问题。

虾米播放器为`embed`结构（flash player），暂时没有出现“资源未加载”问题。也可以根据博客主题实现外观调整。暂时推荐使用[虾米外链播放器](https://sli1989.github.io/music/#xiamiplayer)。

> **说明**：Chrome浏览器中，需要手动点击才能查看flash控件。在Chrome高版本中，plugins 页面被移除后，可以访问: `chrome://settings/content` 调整 Flash、PDF 的设置。如果你想让所有网站都默认启用 flash 不用一个个的添加,可以访问：`chrome://flags/#run-all-flash-in-allow-mode` 选择允许。

添加如下代码：

> 注意添加位置，在`theme.sidebar.b2t`按钮前面添加，全站网页均可见：在`set cc`前面添加，只有主页可见播放器

```diff ~/hexo/themes/next/layout/_macro/sidebar.swig`
...

%　网易云播放器

<br />
<div id="music163player">
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="280" height="260" src="//music.163.com/outchain/player?type=2&id=38358214&auto=0&height=66">
    </iframe>
</div>

%　虾米播放器 Pisces主题设置 200*240 Mist主题设置 270*240

<br />
    <div id="xiamiplayer">
    <embed src="http://www.xiami.com/widget/9731524_277625635_300_260_d90000_333333_0/collectPlayer.swf" type="application/x-shockwave-flash" width="300" height="260" wmode="opaque"></embed>
    </div>
```

<div id="h5player"></div>

#### HTML5音乐播放器

HTML5音乐播放器jQuery插件参考[一款简洁小巧的HTML5底部悬浮音乐播放器](http://www.jq22.com/jquery-info11923)和[为你的博客添加h5的audio播放器](https://ergou.scuxl.cn/2017/05/23/为你的博客添加音乐播放器)。

1. 下载[播放器](http://pan.baidu.com/s/1slyR4yp) （密码：oznd）（[Github源](https://github.com/sli1989/HEXO-NEXT-CUSTOM/tree/master/source/static)），解压后丢到站点根目录，也就是`source-static`目录下面。在站点`_config.yml`中，设置`skip_render: static/**`（<font color=red>两个星号</font>）。以上文件已经包括了如下设置，使用`localstorage`存储音乐的播放状态：
   
   - 在`~/hexo/source/static/js/player.js`的`setProgress`函数中加入
     
     ```diff
     var setProgress = function (value) {
         var currentSec = parseInt(value % 60) < 10 ? '0' + parseInt(value % 60) : parseInt(value % 60),
             ratio = value / audio.duration * 100;
     
         $('.timer').html(parseInt(value / 60) + ':' + currentSec);
     +   localStorage.time = value
     +   localStorage.song = currentTrack
     }
     ```
   
   - `loadMusic`函数后面，新定义一个函数。`sessionStorage.autoPlay = "true"`控制自动播放。
     
     ```diff
     var FirstLoad = function (i, time) {
         if (i == undefined) {
             i = 0
             currentTrack = 0
             shuffleIndex = 0
         }
         loadMusic(i)
         if (time) {
             audio.currentTime = time
         }
         if (localStorage.volume) {
             audio.volume = localStorage.volume
         }
         if (sessionStorage.autoPlay == undefined) {
             sessionStorage.autoPlay = "true"
         }
     
     }
     ```
   
   - 修改`currentTrack`的赋值部分。
     
     ```diff
     var currentTrack = localStorage.song, audio, timeout;
     var shuffle_array = localStorage.qplayer_shuffle_array;
     
     if (isShuffle && shuffle_array != undefined && playlist.length === (shuffleArray = JSON.parse(shuffle_array)).length) {
         shuffleIndex = 0;
         if (currentTrack == undefined) {
             currentTrack = shuffleArray[0];
             $('#QPlayer .cover').attr('title', '点击关闭随机播放');
         }
     } else {
         isShuffle = false;
         $('#QPlayer .cover').attr('title', '点击开启随机播放');
     }
     ```
   
   - 然后，将最开始调用的`loadMusic`替换为`FirstLoad`函数，这样就可以在打开/刷新页面时将播放上次的音乐和上次的时间。
     
     ```diff
     - loadMusic(currentTrack);
     + FirstLoad(currentTrack, localStorage.time);
     if (sessionStorage.autoPlay == "true") {
         play()
     }
     if (localStorage.volume == undefined) {
         localStorage.volume = 0.2
     }
     ```
   
   - `~/hexo/source/static/js/player.js`的`$("div.ssBtn").click()`控制播放器是否一直弹出，注释掉即可。

2. 如果你想整个博客都能够播放音乐，在 `~/hexo/themes/next/layout` 中新建`_my`目录 和`audio.swig` 文件，并添加如下代码：（谨慎利用 [Inject](https://theme-next.org/docs/advanced-settings.html#Injects) 功能，可能会出现`DOMException: The play() request was interrupted`的情况而无法播放）
   
   ```swig
   {% if theme.audio.enable %}
   <head>
     <meta charset="utf-8">
     <meta name="viewport" content="width=device-width, initial-scale=1" />
       <title></title>
       <link rel="stylesheet" href="/static/css/player.css">
   </head>
   
   <div id="QPlayer">
       <div id="pContent">
           <div id="player">
               <span class="cover"></span>
               <div class="ctrl">
                   <div class="musicTag marquee">
                       <strong>Title</strong>
                        <span> - </span>
                       <span class="artist">Artist</span>
                   </div>
                   <div class="progress">
                       <div class="timer left">0:00</div>
                       <div class="contr">
                           <div class="rewind icon"></div>
                           <div class="playback icon"></div>
                           <div class="fastforward icon"></div>
                       </div>
                       <div class="right">
                           <div class="liebiao icon"></div>
                       </div>
                   </div>
               </div>
           </div>
           <div class="ssBtn">
                   <div class="adf"></div>
           </div>
       </div>
       <ol id="playlist"></ol>
   </div>
   <script src="//cdn.bootcss.com/jQuery.Marquee/1.3.94/jquery.marquee.min.js"></script>
   <script>
     var playlist = [];
     {% for src in theme.audio.sources %}
     playlist.push({title:'{{src.title}}',artist:'{{src.artist}}',mp3:'{{ src.mp3 }}',cover:'{{src.cover}}'})
     {% endfor %}
     var isRotate = true;
     var autoplay = false;
   </script>
   <script src="/static/js/player.js"></script>
   <script>
     function bgChange(){
       var lis= $('.lib');
       for(var i=0; i<lis.length; i+=2)
       lis[i].style.background = 'rgba(246, 246, 246, 0.5)';
     }
     window.onload = bgChange;
   </script>
   {% endif %}
   ```
   
   ```diff
   {% include '_third-party/exturl.swig' %}
   
   + {% include '_my/audio.swig' %}
   
   </body>
   </html>
   ```

3. 在主题配置文件中添加如下项：其中`enable`控制是否加载播放器，`sources`代表音乐的配置项。获取[音乐外链](https://sli1989.github.io/music/#music-download)**前试听**。如果有多个音乐的话，每个音乐之间用`,`隔开。
   
   ```yml
   audio:
     enable: true
     sources: [
           {title: '午后庭院',
           artist: '夏天播放',
           mp3: 'https://music.163.com/song/media/outer/url?id=29095562.mp3',
           cover: 'https://p1.music.126.net/5uQHiJSmUMo74VAR4KJCTA==/6670737045946097.jpg' },
           {title: '远走高飞',
           artist: '金志文',
           mp3: 'https://music.163.com/song/media/outer/url?id=1297742772.mp3',
           cover: 'https://p1.music.126.net/elfqBKIdad0KYCCeKQpDSA==/18700493767108166.jpg' }
           ]
   ```

4. 自此，整个H5播放器的基本设置就完成了。另外，可以自定义HTML5音乐播放器颜色：
   
   ```diff
   #pContent .ssBtn {
       width:20px;
       height:60px;
   +    background:#1abc9c none repeat scroll 0% 0%;
       position:relative;
       right:0px;
       bottom:0px;
       box-sizing:border-box;
       border-left:none;
       cursor:pointer;
       display:box-shadow:;
       float:right;
   }
   
   #playlist li:hover {
       color:#716e6e;
       font-weight:bold;
   +    border-left:3px solid #1abc9c;
       padding:3px 15px 3px 11px;
   }
   
   #playlist li.playing {
     color:#716e6e;
       font-weight:bold;
   +    border-left:3px solid #bc1a1a;
       padding:3px 15px 3px 11px;
   }
   ```

另外，你也可以添加音量控制。播放器里是有两个上一首和下一首的按钮的，左键点击他们就会切换歌曲，那么我们让他右键点击降低和升高声音就好啦。

<div class="note info"><p>已知bug：无缓存第一次的声音存在bug，如有缓存时，音量默认为系统音量的0.2倍。</p></div>

```diff
$(document).bind("contextmenu", function () {
    return false;
})
$('.rewind').on('click', function () {
    if (isShuffle) {
        shufflePlay(0);
    } else {
        switchTrack(--currentTrack);
    }
}).mousedown(function (e) {
    if (3 == e.which) {
        if (audio.volume >= 0.05) {
            audio.volume -= 0.05
        } else {
            audio.volume = 0;
        }
        localStorage.volume = audio.volume
    }
});
$('.fastforward').on('click', function () {
    if (isShuffle) {
        shufflePlay(1);
    } else {
        switchTrack(++currentTrack);
    }
}).mousedown(function (e) {
    if (3 == e.which) {
        if (audio.volume <= 0.95) {
            audio.volume += 0.05
        } else {
            audio.volume = 1;
        }
        localStorage.volume = audio.volume
    }
});
```

<div id="hexo-vendor"></div>

### 依赖库 CDN 加速

升级NexT v6后，需要手动安装`Dependencies`。如果出现问题，<font color=red>删除</font>对应文件夹里面的`.git`文件夹。CI部署需要[添加对应的SCRIPT](#gitlab-ci)到`.gitlab-ci.yml`文件。

```bash
$ cd themes/next
$ git clone https://github.com/theme-next/theme-next-pace source/lib/pace
$ git clone https://github.com/theme-next/theme-next-needmoreshare2 source/lib/needsharebutton
$ git clone https://github.com/theme-next/theme-next-reading-progress source/lib/reading_progress
```

The [jsDelivr](https://www.jsdelivr.com/) is a really good CDN. It does not only crawl the js files from npm packages, and it crawls from the GitHub Releases! Therefore, we could use it to deliver some of our third-party plugins. The user doesn't need to manually clone repos, just change the vendors config, and it is done.

1. Go to the third-party plugin repo, publish a Release.
2. use the following link to reference the js files, just as other CDNs. And it could automatically minify the JS and CSS files, even if you don't have the minified version.
   Just use the `filename.min.js` or the `filename.min.css` to replace the file.

```yml
https://cdn.jsdelivr.net/gh/user/repo@version/file

pangu: https://cdn.jsdelivr.net/npm/pangu@3.3.0/dist/browser/pangu.min.js
fontawesome: https://cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css

bookmark: https://cdn.jsdelivr.net/gh/theme-next/theme-next-bookmark@1.0.0/bookmark.min.js
```

## 建立博文

- 新建博文，格式与[博客文件头](#hexo-file-header)`~/hexo//scaffolds/post.md`一致。
  
  ```bash
  $ hexo new post "new blog name"   
  # 新建一个.md文件，并编辑完成自己的博客内容
  ```

- Hexo 另外提供 `draft` 机制[^hexo-draft]，它的原理是新文章将建立在 `source/_drafts` 目录下，因此 `hexo generate` 并不会将其编译到 `public` 目录下，所以 `hexo deploy` 也不会将其部署到 GitHub。
  
  - 本机预览草稿 `$ hexo S --draft`
  - 将草稿发布为正式文章 `$ hexo P <filename>`

[^hexo-draft]: [Hexo 文章保存为草稿](https://novnan.github.io/Hexo/hexo-draft/)

- Markdown编辑器当然推荐Atom，可以直接在实现Atom的Git操作，更多内容点击查看[Atom使用指南](https://sli1989.github.io/markdown-user-guide/#atom)，[Markdown语法](https://sli1989.github.io/markdown-user-guide/#markdowngrammar)。

- 图片大小设置
  
  ```
  {% img [class names] /path/to/image [width] [height] [title text [alt text]] %}
  ```

- 在Hexo主题中，推荐使用Pandoc渲染器结合Mathjax公式，详情点击查看[Hexo中显示公式](https://sli1989.github.io/markdown-user-guide/#hexo-math)配置详情。

- 开启[脚注功能](https://sli1989.github.io/markdown-user-guide#hexo-footnotes)。

- 使用[交叉引用](https://sli1989.github.io/markdown-user-guide#hexo-crossref)功能。

<div id="hexo-tag-plugin"></div>

## 标签插件

「标签」(Tag Plugin) 是 Hexo 提供的一种快速生成特定内容的方式。例如，在标准 Markdown 语法中，我们无法指定图片的大小。这种情景，我们即可使用标签来解决。Hexo 内置来许多标签来帮助写作者可以更快的书写，[完整的标签列表](https://hexo.io/docs/tag-plugins.html) 可以参考 Hexo 官网。另外，Hexo 也开放来接口给主题，使主题有可能提供给写作者更简便的写作方法。以下标签便是 NexT 主题当前提供的标签。详细设置可以参考[内建标签](http://theme-next.iissnan.com/tag-plugins.html)。

但是就我自己的使用感受而言，一方面它的语法规则相对于MarkDown略为冗长和麻烦，另一方面支持这一功能的MarkDown引擎经常会导致各种各样的冲突和解析错误。所以我个人推荐，在写博客文件时，不使用任何Hexo内建的标签插件，而纯粹使用MarkDown原生语法。

### 文本居中引用

此标签将生成一个带上下分割线的引用，同时引用内文本将自动居中。文本居中时，多行文本若长度不等，视觉上会显得不对称，因此建议在引用单行文本的场景下使用。例如作为文章开篇引用 或者 结束语之前的总结引用。

使用方式：

* HTML方式：使用这种方式时，给 `img` 添加属性`class="blockquote-center"` 即可。
* 标签方式：使用 `centerquote` 或者 简写 `cq`。

> 此标签要求 NexT 的版本在 0.4.5 或以上。若你正在使用的版本比较低，可以选择使用 `HTML` 方式。

标签调用方法

```
<!-- HTML方式: 直接在 Markdown 文件中编写 HTML 来调用 -->
<!-- 其中 class="blockquote-center" 是必须的 -->
<blockquote class="blockquote-center">blah blah blah</blockquote>

<!-- 标签 方式，要求版本在0.4.5或以上 -->
{% centerquote %}blah blah blah{% endcenterquote %}

<!-- 标签别名 -->
{% cq %} blah blah blah {% endcq %}
```

效果示例:

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqrb82czcnj30ke0803yr.jpg)

### 代码块

codeblock代码块用法如下：

```
{% codeblock [title] [lang:language] [url] [link text] %}
code snippet
{% endcodeblock %}
```

另一种形式的代码块，不同的是它使用三个反引号来包裹，`[language] [title] [url] [link text]`。推荐使用这种方式，避免了特殊字符的转义高亮。

1. `[language]` 是代码语言的名称，用来设置代码块颜色高亮，非必须；
2. `[title]` 是顶部左边的说明，非必须；
3. `[url]` 是顶部右边的超链接地址，非必须；
4. `[link text]` 如它的字面意思，超链接的名称，非必须。

如果需要对比功能，你只需在 [language] 这写`diff`，然后在相应代码前面加上`-`和`+`就行了。也可以自定义对应的代码颜色，修改如下代码：

```styl
// 文章```代码块diff样式
pre .addition {
    background: #e6ffed;
}
pre .deletion {
    background: #ffeef0;
}
```

### note 标签

1. 在主题配置文件中开启配置：
   
   ```yml
   # Note tag (bs-callout).
   # [class] : default | primary | success | info | warning | danger.
   note:
     # Note tag style values:
     #  - simple    bs-callout old alert style. Default.
     #  - modern    bs-callout new (v2-v3) alert style.
     #  - flat      flat callout style with background, like on Mozilla or StackOverflow.
     #  - disabled  disable all CSS styles import of note tag.
     style: simple
     icons: true
     border_radius: 3
     # Offset lighter of background in % for modern and flat styles (modern: -12 | 12; flat: -18 | 6).
     # Offset also applied to label tag variables. This option can work with disabled note tag.
     light_bg_offset: 0
   ```

2. 在正文`.MD`文件中插入如下代码即可，包括了`success/warning/default/info/danger`：

```
{% note warning %} warning {% endnote %}
<div class="note success"><p>success</p></div>
```

<div class="note success"><p>success</p></div>

### Button 标签

```
Usage: {% button /path/to/url/, text, icon [class], title %}
Alias: {% btn /path/to/url/, text, icon [class], title %}
```

Button with text

```
{% btn #, Text %}{% btn #, Text & Title,, Title %}

{% btn #, Text %}
{% btn #, Text & Title,, Title %}
```

{% btn #, Text %}{% btn #, Text & Title,, Title %}

{% btn #, Text %}
{% btn #, Text & Title,, Title %}

Button with icon

```
<p>{% btn #,, home fa-5x %}
{% btn #,, home fa-4x %}
{% btn #,, home fa-3x %}{% btn #,, home fa-2x %}{% btn #,, home fa-lg %}{% btn #,, home %}</p>

<p>{% btn #, Text & Icon (buggy), home %}
{% btn #, Text & Icon (fixed width), home fa-fw %}</p>

<p>{% btn #, Text & Large Icon, home fa-fw fa-lg %}
{% btn #, Text & Large Icon & Title, home fa-fw fa-lg, Title %}</p>
```

<p>{% btn #,, home fa-5x %}
{% btn #,, home fa-4x %}
{% btn #,, home fa-3x %}{% btn #,, home fa-2x %}{% btn #,, home fa-lg %}{% btn #,, home %}</p>

<p>{% btn #, Text & Icon (buggy), home %}
{% btn #, Text & Icon (fixed width), home fa-fw %}</p>

<p>{% btn #, Text & Large Icon, home fa-fw fa-lg %}
{% btn #, Text & Large Icon & Title, home fa-fw fa-lg, Title %}</p>

Button inside other tag

```
{% note default %}
{% btn #, Text & Icon, home fa-fw %}
{% btn #,, home, Title %}{% btn #, Text %}
{% endnote %}
```

{% note default %}
{% btn #, Text & Icon, home fa-fw %}
{% btn #,, home, Title %}{% btn #, Text %}
{% endnote %}

Button margin

```
<div class="text-center"><span>{% btn #,, header %}{% btn #,, edge %}{% btn #,, times %}{% btn #,, circle-o %}</span>
<span>{% btn #,, italic %}{% btn #,, scribd %}</span>
<span>{% btn #,, google %}{% btn #,, chrome %}{% btn #,, opera %}{% btn #,, diamond fa-rotate-270 %}</span></div>

<div class="text-center">{% btn #, Almost, adn fa-fw fa-lg %} {% btn #, Over, terminal fa-fw fa-lg %}</div>

<div class="text-right">
{% btn #, Test is finished., check fa-fw fa-lg, Button tag test is finished. %}
</div>
```

<div class="text-center"><span>{% btn #,, header %}{% btn #,, edge %}{% btn #,, times %}{% btn #,, circle-o %}</span>
<span>{% btn #,, italic %}{% btn #,, scribd %}</span>
<span>{% btn #,, google %}{% btn #,, chrome %}{% btn #,, opera %}{% btn #,, diamond fa-rotate-270 %}</span></div>

<div class="text-center">{% btn #, Almost, adn fa-fw fa-lg %} {% btn #, Over, terminal fa-fw fa-lg %}</div>

<div class="text-right">
{% btn #, Test is finished., check fa-fw fa-lg, Button tag test is finished. %}
</div>

### Tabs 标签

1. 在主题配置文件中开启配置：
   
   ```yml
   # Tabs tag.
   tabs:
     enable: true
     transition:
       tabs: true
       labels: true
     border_radius: 0
   ```

2. 源码，`, 2`表示一开始在第二个选项卡，非必须，若数值为`-1`则隐藏选项卡内容。更多用法请查看 [这个页面](https://almostover.ru/2016-01/hexo-theme-next-test/#Tab-tag-test) 。

```
{% tabs First unique name %}
<!-- tab -->
**This is Tab 1.**
<!-- endtab -->
<!-- tab -->
**This is Tab 2.**
<!-- endtab -->
<!-- tab -->
**This is Tab 3.**
<!-- endtab -->
{% endtabs %}
```

{% tabs First unique name %}

<!-- tab -->

**This is Tab 1.**

<!-- endtab -->

<!-- tab -->

**This is Tab 2.**

<!-- endtab -->

<!-- tab -->

**This is Tab 3.**

<!-- endtab -->

{% endtabs %}

```
{% tabs Fifth unique name %}
<!-- tab @text-width -->
**This is Tab 1.**
<!-- endtab -->
<!-- tab @amazon -->
**This is Tab 2.**
<!-- endtab -->
<!-- tab @bold -->
**This is Tab 3.**
<!-- endtab -->
{% endtabs %}
```

{% tabs Fifth unique name %}

<!-- tab @text-width -->

**This is Tab 1.**

<!-- endtab -->

<!-- tab @amazon -->

**This is Tab 2.**

<!-- endtab -->

<!-- tab @bold -->

**This is Tab 3.**

<!-- endtab -->

{% endtabs %}

```
{% tabs Sixth unique name %}
<!-- tab Solution 1@text-width -->
**This is Tab 1.**
<!-- endtab -->
<!-- tab Solution 2@amazon -->
**This is Tab 2.**
<!-- endtab -->
<!-- tab Solution 3@bold -->
**This is Tab 3.**
<!-- endtab -->
{% endtabs %}
```

{% tabs Sixth unique name %}

<!-- tab Solution 1@text-width -->

**This is Tab 1.**

<!-- endtab -->

<!-- tab Solution 2@amazon -->

**This is Tab 2.**

<!-- endtab -->

<!-- tab Solution 3@bold -->

**This is Tab 3.**

<!-- endtab -->

{% endtabs %}

Tab tag permalinks：

```
Permalink for > [Tab one](#tab-one).
Permalink for > [Tab one 1](#tab-one-1).
Permalink for > [Tab one 2](#tab-one-2).
Permalink for > [Tab one 3](#tab-one-3).

{% tabs Tab one %}
<!-- tab -->
**This is Tab 1.**
<!-- endtab -->
<!-- tab -->
**This is Tab 2.**
<!-- endtab -->
<!-- tab -->
**This is Tab 3.**
<!-- endtab -->
{% endtabs %}
```

Tab tag with other tags:

```
{% tabs Tags %}
<!-- tab -->
**This is Tab 1.**

1. One
2. Two
3. Three

Tabbed code block:

    nano /etc

{% code %}
code block tag
code block tag
code block tag
{% endcode %}

{% note default %}
Note default tag.
{% endnote %}{% youtube A1Qb4zfurA8 %}
<!-- endtab -->
<!-- tab -->
**This is Tab 2.**

* Five
* Six
* Seven

<!-- endtab -->
<!-- tab -->
**This is Tab 3.**
{% note success %}
Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
{% endnote %}
<!-- endtab -->
{% endtabs %}
```

{% tabs Tags %}

<!-- tab -->

**This is Tab 1.**

1. One
2. Two
3. Three

Tabbed code block:

    nano /etc

{% code %}
code block tag
code block tag
code block tag
{% endcode %}

{% note default %}
Note default tag.
{% endnote %}{% youtube A1Qb4zfurA8 %}

<!-- endtab -->

<!-- tab -->

**This is Tab 2.**

* Five
* Six
* Seven

<!-- endtab -->

<!-- tab -->

**This is Tab 3.**
{% note success %}
Lorem ipsum dolor sit amet, consectetuer adipiscing elit.
{% endnote %}

<!-- endtab -->

{% endtabs %}

# Jekyll BLOG

建立基于Jekyll的个人Github Pages有两条路线：

1. 自己学习Jekyll教程和网页设计，设计绝对自我基因的网页。  
2. Fork（简单来说是把当前仓库复制一份到你的仓库，你可以进行修改，因为你的仓库是原来仓库的新的分支）已有的开源博客仓库，在巨人的肩膀上进行符合自我的创作。建议和我一样的小白们可以从第二条路线学起。[Jekyll项目的wiki页面](https://github.com/jekyll/jekyll/wiki/sites)给出了大量优秀的风格各异的网站，点击右边的source链接，进入到作者的模版仓库，击右上角的`Fork`。然后在你的主页里找到你刚才Fork的分支，点进去。点击`Settings`，将`Repository name`改为 `{你的Github用户名}.github.io`，点击`Rename`。此时你会发现已经可以通过 `http://{你的Github用户名}.github.io` 访问你fork下来的网站啦！

利用git克隆（参考以前内容）后，这时所有远程仓库里的源码都拷贝到 `e:/workspace/{username}.github.io` 这个文件夹里来了。如果clone失败有可能是网络原因，可以过一个时段再试，或者寻找梯子。

打开本地仓库的 `_posts` 文件夹，你的所有博文都将放在这里，写新博文只需要新建一个标准文件名的文件，在文件中编写文章内容。比如我们fork的模版中 `_posts` 文件夹里有一篇 `2016-03-23-hello-world.markdown`，你的文件命名也要严格遵循 `年-月-日-文章标题.文档格式` 这样的格式。（新文档建议使用template文件复制再修改，新建文档自己输入YAML文件头无法正常编译。）

> 参考链接：[使用Github Pages建独立博客](http://beiyuu.com/github-pages)， [Github Pages + Jekyll 独立博客一小时快速搭建&上线指南](http://playingfingers.com/2016/03/26/build-a-blog/)

## 评论功能

> 参考文献
> http://cenalulu.github.io/jekyll/setup-comment-for-your-blog/
> http://pizn.github.io/2011/11/15/use-disqus-for-your-post.html

- 注册一个[Disqus](https://www.disqus.com)帐号。

- 新建实例。注册完毕后登入帐号，点击Admin菜单进入管理页面,选择[Add new site](https://disqus.com/admin/create)来新建一个实例，platform 选择jekyll。然后填入需要的资料。

- 对于 GitHub Page 来说，把这段代码，嵌入到`layout` 里面的 `post.html` 里面，放在最后就好了。
  
  ```
  <div id="disqus_thread"></div>
  <script>
  
  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  /*
  var disqus_config = function () {
  this.page.url = PAGE_URL;  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = PAGE_IDENTIFIER; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };
  */
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://XX(Website Name).disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  ```

- 文章中添加Yaml头文件信息
  
  ```
  layout: default
  comments: true
  # other options
  ```

## 标签功能

> 参考链接
> [为JEKYLL博客添加分类，标签和评论](http://zixiaojindao.github.io/blogging/2012/09/30/jekyll-category-tag-recent-comment/)，[使用Jekyll在Github上搭建个人博客](https://segmentfault.com/a/1190000000406017#articleHeader6)。

## 本地调试

> 参考链接：[Install Jekyll 3 on Windows](http://yizeng.me/2013/05/10/install-jekyll-3-on-windows/)

1. [事先准备](http://jekyllcn.com/docs/installation/#事先准备 "Permalink")。安装 Jekyll 相当简单，但是你得先做好一些准备工作。开始前你需要确保你在系统里已经有如下配置。
   
   * [Ruby](https://rubyinstaller.org/downloads/)，For example, `Ruby 2.3.3-p222 (x64)`
   * [Ruby DevKit](http://rubygems.org/pages/download)，For instance, `DevKit-mingw64-64-4.7.2-20130224-1432-sfx.exe` is for 64-bit Windows with Ruby 2.3.3 x64.
   * [RubyGems](http://rubygems.org/pages/download)
     - Unpack into a directory and `cd` there
     - Install with: `ruby setup.rb` (you may need admin/root privilege)
   * [NodeJS](http://nodejs.org/), 或其他 JavaScript 运行环境（Jekyll 2 或更早版本需要 CoffeeScript 支持）。
   * [Python 2.7](https://www.python.org/downloads/)（Jekyll 2 或更早版本）

2. 用 RubyGems 安装 [Jekyll](http://jekyllcn.com/docs/installation/#用-rubygems-安装-jekyll "Permalink")。安装 Jekyll 的最好方式就是使用[RubyGems](http://rubygems.org/pages/download). 你只需要打开终端输入以下命令就可以安装了。所有的 Jekyll 的 gem 依赖包都会被自动安装，所以你完全不用去担心。如果你在安装中碰到了问题，请查看 [troubleshooting](http://jekyllcn.com/docs/troubleshooting/) 或者
   [report an issue](https://github.com/jekyll/jekyll/issues/new) 那么 Jekyll 社区就会帮助你解决问题了。
   
   ```bash
   $ gem install jekyll
   ```

3. Initialize and create config.yml file. In opened notepad window, if it's not already there, add a new line `- C:/Ruby23` at the end, save and close.
   
   ```bash
   cd C:/RubyDevKit
   ruby dk.rb init
   notepad config.yml
   ruby dk.rb install
   ```

1. Install Jekyll and Bundler.
   
   ```bash
   gem install jekyll bundler
   # Verify that Jekyll gem has been installed properly
   jekyll -v
   bundle -v
   ```

1. Start Jekyll。用浏览器打开`http://127.0.0.1:4000`，即可看到效果，而且在修改文件的同时刷新页面即可实时更新。
   
   ```bash
   jekyll new myblog
   cd myblog
   bundle exec jekyll serve
   ```

第二种方法：未成功链接github-page，只能复制到jekyll本地博客进行调试。

1. 在你的site(github-page) 主目录下，执行`bundle install`

2. 你的site(github-page) 根目录下执行`bundle exec jekyll serve`启动jekyll，默认访问地址为：`http://localhost:4000`，这样你就顺利的得到了一个本地版的github-page镜像。最后你可以随时更新你本地的jekyll，通过`bundle update`。

<div id="domain"></div>

# 域名绑定

> 域名设置参考[域名绑定](http://itcoding.tk/2016/06/26/set-up-custom-domain-for-github-pages/)，[GitHub Pages 绑定来自阿里云的域名](http://quantumman.me/blog/setting-up-a-domain-with-gitHub-pages.html)。

CNAME记录就是把域名解析到另外一个域名，再转跳到IP。A记录就是把一个域名解析到一个IP地址。如果没有A记录，www域名无法访问。CNAME文件是否包含www决定了在同时配置了顶级域名和www域名的情况下，浏览博客时网址栏是否包含www。所以，带不带www看个人喜好。

- CNAME记录比较稳定，一旦主机的IP发生变化，无需重新解析。
- CNAME记录的生效时间要比A记录快。
- 如果你的CNAME文件内容加了www,那么就直接配置CNAME记录就可以了。在域名解析中添加一项CNAME记录解析，主机记录填`www`，记录值填写你的域名如`usermane.github.io.`，这样就可以通过`www.hostname`来访问。
- 如果你的CNAME文件内容没有加www，那么就需要配置A记录，通过`hostname`访问。主机记录填`@`，记录值填`官方服务器ip`（`ping username.github.io.`获取）。

<div class="note info"><p>（2020年4月2日更新）目前带不带www的域名解析都可以通过CNAME解析实现。设置主机记录www/@，记录类型为CNAME，记录值是`username.github.io.`。</p></div>

明白了基础后，下面进行域名绑定，实现在加或者不加www的基础上都能访问。

1. 域名可以在很多地方购买，如[万网](https://wanwang.aliyun.com/domain/)。[万网域名解析设置方法](https://help.aliyun.com/knowledge_detail/39783.html)。

2. 添加Github Pages解析。博客配置好后，在`Hexo/source`中建立 `CNAME` 文件，把文件内容改成你购买的域名，如hosname，不需要加http这样的前缀。在万网的域名解析界面按如下设置，**设置Github Pages解析为海外**：
   
   - 在阿里云控制台，设置主机记录@，记录类型为A，记录值是IP：`185.199.108.153`（Github Pages服务器指定的IP地址：`185.199.108.153`，`185.199.109.153`，`185.199.110.153`，`185.199.111.153`）。
   - 在阿里云控制台，设置主机记录www，记录类型为CNAME，记录值是`username.github.io.`。如果你想将 `blog.hostname`映射到 `usermane.github.io.`，那么在主机记录中就应该填写blog，记录类型为CNAME，记录值是 `usermane.github.io.`。而且这个时候，你github项目的CNAME文件内容也应该相应的改为`blog.hostname`。

3. 添加CODING Pages解析。在项目主页访问`构建与部署->静态网址->设置`，输入你的自己的域名就可以了。一般只配置了CNAME，可以将coding page绑定多个域名实现跳转，设置首选即可（需完善个人信息才能绑定）。原Coding网址的CNAME记录：`pages.coding.me.`，IP地址：`192.30.252.154`，`192.30.252.153`。2020年01月以后Coding网址的CNAME记录：`xxx.coding-pages.com`，IP地址：`124.156.187.34`，`150.109.4.162`。仅供参考。

4. 修改站点配置文件中的url地址为`http://你的域名`，配置完了之后经过一段时间的等待就能通过域名访问博客啦，最终域名都跳转到`hosname`。

## 项目主页

1. 新建一个repo，repo名字随意。
2. 点进repo主页然后点击右面的`Settings`，页面往下拉到**GitHub Pages**部分，选择`Launch automatic page generator`>`Continue to layouts`>`Publish page`即可。

> 这样一个项目主页就建立完成了，此时可以用`<username>.github.io/<projectname>`访问到了。

## 绑定二级域名

> [把 Github 用作 DNS 设置二级域名跳转](https://drkbl.com/use-github-as-dns/)  
> [关于Github Pages绑定二级域名](http://aqiongbei.top/blog/2017/01/07/github-sub-domains/)

<div class="note success"><p>测试成功</p></div>

不考虑绑定的自定义域名的前提下，个人主页的GitHub二级域名为`<username>.github.io`，项目主页的GitHub二级域名为`<username>.github.io/<projectname>`，没有`<projectname>.<username>.github.io`这种方式。个人主页的展示内容以`master`分支里的文件为准；而项目主页的展示内容以`gh-pages`分支内的文件为准。

Github 的项目支持使用 `gh-pages` 分支生成项目页。绑定在`http://sli1989.github.io/project-name`，并且也支持设置CNAME。

1. 新建一个`repository`，也可以在已有的仓库中新建`gh-pages`分支。

2. 对于博客仓库，选择新建仓库，方便部署不同内容。本地[初始化NEXT博客](#hexo-init)，并进行[博客调试](#hexo-debug)和[部署](#hexo-deploy)。
   
   ```yml
   url: http://test.saili.science
   
   # url: https://sli1989.github.io/blog
   # 根目录改成/博客仓库/
   # root: /blog/
   
   deploy:
   - type: git
     repo: 'git@github.com:sli1989/testing.git'
     branch: gh-pages
   ```

3. 对于非博客仓库，我们也需要将branch改成`gh-pages`才可以使用。
   
   ```bash
   git clone git@github.com:sli1989/testing.git
   # 首先复制你的git项目地址，就是以.git结尾的那个地址，将其拉到本地来。
   cd testing
   # 进入代码目录
   git checkout -b gh-pages
   # 在本地建立一个分支 并切换到新分支
   git push origin gh-pages
   # 将新分支发布在github上
   git branch -d master
   # 将本地的master分支删除
   git push origin :master
   # 将github远程端的master分支删除
   ```

4. 修改CNAME文件，将其指向的域名，比如我的`test.saili.science`，**不要添加任何空格或者回车之类的符号**。

5. 添加域名解析记录。选择CNAME 解析，主机记录为`test`（你想要得域名），记录值为`sli1989.github.io`。点击保存，一般10分钟以内就生效，就可以直接访问`test.saili.science`。

# HTTPS访问

> 比较麻烦，还是不要折腾了。

> 参考链接：[获得小绿锁一把！(启用Https)](https://zxc.science/2016/09/06/https/)，[博客启用全站HTTPS](https://www.tiexo.cn/https/)，[Gitlab上设置证书](http://www.figotan.org/2016/04/26/using-free-wosign-to-certificate-your-blog-on-gitlab/)，[Gitlab-pages的https访问设置](#gitlab-pages-ssl)。[Coding-pages的https访问设置](#coding-pages-ssl)

HTTPS全称Hypertext Transfer Protocol Secure 超文本安全协议。也就是HTTP加上安全传输层协议TSL/SSL。介于HTTP层与TCP层之间的一层安全协议。通过安全认证，可以避免HTTP中间人攻击，信息污染，信息劫持等问题。详细信息的话腾讯Bugly的文章[全站HTTPS来了](https://segmentfault.com/a/1190000004199917)介绍得很详细。HTTPS基础原理，通信过程，在这篇文章里都有详细地讲到。

如果是放到Github上，如果按照官方的文档，你不能使用自己的证书，如果使用了自定义的域名，就不能使用`https`了。 当然你可以自己再搭个服务器， 然后做一下转发，但是这样就感觉有点多余了。如果不自建服务器， 就只能从DNS入手，目前国内的DNS供应商都没有提供免费的HTTPS认证, 但是可以使用国外的[cloudflare](https://www.cloudflare.com/)。**但是https环境无法正常解析`embed`类音乐插件**。

<div id="gitlab-pages-ssl"></div>

## GitLab Pages添加SSL

> 参考链接：[Gitlab上设置证书](http://www.figotan.org/2016/04/26/using-free-wosign-to-certificate-your-blog-on-gitlab/)

知乎上有一篇[帖子](https://www.zhihu.com/question/36710815)，无意间介绍了两个提供免费证书的服务商，一个叫[StartSSL](https://www.startssl.com/)，另一个是[沃通SSL](https://www.wosign.com/)。

### 阿里云证书

> 申请的免费证书，但无法部署证书到Github，

1. 登录阿里云控制台，[购买证书](https://common-buy.aliyun.com/?spm=5176.2020520163.cas.1.3R3hjv&commodityCode=cas#/buy)。证书类型选择 免费型DV SSL，然后完成购买。
2. 在[ 我的证书 控制台](https://yundun.console.aliyun.com/?spm=5176.2020520110.1002.d10cas.AOKWvR&p=cas#/cas/home)，找到购买的证书，在操作栏里选择 补全。填写证书相关信息。域名验证：可以选择 DNS，如果域名用了阿里云的 DNS 服务，再勾选一下 证书绑定的域名在 阿里云的云解析。系统生成 CSR，点一下 创建。提交审核。
3. 如果一切正常，10 分钟左右，申请的证书就会审核通过。注意查看“进度”，进行“检查配置”保证正确配置。
   
   ```
   增加如下DNS记录（24小时内有效，过期后请重新获取记录并配置）
   记录类型：TXT
   主机记录：@
   ```
4. 在阿里云的证书管理那里，如果申请的证书审核通过，你就可以下载了，点击 下载，可以选择不同的类型，可以选择 NGINX，或 Apache 之类的服务器。根据自己网站的 Web 服务器类型，下载对应的证书。解压以后，你会得到两个文件一个是` *.key`，一个是 `*.pem`。
5. 根据不同的Web Server类型选择不同的子压缩包。Gitlab的Pages只支持pem（证书的另一种格式）格式的证书和私钥。下载证书for Nginx。回到`GitLab`，找到你的博客项目 **_Settings>Pages>+New Domain**。把你上一步生成得到的`PEM certificate`粘贴到第一栏，把`private key`粘贴到第二栏。然后点击`Create New Domain`。

### CloudFlare证书

1. 想要使用`CloudFlare`的**HTTPS**服务，就必须使用它的`nameserver`，也就是使用它的域名解析服务。添加一条A记录，指向`52.167.214.135`，然后添加一条`CNAME`记录，把`www`子域名设置成`yourname.gitlab.io`。当你的域名接入之后，点击`Crypto`，找到`Origin Certificates`，点击`Create Certificate`。把生成的证书和私钥都**保存到本地**，接下来需要用到。  

2. 回到`GitLab`，找到你的博客项目 **_Settings>Pages>+New Domain:_**  
   把你上一步生成得到的`PEM certificate`粘贴到第一栏，把`private key`粘贴到第二栏。

<div id="coding-pages-ssl"></div>

## Coding Pages添加SSL

在域名配置中，点击开启`强制 HTTPS 访问`即可。目前只能配置`www.hostname`，无法去掉www。

启用过程中遇到几个需要注意的地方(坑)，在这里总结下：

* 如果你在启用HTTPS前，已经绑定好了自定义域名。记得全部解绑后，重新绑定。否则不会自动申请SSL证书。  

* 如果你采用了`Coding Page`和`GitHub Page`双托管的方式，记得将DNS中解析到`GitHub Page`的记录暂停或删除。否则`Let's Encrypt`主机根据域名解析记录验证域名所有权时，会定位到`GitHub Page`的主机上，导致`Let's Encrypt`SSL证书申请失败。

## CDN方式

CDN的全称就是Content Delivery Network，内容分发网络。其最基本的思路就是，用户在访问一个网站的时候，不直接访问这个网站的服务器，CDN系统会根据地理位置，将用户重新导向离其最近的CDN服务器。网站的内容在这个CDN服务器上会有相应的缓存，从而使用户更快地访问到所需要的内容，可以减少网络拥堵的情况，也可以减轻网站的服务器承受太大的访问量，以及带宽不足的情况。

### CloudFlare添加SSL

考虑到 GitHub Pages 不提供对自定义域名的 https 服务，你需要一个反向代理给你加上 HTTPS ， CloudFlare 是最好选择。虽然这里所使用的方法，不是安全的一种方法。网站仍然会面临中间人攻击等一系列问题。因为服务器与CDN之间的通信未加密。但是至少用户在访问网站的时候，不会被通信服务商再拦截再什么广告了。

当Coding + GitHub 双 Pages 部署，CloudFlare 的 NS 不能分区解析，所以无法直连 Coding 服务器。

**网页反应有点慢，多等待至能够输入**。因为CloudFlare的SSL协议标准与国内标准不同的原因，并且在国内没有相应节点，所以会访问慢，还可能会起着反效果。

CloudFlare提供的SSL服务是基于SNI技术的，也就是说，机子上是IE8及以下用户完全无法打开（Chrome使用证书为系统，所以在win7下IE8的Chrome浏览器也是无法打开的，无论版本）

1. 创建[CloudFlare帐户](https://www.cloudflare.com/a/sign-up)，并添加网站。

2. 登陆后，[增加你的域名](https://www.cloudflare.com/a/add-site)。输入你的域名，例如 yicodes.com 并点击 Begin Scan。注意不要写WWW前缀，大约60秒即可完成域名解析扫描。完成后点击 Continue Setup 继续下一步。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqrb8ad41yj30r7088js0.jpg)

3. 选择免费计划，然后下一步~

4. 到你域名控制面板修改cloudflare给出的域名服务器。注：官方说明，域名服务器修改最长需要72小时生效 ，用了两个域名测试，大约需要 5~30 分钟，看到 Status: Active 即可
   
   ```
   Current Nameservers Change Nameservers to:
   dns19.hichina.com david.ns.cloudflare.com
   dns20.hichina.com lily.ns.cloudflare.com
   ```

5. 点击 crypto 菜单 , 然后设置 `full`。

6. 点击 `Page Rules - create Page Rules `菜单，添加自动重定向到 SSL页面。填写完毕之后点击`Save and Deploy`就可以了，可能需要一段时间，毕竟有缓存。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqrb8hp5thj30lx0cdmy3.jpg)

7. 添加SSL的教程就此完成，一般需要5~30分钟生效！

8. 至此，必须手动输入`https`前缀才能访问加密的站点，要想在任何情况下都以加密方式访问网站，可以在网站模版的头中加入`http`到`https`的强制跳转。打开`layout`目录下的`_layout.swig`，在`<head>`标签中加入以下代码，注意把`yoursite.com`替换为你的域名，这里为`g2ex.me`。

### 七牛免费SSL证书

<div class="note warning"><p>未测试</p></div>

[使用七牛免费SSL证书并配置自定义域名CDN加速](https://github.com/excaliburhan/blog/issues/16)

### Let’s Encrypt

<div class="note warning"><p>未测试</p></div>

[Let’s Encrypt](https://letsencrypt.org/)：[安装Cerbot，配置SSL证书](https://github.com/huangqian8/installer)（本脚本使用Let's Encrypt，其余SSL证书请自行安装），等同于[ssl 证书申请(开启 https 服务)](https://thoroughyoung.info/2017/02/08/hexo-build-blog-complete-guide-2/)。
]]></content>
      <categories>
        <category>Software</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>如何阅读文献</title>
    <url>/how-to-read-literatrue/</url>
    <content><![CDATA[
如何提高自己阅读文献的水平呢？ 几十篇文献应该从哪一篇看起，几十页的文献应该重点看哪里；怎么能够从几十页的文献中高效快速地提取自己所需要的信息，怎么才能在规定的时间内尽可能地囊括课题相关的文献内容才是问题的所在[^mid=2652553819][^question/27375221]。

[^mid=2652553819]: [如何看懂英文文献](https://mp.weixin.qq.com/s?__biz=MzA5ODUxOTA5Mg==&mid=2652553819&idx=1&sn=ad59c11dacb7629c4b06170bd209efa7)

[^question/27375221]: [如何看懂英文文献？](https://www.zhihu.com/question/27375221)

<!--more-->

> [读学术文献（literature）的三个进阶](http://daily.zhihu.com/story/9640235)

如果你看文章还不是为了完成自己的 research（比如是为了完成老师给的 reading）, 那么我建议你在读 literature 的时候可以问自己这么 3 个问题：

1. 如果让你用一句话来概括这篇文章作者到底想告诉我们什么，你如何概括？

2. 这篇文章好在哪里？（创新点在哪里？没有这篇文章会怎样？）

3. 这篇文章可能对你将来的 research 有什么帮助？（你能用上哪些环节？）



# 精读

> **精读**：详读了一篇论文后发现，有很多不懂的概念，有很多的疑问，也有很多的思路，并且根据自己在读这篇文献时的问题和想法，展开来查看其他的相关文献和书籍，以便弄懂相关概念和问题。

**法则一**：从文献综述或综述类文献开始，概览全局，缩小范围。

看文献有一个渐进的过程，对于刚刚开始接手一个课题方向什么也不知道的情况下，**硕博士论文前言绪论、文献综述、专著和教材** 都是作为精读的。这样的文献的特点是：覆盖面广，时间跨度大，概括性强，指导性强。力求完全吸收，弄懂这个领域内所涉及到的概念、术语、研究现状和日后的研究方向等。通过这样的文献综述，可以锁定需要特别关注的区域。

也可以多浏览学术会议议题，看看大家都在忙什么，根据自己的倾向，多看看自己感兴趣的方面。

# 详读

> **详读**：将全文看完，并且在看其试验时对照其试验数据与图片进行自己的分析，然后用自己的分析与文献所阐述的分析进行对比。

**法则二**：阅读论文的过程逆向思考就是写论文的过程，互为逆过程的两件事如果能同时进行，一边读一边想，将事半功倍。

接下来就进入详读阶段，详读的过程就是弄懂所研究领域的一般性试验研究方法，与已有的试验分析范式和思路，以及一般性的分析思路，同时也要把握住研究者进行相关的研究的思路和原因。

也要开始提出问题，抓住所看论文的结论进行反问，想想结论是否有一定的局限性和条件性，想想几个研究论文所说结论之间的不同以及内在的发展，或者是根据实验室已有的硬件设计如果要做重复性试验该如何做，如果更改了试验方案会带来什么问题，如果更改试验方式又会有什么地方与所看论文的试验结果有不同，反正第一阶段的详读后以产生了自己的研究思路为终止。

# 略读和概读

> **略读**：仅仅看摘要，看看是否跟自己的研究方向相关。

> **概读**：仔细看完参考文献和引言。如果参考文献中十篇有九篇都不是近五年的文章，也就没有必要看了，这种文章没有跟进最新研究动态的，能给的提示不多。看完参考文献了，就看引言。引言部分一般处于文献开始的位置，统领全文，同时相当于阅读索引，告诉读者 **领域近况**（研究背景），**主要课题/视角/研究方法**（锁定研究范围），**讨论的前提**（保证论证的严密性，同时有自报家门的作用，因为不同的派别遵循的大前提多不同），**研究目的**（明确自己要达到的目标），，**研究思路** （是怎么得出要做所做研究的想法的），**篇章结构**（明确研究步骤）。我们也要反过来想一想，为什么论文摘要多采取这样的结构？它有什么样的必然性，或者说优越性？

等到自己的研究思路形成后就是略读阶段，就需要看大量的文献，选择看摘要，觉得摘要中和自己的思路相近的论文进行概读，这个过程大概就要阅读很多的文献，100篇左右或者更多吧，不过是很有创新性的思路，可以一边做实验，一边来进行略读和概读的。

**法则三**：永远不要放弃寻找联系，联系越多越强越复杂，我们捕捉信息的网就越大越密越严谨。不断构建新的联系，更新/更正已有的联系本来就是科学研究的主要内容之一。

**法则四**：阅读文献的时候要不时地带入自己的知识体系，帮助甄别信息的优先级，同时也有助于理解性地记忆文献的大致结构和主要内容。最终达到在合上书本的时候，脑海中画树形图的境界。

# 文献笔记法

literature notes几乎是文献阅读和文献管理最有效的途径，是一个学者从新手变为高手的必经之路[^p/29931530]。

[^p/29931530]: [文献阅读第一利器：文献笔记法（Literature Notes）](https://zhuanlan.zhihu.com/p/29931530)

- 我们读了文献之后会遗忘。再聪明的人，记忆力再好的人，也不可能记得两年之前读过的一篇学术文章的全部重要细节。记了笔记之后我们可以随时调出来查看文章的重要内容，而不需要回去把几十页的文章重新看一遍。
- 记笔记能教会我们怎么读文章。如果你能清楚哪些东西应该记在笔记里、哪些可以不记，那么你也就逐渐知道了看文章的时候要重点看什么，略看什么，不用看什么。社科类学术文章通常有其独特的”structure”, 通过多记笔记，你会大大提高自己读这类文章的效率--有如总结多了八股文的结构自己也能写得一手好八股。
- 需要引用文献的时候可以信手拈来。笔记记完了之后通过按主题分类和管理，可以大大方便我们在之后写文章时的引用效率---写作和构思中想到了哪篇文章观点、方法、结论就可以随时手到擒来。

在开始记笔记之前我们首先要分清手里的这篇学术文章是一篇theoretical paper （理论性文章）还是empirical paper (实证性文章)，两者一般结构会很不同，记笔记的方法当然也不一样。

理论性文章没有数据，写文章的目的是为了提出一个概念性的观点或搭建理论框架，而不是去验证某个假设是否真实---换句话说作者只是过来跟你讲个构想，至于是不是真的就撒手不管交给其他做empirical studies的研究者了。这类文章我们在记笔记时一定不能错过的部分有：

- Primary thesis （文章主旨---文章想说啥？如果不明显就自己去总结）
- Critical components of the argument that support the thesis (文章通过哪些支持性的的论述去argue 这个主旨？)
- Basic propositions/elements of the theory or framework （文章中理论框架的核心组成都有什么？基本的命题假设有哪些？）


实证性文章则是通过数据去验证某个或某几个实证假设------文章的目的不是给出一个全景，不是给出所有问题的答案，不是构建理论框架，而是只关注某一个假设问题去验证，只关注某一个或某几个dependent variable (因变量) 和 independent variable （自变量）。这一类文章，我们记笔记的时候要记录：

- Research question(s) (文章的研究问题是什么？---通常好的实证研究都有非常具体的研究问题，我们要把它拎出来)
- Hypotheses (文章的实证假设是什么？---一般会非常显眼得列在文章里：Hypothesis1, Hypothesis 2…)
- Methods/measures used (该实证研究用了什么方法收集数据、测量变量、分析数据？)
- Key findings (该研究发现了什么研究结果？哪些假设被支持，哪些并没有成立？)

无论是理论性文章还是实证性文章，我们都应该在文献笔记中记录的是：

- 有哪些重要的观点你想要记住，或是将来可能会引用到 （key citations）；
- 有哪些结论你将来可能用到；
- 有哪些方法你将来可能用到；
- 文章在研究设计上有哪些不足?有没有更好的改进方法？
- 文章让你想到了哪些观点类似或者完全不同的其他文章？
- 你对文章中观点、论述、方法、讨论等部分有什么想法和critique？
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>文献阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>科研经验</title>
    <url>/how-to-research/</url>
    <content><![CDATA[
如果说，本科期间的学习是让学生看到世界之广阔和多样，那么研究生期间的学习则让学生看到世界之深邃和奇妙。研究生期间（包括博士期间）的学习重点和方向是鲜明和有特色的，研究生期间更注重的是某一学科专业的深入，是带着任务去解决某个未知的问题，需要独立开展研究工作，独立思考问题和解决问题，是个在专业学科研究中发现问题和解决问题的过程。

<!--more-->

对于硕士研究生要做的最多的事情就是根据老师的提示摸索出自己研究课题开展的计划，制定出详细的研究计划与方案，拿着这些计划和方案去和老师交流，如此得到老师的指导将是最有效的，同老师共同商量出最终的方案后，依据方案稳步开展工作即可，而所获得的最后答案就是学生和老师共同寻找的答案了。

对于博士生，一般情况下，老师是不能给出具体的研究课题，也就无从给出这个研究课题的答案，一切都靠博士生自己，可以先跟着老师做老师的事情，一边做一边思考，这样就需要非常多的交流，在与老师的交流中结合自己文献阅读的知识去寻找创新型研究课题。所谓博士生，首先要知识“广博”，然后才能专业精深。因为博士生必须做出创新性工作，自然辩证法说过逻辑推演难以做出突破性的创新，而扩散思路点进而触发灵感才是获得创新性思维的基本形态。

> 做研究的核心工作就是目的性很强的思考，有两种思考状态，其一，是拥有了某个结论，依据此结论进行逻辑推演，这是纵向思维；其二，拥有某种结果，需要为结果找原因而又没有现成的线性逻辑，那就得将思考点发散，以结果为中心遍寻各类原因，用原因去套结果，按我的理解应该是所谓的横向思维。纵向思维倚重逻辑推演能力，考察的是你的专业基础是否扎实；横向思维倚重对事物联系的敏感性，考察的更多是一个人知识视野的宽泛与否，考察一个人是否善于联想。寻找创新点首先要有如上的一点认识，然后则是勤于思考，习惯于做总结。

孔夫子的杰出弟子曾子的一句名言：“吾日三省吾身，为人谋而不忠乎？与朋友交而不信乎？传不习乎？”（《论语·学而第一》））。[福州大学，数学与计算机科学学院，陈德旺教授](http://blog.sciencenet.cn/home.php?mod=space&uid=57940&do=blog&id=1065726)提出三点建议给今天的研究生，即优秀研究生的吾日三省吾身：**时间有浪费乎？能力有提升乎？研究有进展乎？** 最后，再送想成为优秀研究生的同学一句话，也是曾子的经典名言：“士不可以不弘毅，任重而道远”（《论语·泰伯章》）。

- 空谈虽然难以误国，但是空谈误事啊，实干才能成事。
- 只要每天能力有点提升，研究生就要给自己积极的心理暗示：我今天能力提升了一点，今天过得很有意义很充实，明天继续！
- 订出合理的计划将是成功的开始，勤于思考，习惯于做总结。实施与推进“**计划-工作-总结**”模式，定期写总结是锻炼逻辑思维能力的好办法，也可以促使逐步向“好的执行力”进发。
- 要“**以做为主，以学为辅**”。光学不做，坐而论道，是难以取得真正的研究进展。“不积跬步无以至千里，不积小流无以成江海”，研究生对研究进展的期望不能操之过急，不怕进展慢，就怕原地站。“水滴石穿，贵在坚持”，研究生慢慢就会发现你们的研究取得了重要的进展，你们的研究能力得到了很大提升。

Julio Peironcely 结合自己的亲身经历，[给博士生或即将成为博士生的人们提出了 17 个建议](https://www.jiqizhixin.com/articles/2018-06-19-5)，内容诚恳，细节丰富；主要涉及了博士学习期间面对的压力、和导师的相处原则、研究项目规划、发表演讲、日常事务处理以及社交生活等。

以下分享一些科研生活经常遇到的工具和经验，仅供大家参考。<font color=red>如有错误遗漏之处，欢迎留言指出，我好方便修正</font> 。

1. 要想快速入门学科，有必要进行有效的情报检索。华中科技大学图书馆提供了[信息检索教学](http://www.lib.hust.edu.cn/ArticleChannel.aspx?ChannelID=233)，帮助学生系统了解和较为熟练地掌握各类数据库的浏览、检索和使用方法，提高学习者的自学能力和研究能力。如何有效的进行文献检索、数据信息检索，可以参考[情报检索](https://sli1989.github.io/information-search/)。

1. 文献管理方面主要包括文献收集、整理、分析与追踪。学习一些文献管理方法，可以提高科研效率。详细内容可以参考[文献检索方法](https://sli1989.github.io/reference-manage/#literature-search)，[文献管理软件](https://sli1989.github.io/reference-manage/#literature-manage)，[文献跟踪](https://sli1989.github.io/reference-manage/#literature-follow)。

1. 几十篇文献应该从哪一篇看起，几十页的文献应该重点看哪里；怎么能够从几十页的文献中高效快速地提取自己所需要的信息，怎么才能在规定的时间内尽可能地囊括课题相关的文献内容才是问题的所在。详细内容可以参考[如何提高自己阅读文献的水平](https://sli1989.github.io/how-to-read-literatrue/)。

1. 写综述是新手入门的一个非常好的方式，也是对自己思路的一个整理，非常不错。一些写综述的经验可以参考[如何写综述](https://sli1989.github.io/write-review/)。

1. [论文写作](https://sli1989.github.io/paper-writing/)介绍了一篇合格的文章应具备的条件。论文写作工具则推荐使用TEX工具。TEX（TeX）是由著名的计算机科学家 Donald E. Knuth（高德纳）发明的排版系统，TeX 就能够排版出精美的文本。<font color=blue>推荐使用组合：前期文档使用底层 Texlive + 界面编辑器 texstudio，后期添加参考文献推荐使用 Texlive+Sublime Text</font> 。详细内容可以参考[Tex 使用指南](https://sli1989.github.io/tex/)。对于需要使用word书写的时候，也可以使用[图表公式的自动编号、交叉使用](https://sli1989.github.io/word-typesetting/#word-figure)，[利用bib文件生成参考文献](https://sli1989.github.io/word-typesetting/#word-reference)等功能，非常实用，详细可以参考[Office Word 排版](https://sli1989.github.io/word-typesetting/)。

1. [论文投稿](https://sli1989.github.io/paper-submission/)针对投稿前的准备工作与事项、各种投稿后状态、对拒稿后的处理或者接受后期的一些相关问题，做了一个汇总。[一般发表论文的若干要求](http://blog.sciencenet.cn/blog-89935-377289.html)。

    - 作者根据评审专家意见修改稿件之后，在重新提交时，除了修改的文章（revised manuscript），还要包括一封 response letter，对所有评审专家的意见一条一条的答复。请注意，这封答复信和修改的稿件几乎一样重要！期刊编辑会把二者发送给原评审专家，由他／她们评定作者的修改是否已经令人满意，达到可以发表的水平。之后，期刊编辑再次根据这些评审专家的意见决定是否采纳稿件。详细内容可以参考[审稿意见回复信](https://sli1989.github.io/paper-response-letter/)。
    - 稿件接受后期的其他相关问题主要有：作者信息和地址的准确性、版权转让、校样proof、单行本、版面费等。详细内容可以参考[论文接受](https://sli1989.github.iopaper-accepted/)。

1. [华中科技大学学位论文格式要求](https://sli1989.github.io/thesis-format/)介绍了华中科技大学学位论文的格式要求，以及各种模板修改。[华中科技大学博士毕业流程](https://sli1989.github.io/phd/)介绍华中科技大学博士毕业全过程。

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>科研经验</tag>
      </tags>
  </entry>
  <entry>
    <title>如何理解HTTPS</title>
    <url>/https/</url>
    <content><![CDATA[
超文本传输安全协议（英语：Hypertext Transfer Protocol Secure，缩写：HTTPS，常称为HTTP over TLS，HTTP over SSL或HTTP Secure）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，但利用SSL/TLS来加密数据包。HTTPS开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。这个协议由网景公司（Netscape）在1994年首次提出，随后扩展到互联网上。

<!--more-->

先放结论[^https]：HTTPS要使客户端与服务器端的通信过程得到安全保证，必须使用的对称加密算法，但是协商对称加密算法的过程，需要使用非对称加密算法来保证安全，然而直接使用非对称加密的过程本身也不安全，会有中间人篡改公钥的可能性，所以客户端与服务器不直接使用公钥，而是使用数字证书签发机构颁发的证书来保证非对称加密过程本身的安全。这样通过这些机制协商出一个对称加密算法，就此双方使用该算法进行加密解密。从而解决了客户端与服务器端之间的通信安全问题。

[^https]: [也许，这样理解HTTPS更容易](http://showme.codes/2017-02-20/understand-https/)

我们先从一个聊天软件说起，我们要实现A能发一个hello消息给B。要实现A发给B的hello消息包，即使被中间人拦截到了，也无法得知消息的内容。

- 对称加密算法。只要这个密钥S不公开给第三者，同时密钥S足够安全，我们就解决了我们一开始所定问题域了。如果服务器端对所有的客户端通信都使用同样的对称加密算法，无异于没有加密。那怎么办呢？答案是：Web服务器与每个客户端使用不同的对称加密算法。
- 我们的服务器端通过协商告诉客户端该使用哪种对称加密算法。但是，你协商的过程是没有加密的，还是会被中间人拦截。
- 非对称加密。密码学领域中，有一种称为“非对称加密”的加密算法，特点是私钥加密后的密文，只要是公钥，都可以解密，但是公钥加密后的密文，只有私钥可以解密。私钥只有一个人有，而公钥可以发给所有的人。我们使用非对称加密算法进行对称加密算法协商过程。
- 要达到Web服务器针对每个客户端使用不同的对称加密算法，同时，我们也不能让第三者知道这个对称加密算法是什么，怎么办？就是使用随机数来生成对称加密算法。这样就可以做到服务器和客户端每次交互都是新的加密算法、只有在交互的那一该才确定加密算法。
- 如果使用非对称加密算法，我们的客户端A，B需要一开始就持有公钥。

    - 方案1. 服务器端将公钥发送给每一个客户端。如果服务器端发送公钥给客户端时，被中间人调包了，怎么办？
    - 方案2. 服务器端将公钥放到一个远程服务器。多了一次请求，还要另外处理公钥的放置问题。
    - 所以，我们不能直接将服务器的公钥传递给客户端，而是第三方机构使用它的私钥对我们的公钥进行加密后，再传给客户端。客户端再使用第三方机构的公钥进行解密。

- 数字签名，解决同一机构颁发的不同证书被篡改问题。客户端在拿到证书后，自己就有能力分辨证书是否被篡改了。客户端拿到证书后根据证书上的方法自己生成一个证书编号，如果生成的证书编号与证书上的证书编号相同，那么说明这个证书是真实的。
- 第三方机构的公钥怎么跑到了客户端的机器中呢？现实中，浏览器和操作系统都会维护一个权威的第三方机构列表（包括它们的公钥）。因为客户端接收到的证书中会写有颁发机构，客户端就根据这个颁发机构的值在本地找相应的公钥。
]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title>如何正确使用和打出英文的破折号</title>
    <url>/hyphen-dash/</url>
    <content><![CDATA[
首先，最好不要把西文的 dash 称作「破折号」，因为中文破折号的用法和西文两种 dash 的用法并不一致，这样称呼更容易让你搞不清它们的功能。Dash 就是西文里比 hyphen 更长的一些横线状连接符号而已，常见两种长度── en dash 和 em dash。

<!--more-->

先看看这4个符号的长相，从左到右依次是：Hyphen ,En dash ,Em dash ,Minus sign。

# HYPHEN

1. 用于复合词，如：

upper-case letter

2. 用于分隔数字或字母，例如电话号码：
或名字的拼写：

1-800-621-2376
My name is Phyllis; that's p-h-y-l-l-i-s.

3. 用于排版时连接因断行而被打断的单词，例如：

Trust Law ranks the Congo as one of themost dangerous coun-
tries for sexual violence.

# EN DASH

1. 相当于 to。主要用于连接数字或单词，表示「到并包括」（up to andincluding）。不过应注意，在 from...to... 和 between...and... 的结构中，不要用 en dash 去替代中间的 to 和 and。例句：

    Her college years, 1998–2002, were thehappiest in her life.
    For documentation and indexing, see chapters 16–18.
    In Genesis 6:13–22 we find God's instructions to Noah.
    Join us on Thursday, 11:30 a.m.–4:00 p.m., to celebrate the New Year.
    The London–Paris train leaves at two o'clock.
    I have blocked out December 2002–March 2003 to complete my manuscript.
    Her articles appeared in Postwar Journal (3 November 1945–4 February 1946).
    Green Bay beat Denver 31–24.
    The legislature voted 101–13 to adopt the resolution.

2. 后面什么也不接。比如用于表示年代，若事件仍在进行中，en dash 后面不要加空格。例句：

    Professor Plato's survey (1999–) willcover the subject in the final volume.
    Jane Doe (1950–); or Jane Doe (b. 1950)

3. 代替hyphen的用途。在复合型形容词中，如果其中一个构成元素是开放型复合词，或者如果其中两个或多个构成元素是开放型复合词或带 hyphen 的复合词，那么应使用en dash。例句：

    the post–World War II years
    a hospital–nursing home connection
    a nursing home–home care policy
    a quasi-public–quasi-judicial body (or, better, a judicial body that isquasi-public and quasi-judicial)

在上述前三例中，post 和 World War II，hospital 和 nursing home，以及 nursing home 和 home 都是所属新的复合词中的元素，这些元素本身已经是开放型复合词，为了避免混淆和层次清晰，应使用 en dash 来连接。第四例中，quasi-public 和 quasi-judicial 是两个独立的均带 hyphen 的复合词，它们需要进一步连接起来，所以中间用了 en dash。

用来对照的反例如下：

non-English-speaking peoples
a wheelchair-user-designed environment (or, better, an environment designed forwheelchair users)
U.S.-Canadian relations

上述前两例都是单个词的复合，尽管由三个以上元素构成，一律都用 hyphen。第三例中，复合词的缩写（U.S.）视为一个词，所以也用 hyphen。

# EM DASH

1. 它的用法最复杂、最灵活。为了避免混淆，一个句子不应包含超过两个 em dash，如果实在需要，应使用圆括弧。

2. 用于详述或解释。基本相当于一组逗号、圆括弧，或冒号的用途。
    例句：

    It was a revival of the most potentimage in modern democracy—the revolutionary idea.
    The influence of three impressionists—Monet, Sisley, and Degas—is obvious inher work.
    The chancellor—he had been awake half the night—came down in an angry mood.
    She outlined the strategy—a strategy that would, she hoped, secure the peace.
    My friends—that is, my former friends—ganged up on me.

3. 用于分隔引导从句的代词。例句：

    Consensus—that was the will-o’-the wisphe doggedly pursued.
    Broken promises, petty rivalries, and false rumors—such were the obstacles heencountered.
    Darkness, thunder, a sudden scream—nothing alarmed the child.
    Kingston, who first conceived the idea; Barber, who organized the fundraisingcampaign; and West, who conducted the investigation—those were the women mostresponsible for the movement's early success.

4. 表示思考或对话中句子结构的突然中断，有时也可用省略号代替。例句：

    "Will he—can he—obtain thenecessary signatures?" asked Mill.
    "Well, I don't know," I began tentatively. "I thought Imight—"
    "Might what?" she demanded.

    但如果中断来自于所引用材料的外部，em dash 应当出现在引号的外面。例如：

    "Someday he's going to hit one ofthose long shots, and"—his voice turned huffy—"I won't be there tosee it."

5. 替代逗号，或与逗号一起使用。如果在需要使用 em dash 时，需要用逗号来分隔从句和独立分句时，逗号可以省略。例句：

    Because the data had not been fullyanalyzed—the reason for this will be discussed later—the publication of thereport was delayed.

    但如果 em dash 出现在引用材料的末尾表示中断，应当在说话人的身份之前用逗号。例句：

    "I assure you, we shallnever—," Sylvia began, but Mark cut her short.

6. 和其他标点连用。一般来说，em dash 可以跟在问号、感叹号的后面，但不能跟在逗号、冒号、分号的后面，也几乎不能跟在句号的后面。例句：

    All at once Richardson—can he have beenout of his mind?—shook his fist in the ambassador's face.
    Only if—heaven forbid!—you lose your passport should you call home.

7. 用于代替引号。有些法语作家常用 em dash 代替引号表示对话，每段话另起一段。例句：

    —Will he obtain the necessarysignatures?
    —Of course he will!

8. 用于索引。例句：

    —body armor: cuirass, 135–36, 147, 152,
    244, 258, 260, 311; greaves, 135, 179,
    260; helmets, 101, 135, 147, 221, 243,
    258

# 2-EM 和 3-EM DASHES

双重和三重的 em dash 相对少见，但也是正规的标点符号，可以介绍一下。

2-em dash 用来表示单词拼写不全，或名字的省略，或粗话的省略，或无法识别的字迹等。如果整个单词都丢失了，2-em dash 的左右两侧都应留出空格，如果只有一部分丢失，那么在 2-em dash 和单词现存部分之间不应有空格。如果 2-em dash 代表整个单词的结束，那么之后应留出正常的词间空格。
例句：

"The region gives its —— to thelanguage spoken there.
Admiral N—— and Lady R—— were among the guests.
David H——h [Hirsch?] voted aye.

3-em dash 用于参考文献（bibliography），后面接一个句号（.），表示和上一条是同一个作者。
例句：

———. The Last Dinosaur Book. Chicago:University of Chicago Press, 1998.

关于 en dash 和 em dash的用法，在英、美略有习惯差异，例如有的英国出版机构，如剑桥大学出版社、企鹅、劳特里奇等，喜欢用两边带空格的 en dash 来替代两边不带空格的 em dash，但这在美国很少见，而另一部分英国出版机构，如牛津大学出版社，也支持美国那种两边不带空格的 em dash 风格。


# 注意事项

1. 慎用 en dash

为了避免和减号混淆，有的地方最好不要用 en dash。
例句：

with temperature of −5 to 25°C 【正确】
with temperature of −5–25°C 【错误】

−4 to −6°C 【正确】
−4– −6°C 【错误】

2. 少用 em dash  

# 输入方法

> [英文破折号（em dash）、连接号（en dash）与连字符（hyphen）的区别及各自用法是什么？在科技写作中有何特点？](http://www.zhihu.com/question/20332423)  
> [Hyphens, En Dashes, Em Dashes](http://www.chicagomanualofstyle.org/qanda/data/faq/topics/HyphensEnDashesEmDashes.html?old=HyphensEnDashesEmDashes07.html)  
> [Hyphens, En Dashes, Em Dashes](http://www.chicagomanualofstyle.org/qanda/data/faq/topics/HyphensEnDashesEmDashes/faq0002.html)


在TeX中，连字符需要使用手动添加的并不多，因为TeX的断词算法相当强大，断行+断词的情况下会自动添加连字符。如需添加其他的断字选项，可使用`\hyphenation{mom-ent}`这个命令进行仿制。而对于连字符的形式，你都可以换成任意的符号形式，这需要使用`\hypenchar`命令进行调整。em-dash和en-dash的生成机制是TeX的tfm中预先设定好的ligature作用得到的。这个方法省事一点。TeX用户需要的只是多敲入-即可。减号呢，也是用连字符可以输入的，在TeX中会自行转换。

> for a hyphen, type a hyphen (-);　　　for an en-dash, type two hyphens (--);　　　for an em-dash, type three hyphens (---);　　　for a minus sign, type a hyphen in mathematics mode ($-$).

![](http://pic4.zhimg.com/ccd3150557ec672f9c0e7840d2e63937_b.jpg)

Hyphen 的 Unicode 编码是 U+2010，在 MS Word 里可以先输入 2010 再按 Alt + X。不过在 ASCII 编码系统中，hyphen 被编为45号字符「hyphen-minus」，也就是我们电脑键盘上「0」和「=」之间的那个「-」。在通常情况下我们直接使用这个符号就可以了。

En dash 的 Unicode 编码是 U+2013，在 MS Word 里可以先输入 2013 再按 Alt + X，更简便的方法是利用 MS Word 的自动更正功能：**按空格，按两下「-」，再按空格**，例如输入「this is -- atest」  (word-space-hyphen-space-word?)，将转换为「this is – a test」（当然，要注意 en dash 前后一般是不留空格的）。En dash 在 Windows 里可以用 Alt + 0150 （即按下 Alt 键的同时依次按下 0150）来输入，在 Mac 里可以用⌥+ - 来输入，在 TeX 里可以用 -- 输入，在 HTML 里可以用 `&ndash;` 来输入。

Em dash 的 Unicode 编码是 U+2014，在 MS Word 里可以先输入 2014 再按 Alt + X，更简便的方法是利用 MS Word 的自动更正功能：**不加空格，直接按两下「-」**（打开中文输入法 输入 shift + - 就会变成 —— (2 个 mdash)，然后 backspace — 就这样了），例如输入「this is--a test」，将转换为「this is—a test」。Em dash 在 Windows 里可以用 Alt + 0151 来输入，在 Mac 里可以用⌥ + ⇧ + - 来输入，在 TeX 里可以用 ---输入，在 HTML 里可以用 `&mdash;` 来输入。

Minus sign (−)的 Unicode 编码是 U+2212，在 MS Word 里可以先输入 2212 再按 Alt + X。减号在 TeX 里可以用 −− 输入，在 HTML 里可以用 `&minus;` 来输入。

---
]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>破折号</tag>
      </tags>
  </entry>
  <entry>
    <title>假设检验</title>
    <url>/hypothesis-testing/</url>
    <content><![CDATA[
假设检验(Hypothesis Testing)是数理统计学中根据一定假设条件由样本推断总体的一种方法。它根据数据样本所提供的证据，指定是肯定还是否定有关总体的声明。具体作法是：根据问题的需要对所研究的总体作某种假设，记作H0；选取合适的[统计量](http://baike.baidu.com/item/%E7%BB%9F%E8%AE%A1%E9%87%8F)，这个统计量的选取要使得在假设H0成立时，其分布为已知；由实测的样本，计算出统计量的值，并根据预先给定的[显著性水平](http://baike.baidu.com/item/%E6%98%BE%E8%91%97%E6%80%A7%E6%B0%B4%E5%B9%B3)进行检验，作出拒绝或接受假设H0的判断。（可使用 p 值来做出判断。如果 p 值小于显著性水平（用 α 或 alpha 表示），则可以否定原假设。）

<!--more-->

常用的假设检验方法有[u—检验法](http://baike.baidu.com/item/u%E2%80%94%E6%A3%80%E9%AA%8C%E6%B3%95)、[t检验](http://baike.baidu.com/item/t%E6%A3%80%E9%AA%8C)法、χ2检验法([卡方检验](http://baike.baidu.com/item/%E5%8D%A1%E6%96%B9%E6%A3%80%E9%AA%8C))、[F—检验法](http://baike.baidu.com/item/F%E2%80%94%E6%A3%80%E9%AA%8C%E6%B3%95)，[秩和检验](http://baike.baidu.com/item/%E7%A7%A9%E5%92%8C%E6%A3%80%E9%AA%8C)等。

> [Minitab® 18 支持-基本概念](http://support.minitab.com/zh-cn/minitab/18/help-and-how-to/statistics/basic-statistics/supporting-topics/basics/what-is-a-hypothesis-test/)  
> [数理统计与Matlab: 第3章 假设检验](http://www.cnblogs.com/begtostudy/archive/2012/06/22/2558946.html)  
> [假设检验的基本概念](http://www.cnblogs.com/begtostudy/archive/2012/06/22/2558946.html)  

<div id="confidence-interval"></div>

# 置信区间

机器学习本质上是对条件概率或概率分布的估计，而这样的估计到底有多少是置信度？这里就涉及到统计学里面的置信区间与置信度。

很多答案当中用关于真值的概率描述来解释置信区间是不准确的。我们平常使用的频率学派（frequentist）95% 置信区间的意思并不是真值在这个区间内的概率是 95%。由于在频率学派当中，真值是一个常数，而非随机变量（后者是贝叶斯学派） ，所以我们不对真值做概率描述。

只有贝叶斯学派才会说某个特定的区间包含真值的概率是多少，但这需要我们为真值假设一个先验概率分布（prior distribution）。这不适用于我们平常使用的基于频率学派的置信区间构造方法。

换言之，我们可以说，如果我们重复取样，每次取样后都用这个方法构造置信区间，有 95% 的置信区间会包含真值。然而（在频率学派当中）我们无法讨论其中某一个置信区间包含真值的概率。

换种方法说，假设我们还没有取样，但已经制定好取样后构造 95% 置信区间的方法。我们可以说取样一次以后，获得的那个置信区间（现在还不知道）包含真值的概率是 95%。然而在取样并得到具体的一个区间之后，在频率学派框架下就无法讨论这个区间包含真值的概率了[^26419030]。

[^26419030]: [如何理解 95% 置信区间？](https://www.zhihu.com/question/26419030/answer/70589735)

- 置信区间，提供了一种区间估计的方法。

假设你想知道美国有多少人热爱足球[^2018-03-28-6]。为了得到 100％ 正确的答案，你可以做的唯一一件事是向美国的每一位公民询问他们是否热爱足球。根据维基百科，美国有超过 3.25 亿的人口。与 3.25 亿人谈话并不现实，因此我们必须通过问更少的人来得到答案。我们可以通过在美国<font color=blue>随机抽取</font>一些人（与更少人交谈）并获得热爱足球的人的百分比来做到这一点，但是我们不能 100％ 确信这个数字是正确的，或者这个数字离真正的答案有多远。所以，我们试图实现的是获得一个区间，例如，对这个问题的一个可能的答案是：「我 95％ 相信在美国足球爱好者的比例是 58％ 至 62％」。这就是置信区间名字的来源，我们有一个区间，并且我们对它此一定的信心。因此，假设我们随机抽取了 1000 个美国人的样本，我们发现，在 1000 人中有 63% 的人喜欢足球，我们能假设（推断）出整个美国人口的情况吗？让我们回到我们的例子，我们抽取了 1000 人的样本，得到了 63％，我们想知道，随机抽样的 1000 人中有 63％ 的足球爱好者的概率是多少。使用这个直方图，我们可以说有（大概）25％的概率，我们会得到一个小于或等于 63％ 的值。该理论告诉我们，我们实际上并不需要得到无限的样本，如果我们随机选择 1000 人，只有 63％ 的人喜欢足球是可能发生的。所以，我们不知道在美国热爱足球的人的实际比例。我们所知道的是，如果我们从总体分布取无数个样本，它将如下所示：

[^2018-03-28-6]: [我们常听说的置信区间与置信度到底是什么？](https://www.jiqizhixin.com/articles/2018-03-28-6)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fpx2stiwi6j30mn0dxdh7.jpg)

这里 μ 是总体分布的平均值（我们例子中足球爱好者的实际百分比），σ 是总体分布的标准差。如果我们知道这一点（并且我们知道标准差），我们可以说约 64％ 的样本会落在红色区域，或者 95％ 以上的样品会落在图中的绿色区域之外：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fpx2thehizj30o209idho.jpg)

如果我们在之前假设的实际百分比 65％ 上使用该图，那么 95％ 以上的样本将在 62％ 和 68％ 之间（+ - 3）。当然，距离是对称的，所以如果样本有 95% 落在在实际百分比 -3 和 +3 之间，那么真实百分比落在样本百分比 -3 和 +3 之间的概率为 95％。如果我们抽取一个样本，得到了 63％，那么我们可以说我们 95％ 确信实际比例在 60％（63-3）和 66％（63 + 3）之间。这就是置信区间，区间为 63 + -3，置信度为 95％。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fpx2txmfr4j30u00k4jtj.jpg)

# 假设检验分类

假设检验可以分为参数检验和非参数检验。在用样本数据对总体信息做出统计推断时，通常要求抽样应满足随机性和独立性，因为几乎所有的抽样定理都是建立在数据独立的基础之上的。而在用样本数据对正态总体参数做出统计推断（例如参数估计和假设检验）时，还要附加一个要求：样本数据应服从正态分布，这种数据分布类型已知的总体参数的假设称为参数假设检验。与参数假设检验相对应的还有非参数假设检验，例如分布的正态性检验，样本的随机性检验等，这类检验通常只假定分布是连续的或对称的，并不要求数据服从正态分布。

## 参数检验

参数检验要求样本来源于正态总体（服从正态分布），且这些正态总体拥有相同的方差，在这样的基本假定（正态性假定和方差齐性假定）下检验各总体均值是否相等，属于参数检验。

参数检验的四种函数分为anova1，anova2，anovan，manova1。他们都基于共同的两个假设：正态性假定和方差齐性假定 ，分别对应着函数lillietest 和vartestn。

- 设总体服从正态分布，在方差已知的条件下，若对期望进行检验，可用U-检验。
- 设总体服从正态分布，如果方差未知，对期望进行检验，可用T—检验。
- 对于单个正态总体有关方差检验的问题，我们可用$\chi^2$—检验来解决。
- 比较两个正态总体的方差是否相等，我们就要用下面的F—检验。


### T检验和F检验的关系

t检验有单样本t检验，配对t检验和两样本t检验。单样本t检验：是用样本均数代表的未知总体均数和已知总体均数进行比较，来观察此组样本与总体的差异性。配对t检验：是采用配对设计方法观察以下几种情形，1，两个同质受试对象分别接受两种不同的处理；2,同一受试对象接受两种不同的处理；3，同一受试对象处理前后。

F检验又叫方差齐性检验。

若是单组设计，必须给出一个标准值或总体均值，同时，提供一组定量的观测结果，应用t检验的前提条件就是该组资料必须服从正态分布；若是配对设计，每对数据的差值必须服从正态分布；若是成组设计，个体之间相互独立，两组资料均取自正态分布的总体，并满足方差齐性。之所以需要这些前提条件，是因为必须在这样的前提下所计算出的t统计量才服从t分布，而t检验正是以t分布作为其理论依据的检验方法。简单来说就是实用T检验是有条件的，其中之一就是要符合方差齐次性，这点需要F检验来验证。

t检验过程，是对两样本均数(mean)差别的显著性进行检验。在两样本t检验、惟t检验中须知道两个总体的方差(Variances)是否相等；t检验值的计算会因方差是否相等而有所不同。也就是说，t检验须视乎方差齐性(Equality of Variances)结果。所以，SPSS在进行t-test for Equality of Means的同时，也要做Levene's Test for Equality of Variances ，故所以就用F检验（F值）。（从两研究总体中随机抽取样本，要对这两个样本进行比较的时候，首先要判断两总体方差是否相同，即方差齐性。若两总体方差相等，则直接用t检验，若不等，可采用t'检验或变量变换或秩和检验等方法。）

> 到底看哪个Levene's Test for Equality of Variances一栏中sig,还是看t-test for Equality of Means中那个Sig. (2-tailed)啊?
答案是：两个都要看。先看Levene's Test for Equality of Variances，如果方差齐性检验「没有显著差异」，即两方差齐(Equal Variances)，故接著的t检验的结果表中要看第一排的数据，亦即方差齐的情况下的t检验的结果。 反之，如果方差齐性检验「有显著差异」，即两方差不齐(Unequal Variances)，故接著的t检验的结果表中要看第二排的数据，亦即方差不齐的情况下的t检验的结果。

### 单正态总体均值的假设检验

方差未知，单个正态总体的均值μ的假设检验( t检验法)
```
函数  
ttest
格式  
h = ttest(x,m)   % x为正态总体的样本，m为均值μ0，显著性水平为0.05
h = ttest(x,m,alpha)   %alpha为给定显著性水平
[h,sig,ci] = ttest(x,m,alpha,tail)   %sig为观察值的概率，当sig为小概率时则对原假设提出质疑，ci为真正均值μ的1-alpha置信区间。
说明  若h=0，表示在显著性水平alpha下，不能拒绝原假设；
      若h=1，表示在显著性水平alpha下，可以拒绝原假设。
      原假设： ，
若  tail=0，表示备择假设： （默认，双边检验）；
tail=1，表示备择假设： （单边检验）；
tail=-1，表示备择假设： （单边检验）。
```

### 单正态总体方差的假设检验


### 两正态总体均值的假设检验


两个正态总体均值差的检验（t检验）
```
两个正态总体方差未知但等方差时，比较两正态总体样本均值的假设检验
函数  ttest2  
格式  [h,sig,ci]=ttest2(X,Y)    %X，Y为两个正态总体的样本，显著性水平为0.05
      [h,sig,ci]=ttest2(X,Y,alpha)   %alpha为显著性水平
[h,sig,ci]=ttest2(X,Y,alpha,tail)   %sig为当原假设为真时得到观察值的概率，当sig为小概率时则对原假设提出质疑，ci为真正均值μ的1-alpha置信区间。
说明  若h=0，表示在显著性水平alpha下，不能拒绝原假设；
      若h=1，表示在显著性水平alpha下，可以拒绝原假设。
      原假设： ，  ( 为X为期望值， 为Y的期望值)
若    tail=0，表示备择假设： （默认，双边检验）；
tail=1，表示备择假设： （单边检验）；
tail=-1，表示备择假设： （单边检验）。
```

### 两正态总体方差的假设检验

### 大样本非正态总体均值的假设检验

## 非参数检验

> [MATLAB参数统计与假设检验-常用非参数检验](http://blog.csdn.net/matlab_matlab/article/details/56005671)  
> [非参数检验](http://rpubs.com/xuefliang/153258)

当数据不满足正态性和方差齐性假定时，参数检验可能会给出错误的答案，此时应采用基于秩的非参数检验。

大样本情形下，对于非正态总体，可以利用中心极限定理近似用标准正态分布进行假设检验。小样本情形，若总体不是正态分布的，可以使用非参数检验的方法。非参数检验的效率稍差，但适应各种总体类型，应用范围较广。

两种非参数检验：Kruskal-Wallis检验，Friedman检验。

### 游程检验

在实际应用中，需要对样本数据的随机性和独立性作出检验，这要用到游程检验，它是一种非参数检验，用来检验样本数据的随机性，通常人们认为满足随机性的样本数据也满足独立性。在以一定顺序（如时间）排列的有序数列中，具有相同属性（如符号）的连续部分被称为一个游程，一个游程中所包含数据的个数称为游程的长度，通常用R表示一个数列中的游程总数。

MATLAB统计工具箱中提供了runstest函数，用来做游程检验。

### friedman test

friedman test中的p值是该test中使用的Chi-sq分布的q值，当该值小于我们设定的significance level时，我们认为假设（treatment没有影响）成立时极小概率的事件发生，从而拒绝该假设。在matlab中的treatment设定为矩阵的列，即列对应的变量对数据没有影响。

stats结构体中的meanranks是各列rank的平均值，在matlab中是给同一行中较大的值赋给较大的ra搜索nk,所以最小的值的rank为1，第二小的为2，以此类推。每行赋给rank后就求每列的平均rank,如果列变量对数据影响不大的话rank 一般会比较接近，friedman test用这些平均值构建了一个统计量，它符合chi-sq分布，如果该分布下极小概率的事件发生，我们拒绝假设并认为列变量对数据有影响。

### 符号检验

符号检验还可用于配对样本的比较检验，符号检验法是通过两个相关样本的每对数据之差的符号进行检验，从而比较两个样本的显著性。具体地讲，若两个样本差异不显著，正差值与负差值的个数应大致各占一半。

MATLAB统计工具箱中提供了signtest函数，用来符号检验。

两个总体中位数相等的假设检验——符号检验

```
函数  
signtest
格式  
p=signtest(X, Y, alpha)   % X、Y为两个总体的样本，长度必须相同，alpha为显著性水平，P两个样本X和Y的中位数相等的概率，p接近于0则可对原假设质疑。
[p, h]=signtest(X, Y, alpha)  % h为检验结果：h=0表示X与Y的中位数之差不显著，h=1表示X与Y的中位数之差显著。
[p,h,stats] = signtest(X,Y,alpha)  % stats中sign为符号统计量的值
```

### 曼-惠特尼秩和检验

曼-惠特尼U检验又称“曼-惠特尼秩和检验”，是由H.B.Mann和D.R.Whitney于1947年提出的。它假设两个样本分别来自除了总体均值以外完全相同的两个总体，目的是检验这两个总体的均值是否有显著的差别。

MATLAB统计工具箱中提供了ranksum函数，用来做秩和检验。

两个总体一致性的检验——秩和检验
```
函数  ranksum
格式  p = ranksum(x,y,alpha)   %x、y为两个总体的样本，可以不等长，alpha为显著性水平，它必须为0和1之间的数量。该检验零假设认为x和y的总体是同分布的。
      [p,h] = ranksum(x,y,alpha)   % h为检验结果，h=0表示X与Y的总体差别不显著，h=1表示X与Y的总体差别显著
      [p,h,stats] = ranksum(x,y,alpha)  %stats中包括：ranksum为秩和统计量的值以及zval为过去计算p的正态统计量的值
说明：
p返回产生两独立样本的总体是否相同的显著性概率，h返回假设检验的结果。
如果x和y的总体差别不显著，则h为零；如果x和y的总体差别显著，则h为1。
如果p接近于零，则不一致较明显，可对原假设质疑。
```

### Wilcoxon符号秩检验

符号检验只考虑的分布在中位数两侧的样本数据的个数，并没有考虑中位数两侧数据分布的疏密程度，这就使得符号检验的结果比较粗糙，检验功率较低。统计学家维尔科克森在1945年，提出了一种更为精细的“符号秩检验法”，该方法是在配对样本的符号检验基础上发展起来的，比传统的单独用正负号的检验更加有效。它适用于单个样本中位数的检验，也适用于配对样本的比较检验，但并不要求样本之差服从正态分布，只要求对称分布即可。

威尔科克森符号秩检验（Wilcoxon Signed Rank Test）亦称威尔科克伦代符号的等级检验，是由威尔科克森（F·Wilcoxon）于1945年提出的。该方法是在成对观测数据的[符号检验](http://baike.baidu.com/view/2135302.htm)基础上发展起来的，比传统的单独用[正负号](http://baike.baidu.com/view/2114114.htm)的检验更加有效。

在Wilcoxon符号秩检验中，它把观测值和零假设的中心位置之差的绝对值的秩分别按照不同的符号相加作为其检验统计量。它适用于T检验中的成对比较，但并不要求成对数据之差di服从正态分布，只要求对称分布即可。检验成对观测数据之差是否来自[均值](http://baike.baidu.com/view/1052684.htm)为0的总体（产生数据的总体是否具有相同的均值）。

> paired t-test：检验两组均值是否相等。
Wilcoxon signed-rank test： 检验两组的中位数是不是相等。这个是paired t-test的非参检验版本的类比。从名字可以看出就是用两组数的rank信息。因为t test是在正态条件下，当数据偏的离谱的时候，就没法用t了。所以只好做出牺牲，用Wilcoxon signed-rank test。 但于此同时，你可以看到，你能得到的结果弱的多了。

在小样本下，可能不符合normal分布，同样，用渐近分布（样本量趋向无穷），也不合适（应为只有5个样本），不满足T检验要求，那么采用非参（放宽了这个条件）。

wilcoxon signed rank test针对一元数据 or 配对数据的。wilcoxon rank sum test or MWW Test是两组数据的。

MATLAB统计工具箱中提供了signrank函数，用来做Wilcoxon（威尔科克森）符号秩检验。

[Wilcoxon Signed Rank Test举例](http://sphweb.bumc.bu.edu/otlt/MPH-Modules/BS/BS704_Nonparametric/BS704_Nonparametric6.html)

两个总体中位数相等的假设检验——符号秩检验
```
函数  signrank
格式  p = signrank(X,Y,alpha)   % X、Y为两个总体的样本，长度必须相同，alpha为显著性水平，P两个样本X和Y的中位数相等的概率，p接近于0则可对原假设质疑。
      [p,h] = signrank(X,Y,alpha)   % h为检验结果：h=0表示X与Y的中位数之差不显著，h=1表示X与Y的中位数之差显著。
      [p,h,stats] = signrank(x,y,alpha)   % stats中包括：signrank为符号秩统计量的值以及zval为过去计算p的正态统计量的值。
```


# 显著性检验

> [关于显著性检验，你想要的都在这儿了！！（基础篇）](http://www.cnblogs.com/hdu-zsk/p/6293721.html)  

无论你从事何种领域的科学研究还是统计调查，显著性检验作为判断两个乃至多个数据集之间（实验组与对照组之间）是否存在差异以及差异是否显著的方法被广泛应用于各个科研领域。

在统计学中，**显著性检验是“统计假设检验”的一种**，所谓统计假设检验就是事先对总体（随机变量）的参数或总体分布形式做出一个假设，然后利用样本信息来判断这个假设是否合理。而把**只限定第一类错误概率的统计假设检验**就称之为显著性检验。

任何人在使用显著性检验之前必须在心里明白自己的科研假设是什么，否则显著性检验就是“水中月，镜中花”，可望而不可即。如果原假设为真，而检验的结论却劝你放弃原假设。此时，我们把这种错误称之为**第一类错误**。通常把第一类错误出现的概率记为α。如果原假设不真，而检验的结论却劝你不放弃原假设。此时，我们把这种错误称之为**第二类错误**。通常把第二类错误出现的概率记为β。**通常只限定犯第一类错误的最大概率α，不考虑犯第二类错误的概率β。我们把这样的假设检验称为显著性检验，概率α称为显著性水平**。

> eg
赵先生开了一家日用百货公司，该公司分别在郑州和杭州开设了分公司。现在存在下列数据作为两个分公司的销售额，集合中的每一个数代表着一年中某一个月的公司销售额。现在，赵先生想要知道两个公司的销售额是否有存在明显的差异。
     郑州分公司Z = {23,25,26,27,23,24,22,23,25,29,30}
     杭州分公司H = {24,25,23,26,27,25,25,28,30,31,29}  
> 他的假设就是“样本集Z（郑州分公司）和样本集H（杭州分公司）不存在显著性差异，换言之这两个集合没有任何区别（销售额间没有区别）！”这个假设（Hypothesis）正是方差检验的原假设（null hypothesis）。  
> 在显著性水平α =0.05的情况下，p>0.05接受原假设，p值＜0.05拒绝原假设。  
> 方差检验不适用于估计参数和估计总体分布，而是用于检验试验的两个组间是否有差异。而方差检验正是用于检测我们所关心的是这两个集合（两个分布）的均值是否存在差异。  
> 虽然杭州分公司的年平均销售额26.63大于郑州分公司的销售额25.18。方差检验的p 值= 0.2027，意味着销售额没有明显差异。


# 讨论



## 所有的检验统计都是正态分布的吗

并不完全如此，但大多数检验都直接或间接与之有关，可以从正态分布中推导出来，如t检验、f检验或卡方检验。这些检验一般都要求：所分析变量在总体中呈正态分布，即满足所谓的正态假设。许多观察变量的确是呈正态分布的，这也是正态分布是现实世界的基本特征的原因。当人们用在正态分布基础上建立的检验分析非正态分布变量的数据时问题就产生了，（参阅非参数和方差分析的正态性检验）。这种条件下有两种方法：一是用替代的非参数检验（即无分布性检验），但这种方法不方便，因为从它所提供的结论形式看，这种方法统计效率低下、不灵活。另一种方法是：当确定样本量足够大的情况下，通常还是可以使用基于正态分布前提下的检验。后一种方法是基于一个相当重要的原则产生的，该原则对正态方程基础上的总体检验有极其重要的作用。即，随着样本量的增加，样本分布形状趋于正态，即使所研究的变量分布并不呈正态。

## 如何判定结果具有真实的显著性

在最后结论中判断什么样的显著性水平具有统计学意义，不可避免地带有武断性。换句话说，认为结果无效而被拒绝接受的水平的选择具有武断性。实践中，最后的决定通常依赖于数据集比较和分析过程中结果是先验性还是仅仅为均数之间的两两>比较，依赖于总体数据集里结论一致的支持性证据的数量，依赖于以往该研究领域的惯例。通常，许多的科学领域中产生p值的结果≤0.05被认为是统计学意义的边界线，但是这显著性水平还包含了相当高的犯错可能性。结果0.05≥p>0.01被认为是具有统计学意义，而0.01≥p≥0.001被认为具有高度统计学意义。但要注意这种分类仅仅是研究基础上非正规的判断常规。

## p值统计学意义

> [统计学假设检验中 p 值的含义具体是什么？](https://www.zhihu.com/question/23149768)

In statistical hypothesis testing, the [p-value](https://en.wikipedia.org/wiki/P-value) or probability value is the probability for a given statistical model that, when the null hypothesis is true, the statistical summary (such as the sample mean difference between two compared groups) would be the same as or of greater magnitude than the actual observed results.[1] The use of p-values in statistical hypothesis testing is common in many fields of research[2] such as economics, finance, political science, psychology,[3] biology, criminal justice, criminology, and sociology.[4] Their misuse has been a matter of considerable controversy.

结果的统计学意义是结果真实程度（能够代表总体）的一种估计方法。专业上，p值为结果可信程度的一个递减指标，p值越大，我们越不能认为样本中变量的关联是总体中各变量关联的可靠指标。p值是将观察结果认为有效即具有总体代表性的犯错概率。

这里有一个超级好懂的解释：

- P值大小指示的是假阳性的出现概率，代表了研究者对假阳性的容忍度。“P≤0.05 reflects our level of tolerance for false-positive results."
- 当我们检验一个统计假设H0时，p值是当H0为真时样本结果或者更极端结果出现的概率。p值越小，也就越应该拒绝原假设，也就是结果越显著。

从本质上讲，p值只是结果在现有实验条件下是否可能是随机产生的度量，它对应的因果链是p值越小，结果越不可能随机产生，贝叶斯因子也就越大。但这不代表Pr(H1|xobs)/Pr(H0|xobs)就越大。因为根据上述的公式，它还依赖于H1和H0概率的比值，也就是先验风险。

如p=0.05提示样本中变量关联有5%的可能是由于偶然性造成的。即假设总体中任意变量间均无关联，我们重复类似实验，会发现约20个实验中有一个实验，我们所研究的变量关联将等于或强于我们的实验结果。（这并不是说如果变量间存在关联，我们可得到5%或95%次数的相同结果，当总体中的变量存在关联，重复研究和发现关联的可能性与设计的统计学效力有关。）在许多研究领域，0.05的p值通常被认为是可接受错误的边界水平。

2014年2月，美国曼荷莲学院（Mount Holyoke College）数学与统计学教授George Cobb在美国统计学会（American Statistical Association, ASA）的论坛上提出了两个问题：**问：为什么这么多学校都在教“P=0.05”？答：因为科学界和期刊编辑现在还用这个。问：为什么这么多人还在用“P=0.05”？答：因为学校就是这么教的。**

**为什么选择.005呢？** 作者们写下如下两点原因：第一、.005大约与贝叶斯因子的14~26相对应，是比较强的证据；第二、.005在许多研究领域者能够较好地控制假阳性（关于假阳性的控制，可以看这个帖子：[控制一类错误和二类错误](https://zhuanlan.zhihu.com/p/23334271)）；



There is widespread agreement that p-values are often misused and misinterpreted.[21][22][23] One practice that has been particularly criticized is accepting the alternative hypothesis for any p-value nominally less than .05 without other supporting evidence. Although p-values are helpful in assessing how incompatible the data are with a specified statistical model, contextual factors must also be considered, such as "the design of a study, the quality of the measurements, the external evidence for the phenomenon under study, and the validity of assumptions that underlie the data analysis".[23] Another concern is that the p-value is often misunderstood as being the probability that the null hypothesis is true.[23][24] Some statisticians have proposed replacing p-values with alternative measures of evidence,[23] such as confidence intervals,[25][26] likelihood ratios,[27][28] or Bayes factors,[29][30][31] but there is heated debate on the feasibility of these alternatives.[32][33] Others have suggested to remove fixed significance thresholds and to interpret p-values as graded measures of the strength of evidence against the null hypothesis.[34]

> [p-values Controversy](https://en.wikipedia.org/wiki/P-value#Controversy)  
> [Misunderstandings of p-values](https://en.wikipedia.org/wiki/Misunderstandings_of_p-values)

在阅读了太多不可重复或者包含统计错误的论文（或者同时出现）后，ASA决定行动起来：2016年3月7日，ASA正式发表了使用和解释P值的“六原则”（[Wasserstein, R. L., & Lazar, N. A. (2016). The ASA's statement on p-values: context, process, and purpose. The American Statistician](http://amstat.tandfonline.com/doi/pdf/10.1080/00031305.2016.1154108)）。我们使用P值来检测组间或方法间的差别、评估目标变量间的关系，等等。但ASA指出，P值被广泛误用了。

ASA对这六个原则进行了具体的阐释：

**1. P值可以指示数据与一个给定模型的不相容程度。（P-values can indicate how incompatible the data are with a specified statistical model.）**

我们基于一系列的假设建立的模型称为原假设；我们同时还会建立零假设（null hypothsis），即指某种我们想要检测的效应不存在，例如两组无差，或者某个因子与结果无关。P值越小，说明数据与零假设之间越不相容。这里的不相容，可以解释为对零假设的存疑程度。

**2. P值不能衡量某假设为真的概率，也不能衡量数据仅由随机因素造成的概率。（P-values do not measure the probability that the studied hypothesis is true, or the probability that the data were produced by random chance alone.）**

尽管研究者常常希望计算出零假设是否为真，或是算出观测结果仅由随机事件造成的概率，但P值的作用并不是这个，P值只解释数据与假设之间的关系，它并不解释假设本身。

**3. 科学结论、商业决策或政策制定，不应只取决于P值是否达到了一个给定标准。（Scientific conclusions and business or policy decisions should not be based only on whether a p-value passes a specific threshold. ）**

为了给某种科学主张或论断提供佐证而把数据分析或科学评估[我怀疑“还原”这个词是不是有点不准确，但我可以理解，“简化”？]简化成一种机械性的规则（例如p<0.05），这会导致错误的结论和糟糕的决定。一个结论的正确与否并不会因为研究者算出的P值大于还是小于0.05而改变[虽然原作很绕，但这句话吐槽还是很清楚的，它吐槽的是一种是否通过了类似0.05之类的二元类的方法：后文他的观点是如果用P值的话，应该给出具体的大小。如果你改成“P值大小”，实际上把槽点扭曲了。]。研究者需要将很多因子纳入考虑来作出科学推断，包括研究设计、测量的质量、与研究对象有关的外部证据，以及分析数据时使用的假设的合理性等。决策者常常需要根据研究结果作出“做”或“不做”的决定，但p值本身不能决定决策的正确与否。科研界将显著性标准（例如p<0.05）作为发表科学发现（暗示了其真实性）的“许可证”广泛使用，然而这却扭曲了科研的过程。

**4. 研究者需对研究进行完整的报告、保证透明度，才能做出合理的推论。（Proper inference requires full reporting and transparency. ）**

研究者不应选择地报道P值和相关的统计分析。某项研究可能使用了好几种分析方法，而研究者只报告其中的一部分（特别是那些符合标准的），这就使得P 值难以解释。一旦研究者根据统计结果选择性地展示相应的方法，而读者对此并不知情，结果的有效性就打了折扣。研究者应该展示研究过程中检验过的假设的数量、数据收集的方法、所有使用过的统计方法和相应的P值。

**5. P值或统计显著性并不能衡量效应的大小和结果的重要性。（A p-value, or statistical significance, does not measure the size of an effect or the importance of a result. ）**

某项个结果的统计显著性并不代表其在科学、人文的或者经济上的重要性。P值小并不意味着效应更重要，P值大也不代表不重要或没有效应。无论某个效应的影响有多小，当样本量足够大或测量精度足够高时，总能得到小的P值。对于相同的效应，当测量精度不同时，得到不同的P值也会不同。

**6. P值本身并不能衡量模型或假设的可信度。（By itself, a p-value does not provide a good measure of evidence regarding a model or hypothesis.）**

研究者应该意识到，在没有一定的背景时，P值能提供的信息非常有限。接近0.05的P值只能为反驳零假设提供非常弱的证据。同样的，相对大的P值也不一定意味着证据就偏向支持零假设，还是有很多其他的假设可能导致现有的结果。因此，当其他方法适用时，研究者对数据的分析不应止于P值分析。

**为进一步解读“六原则”的意义，关注论文撤稿的博客retractionwatch.com采访了ASA执行主任Ron Wasserstein。**

**R：为什么现在发表“六原则”？是否是因为科学发展到现在阶段让P值误用成为了一个特别急迫的问题？**

**W**：我们是被现在持续加剧的可重复性危机以及人们将此归咎于统计方法的现象刺激了。学术期刊《基础和应用社会心理学》（_Basic and Applied Social Psychology_）的编辑对于P值的误用和误解感到如此的无力，因此在2015年决定禁用这一指标。这一做法更证实了对P值的信任危机已经到来，ASA不能再坐视不管。

**R：部分原则看起来非常直白，但我对第二条有点疑问。我常常听说P值可用来估计数据是否仅由随机过程产生，为什么这是一种错误的想法？**

**W**：让我们设想一个简单的情境来解释这样的想法意味着什么。假设出现了一种针对某严重疾病的新疗法，研究者宣称这比已有的疗法更有效。我们选取2个情况类似的病人配对，一共得到5对这样的病人，给每对中的两个病人随机分配新、旧两种疗法。零假设(无效假设)是指新旧两种疗法在5组内都有50：50的概率更有效。假如零假设为真，新疗法在5个组中都表现出更好的概率是（1/2）5=1/32,约等于0.03.如果在实验中，每组接受新疗法的病人都表现的更好，我们就会得到0.03的p值。它代表的是这样一种概率：当新旧两种疗法实际效果相同时，实验结果显示新疗法全比旧疗法好的概率（即假阳性的概率，译者注）。[如果加注的话这里就很合适]但这不是新旧两种疗法效果相同的概率。

这可能很微妙，但绝非诡辩。这是一个非常常见的逻辑谬误：为了让结论为真，你不得先不假定其为真，然后才能得到这个结论。如果你掉进了这个逻辑谬误，你得到的结论会变为“只有3%的概率这两种疗法疗效相当”，然后认为新疗法有97%的概率更好。你就犯了一个经典并且非常严重的错误。

**R：在研究者使用和解释P值时，他们犯的最大的错误是什么？**

**W：** 有几种错误特别普遍，并且导致了很大的问题。刚刚提到的那个就很常见。另一个是常见的误解是：计算出了较大的P值，就认为零假设为真。还有其他的误解，但引起我们更大重视的是误用的问题，特别是研究者把统计显著性作为科学价值的评价标准。这种误用是糟糕的决策和不能重复的研究的始作俑者之一，最终不仅会危害科学的进步，还会摧毁公众对科学的信任。

**R：有没有哪些领域比其他领域出的错更多？**

**W：** 据我所知还没有人研究过这个问题。我感觉所有科学领域都有诸多明显的错误，但也有研究非常漂亮地使用了统计学方法。但总体来说，在那些对被试者或试验单位进行了多重测量的研究中，P值更易被误用。这种测量方法会给予研究者成为“P值黑客”（即找到一种方法获得满意的P值）的机会，但这种机会却不能给科学本身带来任何益处。

**R：你能否详细解释一下第四条——“研究者需对研究进行完整的报告、保证透明度，才能做出合理的推论”？**

**W：** 这当然有很多可说的，但简而言之，从统计学的角度，这意味着要追踪和报道关于你对数据作的所有决定，包括数据收集的设计和执行过程，以及你在分析数据过程中做的一切。你是否以某种方式进行了跨组平均或合并了组间数据？你是否用数据来决定检测或控制哪个变量，或者在最终的分析中包括和删除了某个变量？你是否不断地增减变量，好让自己的回归模型和系数通过了某个显著性标准？这些决定，以及所有基于数据本身的决定都需要被包括在内。

**R：在随ASA的声明一起发表的内容里，你提到希望学术界能够进入“后p<0.05”时代。这指的是什么呢？如果不使用P值的话，我们应该用什么代替它？**

**W**：在后p<0.05时代，科学论证不应基于P值是否足够小。效应量和置信区间都应被郑重对待。统计结果应被理解为连续、而非二元的。当用这种方法考虑问题时，面对P值，我们应该看到一个数字，而不是一个不等式，如p=0.0168而非p<0.05。所有与推断有关的假设都应该被检测，包括和数据选择和分析方法有关的决定。在后p<0.05时代，数据分析仍然很重要，但没有一种数值，而且必然不是P值，能够代替统计思考和科学推理。

**R： 还有什么要补充的么？**

W：我们很快就会知道这份声明是否能达到它的目的。如果是的话，期刊将不再把统计显著性作为是否接受论文的标准。取而代之、被接受的论文的特征应是：试验设计、执行和分析被清晰细致地描述出来；结论建立在有效的统计解释和科学论点之上；报告得足够全面、透明，能够被其他人严格的审查。我认为这是杂志编辑想要做的，有人已经在做了，但也有一些人这被看起来简单的统计显著性所诱惑。

### p值的选取

Science杂志网站发布了Kelly Servick 撰写的评论：[It will be much harder to call new findings ‘significant’ if this team gets its way](http://www.sciencemag.org/news/2017/07/it-will-be-much-harder-call-new-findings-significant-if-team-gets-its-way?utm_campaign=news_daily_2017-07-25&et_rid=16767597&et_cid=1459082). Kelly Servick依据和引用了Daniel J. Benjamin等72位作者联合署名的、发表在PsyArXiv预发布平台上的文章：[Redefine Statistical Significance](https://osf.io/preprints/psyarxiv/mky9j/). Redefine Statistical Significance即将正式发表在Nature Human Behavior杂志上。P < 0.05的使用及其结果解释，一直受到人们的诟病。为此，Daniel J. Benjamin等建议摒弃一直以来使用的P < 0.05阈值，作为有“统计学意义”的评价金标准；改用更为严格的P < 0.005阈值来作为有“统计学意义”的评价金标准。Daniel J. Benjamin等认为：使用P < 0.005代替P < 0.05，可以将假阳性率从33%（P < 0.05）降到 5%（P < 0.005）。当P < 0.005时，可以认为具有“统计学意义”；当0.005< P <0.05时，可以认为具有“suggestive或暗示”价值。依据Daniel J. Benjamin等作者的估计，选择P < 0.005阈值时，实验研究的样本量至少要增加70%。Daniel J. Benjamin解释道：大多数研究人员都认识到，在P < 0.05阈值条件下获得的证据，其可靠性差。他们的文章以及提出的新标准是为了帮助人们更好的理解实验研究证据。如果，Daniel J. Benjamin等72位作者的观点能够获得科学界的认可和支持，是否就会意味着使用了百年以上的P < 0.05阈值将退出历史舞台？！我们将拭目以待。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>HypothesisTesting</tag>
      </tags>
  </entry>
  <entry>
    <title>情报检索</title>
    <url>/information-search/</url>
    <content><![CDATA[
“情报检索”是指将情报(信息)按一定方式组织和存贮起来,。对于情报用户来说，情报检索仅指过程的后一部分，即情报(信息)的查找过程。情报检索的目的是为了解决特定的情报需求和满足情报用户的需要。它根据检索（查找）对象的不同，又可以分为文献检索、事实检索和数据检索。

<!--more-->

<div id="search-tips"></div>

# 搜索技巧

- 精确匹配搜索：`“关键词”`（不加则并列显示结果）
- 文件类型搜索：`filetype:文件类型 关键词`
- 定位于某个网站的搜索：`关键词 site:网站`
- 选择来源网站搜索：`关键词 网站类型 filetype:文件类型`
- 开源网址：用`awesome`加你想要搜索的关键词

更多搜索语法技巧自行查阅。

<div id="resource"></div>

# 数据搜索引擎

1. 通用信息检索，利用[搜索技巧](#search-tips)进行**谷歌搜索**（[谷歌访问配置](https://sli1989.github.io/windows-use/#google)）。
1. 善用垂直类引擎：
    - [国家数据](http://data.stats.gov.cn/)
    - [中国统计信息网](http://www.tjcn.org/)
1. 使用网盘搜索器引擎：
    - [资源搜索引擎](https://iui.su/3700/)
	- [盘搜](http://www.vpansou.com/)
    - [fastsoso](https://www.fastsoso.cn/)

<div id="theoretical-knowledge"></div>

# 理论知识

1. 常见的理论知识查阅，使用[读秀学术搜索](https://www.duxiu.com/)或[超星发现](https://www.zhizhen.com/)
1. 更加全面的理论知识，选择[知网](https://www.cnki.net/)检索硕博论文即可。
1. 还有一些博客网站（[博客园](http://www.cnblogs.com/)，[CSDN博客](http://blog.csdn.net/)），学习博主的知识总结。
1. 其它可以尝试[百度文库](https://wenku.baidu.com/)。
    - 配合[Tampermonkey 插件](https://tampermonkey.net/?ext=dhdg&browser=chrome)使用[JS脚本](https://greasyfork.org/zh-CN/scripts?q=%E7%99%BE%E5%BA%A6%E6%96%87%E5%BA%93)。

<div id="online-courses"></div>

# 在线课程

- [NPTEL](http://nptel.ac.in/)
- [Khan Academy](https://zh-hans.khanacademy.org/)：可汗学院是一个负有使命的组织。作为一个非营利组织，我们的目的是，通过给所有人提供免费的世界级教育平台，来改善教育。

<div id="literature-search"></div>

# 文献检索引擎

文献检索(document retrieval)是在科学研究，撰写论文时所必需的一种手段。

最简单的文献检索方法就是利用 **[谷歌学术搜索](https://scholar.google.com/)** （[谷歌访问配置](https://sli1989.github.io/windows-use/#google)）和 **[百度学术搜索](http://xueshu.baidu.com/)** 服务。第三方学术搜索合辑如[chongbuluo](http://scholar.chongbuluo.com/)等。

常用数据库：

1. [中国知网知识发现网络平台](https://www.cnki.net/)，[万方数据库](http://www.wanfangdata.com.cn/)。[中国知网知识发现网络平台-海外版](https://chn.oversea.cnki.net/index/)提供PDF版本的下载。
1. [Scopus](https://www.scopus.com/home.uri?zone=header&origin=AuthorProfile)（**推荐使用**），可以进行学者跟踪，收录较及时。
1. [Web of Science (WOS)](http://apps.webofknowledge.com/)，[Engineering Information Village](https://www.engineeringvillage.com/search/quick.url?database=3)，此类数据库收录不及时。

<div id="literature-download"></div>

# 图书资料下载

> [在哪里可以找到英文原版书下载地址](https://www.zhihu.com/question/21253522)

<div id="scihub"></div>

- 外文文献：在[科学上网配置](https://sli1989.github.io/windows-use/#goagent)的基础上，获取论文题目或论文[DOI](https://sli1989.github.io/reference-manage/#doi)（推荐[CROSSREF数据库](https://search.crossref.org/)），最后使用Sci-Hub数据库下载。
    - [Sci-Hub 可用网址1](http://tool.yovisun.com/scihub/)。或者使用Sci-Hub桌面客户端：SciHub Desktop，[Sci-Hub EVA](https://github.com/leovan/SciHubEVA) 。（[四款桌面客户端软件性能评测](https://zhuanlan.zhihu.com/p/37471780)）
    - Chrome用户则<font color=red>推荐</font>使用 [Sci-hub Links 谷歌插件](https://pan.baidu.com/s/1Hgkdp3vnKCVIREm_6InD_Q)（提取码：4pbu）。（替代软件 [Auto_Sci-Hub](https://github.com/RoiArthurB/Side-Auto_Sci-Hub)）
        1. 下载插件，解压得到 `SciHubLinks_for_chrome_1.2.3` 文件夹
        1. 进去谷歌浏览器插件管理器页面 `chrome://extensions`，开启`开发者模式`，选择`加载已解压的扩展程序`，选择到 `SciHubLinks_for_chrome_1.2.3` 文件夹
        2. 找到浏览器插件栏中的`Sci-hub Links`，右键选择`选项`，填写可用的Sci-Hub地址，如`sci-hub.se`，即可启用插件，在浏览器页面中<font color=blue>直接点击</font> `PMID` 或者 `DOI` 链接直接下载文献（按住 `Ctrl` 键可用还原链接）。
		2. [禁用`请停用以开发者模式运行的扩展程序`提示](https://blog.csdn.net/ldu_liuyang/article/details/106333321)：关闭Chrome浏览器，在`chrome.exe`所在的目录以管理员身份运行[补丁文件](https://pan.baidu.com/s/1TQ-u-kgL09mnrRz1vj5kUA)（提取码：wkr3）。
- [Internet Archive Search](https://archive.org/search.php)
- [ScienceHuβ](https://scihub.org/search/)，[The National Academies Press](https://www.nap.edu/)，[Open Access Theses and Dissertations](https://oatd.org/)
- **英文书籍搜索推荐引擎**：[Jiumo E-Book Search 鸠摩搜书](https://www.jiumodiary.com/)，[Zlibrary](https://anotherdayu.com/2022/3809/),[Library Genesis](http://gen.lib.rus.ec/)，[Free ebooks - Project Gutenberg](http://www.gutenberg.org/)，[hathitrust](https://www.hathitrust.org/)，[PDF Drive](https://www.pdfdrive.com/)，[PDF search engine](https://pdf-downloads.net/)
- **中文书籍搜索推荐引擎**
    - [Jiumo E-Book Search 鸠摩搜书](https://www.jiumodiary.com/)
    - [全国图书馆参考咨询联盟](http://www.ucdrs.superlib.net/) ：通过脚本[获取或购买图书](https://greasyfork.org/zh-CN/scripts?q=%E5%9B%BE%E4%B9%A6%E9%A6%86%E5%8F%82%E8%80%83%E5%92%A8%E8%AF%A2%E8%81%94%E7%9B%9F&sort=total_installs)进行购买，
    - 需要图书馆权限：[读秀学术搜索](http://www.duxiu.com/login.jsp)，[超星汇雅电子图书数据库](http://edu.sslibrary.com/)
- 电子书：[SoBooks（原"SoKindle"）](https://sobooks.cc/)

<div id="code-download"></div>

# 代码库

部分资源**需要自己上传资源获取积分后才能下载**，或者考虑通过淘宝等渠道购买，注意防骗。

- [CSDN](http://download.csdn.net/search?keywords=)
- [编程源码资料联合开发网](http://www.pudn.com/)
- [Searchcode](https://searchcode.com/)，[Github](https://github.com/)，[Codeplex](https://www.codeplex.com/)、[Sourceforge](https://sourceforge.net/)等开源站点
- [File exchange](https://cn.mathworks.com/matlabcentral/fileexchange/)提供了一些常用的matlab源代码资源。
- [Machine Learning open source software](http://mloss.org/software/)
- [Stack Overflow](http://stackoverflow.com/)
- [NASA Open Source Software](https://code.nasa.gov/#/)
- [Codase - Source Code Search Engine](http://www.codase.com/)

<div id="patent-search"></div>

# 专利搜索引擎

目前专利检索主要分收费和免费的商业数据库，

- [中国专利公布公告](http://epub.cnipa.gov.cn/)
- [智慧芽（PatSnap）](https://analytics.zhihuiya.com/)
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>文献检索</tag>
        <tag>科研经验</tag>
        <tag>数据检索</tag>
      </tags>
  </entry>
  <entry>
    <title>Jacobian矩阵</title>
    <url>/jacobian/</url>
    <content><![CDATA[
在向量分析中， 雅可比矩阵是一阶偏导数以一定方式排列成的矩阵， 其行列式称为雅可比行列式。 还有， 在代数几何中， 代数曲线的雅可比量表示雅可比簇：伴随该曲线的一个代数群， 曲线可以嵌入其中。 它们全部都以数学家卡尔·雅可比(Carl Jacob， 1804年10月4日－1851年2月18日)命名；英文雅可比量”Jacobian”可以发音为[ja ˈko bi ən]或者[ʤə ˈko bi ən]。

<!--more-->

# 雅可比矩阵

雅可比矩阵的重要性在于它体现了一个可微方程与给出点的最优线性逼近。 因此， 雅可比矩阵类似于多元函数的导数。

假设 $F: {R_n} \to {R_m}$ 是一个从欧式n维空间转换到欧式m维空间的函数。 这个函数由m个实函数组成：$y_1(x_1,\cdots,x_n), \cdots , y_m(x_1,\cdots ,x_n)$ 。 这些函数的偏导数(如果存在)可以组成一个m行n列的矩阵， 这就是所谓的雅可比矩阵[^1]：

[^1]: [Jacobian矩阵和Hessian矩阵](http://jacoxu。com/jacobian%E7%9F%A9%E9%98%B5%E5%92%8Chessian%E7%9F%A9%E9%98%B5/)

$$
\begin{bmatrix}
\frac{\partial y_1}{\partial x_1}  \cdots  \frac{\partial y_1}{\partial x_n} \\
\vdots  \ddots  \vdots \\
\frac{\partial y_m}{\partial x_1}  \cdots \frac{\partial y_m}{\partial x_n}  
\end{bmatrix}
$$

此矩阵表示为: ${J_F}({x_1}, \ldots ,{x_n})$, 或者 $\frac{\partial ({y_1}, \ldots , {y_m})}{\partial ({x_1}, \ldots , {x_n})}$ 。

这个矩阵的第i行是由梯度函数的转置 $y_i(i=1, \ldots, m)$ 表示的。

如果 ${\bf{p} }$ 是 ${R_n}$ 中的一点， $F$ 在 ${\bf{p} }$ 点可微分， 那么在这一点的导数由 ${J_F}({\bf{p} })$ 给出(这是求该点导数最简便的方法)。 在此情况下， 由 $F({\bf{p} })$ 描述的线性算子即接近点 ${\bf{p} }$ 的 $F$ 的最优线性逼近， ${\bf{x} }$ 逼近于 ${\bf{p} }$ :

$$F({\bf{x} }) \approx F({\bf{p} }) + {J_F}({\bf{p} }) \cdot ({\bf{x} } \cdot  {\bf{p} })$$

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125302.png)

# 雅可比行列式

如果m = n， 那么$F$是从n维空间到n维空间的函数， 且它的雅可比矩阵是一个方块矩阵。 于是我们可以取它的行列式， 称为雅可比行列式。

在某个给定点的雅可比行列式提供了 在接近该点时的表现的重要信息。 例如， 如果连续可微函数$F$在 ${\bf{p} }$ 点的雅可比行列式不是零， 那么它在该点附近具有反函数。 这称为反函数定理。 更进一步， 如果 ${\bf{p} }$ 点的雅可比行列式是正数， 则$F$在 ${\bf{p} }$ 点的取向不变；如果是负数， 则$F$的取向相反。 而从雅可比行列式的绝对值， 就可以知道函数 $F$ 在 ${\bf{p} }$ 点的缩放因子；这就是为什么它出现在换元积分法中。

对于取向问题可以这么理解， 例如一个物体在平面上匀速运动， 如果施加一个正方向的力$F$， 即取向相同， 则加速运动， 类比于速度的导数加速度为正；如果施加一个反方向的力 $F$ ， 即取向相反， 则减速运动， 类比于速度的导数加速度为负。

# 雅可比求矩阵特征值和特征向量

> [Jacobi迭代求矩阵特征值和特征向量+C代码](http://blog.csdn.net/u014070279/article/details/48208753)，[矩阵的特征值和特征向量的雅克比算法C/C++实现](http://blog.csdn.net/zhouxuguang236/article/details/40212143)


矩阵的特征值和特征向量是线性代数以及矩阵论中非常重要的一个概念。在遥感领域也是经常用到，比如多光谱以及高光谱图像的主成分分析要求解波段间协方差矩阵或者相关系数矩阵的特征值和特征向量。

根据普通线性代数中的概念，特征值和特征向量可以用传统的方法求得，但是实际项目中一般都是用数值分析的方法来计算，这里介绍一下雅可比迭代法求解特征值和特征向量。


# MATLAB计算雅可比

计算雅可比（Jacobi）矩阵及其行列式的MATLAB方法[^3]：

[^3]: [计算雅可比（Jacobi）矩阵及其行列式的MATLAB方法](http://yishouce.com/book/3/3080402.html)

```
syms x y z
T=[x y z]; u=3*(x-1)^2*exp(-(x+1)^2-y^2);
v=x^2-2*x+y^2+2*z+1; w=3*x*y*z;
f=[u;v;w];
Jfv=jacobian (f,T)

x=2;y=1;z=5;

%雅可比矩阵
Jfv=[6*(x-1)*exp(-(x+1)^2-y^2)+3*(x-1)^2*(-2*x-2)*exp(-(x+1)^2-y^2),-6*(x-1)^2*y*exp(-(x+1)^2-y^2),0;2*x-2,2*y,2;3*y*z,3*x*z,3*x*y]
%雅可比行列式
Jfd215=det(Jfv)
```

```
syms x y z i j k dx dy dz
T=[x y z];
f=3*(x-1)^2*exp(-(x+1)^2-y^2)+3*x*y*z+x^2-2*x+y^2+2*z+1;
Jfv=jacobian (f,T);
%全微分
Df= Jfv*[dx dy dz]',
%一阶偏导数ux, uy, uz
ux= Jfv(1), uy= Jfv(2), uz= Jfv(3),
d=[i j k];
%梯度gradf
gradf=Jfv*d',
%沿向量V=(2,1,5)的方向导数Fxdf
V=[2,1,5]; Fxdf=Jfv*V'
```

```
syms i j k dx dy dz,x=2;y=1;z=5;

%  x=2;y=1;z=5处的全微分Df
Df=(6*(x-1)*exp(-(x+1)^2-y^2)+3*(x-1)^2*(-2*x-2)*exp(-(x+1)^2-y^2)+3*y*z+2*x-2)*conj(dx)+(-6*(x-1)^2*y*exp(-(x+1)^2-y^2)+3*x*z+2*y)*conj(dy)+(3*x*y+2)*conj(dz)

%  x=2;y=1;z=5处的一阶偏导数ux, uy, uz
ux=6*(x-1)*exp(-(x+1)^2-y^2)+3*(x-1)^2*(-2*x-2)*exp(-(x+1)^2-y^2)+3*y*z+2*x-2
uy=-6*(x-1)^2*y*exp(-(x+1)^2-y^2)+3*x*z+2*y
uz=3*x*y+2

%  x=2;y=1;z=5处的梯度gradf和
gradf=-i*(6*(x-1)*exp(-(x+1)^2-y^2)+3*(x-1)^2*(-2*x-2)*exp(-(x+1)^2-y^2)+3*y*z+2*x-2)-i*(-6*(x-1)^2*y*exp(-(x+1)^2-y^2)+3*x*z+2*y)+(3*x*y+2)*conj(k)

%  x=2;y=1;z=5处的沿向量V=(2,1,5)的方向导数Fxdf
Fxdf=12*(x-1)*exp(-(x+1)^2-y^2)+6*(x-1)^2*(-2*x-2)*exp(-(x+1)^2-y^2)+6*y*z+4*x+6-6*(x-1)^2*y*exp(-(x+1)^2-y^2)+3*x*z+2*y+15*x*y
```

]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>JacobianMatrix</tag>
      </tags>
  </entry>
  <entry>
    <title>斐讯路由器刷机</title>
    <url>/k1-k2/</url>
    <content><![CDATA[
{% centerquote %}斐讯路由器刷机和mentohust配置。{% endcenterquote %}

<!--more-->

# K2刷机

> [“免费”斐讯K2路由器刷OpenWRT](http://benyouhui.it168.com/thread-5692781-1-1.html)

## 开启系统Telnet


1. Windows默认没有装Telnet客户端，需要进入控制面板，程序和功能，启用和关闭windows功能。添加Telnet客户端。

    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729123715.png)

1. **如果选择全自动方案进行刷breed时，这部分不需要操作。而且，最新版K2无法上传‘config_telnetd_K2’文件**。默认K2没有开启Telnet登录管理功能，所以需要上传开启Telnet配置文件，然后利用网友编写的软件，刷入breed，再利用Breed刷第三方固件。

    - 首先接通电源，使用电脑网卡通过网线连接斐讯K2路由器 lan口，建议是lan4口。DHCP自动分配IP将会是192.168.1.1。
    - 通过网线连接K2路由器的电脑的浏览器中输入：http://192.168.2.1 或者 phicomm.me 进入路由器原厂固件。第一次进入有设置向导，具体略过不讲。进入系统工具——>系统管理。点击：浏览。选择‘开启telnet-config_telnetd_K2’，上传成功后，等待路由器重启。

## 刷breed

进入文件夹‘路由器刷breed Web控制台助手v3.4版本’。以Windows管理员身份运行：‘路由器刷breed Web控制台助手v3.4版本’。

等待检查完整性。选择‘自动刷机方案’（无需设置K2的Telnet功能），点击：“开始刷机”（如果遇到问题多刷新重启软件几次）。注意状态提示。刷新完毕后，最好等两分钟再拔路由。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729123735.png)

在刷机过程中，会自动打开如下软件，请确保如下软件正常运行，无需关闭。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729123757.png)

## 第三方固件

- 重启后拔掉K2路由器的电源线，按reset不放，插电源插头，等约5秒后，松开reset键，等待1分钟。在PC自动获取DHCP地址以后，在浏览器输入：192.168.1.1 进入breed界面。breed 中可以看到斐讯K2配置，内存RAM容量为64M，Flash ROM容量为8M，配置很一般。

- 刷入第三方固件，选择“固件更新”，点击目录中的‘PandoraBox-ralink-mt7620-phicomm-k2-2017-01-03-git-6c24a7a-squashfs-sysupgrade（root-admin）’文件即可。重启后等待2分钟。

    > openwrt-15.05.1-ramips-mt7620-xiaomi-miwifi-mini-squashfs-sysupgrade（root-root）：无法自启动mento，无法设置无线密码。
    > openwrt-ramips-mt7620-psg1208-squashfs-sysupgrade.bin（root-root）系列，翻墙固件非常卡，翻墙固件、多拨和纯净固件无法设置无线密码，无线无法联网。

    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729123821.png)

- 在浏览器输入：192.168.1.1。‘Go to password configuration’，输入原始账号密码root-root，**一定修改新登陆密码**，才能进入ssh设置。

    ```
    未设置密码！
    尚未设置密码。请为root用户设置密码以保护主机并开启SSH。
    跳转到密码配置页...
    ```


# 配置mentohust

1. 打开WinSCP工具，配置登陆IP（`http://192.168.1.1`）、账户（root）、密码（新登陆密码）。右边是路由器目录，在root目录下打开etc目录。左边是电脑本地目录，找到下载的mentohust（MT7620）文件，点上传。软件先别关闭，后面还要用到。

    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729123839.png)

2. 登陆putty：打开程序，配置登陆IP（root@192.168.1.1），端口22，选择SSH。点击打开后，弹出cmd窗口，passward还是上面的新登陆密码，这里不显示，打完直接回车。

    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729123906.png)

3. 测试mentohust。如果出现dhclient无法取得ip，请查看网卡编码（eth0.2）。

    ```
    %修改mentohust权限，也可以利用WinSCP界面，找到‘mentohust’，右键属性，勾选前三列，赋予777权限。
    chmod a+x /etc/mentohust
    /etc/mentohust -u学号 -p密码 -a1 -d2 -b3 -neth0.2
    % 运行后路由器可验证上网了。
    ```

    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729123931.png)

4. 设置mentohust自启动。在/etc/init.d下添加文件launchmento并输入以下内容，并保存。然后修改launchmento权限为777（或a+x），并在/etc/rc.d中建立链接。  

    ```
    #!/bin/sh /etc/rc.common
    # /init.d/launchMento
    START = 97 % 启动顺序
    start()
    {
            /etc/mentohust -u学号 -p密码 -a1 -d2 -b3 -neth0.2
    }

    stop()
    {
            /etc/mentohust -k
    }
    ```

    ```
    %修改launchmento权限，也可以利用WinSCP界面，找到‘mentohust’，右键属性，勾选前三列，赋予777权限
    chmod 777 /etc/init.d/launchmento
    %在/etc/rc.d中建立链接
    ln -s /etc/init.d/launchmento /etc/rc.d/S97launchmento
    ```

## 配置ipv6

1. 登录路由。把network中global network options中的ipv6 ULA-Prefix清空

2. 修改/etc/config/dhcp为

    ```
    config dnsmasq
    	option domainneeded '1'
    	option boguspriv '1'
    	option filterwin2k '0'
    	option localise_queries '1'
    	option rebind_protection '1'
    	option rebind_localhost '1'
    	option local '/lan/'
    	option domain 'lan'
    	option expandhosts '1'
    	option nonegcache '0'
    	option authoritative '1'
    	option readethers '1'
    	option leasefile '/tmp/dhcp.leases'
    	option resolvfile '/tmp/resolv.conf.auto'
    	option localservice '1'


    config dhcp 'lan'
        option interface 'lan'
        option start '100'
        option limit '150'
        option leasetime '12h'
        option ra 'hybrid'
        option dhcpv6 'hybrid'
        option ndp 'hybrid'
        option ra_management '1'

    config dhcp 'wan6'
        option interface 'wan'
        option dhcpv6 'hybrid'
        option ra 'hybrid'
        option ndp 'hybrid'
        option master '1'

    config odhcpd 'odhcpd'
    	option maindhcp '0'
    	option leasefile '/tmp/hosts/odhcpd'
    	option leasetrigger '/usr/sbin/odhcpd-update'
    ```

## 重启路由

---
]]></content>
      <categories>
        <category>Software</category>
        <category>Router</category>
      </categories>
      <tags>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>卡尔曼滤波</title>
    <url>/kalman-filter/</url>
    <content><![CDATA[
卡尔曼滤波（Kalman filtering）一种利用线性系统状态方程，通过系统输入输出观测数据，对系统状态进行最优估计的算法。由于观测数据中包括系统中的噪声和干扰的影响，所以最优估计也可看作是滤波过程。
<!--more-->

# 卡尔曼滤波器

# 扩展卡尔曼滤波器

经典的卡尔曼滤波只适用于线性且满足高斯分布的系统，但实际工程中并不是这么简单，比如飞行器在水平运动时有可能伴随着自身的自旋，此时的系统并不是线性的，这时就需要应用扩展卡尔曼滤波（EKF）来解决这种情况[^2]。

[^2]: [扩展卡尔曼滤波器的原理及应用](http://blog.csdn.net/lizilpl/article/details/45289541)

在扩展卡尔曼滤波器（Extended Kalman Filter，简称EKF）中状态转换和观测模型不需要是状态的线性函数，可替换为（可微的）函数。函数f可以用来从过去的估计值中计算预测的状态，相似的，函数h可以用来以预测的状态计算预测的测量值。然而f和h不能直接的应用在协方差中，取而代之的是计算偏导矩阵（[Jacobian](https://zh.wikipedia.org/wiki/%E9%9B%85%E5%8F%AF%E6%AF%94%E7%9F%A9%E9%98%B5 "雅可比矩阵")）。

$${  {x} }_{k}=f({  {x} }_{k-1},{  {u} }_{k},{  {w} }_{k})$$

当前状态的概率分布是关于上一状态和将要执行的控制量的二元函数，再叠加一个高斯噪声，测量值同样是关于当前状态的函数叠加高斯噪声。具体表达式如下： $g(u_t, x_{t-1})$ 和 $h(x_t)$ 可以是非线性的函数。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1ft727nc1q5j305y01pmwz.jpg)

为了用经典卡尔曼滤波器的思想来解决非线性系统中的状态估计问题，首先要做的就是把 $g(u_t, x_{t-1})$ 和 $h(x_t)$ 用泰勒级数展开，将其线性化，只取一次项为一阶EKF滤波。具体如下：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1ft727zhqp4j30ds02kjrb.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1ft7284zz0dj309f02sdfq.jpg)

$g(u_t, x_{t-1})$ 在上一状态估计的最优值处取一阶导数，$h(x_t)$ 在当前时刻预测值处取一阶导数，得到G和H分别相当于Kalman Filter中的A和C。

在每一步中使用当前的估计状态计算Jacobian矩阵，这几个矩阵可以用在卡尔曼滤波器的方程中。这个过程，实质上将非线性的函数在当前估计值处线性化了。

这样一来，卡尔曼滤波器的等式为（非线性离散方程，对于非线性连续微分方程来说，需要先一阶近似离散）：

$${\hat {  {x} } }_{k|k-1}=f({  {x} }_{k-1},{  {u} }_{k},0)$$

使用[Jacobians矩阵](https://sli1989.github.io/jacobian/)更新模型：

$$ {F}_{k}=\left.{\frac {\partial f}{\partial {  {x} } } }\right\vert _{ {\hat {x} }_{k-1|k-1},{ {u} }_{k} } $$

$$ {  {H} }_{k}=\left.{\frac {\partial h}{\partial {  {x} } } }\right\vert _{ {\hat{x} }_{k|k-1} } $$


状态矩阵A的雅克比矩阵：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1ft728pukycj30dc05jdgc.jpg)

观测矩阵H的雅克比矩阵：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1ft728yklm7j30dc06xaax.jpg)

**Extended Kalman Filter五条黄金公式** ：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1ft7296560fj30fa04owet.jpg)

## 更新

$${\displaystyle {\tilde {  {y} } }_{k}={  {z} }_{k}-h({\hat {  {x} } }_{k|k-1},0)}$$

$${\displaystyle {  {S} }_{k}={  {H} }_{k}{  {P} }_{k|k-1}{  {H} }_{k}^{T}+{  {R} }_{k} }$$

$${\displaystyle {  {K} }_{k}={  {P} }_{k|k-1}{  {H} }_{k}^{T}{  {S} }_{k}^{-1} }$$

$${\displaystyle {\hat {  {x} } }_{k|k}={\hat {  {x} } }_{k|k-1}+{  {K} }_{k}{\tilde {  {y} } }_{k} }$$

$${\displaystyle {  {P} }_{k|k}=(I-{  {K} }_{k}{  {H} }_{k}){  {P} }_{k|k-1} }$$

## 预测

如同扩展卡尔曼滤波器（EKF）一样， UKF的预测过程可以独立于UKF的更新过程之外，与一个线性的（或者确实是扩展卡尔曼滤波器的）更新过程合并来使用；或者，UKF的预测过程与更新过程在上述中地位互换亦可。

## MATLAB实现

```
% author :  Perry.Li  @USTC
% function: simulating the process of EKF
% date:     04/28/2015
%
N = 50;         %计算连续N个时刻
n=3;            %状态维度
q=0.1;          %过程标准差
r=0.2;          %测量标准差
Q=q^2*eye(n);   %过程方差
R=r^2;          %测量值的方差
% 离散状态方程
f=@(x)[x(2);x(3);0.05*x(1)*(x(2)+x(3))];  %状态方程
h=@(x)[x(1);x(2);x(3)];                   %测量方程
s=[0;0;1];                                %初始状态
%初始化状态
x=s+q*randn(3,1);                         
P = eye(n);                               
xV = zeros(n,N);          
sV = zeros(n,N);         
zV = zeros(n,N);
for k=1:N
  z = h(s) + r*randn;                     
  sV(:,k)= s;                             %实际状态
  zV(:,k)  = z;                           %状态测量值
  [x1,A]=jaccsd(f,x); %计算f的雅可比矩阵，其中x1对应黄金公式line2
  P=A*P*A'+Q;         %过程方差预测，对应line3
  [z1,H]=jaccsd(h,x1); %计算h的雅可比矩阵
  K=P*H'*inv(H*P*H'+R); %卡尔曼增益，对应line4
  x=x1+K*(z-z1);        %状态EKF估计值，对应line5
  P=P-K*H*P;            %EKF方差，对应line6
  xV(:,k) = x;          %save
  s = f(s) + q*randn(3,1);  %update process
end
for k=1:3
  FontSize=14;
  LineWidth=1;
  figure();
  plot(sV(k,:),'g-'); %画出真实值
  hold on;
  plot(xV(k,:),'b-','LineWidth',LineWidth) %画出最优估计值
  hold on;
  plot(zV(k,:),'k+'); %画出状态测量值
  hold on;
  legend('真实状态', 'EKF最优估计估计值','状态测量值');
  xl=xlabel('时间(分钟)');
  t=['状态 ',num2str(k)] ;
  yl=ylabel(t);
  set(xl,'fontsize',FontSize);
  set(yl,'fontsize',FontSize);
  hold off;
  set(gca,'FontSize',FontSize);
end

function [z,A]=jaccsd(fun,x)
% JACCSD Jacobian through complex step differentiation
% [z J] = jaccsd(f,x)
% z = f(x)
% J = f'(x)
%
z=fun(x);
n=numel(x);
m=numel(z);
A=zeros(m,n);
h=n*eps;
for k=1:n
    x1=x;
    x1(k)=x1(k)+h*i;
    A(:,k)=imag(fun(x1))/h;
end
```
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>StateEstimation</tag>
      </tags>
  </entry>
  <entry>
    <title>KKT条件</title>
    <url>/kkt/</url>
    <content><![CDATA[
已经解决的在等式约束条件下的求函数极值的问题，那不等式约束条件下，应该如何解决呢？这就需要引出KKT条件（Karush-Kuhn-Tucker Conditions），它是在满足一些有规则的条件下，一个非线性规划问题能有最优化解法的一个必要和充分条件。

<!--more-->

考虑以下非线性最优化问题[^qVhRQ][^%E6%8]:，含有 $m$ 个不等式约束，$l$ 个等式约束:

$$\operatorname*{min}_{x}f(x) \qquad s.t. \; g_i(x) \leqslant 0,\; h_j(x) =0$$

[^qVhRQ]: [KKT条件](https://mp.weixin.qq.com/s/qVhRQr92gBkUjXGymkXGZw)
[^%E6%8]: [【直观详解】拉格朗日乘法和KKT条件](https://charlesliuyx.github.io/2017/09/20/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%B3%95%E5%92%8CKKT%E6%9D%A1%E4%BB%B6/)

# 必要条件

假设 $f,g_i,h_j$ 三个函数为**实数集映射**，再者，他们都在 $x^\ast$ 这点**连续可微** ，如果 $x^\ast$  是一个**局部极值**，那么**将会存在**一组**称为乘子**的常数 $\lambda \geqslant 0,\mu_i \geqslant0, \nu_j$ , 令

$$
\lambda + \sum_{i=1}^m \mu_i + \sum_{j=1}^l |\nu_i| \gt 0, \\
\lambda \nabla f(x^\ast) + \sum_{i=1}^m \mu_i  \nabla g_i(x^\ast) + \sum_{j=1}^l \nu_i  \nabla h_j(x^\ast) = 0, \\
\mu_i  g_i(x^\ast) =0 \; \text{for all} \; i=1,\ldots,m
$$

这里有一些**正则性条件或约束规范**能保证解法不是退化的（比如$\lambda$为0 ）。

# 充分条件

假设 $f,g_i$ 为**凸函数**，$h_j$ 函数是**仿射函数**（平移变换），假设有一个可行点 $x^\ast$，如果有常数 $\mu_i \geqslant 0$ 及 $\nu_j$ 满足

$$
\nabla f(x^\ast) + \sum_{i=1}^m \mu_i  \nabla g_i(x^\ast) + \sum_{j=1}^l \nu_i  \nabla h_j(x^\ast) = 0 \\
\mu_i  g_i(x^\ast) =0 \; \text{for all} \; i=1,\ldots,m
$$

那么 $x^\ast$ 就是**全局极小值**。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>SVM</tag>
        <tag>KKT</tag>
      </tags>
  </entry>
  <entry>
    <title>拉格朗日对偶</title>
    <url>/lagrange-multiplier/</url>
    <content><![CDATA[
无论原问题是不是凸优化问题，都可以将原问题转化为凸优化问题来求解。当Lagrange对偶问题的强对偶性成立时，可以利用求解对偶问题来求解原问题；而原问题是凸优化问题时，强对偶性往往成立。否则，可以利用求解对偶问题求出原问题最优值的下界。总的来说，拉格朗日乘子法是一个工具（手段或方法），来解决在有约束情况的求函数极值的问题。

<!--more-->

拉格朗日乘法（Lagrange multiplier）是一种在最优化的问题中寻找多元函数在其变量受到一个或多个条件的相等约束时的求局部极值的方法。这种方法可以将一个有 n 个变量和 k 个约束条件的最优化问题转换为一个解有 n+k 个变量的方程组的解的问题。

虽然在应用拉格朗日乘子法时，我们把条件极值问题转化称为一个方程求解的问题，整个过程都是代数的。但[拉格朗日乘子法的原创思想是非常几何直观的，用向量语言表述起来很漂亮，也很容易理解和记忆](https://zhuanlan.zhihu.com/p/29525538)。

> [凸优化（八）——Lagrange对偶问题](https://www.jianshu.com/p/96db9a1d16e9)

考虑一个最优化问题

$$
\operatorname*{max}_{x,y} f(x,y) \qquad s.t.\;\; g(x,y)=c
$$

为了求 $x$ 和 $y$ ，引入一个新的变量 $\lambda$ 称为**拉格朗日乘数**，再引入朗格朗日函数的极值

$$\mathcal{L}(x,y,\lambda)=f(x,y)-\lambda \cdot \bigl( g(x,y) - c\bigl) \tag 1$$

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125049.png)

> 红线表示 $g(x,y) = c$ ，蓝线是 $f(x,y)$ 的**等高线**，所有箭头表示梯度下降最快的方向。图中**红线与等高线相切**的位置就是待求的极大值

# 单约束

对(1)式直接求微分，并令其为零，计算出**鞍点**

$$
\nabla_{x,y,\lambda} \mathcal{L}(x,y,\lambda) = 0
$$

有三个未知数，所以需要3个方程。求 $\lambda$ 的偏微分有 $\nabla_{\lambda} \mathcal{L}(x,y,\lambda) = 0 \implies g(x,y)=0$，则总结得

$$
\nabla_{x,y,\lambda} \mathcal{L}(x,y,\lambda) = 0 \iff
\begin{cases}
\nabla_{x,y} f(x,y) = \lambda \nabla_{x,y} g(x,y) \\
g(x,y)=0
\end{cases}
$$

## 例子1

设一个具体的例子，我们需要求下列问题

$$
\operatorname*{max}_{x,y} f(x,y) = x^2y \qquad s.t.\;\; g(x,y): x^2+y^2-3=0
$$

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124931.png)

只有**一个约束**，使用**一个乘子**，设为 $\lambda$，列出**拉格朗日函数**

$$
\mathcal{L}(x,y,\lambda)=f(x,y)-\lambda \cdot \bigl( g(x,y) - c\bigl) = x^2y + \lambda(x^2+y^2-3)
$$

接下来求解上式，分别对**三个待求量偏微分**

$$
\begin{align}
\nabla_{x,y,\lambda} \mathcal{L}(x,y,\lambda) & = \left( \frac{\partial \mathcal{L}}{\partial x},\frac{\partial \mathcal{L}}{\partial y},\frac{\partial \mathcal{L}}{\partial \lambda}\right)\\
& = (2xy + 2\lambda x, x^2 + 2\lambda y, x^2 + y^2 - 3)
\end{align}
$$

令**偏微分分别等于0**，得到

$$
\nabla_{x,y,\lambda} \mathcal{L}(x,y,\lambda) = 0 \iff
\begin{cases}
2xy+2\lambda x = 0 \\
x^2 + 2\lambda y = 0 \\
x^2 + y^2 - 3 = 0
\end{cases}
\iff
\begin{cases}
x(y + \lambda) = 0  & (i)\\
x^2 = -2\lambda y  & (ii)\\
x^2 +y^2 = 3 & (iii)
\end{cases}
$$

根据上式，我们可以解得 $\mathcal{L}$:

$$
(\pm \sqrt{2},1,-1 ); (\pm \sqrt{2},-1,1 );(0,\pm \sqrt{3},0)
$$

根据几个不同的解带入 $f(x,y)$ 得到，2，-2，0，也就是我们需要的最大值，最小值，对应的直观图像解释如下图所示（**非常直观的展现约束和等高线的含义**）.

## 例子2

关于拉格朗日乘子法的应用，有一个十分著名的：求**离散概率分布  $p_1,p_2,\cdots,p_n$  的最大[信息熵](http://sli1989.github.io/entropy-method/)。

$$
f(p1,p2,\cdots,p_n) = - \sum_{j=1}^n p_j log_2{p_j} \\
s.t. \quad g(p1,p2,\cdots,p_n) = \sum_{k=1}^n p_k = 1 \text{（概率和为1）}
$$

单约束问题，引入一个乘子 $\lambda$ ，对于 $k \in [1,n]$ ，要求

$$
\frac{\partial}{\partial p_k} (f + \lambda(g - 1)) = 0
$$
将 $f$ 和 $g$ 带入有
$$
\frac{\partial}{\partial p_k} \left(  -\sum_{k=1}^np_klog_2{p_k} + \lambda (\sum_{k=1}^n p_k - 1)\right) = 0
$$

计算这 n 个等式的偏微分，我们可以得到：
$$
-\left( \frac{1}{\ln(2)} + log_2p_k \right) + \lambda = 0
$$

这说明所有的 $p_i$ 都相等，所以得到 $p_k = \frac{1}{n}$ 。

我们可以得到一个结论是：**均匀分布的信息熵是最大的** 。

# 多约束

既然可以解决单约束，继续思考一下多约束情况的直观表现，假设我们的约束是两条线，如下图所示。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124953.png)

和单约束的解决方法类似，我们画出等高线图，目的就是在约束线上找到一个点可以和等高线相切，所得的值实在约束范围内的最大值或者最小值，直观表示如下图.

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125032.png)

解算方法是讲单约束的扩展到多约束的情况，较为类似，可举一反三 。


---

参考文献：

- [【直观详解】拉格朗日乘法和KKT条件](https://charlesliuyx.github.io/2017/09/20/%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E4%B9%98%E6%B3%95%E5%92%8CKKT%E6%9D%A1%E4%BB%B6/)

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>SVM</tag>
        <tag>LagrangianMultiplierMethod</tag>
      </tags>
  </entry>
  <entry>
    <title>线性回归</title>
    <url>/linear-regression/</url>
    <content><![CDATA[
线性回归可以说是机器学习中最简单，最基础的机器学习算法，它是一种监督学习方法，可以被用来解决回归问题。它用一条直线(或者高维空间中的平面)来拟合训练数据，进而对未知数据进行预测。

<!--more-->

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125134.png)

# 基本套路

机器学习方法，无外乎三点：模型，代价函数，优化算法。首先找到一个模型用于预测未知世界，然后针对该模型确定代价函数，以度量预测错误的程度，最后使用优化算法在已有的样本数据上不断地优化模型参数，来最小化代价函数。通常来说，用的最多的优化算法主要是梯度下降或拟牛顿法([L-BFGS](http://blog.csdn.net/itplus/article/details/21896453)或[OWL-QN](http://research.microsoft.com/en-us/um/people/jfgao/paper/icml07scalable.pdf))，计算过程都需要计算参数梯度值，下面仅从模型、代价函数以及参数梯度来描述一种机器学习算法。

**基本模型**：

$$ h_ \theta(X) =  \theta^T X = \theta_0 + \theta_1 x_1 + \theta_2 x_2 + \cdots + \theta_n x_n $$

其中，$X$ 为表示样本特征，为 $n$ 维向量，$\theta$ 为模型参数，为 $n+1$ 维向量，包括一个偏置 $\theta_0$。

**代价函数**：

$$ J(\theta) = \frac {1} {2m} \sum_{i=1}^m \left ( y^{(i)}-h_\theta(X) \right ) ^2 $$

上述公式也称之为平方误差，$m$ 为样本个数，$(X^{(i)}, y^{(i)})$ 为第 $i$ 个样本。

**参数梯度**：

$$ \bigtriangledown_{\theta_j} J(\theta)  =  \frac {1} {m} \sum_{i=1}^m \left[\left ( y^{(i)} - h_ \theta(X^{(i)}) \right ) X^{(i)}_j \right] $$

$\theta_j$ 表示第 $j$ 个参数，$X^{(i)}_j$ 表示样本 $X^{(i)}$ 的第 $j$ 个特征值。

上述描述是按照常规的机器学习方法来描述线性回归，模型参数一般是通过梯度下降或拟牛顿法优化迭代得到，其实线性回归问题是可解的，只是在样本维度较大时很难求解才使用优化迭代的方法来逼近，如果样本维度并不是很大的情况下，是可以解方程一次性得到样本参数。

最小二乘：

$$ \theta = {\left( X^T X \right)} ^{-1} X^T y$$

注意这里 $X$ 为 $m \times n$ 矩阵，$n$ 为特征维度，$m$ 为样本个数； $y$ 为 $m \times 1$ 向量，表示每个样本的标签。

加权最小二乘：

$$ \theta = {\left( X^T W X \right)} ^{-1} X^T W y$$

$W$ 为 $m \times m$ 对角矩阵，对角线上的每个值表示对应样本实例的权重。

# 应用套路

在实际应用时，基于上述基本套路可能会有些小变化，下面首先还是从模型、代价函数以及参数梯度来描述。把基本套路中模型公式中的 $\theta_0$ 改成 $b$，表示截距项，模型变成如下形式：

$$h_{\theta,b}(X) =  \theta^T X  + b = \theta_1 x_1 + \theta_2 x_2 + \cdots + \theta_n x_n + b$$

## 正则化

为了防止过拟合，一般会在代价函数上增加正则项，常见的正则方法有：

- L1:  $\lambda \left \|  \theta \right \|$ , 也称之为套索回归(Lasso)，可将参数稀疏化，但是不可导
- L2:  $\frac {\lambda} {2}  {\left \|  \theta \right \|}^2$，也称之为岭回归(Ridge)，可将参数均匀化，可导
- L1&L2:  $\lambda \left(\alpha \left \|  \theta \right \| + \frac {1-\alpha} {2} {\left \|  \theta \right \|}^2 \right)$,  也称之为弹性网络(ElasticNet)，具备L1&L2的双重特性

加上正则项后，代价函数变成如下形式：

$$J(\theta, b) =\frac {1} {2m} \sum_{i=1}^m \left ( y^{(i)}-h_{\theta,b}(X) \right ) ^2  +  \frac {\lambda} {m} \left(\alpha \left \|  \theta \right \| + \frac {1-\alpha} {2} {\left \|  \theta \right \|}^2 \right)$$

其中，$\lambda$ 为正则项系数，$\alpha$ 为ElasticNet参数，他们都是可调整的超参数， 当 $\alpha = 0$，则为L2正则， 当 $\alpha = 1$，则为L1正则。L1正则项增加 $1/m$ 以及L2正则项增加 $1/2m$ 系数，仅仅是为了使求导后的形式规整一些。

由于L1正则项不可导，如果 $\alpha$ 不为0，那么不能简单的套用梯度下降或L-BFGS，需要采用借助[软阈值(Soft Thresholding)](http://blog.csdn.net/jbb0523/article/details/52103257)函数解决，如果是使用拟牛顿法，可以采用[OWL-QN](http://research.microsoft.com/en-us/um/people/jfgao/paper/icml07scalable.pdf)，它是基于L-BFGS算法的可用于求解L1正则的算法。基于上述代价函数，下面仅列出包含L2正则项时的参数梯度：

$$\bigtriangledown_{\theta_j} J(\theta, b) = \frac {1} {m} \sum_{i=1}^m \left ( y^{(i)} - h_{\theta,b} (X^{(i)}) \right ) X^{(i)}_j + \frac {\lambda (1-\alpha)} {m}  {\theta_j}^\ast \\ \bigtriangledown_b J(\theta, b) = \frac {1} {m} \sum_{i=1}^m \left( y^{(i)} - h_{\theta,b} (X^{(i)}) \right)$$

其中，${\theta_j}^\ast$ 为上一次迭代得到的参数值。

实际上，使用L2正则，是将前面所述的最小二乘方程改成如下形式：

$$ \theta = {\left( X^T X + kI \right)}^{-1} X^T y$$

这样可以降低矩阵 $X^T X $ 奇异的可能，否则就不能求逆了。

## 标准化

一般来说，一个特征的值可能在区间 $(0, 1)$ 之间，另一特征的值可能在区间$(-\infty, \infty)$  ，这就是所谓的样本特征之间量纲不同，这样会导致优化迭代过程中的不稳定。当参数有不同初始值时，其收敛速度差异性较大，得到的结果可能也有较大的差异性，如下图所示，可以看到X和Y这两个变量的变化幅度不一致，如果直接使用梯度下降来优化迭代，那么量纲较大的特征信息量会被放大，量纲较小的特征信息量会被缩小。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125153.png)

所以一般要对数据作无量纲化处理，通常会采用标准化方法 $(x-u)/\sigma$ ，得到如下数据分布，这样无论从哪个点开始，其迭代方向的抖动都不会太大，每个特征的信息也不至于被放大和缩小。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125210.png)

# 总结

虽然线性回归现在可能很少用于解决实际问题，但是因为其简单易懂，学习它有助于对机器学习有个入门级的初步掌握，了解机器学习的套路等。

> 本文转载自[机器学习套路--线性回归](http://sharkdtu.com/posts/ml-linear-regression.html)

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux sed 命令</title>
    <url>/linux-sed/</url>
    <content><![CDATA[
Linux sed命令是利用script来处理文本文件。sed可依照script的指令，来处理、编辑文本文件。Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。


<!--more-->

sed编辑器逐行处理文件（或输入），并将结果发送到屏幕。具体过程如下：首先sed把当前正在处理的行保存在一个临时缓存区中（也称为模式空间），然后处理临时缓冲区中的行，完成后把该行发送到屏幕上。sed每处理完一行就将其从临时缓冲区删除，然后将下一行读入，进行处理和显示。处理完输入文件的最后一行后，sed便结束运行。sed把每一行都存在临时缓冲区中，对这个副本进行编辑，所以不会修改原文件。

# 语法

```
sed [-hnV][-e<script>][-f<script文件>][文本文件]
```

参数说明：

* `-e<script>`或`--expression=<script>`   以选项中指定的script来处理输入的文本文件。
* `-f<script文件`>或`--file=<script文件>`  以选项中指定的script文件来处理输入的文本文件。
* `-h`或`--help`   显示帮助。
* `-n`或`--quiet`或`--silent`   仅显示script处理后的结果。
* `-V`或`--version`   显示版本信息。

**动作说明**：

* `a` ：新增， `a` 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～
* `c` ：取代， `c `的后面可以接字串，这些字串可以取代 $n_1$，$n_2$之间的行！
* `d` ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；
* `i` ：插入， `i` 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
* `p` ：打印，亦即将某个选择的数据印出。通常 `p` 会与参数 `sed -n` 一起运行～
* `s` ：取代，可以直接进行取代的工作哩！通常这个 `s` 的动作可以搭配正规表示法！例如 `1,20s/old/new/g` 就是啦！

# 实例

> [Linux sed命令](http://www.runoob.com/linux/linux-comm-sed.html)  
> [sed命令详解](http://www.cnblogs.com/edwardlost/archive/2010/09/17/1829145.html)

命令中的三根斜线分隔符可以换成别的符号。特殊字符需要使用反斜线`\`进行转义，但是单引号是没有办法用反斜线`\`转义的，这时候只要把命令中的单引号改为双引号就行了。


## 查看

```
# 只查看文件的第100行到第200行
sed -n '100,200p' mysql_slow_query.log
```

## 替换

> [查找与替换](http://wiki.jikexueyuan.com/project/shell-learning/sed-search-and-replace.html)

```
sed 's/原字符串/替换字符串/'
sed 's?原字符串?替换字符串?' //自定义分隔符为问号
sed "s/原字符串包含'/替换字符串包含'/" //要处理的字符包含单引号

# 可以在末尾加g替换每一个匹配的关键字，否则只替换每行的第一个
sed 's/原字符串/替换字符串/' //替换所有匹配关键字

# 替换样式可以多个在同一条命令中执行，用分号分隔
sed 's/^/添加的头部&/g; s/$/&添加的尾部/g'

# 上箭头”^”表示行首
# 美元”$”符号如果在引号中表示行尾
# 但是在引号外却表示末行(最后一行)
sed 's/^/添加的头部&/g' //在所有行首添加
sed 's/$/&添加的尾部/g' //在所有行末添加
sed '2s/原字符串/替换字符串/g' //替换第2行
sed '$s/原字符串/替换字符串/g' //替换最后一行
sed '2,5s/原字符串/替换字符串/g' //替换2到5行
sed '2,$s/原字符串/替换字符串/g' //替换2到最后一行

# 在文件夹中批量替换
# 在其他文件夹
sed -i “s/oldstring/newstring/g” `grep oldstring -rl yourdir`
# 在当前文件夹
sed -i "s/wordcount/symbols_count/g" `grep wordcount -rl ./`
```

## 插入

```
# 在某行（指具体行号）前或后加一行内容
# 在第2行前插入ttt，并且将结果更新到a.txt（如果不想将插入真正更新到文件，去掉后面的-i选项就可以）
sed '2 ittt' -i a.txt
# 在第2行后插入ttt,并且将结果更新到a.txt（如果不想更新原文件，去掉-i）
sed '2 attt' -a a.txt
# 在指定的多行前面插入
sed 'n,m ittt' -i a.txt
# 在指定的多行后面插入
sed 'n,m attt' -a a.txt

# 插入另外一个文件的内容
# 匹配naughty这个单词并且在该行的下一行开始插入dd文件的内容
sed '/naughty/r dd' data

# 配合find查找的内容处理
find . -name server.xml|xargs sed -i '/directory/i       <!--'
find . -name server.xml|xargs sed -i '/pattern="%h/a       -->'
```

## 删除

```
sed '2,5d' datafile
#删除第二到第五行
sed '/My/,/You/d' datafile
#删除包含"My"的行到包含"You"的行之间的行
sed '/My/,10d' datafile
#删除包含"My"的行到第十行的内容

# 删除指定行的上一行或下一行
删除指定文件的上一行
sed -i -e :a -e '$!N;s/.*n(.*directory)/1/;ta' -e 'P;D' server.xml
删除指定文件的下一行
sed -i '/pattern="%/{n;d}' server.xml
```

---
]]></content>
      <categories>
        <category>Programming</category>
        <category>Sed</category>
      </categories>
      <tags>
        <tag>Sed</tag>
      </tags>
  </entry>
  <entry>
    <title>Long short-term memory</title>
    <url>/lstm/</url>
    <content><![CDATA[
LSTM算法全称为Long short-term memory，最早由 Sepp Hochreiter和Jürgen Schmidhuber于1997年提出，是一种特定形式的RNN（Recurrent neural network，循环神经网络），而RNN是一系列能够处理序列数据的神经网络的总称。

<!--more-->

# 推导

关于lstm，有个非常好的[博客](http://colah.github.io/posts/2015-08-Understanding-LSTMs/)。

前向更新公式为：

![image](http://vsooda.github.io/assets/lstm/lstm.png)

依照上文的后向传播的推导方式，可以得到，
前向更新，请见代码中`#sooda注释`部分：

![image](http://vsooda.github.io/assets/lstm/lstm_forward.png)

后向更新：

![image](http://vsooda.github.io/assets/lstm/lstm_backward.png)

**注意点**:

1. 通过观察公式1到4， 发现所有的乘机因子为x、h，互相没有依赖，可以并行化。利用向量化进行加速
2. IFOG指的是Input，Forget， Output， Cell Gate的计算值。IFOGf是IFOG经过激活函数后的激活值. 并以此为顺序。o-d表示input gate， d-2d表示forget gate， 2d-3d表示output gate， 3d-end 表示cell gate
3. WLSTM保存的实际上是所有这些门相对于输入+隐藏层+偏置的权值。
4. 后向传播从最后一个进行求偏导， 即按照从后向前，按部就班即可，不需要跨步骤考虑
5. cache是为了保存后向传播所需要的值

本文代码可以参考[gist](https://gist.github.com/f93810ce107b0d393cbf.git)

## 反向传播

LSTM的后向推导说是推导，基本上没有一个公式。注重理解。

cs231上有一篇关于[非常好的文章](http://cs231n.github.io/optimization-2/#intuitive), 讲得非常好。
一个例子：
$$f(x,y) = \frac{x + \sigma(y)}{\sigma(x) + (x+y)^2}$$

```python
x = 3 # example values
y = -4
# forward pass
sigy = 1.0 / (1 + math.exp(-y)) # sigmoid in numerator   #(1)
num = x + sigy # numerator                               #(2)
sigx = 1.0 / (1 + math.exp(-x)) # sigmoid in denominator #(3)
xpy = x + y                                              #(4)
xpysqr = xpy**2                                          #(5)
den = sigx + xpysqr # denominator                        #(6)
invden = 1.0 / den                                       #(7)
f = num * invden # done!                                 #(8)
```

对应的后向传播为：

```python
# backprop f = num * invden
dnum = invden # gradient on numerator                             #(8)
dinvden = num                                                     #(8)
# backprop invden = 1.0 / den
dden = (-1.0 / (den**2)) * dinvden                                #(7)
# backprop den = sigx + xpysqr
dsigx = (1) * dden                                                #(6)
dxpysqr = (1) * dden                                              #(6)
# backprop xpysqr = xpy**2
dxpy = (2 * xpy) * dxpysqr                                        #(5)
# backprop xpy = x + y
dx = (1) * dxpy                                                   #(4)
dy = (1) * dxpy                                                   #(4)
# backprop sigx = 1.0 / (1 + math.exp(-x))
dx += ((1 - sigx) * sigx) * dsigx # Notice += !! See notes below  #(3)
# backprop num = x + sigy
dx += (1) * dnum                                                  #(2)
dsigy = (1) * dnum                                                #(2)
# backprop sigy = 1.0 / (1 + math.exp(-y))
dy += ((1 - sigy) * sigy) * dsigy                                 #(1)
# done! phew
```

]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>LSTM</tag>
      </tags>
  </entry>
  <entry>
    <title>机器学习</title>
    <url>/machine-learning/</url>
    <content><![CDATA[
机器学习（Machine Learning，常简称为ML）研究的是计算机怎样模拟人类的学习行为，以获取新的知识或技能，并重新组织已有的知识结构使之不断改善自身。简单一点说，就是计算机从数据中学习出规律和模式，以应用在新数据上做预测的任务。机器学习在近30多年已发展为一门多领域交叉学科，涉及概率论、统计学、逼近论、凸分析、计算复杂性理论等多门学科。

<!--more-->

![人工智能关系图](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65gy1foo3vai8r0j30h2090glt.jpg)

![机器学习框架图](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65gy1fogasefrboj312g1wtk0l.jpg)

- 它是人工智能（Artificial Intelligence，常简称为AI）的一个重要子领域，而人工智能又与更广泛的数据挖掘（Data Mining，常简称为DM）和知识发现（Knowledge Discovery in Database，常简称为KDD）领域相交叉。
- 机器学习是人工智能的一个分支。人工智能的研究是从以“推理”为重点到以“知识”为重点，再到以“学习”为重点，一条自然、清晰的脉络。
- 机器学习是实现人工智能的一个途径，即以机器学习为手段解决人工智能中的问题。
- 机器学习是人工智能的核心，应用遍及人工智能的各个领域，

机器学习算法是一类从数据中自动分析获得规律，并利用规律对未知数据进行预测的算法。为此，机器学习主要关注于模式识别。机器学习有助于识别数据集内的模式，并因此尝试根据现有数据进行预测。[深度学习](https://sli1989.github.io/deep-learning-1/)是一种实现机器学习的技术[^2888249]。

[^2888249]: [一篇文章讲清楚人工智能、机器学习和深度学习的区别和联系](http://blog.sciencenet.cn/blog-2888249-1082369.html)

一个简单的数学建模，我们需要考虑的是：1. 要做什么？2. 怎么做？3. 这样做合理吗？4. 如果这样做，假设那些可以改变？5. 这样做需要用到那些模型？6. 这种模型简洁吗？7. 确定了这种模型，怎么求解？8. 求解出来了，与现实合理吗？9. 在这个模型中，存在什么缺点，怎么去优化？10. 总结。

# 发展过程

目前机器学习已经在数据挖掘、计算机视觉、自然语言处理、生物特征识别、搜索引擎、DNA序列测序、战略游戏和机器人等多个方面都得到了运用。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g0bvn0r77uj20m80cigoj.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g0bvt3avxvj20gy0a7tbt.jpg)

# 实现过程

华盛顿大学 eScience Institute 和 Institute for Neuroengineering 的数据科学博士后 Michael Beyeler[^25459407]介绍了如何依靠已有的方法（模型选择和超参数调节）去指导你更好地去选择算法。

[^25459407]: [经验之谈：如何为你的机器学习问题选择合适的算法](https://zhuanlan.zhihu.com/p/25459407)

1. 了解基本知识。机器学习里面三个主要类别：监督学习，无监督学习和强化学习。
    - 在监督学习（supervised learning）中，每个数据点都会获得标注，如类别标签或与数值相关的标签。一个类别标签的例子：将图片分类为「猫」或「狗」；数值标签的例子如：预测一辆二手车的售价。监督学习的目的是通过学习许多有标签的样本，然后对新的数据做出预测。例如，准确识别新照片上的动物（分类）或者预测二手车的售价（回归）。
    - 在无监督性学习（unsupervised learning）中，数据点没有相关的标签。相反，无监督学习算法的目标是以某种方式组织数据，然后找出数据中存在的内在结构。这包括将数据进行聚类，或者找到更简单的方式处理复杂数据，使复杂数据看起来更简单。
    - 在强化学习（reinforcement learning）中，算法会针对每个数据点来做出决策（下一步该做什么）。这种技术在机器人学中很常用。传感器一次从外界读取一个数据点，算法必须决定机器人下一步该做什么。强化学习也适合用于物联网应用。在这里，学习算法将收到奖励信号，表明所做决定的好坏，为了获得最高的奖励，算法必须修改相应的策略。
1. 对问题进行分类
    - 根据输入数据分类：如果我们的数据有标签，这就是一个监督学习问题；如果数据没有标签而且我们想找出数据的内在结构，那这就是无监督学习；如果我们想通过与环境交互来优化目标函数，这是强化学习。
    - 根据输出结果分类：如果模型输出结果是一个数值，这是回归问题；如果输出结果是一个类别，这是分类问题；如果输出结果是一组输入数据，那这是聚类问题。
1. 寻找可用的算法。
2. **数据特征探索工程**。或许比选择算法更重要的是正确选择表示数据的特征。虽然大多数特征的有效性需要靠实验来评估，但是了解常见的选取数据特征的方法是很有帮助的。这里有几个较好的方法：
    - 主成分分析（PCA）：一种线性降维方法，可以找出包含信息量较高的特征主成分，可以解释数据中的大多数方差。
    - 尺度不变特征变换（SIFT）：计算机视觉领域中的一种有专利的算法，用以检测和描述图片的局部特征。它有一个开源的替代方法 ORB（Oriented FAST and rotated BRIEF）。
    - 加速稳健特征（SURF）：SIFT 的更稳健版本，有专利。
    - 方向梯度直方图（HOG）：一种特征描述方法，在计算机视觉中用于计数一张图像中局部部分的梯度方向的 occurrence。
    - 智能的特征选择
         - 前向搜索：
         - 最开始不选取任何特征。
         - 然后选择最相关的特征，将这个特征加入到已有特征；计算模型的交叉验证误差，重复选取其它所有候选特征；最后，选取能使你交叉验证误差最小特征，并放入已选择的特征之中。
         - 重复，直到达到期望数量的特征为止！
         - 反向搜索：
         - 从所有特征开始。
         - 先移除最不相关的特征，然后计算模型的交叉验证误差；对其它所有候选特征，重复这一过程；最后，移除使交叉验证误差最大的候选特征。
         - 重复，直到达到期望数量的特征为止！
1. 实现所有适用的算法，模型选择。
    - 对于任何给定的问题，通常有多种候选算法可以完成这项工作。那么我们如何知道选择哪一个呢？通常，这个问题的答案并不简单，所以我们必须反复试验。原型开发最好分两步完成。在第一步中，我们希望通过最小量的特征工程快速且粗糙地实现一些算法。在这个阶段，我们主要的目标是大概了解哪个算法表现得更好。
    - 一旦我们将列表减少至几个候选算法，真正的原型开发开始了。理想情况下，我们会建立一个机器学习流程，使用一组经过仔细选择的评估标准来比较每个算法在数据集上的表现。
1. 超参数优化。例如，主成分分析中的主成分个数，k 近邻算法的参数 k，或者是神经网络中的层数和学习速率。最好的方法是使用交叉验证来选择。

# 学习方式

## 离线学习与在线学习

机器学习算法可以分成两类。离线学习和在线学习。[在线机器学习](https://sli1989.github.io/online-learning/)指每次通过一个训练实例学习模型的学习方法。

## 主动学习与直推学习

### 主动学习

主动学习（active learning），指的是这样一种学习方法：有的时候，有类标的数据比较稀少而没有类标的数据是相当丰富的，但是对数据进行人工标注又非常昂贵，这时候，学习算法可以主动地提出一些标注请求，将一些经过筛选的数据提交给专家进行标注。这个筛选过程也就是主动学习主要研究的地方了，怎么样筛选数据才能使得请求标注的次数尽量少而最终的结果又尽量好。

主动学习的过程大致是这样的，有一个已经标好类标的数据集K（初始时可能为空），和还没有标记的数据集U，通过K集合的信息，找出一个U的子集C，提出标注请求，待专家将数据集C标注完成后加入到K集合中，进行下一次迭代。

按wiki上所描述的看，**主动学习也属于半监督学习的范畴了，但实际上是不一样的，半监督学习和直推学习（transductive learning）以及主动学习，都属于利用未标记数据的学习技术，但基本思想还是有区别的**。

如上所述，主动学习的“主动”，指的是主动提出标注请求，也就是说，还是需要一个外在的能够对其请求进行标注的实体（通常就是相关领域人员），即主动学习是交互进行的。而半监督学习，特指的是学习算法不需要人工的干预，基于自身对未标记数据加以利用。

### 直推学习

它与半监督学习一样不需要人工干预，不同的是，直推学习假设未标记的数据就是最终要用来测试的数据，学习的目的就是在这些数据上取得最佳泛化能力。相对应的，半监督学习在学习时并不知道最终的测试用例是什么。也就是说，直推学习其实类似于半监督学习的一个子问题，或者说是一个特殊化的半监督学习，所以也有人将其归为半监督学习。

## 强化学习

所谓强化学习就是智能系统从环境到行为映射的学习，以使奖励信号（强化信号）函数值最大，强化学习不同于连接主义学习中的监督学习，主要表现在教师信号上，强化学习中由环境提供的强化信号是对产生动作的好坏作一种评价（通常为标量信号），而不是告诉强化学习系统RLS（reinforcement learning system）如何去产生正确的动作。由于外部环境提供的信息很少，RLS必须靠自身的经历进行学习。通过这种方式，RLS在行动-评价的环境中获得知识，改进行动方案以适应环境。

在这种学习模式下，输入数据作为对模型的反馈，不像监督模型那样，输入数据仅仅是作为一个检查模型对错的方式，在强化学习下，输入数据直接反馈 到模型，模型必须对此立刻作出调整。设计一个回报函数（reward function），如果learning agent（如上面的四足机器人、象棋AI程序）在决定一步后，获得了较好的结果，那么我们给agent一些回报（比如回报函数结果为正），得到较差的结果，那么回报函数为负。比如，四足机器人，如果他向前走了一步（接近目标），那么回报函数为正，后退为负。如果我们能够对每一步进行评价，得到相应的回报函数，那么就好办了，我们只需要找到一条回报值最大的路径（每步的回报之和最大），就认为是最佳的路径。

常见的应用场景包括动态系统以及机器人控制等。常见算法包括Q-Learning以及时间差学习（Temporal difference learning）

## 迁移学习

在传统的机器学习的框架下，学习的任务就是在给定充分训练数据的基础上来学习一个分类模型；然后利用这个学习到的模型来对测试文档进行分类与预测。然而，我们看到机器学习算法在当前的Web挖掘研究中存在着一个关键的问题：一些新出现的领域中的大量训练数据非常难得到。我们看到Web应用领域的发展非常快速。大量新的领域不断涌现，从传统的新闻，到网页，到图片，再到博客、播客等等。传统的机器学习需要对每个领域都标定大量训练数据，这将会耗费大量的人力与物力。而没有大量的标注数据，会使得很多与学习相关研究与应用无法开展。其次，传统的机器学习假设训练数据与测试数据服从相同的数据分布。然而，在许多情况下，这种同分布假设并不满足。通常可能发生的情况如训练数据过期。这往往需要我们去重新标注大量的训练数据以满足我们训练的需要，但标注新数据是非常昂贵的，需要大量的人力与物力。从另外一个角度上看，如果我们有了大量的、在不同分布下的训练数据，完全丢弃这些数据也是非常浪费的。如何合理的利用这些数据就是迁移学习主要解决的问题。迁移学习可以从现有的数据中迁移知识，用来帮助将来的学习。

迁移学习（Transfer Learning）的目标就是将从一个环境中学到的知识用来帮助新环境中的学习任务。因此，迁移学习不会像传统机器学习那样作同分布假设。举一个通俗的例子，一个会下象棋的人可以更容易的学会下围棋；一个认识桌子的人可以更加容易的认识椅子；

在迁移学习方面的工作目前可以分为以下三个部分：同构空间下基于实例的迁移学习，同构空间下基于特征的迁移学习与异构空间下的迁移学习。基于实例的迁移学习有更强的知识迁移能力，基于特征的迁移学习具有更广泛的知识迁移能力，而异构空间的迁移具有广泛的学习与扩展能力。

迁移学习即一种学习对另一种学习的影响，它广泛地存在于知识、技能、态度和行为规范的学习中。任何一种学习都要受到学习者已有知识经验、技能、态度等的影响，只要有学习，就有迁移。迁移是学习的继续和巩固，又是提高和深化学习的条件，学习与迁移不可分割。对于人工智能的发展路径，很多人可能对基于大数据的人工智能很熟悉，但其实还有基于小样本的尝试和迁移，这也是人工智能的一种路径。

# 实用建议

总结了机器学习研究者和从业者的宝贵经验[^useful-suggestions][^Pedro-Domingos]，其中包括需要避免的陷阱、值得关注的重点问题、常见问题的答案：

[^useful-suggestions]: [7 Useful Suggestions from Andrew Ng “Machine Learning Yearning”](https://www.kdnuggets.com/2018/05/7-useful-suggestions-machine-learning-yearning.html)
[^Pedro-Domingos]: [A Few Useful Things to Know about Machine Learning](https://www.jiqizhixin.com/articles/Pedro-Domingos-12-useful-things-to-know-about-machine-learning)

1. 并非所有的问题都适合用机器学习解决（很多逻辑清晰的问题用规则能很高效和准确地处理），也没有一个机器学习算法可以通用于所有问题。从功能的角度分类，机器学习在一定量级的数据上，可以解决下列问题：分类、回归、聚类。
2. 快速选择开发/测试集——如果有必要不要害怕更换。思考清理贴错标签的开发/测试集是否值得。考虑将开发集分为多个子集。
1. 学习=表征+评估+优化。一个相关的问题是如何表征输入，即使用哪些特征。需要一个评估函数来区分分类器的好坏。我们要用一种方法搜索得分最高的分类器。
2. 泛化能力很关键。
3. 选择正确的评估指标。
3. 仅有数据是不够的。机器学习并非魔术，它无法做到无中生有，它所做的是举一反三。
4. 过拟合具有多面性。理解过拟合的一种方法是将泛化的误差进行分解，分为偏差和方差。除交叉验证之外，还有很多方法可以解决过拟合问题。最流行的是在评估函数中增加一个正则化项。
5. 高维度会挫伤直觉。
6. 理论保证与实际的出入。
7. 特征工程是关键。
8. 数据量为王。
9. 不单单学习一个模型。
10. 简单不意味着准确。
11. 可表征并不意味着可学习。
12. 相关性并不意味着因果关系。
13. 机器学习是一个迭代过程：不要指望第一次就成功。快速构建第一个系统，然后迭代。并行评估多个想法。


# 学习资源

[The Who’s Who Of Machine Learning, And Why You Should Know Them](https://towardsdatascience.com/the-whos-who-of-machine-learning-and-why-you-should-know-them-9cefbbc84f07)

机器学习里所说的“算法”与程序员所说的“数据结构与算法分析”里的“算法”略有区别。前者更关注结果数据的召回率、精确度、准确性等方面，后者更关注执行过程的时间复杂度、空间复杂度等方面。 当然，实际机器学习问题中，对效率和资源占用的考量是不可或缺的。

『数学基础』『典型机器学习算法』『编程基础』三个并行的部分，是因为机器学习是一个将数学/算法理论和工程实践紧密结合的领域，需要扎实的理论基础帮助引导数据分析与模型调优，同时也需要精湛的工程开发能力去高效化地训练和部署模型和服务。（每一个算法，要在训练集上最大程度拟合同时又保证泛化能力，需要不断分析结果和数据，调优参数，这需要我们对数据分布和模型底层的数学原理有一定的理解。）。具备了机器学习的必要条件，剩下的就是怎么运用它们去做一个完整的机器学习项目。其工作流程如下: 抽象成数学问题—— 获取数据——特征预处理与特征选择——训练模型与调优——模型诊断——模型融合——上线运行。

入门系列：

- [读懂机器学习需要哪些数学知识](https://www.jiqizhixin.com/articles/2018-04-12-4)
- 机器学习 新手快速入门 [Getting Started With MachineLearning (all in one).pdf](https://pan.baidu.com/s/1tNXYQNadAsDGfPvuuj7_Tw)
- Andrew Ng（中文名：吴恩达）自2002年获得博士学位以来，Andrew Ng一直在斯坦福任教。他创建并领导了谷歌大脑团队，该团队被认为是世界上最先进的ML/AI研究机构之一。
    - [My First Step Into Machine Learning](https://codeburst.io/my-first-step-into-machine-learning-23d2b071560e)。
    - Andrew Ng所拍摄的[《深度学习的英雄》(the heroes of deeplearning)的采访列表](https://www.youtube.com/watch?list=PLfsVAYSMwsksjfpy8P2t_I52mugGeA5gR&v=-eyhCTvrEtE)。
    - 吴恩达的新书[Machine Learning Yearning](http://www.mlyearning.org/)，是Ng在机器学习工程实践中的经验总结，非常实用且独一无二的一本书，短小精悍但干货十足，强烈推荐给从事数据领域的团队与个人。
- Geoffrey Hinton被称为AI教父，是神经网络领域的首批研究者之一。当他是卡内基梅隆大学的教授时，他是最早证明广义反向传播算法的研究者之一。在Andrew Ng的引导下，他在coursera上发布了他的[神经网络课程](https://www.coursera.org/learn/neural-networks)，这是一个巨大的成功。
- 2014年，Ian Goodfellow发表了一篇关于[GANs](https://medium.com/@ekss1121/generative-adversarial-networks-b9f80e6d7679)的论文，这是AI行业的一个突破。GANs基本上允许计算机进行想象，计算机可以训练与我们提供给它的模型相似的模型。
- Yann LeCun发明了卷积神经网络，如果没有他的贡献，图像识别领域就不会有进展。[关于人工智能未来的一个有趣的演讲](https://www.youtube.com/watch?v=rtGXv88UQ-c)。

个人博客系列：

- [统计学习方法– weng-JJ技术小站](http://120.79.254.53/)

免费机器学习书籍[^m9Vwc3SFZx3gv3RANJ72qA][^89576749d2ff]：

- [Data Science and Robots-Brandon Rohrer](http://brohrer.github.io/blog.html)
- 2018年3月1日，Google上线了AI学习网站——Learn with Google AI，并重磅推出了[机器学习速成课程MLCC](https://developers.google.com/machine-learning/crash-course/)，该课程基于TensorFlow（TF），旨在为所有经验水平的人提供免费课程、教程和动手练习。
- [Mining of Massive Datasets](http://mmds.org/#ver21)，[Social Media Mining](http://dmml.asu.edu/smm/)，
- [Awesome Data Science](https://github.com/bulutyazilim/awesome-datascience)（清单），[Scikit-Learn Tutorial: Statistical-Learning for Scientific Data Processing](http://gael-varoquaux.info/scikit-learn-tutorial/)
- [Think Bayes](http://greenteapress.com/wp/think-bayes/)，[Machine Learning and Big Data](http://www.kareemalkaseer.com/books/ml)，[Statistical Learning with Sparsity](https://web.stanford.edu/~hastie/StatLearnSparsity/)，[Statistical inference for data science](https://leanpub.com/LittleInferenceBook)，[Convex Optimization](http://stanford.edu/~boyd/cvxbook/)，
- [Understanding MachineLearning: From Theory to Algorithms](http://www.cs.huji.ac.il/~shais/UnderstandingMachineLearning/understanding-machine-learning-theory-algorithms.pdf)
- [Awesome Artificial Intelligence (AI)](https://github.com/owainlewis/awesome-artificial-intelligence)（清单）
- [Awesome-machine-learning](https://github.com/josephmisiti/awesome-machine-learning) （清单）。[Machine Learning (An Algorithmic Perspective)](https://seat.massey.ac.nz/personal/s.r.marsland/MLBook.html)
- [Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/)，[Deep Learning](http://www.iro.umontreal.ca/~bengioy/talks/lisbon-mlss-19juillet2015.pdf) [Deep Learning Tutorial](http://deeplearning.net/tutorial/deeplearning.pdf)
- [Awesome Reinforcement Learning](https://github.com/aikorea/awesome-rl)来自于aikorea整理的一份关于强化学习的代码、论文、应用、教程的清单。
- [An Introduction to Statistical Learning (with applications in R)](http://www-bcf.usc.edu/~gareth/ISL/)
- [Python Data Science Handbook](https://github.com/jakevdp/PythonDataScienceHandbook)，[Building Machine Learning Systems with Python](http://totoharyanto.staff.ipb.ac.id/files/2012/10/Building-Machine-Learning-Systems-with-Python-Richert-Coelho.pdf)，[Natural Language Processing with Python](https://www.nltk.org/book/)，[Automate the Boring Stuff with Python](https://automatetheboringstuff.com/)，

[^m9Vwc3SFZx3gv3RANJ72qA]: [一份最新的人工智能10大主题Github Awesome知识资料清单！值得收藏](https://mp.weixin.qq.com/s/m9Vwc3SFZx3gv3RANJ72qA)
[^89576749d2ff]: [免费机器学习书籍](https://towardsdatascience.com/list-of-free-must-read-machine-learning-books-89576749d2ff)

<div id="ml-dataset"></div>

# 数据集

> [机器学习高质量数据集大合辑](https://www.jiqizhixin.com/articles/2018-10-24-10)

<div class="note info"><p>部分网址需要[科学上网配置](https://sli1989.github.io/windows-use/#goagent)。</p></div>

- [List of datasets for machine learning research](https://en.wikipedia.org/wiki/List_of_datasets_for_machine_learning_research)  
- [UCI Machine Learning Repository: Data Sets](http://archive.ics.uci.edu/ml/datasets.html)是网络上最早的数据集来源之一，是寻找各种有趣数据集的第一选择。
- [Comp-Engine Time Series](http://www.comp-engine.org/timeseries/)
- [Datasets | Kaggle](https://www.kaggle.com/datasets)是由联合创始人、首席执行官安东尼·高德布卢姆（Anthony Goldbloom）2010年在墨尔本创立的，主要为开发商和数据科学家提供举办机器学习竞赛、托管数据库、编写和分享代码的平台。该平台已经吸引了80万名数据科学家的关注。
- [Data.gov](https://www.data.gov/?spm=5176.100239.0.0.Dlz4EY)
- [17 Free Data Science Projects To Boost Your Knowledge & Skills](https://www.analyticsvidhya.com/blog/2016/10/17-ultimate-data-science-projects-to-boost-your-knowledge-and-skills)
- [数据堂](http://www.datatang.com/)
- [Prognostics Center of Excellence - Data Repository](http://ti.arc.nasa.gov/tech/dash/pcoe/prognostic-data-repository/)
- [LIBSVM Data: Regression](http://www.csie.ntu.edu.tw/~cjlin/libsvmtools/datasets/regression.html)
- [Regression Data Sets](http://www.dcc.fc.up.pt/~ltorgo/Regression/DataSets.html)
- [Environmental and Industrial Machine Learning Group](http://research.ics.aalto.fi/eiml/datasets.shtml)
- [KEEL: A software tool to assess evolutionary algorithms for Data Mining problems (regression, classification, clustering, pattern mining and so on)](http://keel.es/datasets.php)
- [Sunspot Number | SILSO](http://www.sidc.be/silso/datafiles)
- [Met Office Hadley Centre observations datasets](http://hadobs.metoffice.com/hadcet/)
- [Energy Consumption Database](http://ecdms.energy.ca.gov/)
- [Time Series Data Library - Data provider — DataMarket](https://datamarket.com/data/list/?q=provider:tsdl)
- [Time Series Data | International Institute of Forecasters](https://forecasters.org/resources/time-series-data/)
- [neural-forecasting-competition](http://www.neural-forecasting-competition.com/datasets.htm)
- [Browse time-series data by category - Comp-Engine Time Series](http://www.comp-engine.org/timeseries/browse-data-by-category/)
- [PhysioBank Databases](https://physionet.org/physiobank/database/)
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown使用指南</title>
    <url>/markdown-user-guide/</url>
    <content><![CDATA[
Markdown 是一种轻量级标记语言，创始人为约翰·格鲁伯（John Gruber）。它允许人们“使用易读易写的纯文本格式编写文档，然后转换成有效的XHTML(或者HTML)文档”。这种语言吸收了很多在电子邮件中已有的纯文本标记的特性。本文主要介绍目前各种Markdown编辑器平台的优缺点，以及一些常用Markdown语言。

<!--more-->

# Markdown复制粘贴插件

- [Markdown, Please!](https://markdown.readmorejoy.com) 是一款能够将任意网页转换为 MarkDown 格式的在线服务，利用浏览器小书签，只需要点一下转换按钮即可获得 MarkDown 格式的网页内容。
- [拷贝为Markdown - Google Chrome](https://chrome.google.com/webstore/detail/copy-as-markdown/dgoenpnkphkichnohepecnmpmihnabdg)：将你在页面中选中的HTML格式转化为Markdown格式。


# Markdown编辑器

国产 Markdown 软件的数量虽然不多，但质量都很高，比如 [MWeb](https://sspai.com/app/MWeb) 和 [MarkEditor](https://sspai.com/app/MarkEditor)，也已有着各自的稳定用户群。Ulysses 的付费策略似乎让大家很不爽，网络上又开始聊起了「[有哪些好用的 Markdown 工具](https://sspai.com/post/40358)」的话题。

## Markdown在线编辑器

大体语法一致，有些功能不支持。推荐使用[作业部落 Cmd Markdown](https://www.zybuluo.com/)和[有道云笔记](https://note.youdao.com/web)。

- [作业部落 Cmd Markdown](https://www.zybuluo.com/)：实时更新预览，**推荐用于快速编辑分享**。没有批量导出功能，没有独立博客主页面。
- [有道云笔记](https://note.youdao.com/web)：排版一般，没有TOC列表。**推荐用于笔记保存**。
- [小书匠主页地址](http://markdown.xiaoshujiang.com/)：加载缓慢。
- [Markdown Plus](http://mdp.tylingsoft.com/)：不支持公开分享。
- [MaHua](http://mahua.jser.me/)：向编辑器mou致敬
- [马可飞象主页地址](https://maxiang.io/)：支持公式、TOC等高级功能，不支持公开分享链接，账户等级限制
- [简书](http://www.jianshu.com/)：不支持公式、TOC等高级功能。体验很一般。
- [CSDN博客](http://blog.csdn.net/)：预览模式有bug，体验一般。
- [Online Markdown Editor ](http://dillinger.io/)：不支持同步预览。

## Markdown离线编辑器

Windows离线编辑器则推荐使用[atom](#atom)（配合GIT BLOG使用）和[CuteMarkEd](https://cloose.github.io/CuteMarkEd/)。

- [CuteMarkEd](https://cloose.github.io/CuteMarkEd/)：内容过多时，反应速度慢，同步预览存在差距。
- [MarkdownPad](http://markdownpad.com/)：[TOC]和`~~`删除线无效。[破解版下载地址](http://pan.baidu.com/share/link?uk=4279083791&shareid=1114954037)，更多介绍[点击](https://wizardforcel.gitbooks.io/markdown-simple-world/content/1.html)查看。
  - 从 Win 8 开始右侧预览页面打不开，解决办法就是安装 [Awesomium 1.6.6 SDK](http://pan.baidu.com/s/1jGxpWxg)，如果还是不行就再安装 [Microsoft's DirectX End-User Runtimes (June 2010)](https://www.microsoft.com/en-us/download/details.aspx?id=8109)。一般只需要安装前者就可以了。
- [Yu Writer](https://ivarptr.github.io/yu-writer.site/)：支持全文搜索、支持 Tag（标签）管理。支持阅读模式。

<div id="atom"></div>

### Atom

1. 下载[atom](https://atom.io/)，并安装 `Visual Studio`。
1. 呼出`Panel`对话框(`Ctrl + Shift + P`)，跟Sublime Text是一样的。
1. 打开`settings`界面，点击左侧栏的`Install`按钮。然后在搜索框中输入关键字点击packages开始搜索，点击安装即可。
2. 重启ATOM

如果由于墙内原因，无法顺利安装。就需要进行离线安装packages

1. 到对应的github仓库下载压缩文件解压
2. 运行CMD，CD到对应文件夹
3. 运行npm install，不要用apm install，重启。  

常用插件可以参考：[Atom：优雅迷人的编辑神器](http://www.jianshu.com/p/b4c8479cfaa5)，[Atom 有什么优秀插件](https://www.zhihu.com/question/39938370)。

这里推荐以下几种：

- [markdown-preview-enhanced](https://atom.io/packages/markdown-preview-enhanced)，支持跟随预览、Tex公式、Pandoc等。[Markdown Preview En
hanced使用指南](https://shd101wyy.github.io/markdown-preview-enhanced/#/zh-cn/)
- [markdown-writer](https://atom.io/packages/markdown-writer)：支持快捷管理链接。安装后`Ctrl + Shift + P`运行`Markdown Writer: Create Default keymaps`并重启。  
- [Atom-Hexo](https://github.com/heroicyang/atom-hexo)，设置插件目录 `Current Working Directory`，执行`cmd-shift-P`，输入对应的命令即可。

其他可选插件：

- [git-control](https://github.com/jacogr/atom-git-control)，包括了比较,提交,撤销,获取,拉取,推送,合并,分支,版本发布等。
- [language-markdown](https://atom.io/packages/language-markdown)：提供 Github Flavored Markdown 等 MD 高亮支持  
- [markdown-scroll-sync](https://atom.io/packages/markdown-scroll-sync)：将内置插件 [markdown-preview](https://atom.io/packages/markdown-preview) 的编辑区和预览区同步滚动。
- [Markdown Preview Plus](https://github.com/atom-community/markdown-preview-plus)，支持显示latex公式。
- [tool-bar-markdown-writer](https://atom.io/packages/tool-bar-markdown-writer)，提供markdown写作工具栏，替代输入指令，必须先安装`tool-bar`和`markdown-writer packages`。
- [markdown-table-formatter](https://atom.io/packages/markdown-table-formatter)，格式化表格  
- [atom-pandoc-convert](https://github.com/josa42/atom-pandoc-convert)
- [markdown-pdf](https://atom.io/packages/markdown-pdf)，输出为PDF文件。在`Markdown Preview Plus`环境中无法使用，需要`markdown-preview atom package`。  
- [markdown-themeable-pdf](https://atom.io/packages/markdown-themeable-pdf)，输出为PDF文件，公式不支持打印。遇到不能转换PDF时，打开cmd，执行 `npm install phantomjs-prebuilt`，看到`Done. Phantomjs binary available at C:\Users\wxl\node_modules\phantomjs-prebuilt\lib\phantom\bin\phantomjs.exe `，重启atom。点击右键选择Markdown to PDF，即可。

### Sublime text

1. 安装[Package Control](https://packagecontrol.io/installation)、安装[Sublime text](https://www.sublimetext.com/3)
1. 安装插件。[Sublime Text 2安装插件方法详解](http://www.monring.com/front_end/sublime-text-2-install-package.html)。在 Sublime Text 中，按 `Ctrl+Shift+P` 呼出 `Command Palette` 然后找到 `Package Control: Install Package`，输入名称搜索即可。

推荐插件：

- markdown preview。默认没有快捷键，如下方式设置快捷键：在`Preferences -> Key Bindings User`打开的文件的中括号中添加以下代码： `{ "keys": ["alt+m"], "command": "markdown_preview", "args": { "target": "browser"} }`
- Markmon实时预览（[本地安装地址](https://github.com/yyjhao/sublime-text-markmon)）
  - 下载 [node](https://nodejs.org/en/download/)，启动CMD，`node -v`，`npm -v` 测试安装。输入 `npm install -g markmon` 安装 markmon (npm)。参考 [node 和 npm 安装使用](http://www.jianshu.com/p/c4b3c8b435ab)。
  - 安装 [pandoc](http://pandoc.org/installing.html)，实时监控文件编辑，以便实时预览。
  - 配置：`Preferences->Package Settings->Markmon->Settings - User`，编辑文件如下：`{ "executable": "markmon.cmd", }`
  - 重启 Sublime
  - 通过菜单 `Tools > markmo > Launch`，或者 `Control+Shift+P：Markmon launch`。在浏览器会打开 localhost:3000 页面，对于 Sublime 中的改变，你就会在浏览器中实时看到。Sublime 切换文件的同时，浏览器也会自动跟随切换，方便。

<div id="markdowngrammar"></div>

# Markdown语法

常用的Markdown语法可以查看[Cmd Markdown 编辑阅读器](https://www.zybuluo.com/mdeditor#527061)。

<div id="math"></div>

## 数学公式

[Mathjax与LaTex公式简介](http://mlworks.cn/posts/introduction-to-mathjax-and-latex-expression/)从[math.stackexchange.com](http://math.stackexchange.com/)上名为[MathJax basic tutorial and quick reference](http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference/5044)的问题翻译而来，并有所改动。主要讲述了如何使用MathJax和相关的Latex语法。

编辑TEX公式的详细内容可以点击查看[Latex公式使用技巧](https://sli1989.github.io/tex/#tex-math)，[Cmd Markdown 公式指导手册](https://www.zybuluo.com/codeep/note/163962)，[markdown编辑器使用LaTex数学公式](http://blog.csdn.net/testcs_dn/article/details/44229085)。

### MathJax渲染器

[MathJax](http://www.mathjax.org/ "MathJax官方网站")是一款运行在浏览器中的开源的数学符号渲染引擎，使用MathJax可以方便的在浏览器中显示数学公式，不需要使用图片。目前，MathJax可以解析Latex、MathML和ASCIIMathML的标记语言。著名的[Stackoverflow](http://stackoverflow.com/)网站上的漂亮公式，就是使用了MathJax插件的效果。添加MathJax插件也非常简单，只需要在markdown文件中，添加`MathJax CDN`，就可以在md文件中插入Tex格式的公式了。


```
<script type="text/javascript"
   src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
```

`行间公式`的形式为

```
$$ 此处插入公式 $$
```

而`行内公式`的形式为

```
\\( 此处插入公式 \\)
```

### Markdown Pad显示数学公式

之前的博文有推荐[Markdown Pad 2](http://markdownpad.com/)作为Window下的Markdown编辑器。如果你是使用该软件作为markdown的编辑器，你只需要在软件的`Tools-> Options-> Advanced-> HTML Head Editor`中添加上述的`MathJax CDN`即可。这样你就不必每次都在md文件中重复添加了。

### Atom中显示数学公式

点击查看[Atom的安装和使用](#atom)。实测在Atom实时渲染视图下，倘若使用`\ref`等标签可能无法正常显示公式，但是只要公式编写正确，在其他网站，如[在线Latex编辑器](http://latex.codecogs.com/eqneditor/editor.php)测试通过，那么就不必担心，猜测可能是markdown-preview-plus或者Atom的bug。另外，如果是通过apm安装的package，卸载时需要通过`apm uninstall {package_name}`或者`rm -rf .apm/{package_name}/`，通过GUI界面卸载可能会出现问题。

#### Markdown Preview Plus插件

[Markdown Preview Plus](https://github.com/atom-community/markdown-preview-plus)插件支持显示latex公式。

  - Search for and install markdown-preview-plus in Atom's Settings view.
  - Search for and **disable the built-in package markdown-preview**.
  - (Optional) Install and enable Pandoc.   
  - Toggle Preview: ctrl-shift-m
  - Toggle Math Rendering: ctrl-shift-x。Math Rendering Settings 可以指定两种不同parser：MathJax和Pandoc。[Pandoc](http://pandoc.org/)，堪称文档转换的瑞士军刀。勾选`markdown-preview-plus/Settins/Enable Pandoc Parser`，然后在`Pandoc Options: Path`输入pandoc的路径，如*nix系统可通过`which pandoc`获取。如果想获取公式渲染后的页面，那么在普通markdown渲染的基础上，还需要键入`Ctrl+Shift+X`以完成公式的渲染。

#### Markdown-preview-enhanced插件

[Markdown-preview-enhanced](https://atom.io/packages/markdown-preview-enhanced)，包含`markdown-scroll-sync`插件，自动显示latex公式，可以输出公式格式。**建议使用**。安装后在设置面板使用Pandoc parser。

<div id="hexo-math"></div>

### Hexo中显示数学公式

Markdown本身没有支持Latex，hexo先用[marked.js](http://lib.csdn.net/base/javascript "JavaScript知识库")渲染，然后再交给MathJax渲染。

在默认`hexo-renderer-marked`环境下，在`marked.js`渲染的时候下划线`_`是被escape掉并且换成了`<em>`标签，即斜体字，另外LaTeX中的`\\`也会被转义成一个`\`，这样会导致MathJax渲染时不认为它是一个换行符了。所以这个错误是由Markdown渲染器引起的。

我们要做的是怎样解决 `Markdown` 与 `Mathjax` 的一些冲突的问题，接下来介绍一些常用的方法。

#### 选择渲染器

推荐使用[pandoc渲染器](#hexo-pandoc)。

<div class="note info"><p>第一种方法：手动修改转义符。</p></div>

这个方法最直接，需要转义我就转义。比如我需要在公式中写下标符号，那就修改写法写为: `$x\_i$`；需要换行就使用`\\\\`。 很明显，这种方式虽然可以解决问题，但通用性很差，比如想迁移到其它地方，就无法识别了，因为大部分的markdown引擎是没有这个问题的。

文章[让Hexo在使用Mathjax时支持多行公式](http://kubicode.me/2016/03/18/Hexo/The-Trick-about-Hexo-Support-MutliLine-Equation-using-Mathjax/)提到如何解决这一问题：将换行符`\\`改写成`\\\\`。

<div class="note info"><p>第二种方法：修改渲染源码。</p></div>

具体思路参考了[使Marked.js与MathJax共存](http://blog.csdn.net/emptyset110/article/details/50123231)，其他本地修改策略可以查看[在 Hexo 中完美使用 Mathjax 输出数学公式](http://lukang.me/2014/mathjax-for-hexo.html)，打开hexo的markdown引擎渲染源码`nodes_modules/marked/lib/marked.js`，进行如下修改（未测试）。这种方式指标不治本，因为保证不了还可能有其它的字符会冲突。

第一步: 找到下面的代码，去掉`\\`的转义了。

```
escape: /^\\([\\`*{}\[\]()# +\-.!_>])/,
改为:
escape: /^\\([`*{}\[\]()# +\-.!_>])/,
```

第二步: 找到em的符号: 去掉`_`的斜体含义，markdown中有`*`也可以表示斜体，这样就解决了。


```
em: /^\b_((?:[^_]|__)+?)_\b|^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,
修改为
em: /^\*((?:\*\*|[\s\S])+?)\*(?!\*)/,

em: /^_(?=\S)([\s\S]*?\S)_(?!_)|^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
修改为
em: /^\*(?=\S)([\s\S]*?\S)\*(?!\*)/
```

<div class="note info"><p>第三种方法：使用其他渲染器插件。</p></div>

- Rawblock插件（未测试）

在[issue #524](https://github.com/hexojs/hexo/issues/524) 中，有人提到了**可以使用 rawblock 来解决**，可是每次要写公式都得在公式前后加上 rawblock 来声明实在太烦了，对于公式大户来说简直要崩溃。

- ~~Hexo-math插件~~

[利用MathJax来渲染LaTeX数学公式](http://blog.csdn.net/emptyset110/article/details/50123231#t5)，首先通过安装Hexo-math插件，然后手动修改`marked.js`与MathJax并存，之后重新生成和部署网站即可。Gitlab方案无法执行，本地HEXO未测试。

```
npm install hexo-math --save
```

- Hexo-renderer-markdown-it插件

~~在[为hexo添加上标、下标、脚注等功能](http://jovi.cc/2016/12/03/%E4%B8%BAhexo%E6%B7%BB%E5%8A%A0%E4%B8%8A%E6%A0%87%E3%80%81%E4%B8%8B%E6%A0%87%E3%80%81%E8%84%9A%E6%B3%A8%E7%AD%89%E5%8A%9F%E8%83%BD/)中使用 [hexo-renderer-markdown-it](https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki/Getting-Started) 进行渲染，先卸载Hexo自带的Markdown解析器 hexo-renderer-marked，再安装 `hexo-renderer-markdown-it` 就可以了。安装完以后，先 `hexo clean && hexo g` 重新生成静态网页，然后 `hexo s` 查看，这回公式能正常显示了。~~

```
npm uninstall hexo-renderer-marked --save
npm install hexo-renderer-markdown-it --save
```

但是使用 hexo-renderer-markdown-it 渲染之后，<font color=red>原本为Markdown编写的TOC里的链接都失效了，侧边栏的快速导航链接也失效了，也不支持NexT的`<!–more–>`标签</font> 。本地hexo推送可以参考[使用hexo-markdown-it导致文章目录失效的解决方案](http://www.jasonsi.com/2016/08/12/20/)。

- Hexo-renderer-kramed插件（未测试）

[Hexo-renderer-kramed ](https://github.com/sun11/hexo-renderer-kramed)插件fork了 hexo-renderer-marked 项目，并且只针对MathJax支持进行了改进。卸载 hexo-renderer-marked（注意，如果你使用了其他的渲染插件，请卸载对应的插件），然后安装 hexo-renderer-kramed。这下，不仅能正常使用TOC，也能完美地支持MathJax渲染了。至此，问题得到了解决。

```
npm uninstall hexo-renderer-marked --save
npm install hexo-renderer-kramed --save
```

但<font color=red> 关于行内代码，确实还存在一点问题</font>。因为kramed只是提高了LaTeX公式渲染的优先级，使类似 `'formula'`的语法不会被Markdown引擎替换，从而可以正确的被渲染成LaTeX公式。也就是说，对于kramed而言，出现 `'` 符以后的两个 `$` 符之间的部分才会被kramed认为是行内公式。要解决这个问题需要修改kramed的渲染机制。

<div id="hexo-pandoc"></div>

- hexo-renderer-pandoc插件<font color=blue>（推荐）</font>

Hexo 默认的渲染器为 marked (hexo-renderer-marked) 渲染器，该渲染器仅支持 md 的基本规范。感兴趣的朋友也不妨去[hexo-renderer-pandoc主页](https://github.com/wzpan/hexo-renderer-pandoc)看看。**Pandoc也可以实现在gitlab自动部署**，查看[`.gitlab-ci.yml`](http://sli1989.github.io/git/#gitlab-ci)文件设置。

本地hexo博客的搭建：

1. 首先需安装 [pandoc](https://github.com/jgm/pandoc) 软件。
1. 然后卸载Hexo自带的Markdown解析器 `hexo-renderer-marked`，再安装 hexo-renderer-pandoc 就可以了。

    ```
    npm un hexo-renderer-marked --save
    npm install hexo-renderer-pandoc --save
    ```

<div class="note info"><p>由于`hexo-renderer-pandoc`更新加入了`template`设置，需要在站点配置文件`~/blog/_config.yml`中加入默认配置（[issues](https://github.com/wzpan/hexo-renderer-pandoc/issues/16)）。</p></div>

<div class="note info"><p>考虑到[图片块解析错误](https://github.com/wzpan/hexo-renderer-pandoc/issues/34)，建议添加`-implicit_figures`选项。</p></div>

```
pandoc:
  filters:
  extra:
  template:
  meta:
  mathEngine:
  extensions:
    - '-implicit_figures'
```

<div id="hexo-mathjax"></div>

#### 配置MathJax

Hexo内置的Mathjax开启方式:

```
# Math Equations Render Support
math:
  enable: false

  # Default(true) will load mathjax/katex script on demand
  # That is it only render those page who has 'mathjax: true' in Front Matter.
  # If you set it to false, it will load mathjax/katex srcipt EVERY PAGE.
  per_page: true

  engine: mathjax
  #engine: katex

  # hexo-rendering-pandoc (or hexo-renderer-kramed) needed to full MathJax support.
  mathjax:
    # Use 2.7.1 as default, jsdelivr as default CDN, works everywhere even in China
    cdn: //cdn.jsdelivr.net/npm/mathjax@2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML
    # For newMathJax CDN (cdnjs.cloudflare.com) with fallback to oldMathJax (cdn.mathjax.org).
    #cdn: //cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML
    # For direct link to MathJax.js with CloudFlare CDN (cdnjs.cloudflare.com).
    #cdn: //cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML

  # hexo-renderer-markdown-it-plus (or hexo-renderer-markdown-it with markdown-it-katex plugin)
  # needed to full Katex support.
  katex:
    # Use 0.7.1 as default, jsdelivr as default CDN, works everywhere even in China
    cdn: //cdn.jsdelivr.net/npm/katex@0.7.1/dist/katex.min.css
    # CDNJS, provided by cloudflare, maybe the best CDN, but not works in China
    #cdn: //cdnjs.cloudflare.com/ajax/libs/KaTeX/0.7.1/katex.min.css
```

<div class="note info"><p>如果在 Next 低版本中Mathjax开启后还是无法显示公式，尝试更改主题配置文件`~/blog/themes/next/_config.yml`中 CDN 地址，相关[issues](https://github.com/theme-next/hexo-theme-next/issues/19)。</p></div>

<div class="note info"><p>如果上述配置成功，不必修改以下。</p></div>

如果CDN还是失效，可以尝试进行如下修改。

[NexT 主题私人定制](https://maxchendt.github.io/Blog/20161007NextSet.html)遵照 [Loading and Configuring MathJax](http://docs.mathjax.org/en/latest/configuration.html) 的指引，修改MathJax为纯 JavaScript 代码。对于整个博客网站，只需要载入一次，任何页面都不需要重复载入。

1. 在`/themes/next/source/js`中添加文件`custom.js`，在`custom.js`中添加

    ```
    //MathJax
    window.MathJax = {
        AuthorInit: function () {
          MathJax.Hub.Register.StartupHook("Begin",function () {
            MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for (i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
          }
        });
          });
        }
      };

    window.MathJax = {
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      };


    //  <script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    // jQuery
    $.getScript('https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML', function()
    {
        // script is now loaded and executed.
        // put your dependent JS here.
    });
    ```

1. 然后在文件`/layout/_layout.swig`中`/body`前加入以下代码。~~为了避免首页MathJax加载出错，配合判断条件`page.comments`使用（需要显示公式的文章一定要设置`comments: true`）。~~

    ```
    //{% if page.comments %}
    <script type="text/javascript" src="/js/custom.js"></script>
    //{% endif %}
    ```

#### 公式测试

<font color=red>Bug 提醒</font> ：[hexo issues/2064](https://github.com/hexojs/hexo/issues/2064) 提到了 连续两个花括号的问题，即两个连续 `{ {`会提示渲染错误`Template render error: (unknown path) expected variable end`。

```
$EI=\{{EI}_1,{EI}_2,\cdots,{EI}_V\}$
1+e^{{\mathbf{v}_{w_j}^{'}}^{T}}`
```

<font color=red>目前暂时解决办法是</font> ：

1.  采用`\lbrace`和`\rbrace`替换原先的`{`和`}`
2.  两个`{`中间加个空格：`$\mathrm{cov}_{t_{b}}^{ {}}\left(  S(t_{c}),F(t_{c})\right)$`，其中空上标 `^{ {}}` 无效果，应该改成 `^{\,}`。或者使用使用 `\` 保留外层花括号：`$EI=\{ {EI}_1,{EI}_2,\cdots,{EI}_V\}$` 。

<font color=blue>行内公式：测试正常。</font>

```
行内公式： $R{m \times n} = U{m \times m} S{m \times n} V{n \times n}’$，$d_{1}=\frac{\ln(S_{t}/K)  +(r+\sigma^{2}/2)(T-t)}{\sigma\sqrt{T-t}}$。This is an example for $x_mu$ and $y_mu$. This is an example for $x_{mu}$ and $y_{mu}$.
This is an example for $x\_mu$ and $y\_mu$.
```

行内公式测试： $R{m \times n} = U{m \times m} S{m \times n} V{n \times n}’$，$d_{1}=\frac{\ln(S_{t}/K)  +(r+\sigma^{2}/2)(T-t)}{\sigma\sqrt{T-t}}$。This is an example for $x_mu$ and $y_mu$. This is an example for $x_{mu}$ and $y_{mu}$.

<font color=blue>行间公式：测试正常。一个`$ $`公式为行内公式，显示不居中。二个`$$ $$`公式为行间公式，显示居中。加入转义符就是转义符意思。</font>

```
$T(n) = \Theta(n)$
$$T(n) = \Theta(n)$$
```

$T(n) = \Theta(n)$

$$T(n) = \Theta(n)$$


```
$$R{m \times n} = U{m \times m} S{m \times n} V{n \times n}’$$
$$R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}'$$
```

$$R{m \times n} = U{m \times m} S{m \times n} V{n \times n}’$$
$$R_{m \times n} = U_{m \times m} S_{m \times n} V_{n \times n}'$$

```
$$d_{1}=\frac{\ln(S_{t}/K)  +(r+\sigma^{2}/2)(T-t)}{\sigma\sqrt{T-t}}$$

加markdown转义字符：
$$d\_{1}=\frac{\ln(S\_{t}/K)  +(r+\sigma^{2}/2)(T-t)}{\sigma\sqrt{T-t}}$$
```

$$d_{1}=\frac{\ln(S_{t}/K)  +(r+\sigma^{2}/2)(T-t)}{\sigma\sqrt{T-t}}$$

$$d\_{1}=\frac{\ln(S\_{t}/K)  +(r+\sigma^{2}/2)(T-t)}{\sigma\sqrt{T-t}}$$

```
$$T(n) = \Theta(n) + \sum{i=0}^{n-1}{O({n}{i}^2)}$$
$$T(n) = \Theta(n) + \sum_{i=0}^{n-1}{O({n}_{i}^2)}$$
$$T(n) = \Theta(n) + \sum\_{i=0}^{n-1}{O({n}\_{i}^2)}$$
```

$$T(n) = \Theta(n) + \sum{i=0}^{n-1}{O({n}{i}^2)}$$
$$T(n) = \Theta(n) + \sum_{i=0}^{n-1}{O({n}_{i}^2)}$$
$$T(n) = \Theta(n) + \sum\_{i=0}^{n-1}{O({n}\_{i}^2)}$$


<font color=blue>麦克斯韦方程组查看LaTeX效果：测试正常。</font>

```
$$
\begin{eqnarray}
\nabla\cdot\vec{E} &=& \frac{\rho}{\epsilon_0} \\
\nabla\cdot\vec{B} &=& 0 \\
\nabla\times\vec{E} &=& -\frac{\partial B}{\partial t} \\
\nabla\times\vec{B} &=& \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)
\end{eqnarray}
$$
```

$$
\begin{eqnarray}
\nabla\cdot\vec{E} &=& \frac{\rho}{\epsilon_0} \\
\nabla\cdot\vec{B} &=& 0 \\
\nabla\times\vec{E} &=& -\frac{\partial B}{\partial t} \\
\nabla\times\vec{B} &=& \mu_0\left(\vec{J}+\epsilon_0\frac{\partial E}{\partial t} \right)
\end{eqnarray}
$$

## 交叉引用

<div id="hexo-crossref"></div>

在HEXO中使用交叉引用，you only need learning how to install `Haskell` package。

<div class="note warning"><p>未测试</p></div>

- [hexo-renderer-pandoc](https://github.com/wzpan/hexo-renderer-pandoc). But there seems some confusion in its `readme.md`, and you could investigate more deeply by [blog](http://bitwan.net/2018/02/20/hackHexoRenderPandoc/).
- [pandoc](http://pandoc.org/installing.html). You just need to install it if you only use `hexo-renderer-pandoc`.
- [pandoc-citeproc](https://github.com/jgm/pandoc-citeproc). You just need to install it if you only use `hexo-renderer-pandoc`.
- [pandoc-crossref](https://github.com/lierdakil/pandoc-crossref). And its syntax usage when writing your markdown.

1. Do not use `Haskell` within `windows operation system`;  
1. Do not mess up the order of the filters, i.e. `pandoc-crossref` and `pandoc-citeproc`, as well as `--bibliography`. At least when use `pandoc` in `shell`, if you mess up the order of them, it won't work as you expect. ( refer to: [`pandoc`, `multiple filter`](https://www.google.de/search?q=pandoc+multiple+filters&ie=utf-8&oe=utf-8&gws_rd=cr&dcr=0&ei=fhSVWpWJB8GhUZyBoNgK))

## 列表排列

Markdown在使用有序列表和无序列表的时候，如果中间插入其他内容（甚至是子层级的内容），有序列表的自动编码功能以及无序代码的层级功能会遇到问题。解决方法是，有点类似于编程中，通过缩进对齐的方式（通过Tab键），最外层同级别的不需要缩进，然后下一级的都缩进一次（点一次Tab），然后如果还继续细分下一层，那么输入的时候就缩进两次。

第一次测试：（Tab键以[Tab]展示，空格以[空格]展示）

```
1.[空格]测试文字1
[Tab]-[空格]测试文字1-1
[Tab]-[空格]测试文字1-2
2.[空格]测试文字2
[Tab]-[空格]测试文字2-1
[Tab][Tab]-[空格]测试文字2-1-1
[Tab][Tab]-[空格]测试文字2-1-2
[Tab]-[空格]测试文字2-2
```

## 页面跳转


定义一个锚，其中`id="jump_label"`是自己设定的该位置标记，可以随意修改。推荐使用`div`标签实现跳转。

```
<div id="jump_label"></div>

<span id="jump_label">text</span>
```

- 页内跳转

将定义好的位置标记放到要跳转到的地方，Hexo主题不支持[内嵌图标](http://fontawesome.io/3.2.1/icons/)显示。

```
[这句话是想要跳转到footer处的锚点链接，点击即会跳转](#jump_label)
[<i class="icon-home"></i>](#jump_label)
```

- 页间跳转

最直接的方法，jekyll主题博客点击目录标签，复制地址栏地址即可。hexo主题博客需要在目录标签处右键复制链接即可。但是如果存在中文内容，该方法不好看。推荐使用自定义标签方法。

首先，先定义一个锚，然后添加跳转到的页面的链接，再加`/#jump_label`。

```
[现在点击此链接，可实现页间跳转](http://blog.csdn.net/thither_shore/article/details/52185758/#jump_label)
```

## Emoji

```
:camel:
:blush:
:smile:
```

<div id="footnotes"></div>

## 脚注

脚注是在需要标记脚注文字的后面增加一个方括号，方括号中的内容必须以 `^` 开头，再接着是数字、字符串标记：

```
Footnotes[^1] have a label[^label] and a definition[^2].
```

Footnotes[^1] have a label[^label] and a definition[^2].

接着，在文件的任意地方，你可以把这个脚注的内容定义出来：

```
[^1]: This is a footnote
[^label]: A footnote on "label"
[^2]: The definition of a footnote.
```

[^1]: This is a footnote
[^label]: A footnote on "label"
[^2]: The definition of a footnote.

脚注内容定义的形式就是前面引用脚注的内容，接着一个冒号，再接着一个以上的空格或制表符，最后是脚注定义的内容。

A footnote definition may contain multiple lines, paragraphs, code blocks, blockquotes and most any other markdown syntax. The additional line simply must be indented at least an additional four spaces.
脚注定义的内容可以包含多行、段落、代码区块、区块引用和大多数其他 markdown 格式的内容。对于多行的内容只需要简单缩进至少4个空格。

```
[^1]: The first paragraph of the definition.

        Paragraph two of the definition.

        > A blockquote with
        > multiple lines.

                a code block

        A final paragraph.
```

By default, the footnote definitions are placed at the end of the resulting HTML document. However, you may want the footnotes in another location within the document. Simply place the following text at that location within your markdown document.

默认情况下，脚注内容位于生成的 HTML 文档末尾。但是，你也许想将脚注内容放在文档的其他位置。只需要将如下内容放在需要的 markdown 文档位置即可。

```
///Footnotes Go Here///
```


<div id="hexo-footnotes"></div>

### Hexo显示脚注

关于脚注的支持，[hexo-footnotes](https://github.com/LouisBarranqueiro/hexo-footnotes)，脚注要人工编号，也不支持 inline 脚注。 [Markdown-it](https://github.com/markdown-it/markdown-it) 对脚注等支持体验不佳，不仅需要改变渲染器，并且配置复杂，此外还需要 [markdown-it-footnote](https://github.com/markdown-it/markdown-it-footnote) 插件。

1. ~~第一种方法，hexo-reference插件，这个插件默认使用的是一个 CDN 的CSS，我给改成本地的了，需要修改的是`node_modules/hexo-reference/index.js`~~。**测试后该插件版式异常，不要使用**。

    ```
    npm install hexo-reference --save
    ```

    ```
    // Add CDN CSS resources
    hexo.extend.filter.register('after_post_render', function(data) {
      data.content =
          util.htmlTag('link', {rel: 'stylesheet', type: 'text/css', href: '/css/lib/hint.min.css'}) +
          data.content;
      return data;
    });
    ```

Pandoc is a universal document converter！对 md 扩展支持让我拜倒，例如[脚注的支持](http://pandoc.org/MANUAL.html#footnotes)部分。需要提醒的是：pandoc 渲染器对 md 的格式要求更加规范些，例如 链接需要用`< >`括号显式包含；quoteblock 每行必须跟两空格表示换行(如果后续行没有`>`标记的话)。当然，把 [Pandoc’s Markdown](http://pandoc.org/MANUAL.html#pandocs-markdown) 浏览一下是很有必要的，或者 [pdf 版本](http://pandoc.org/MANUAL.pdf)。

1. 第二种方法，使用Pandoc渲染器：

    在文件`/layout/_layout.swig`中`/body`前加入：

    ```
    <script type="text/javascript" src="/js/custom.js"></script>
    ```

    在`/themes/next/source/js`中添加文件`custom.js`，在`custom.js`中添加

    ```
    // 函数: html 中去掉 某 tag 最后那一次出现
    var rmLastElm = function(text, selector) {
        var wrapped = $("<div>" + text + "</div>");
        wrapped.find(selector).last().remove();
        return wrapped.html();
    }
    // 弹出 tip 显示 脚注
    var $fRef = $(".footnoteRef");
    for(let i=0; i<$fRef.length; i++) {
    	var sup = $fRef.children("sup")[i];		//work reliably as long as there's exactly one sup per footnotRef
    //	var sup = $fRef[i].children("sup");		//a classic Dom Element, so it doesn't have any children method
    	sup.onmouseover = function(event) {
    		$('.footnoteTip').remove();
    		var pTip = document.createElement('div');
    		pTip.className = 'footnoteTip';		// CSS
    		pTip.innerHTML = rmLastElm(document.getElementById($fRef[i].getAttribute("href").substring(1)).innerHTML,"a");
    		document.body.appendChild(pTip);

    		var posLeft = event.pageX - 180;
    		if (posLeft<0) posLeft = 20;
    		var posTop = event.pageY + 20;
    		var od = $('.footnoteTip');
    		var oH = od.outerHeight();
    		var oW = od.outerWidth();
    		if(posTop + oH - window.pageYOffset > $(window).height()) 	posTop = posTop - oH -40;
    		if (posLeft + oW > $(window).width()) posLeft = $(window).width() - oW -20;	//NexT.Mist pageXOffset=0
    		pTip.style.left = posLeft + 'px';
    		pTip.style.top = posTop + 'px';

    	};

    	sup.onmouseout = function(event) {
    		$('.footnoteTip').remove();
    	};
    }
    ```

## 外链播放器

更多设置，查看[音乐外链](https://sli1989.github.io/music/)。

## 字体、字号与颜色

Markdown是一种可以使用普通文本编辑器编写的标记语言，通过类似HTML的标记语法，它可以使普通文本内容具有一定的格式。但是它本身是不支持修改字体、字号与颜色等功能的！[CSDN-markdown编辑器语法——字体、字号与颜色](http://blog.csdn.net/testcs_dn/article/details/45719357)

```
<font face="黑体">我是黑体字</font>
<font face="微软雅黑">我是微软雅黑</font>
<font face="STCAIYUN">我是华文彩云</font>
<font color=#0099ff size=7 face="黑体">color=#0099ff size=72 face="黑体"</font>
<font color=#00ffff size=72>color=#00ffff</font>
<font color=gray size=72>color=gray</font>
```

### 字体颜色名列表

颜色名 | 十六进制颜色值  | 颜色   
-- | -- | --
<font color="AliceBlue">AliceBlue</font>                       | <font color="#F0F8FF">#F0F8FF</font> | rgb(240, 248, 255)
<font color="AntiqueWhite">AntiqueWhite</font>                 | <font color="#FAEBD7">#FAEBD7</font> | rgb(250, 235, 215)
<font color="Aqua">Aqua</font>                                 | <font color="#00FFFF">#00FFFF</font> | rgb(0, 255, 255)  
<font color="Aquamarine">Aquamarine</font>                     | <font color="#7FFFD4">#7FFFD4</font> | rgb(127, 255, 212)
<font color="Azure">Azure</font>                               | <font color="#F0FFFF">#F0FFFF</font> | rgb(240, 255, 255)
<font color="Beige">Beige</font>                               | <font color="#F5F5DC">#F5F5DC</font> | rgb(245, 245, 220)
<font color="Bisque">Bisque</font>                             | <font color="#FFE4C4">#FFE4C4</font> | rgb(255, 228, 196)
<font color="Black">Black</font>                               | <font color="#000000">#000000</font> | rgb(0, 0, 0)      
<font color="BlanchedAlmond">BlanchedAlmond</font>             | <font color="#FFEBCD">#FFEBCD</font> | rgb(255, 235, 205)
<font color="Blue">Blue</font>                                 | <font color="#0000FF">#0000FF</font> | rgb(0, 0, 255)    
<font color="BlueViolet">BlueViolet</font>                     | <font color="#8A2BE2">#8A2BE2</font> | rgb(138, 43, 226)
<font color="Brown">Brown</font>                               | <font color="#A52A2A">#A52A2A</font> | rgb(165, 42, 42)  
<font color="BurlyWood">BurlyWood</font>                       | <font color="#DEB887">#DEB887</font> | rgb(222, 184, 135)
<font color="CadetBlue">CadetBlue</font>                       | <font color="#5F9EA0">#5F9EA0</font> | rgb(95, 158, 160)
<font color="Chartreuse">Chartreuse</font>                     | <font color="#7FFF00">#7FFF00</font> | rgb(127, 255, 0)  
<font color="Chocolate">Chocolate</font>                       | <font color="#D2691E">#D2691E</font> | rgb(210, 105, 30)
<font color="Coral">Coral</font>                               | <font color="#FF7F50">#FF7F50</font> | rgb(255, 127, 80)
<font color="CornflowerBlue">CornflowerBlue</font>             | <font color="#6495ED">#6495ED</font> | rgb(100, 149, 237)
<font color="Cornsilk">Cornsilk</font>                         | <font color="#FFF8DC">#FFF8DC</font> | rgb(255, 248, 220)
<font color="Crimson">Crimson</font>                           | <font color="#DC143C">#DC143C</font> | rgb(220, 20, 60)  
<font color="Cyan">Cyan</font>                                 | <font color="#00FFFF">#00FFFF</font> | rgb(0, 255, 255)  
<font color="DarkBlue">DarkBlue</font>                         | <font color="#00008B">#00008B</font> | rgb(0, 0, 139)    
<font color="DarkCyan">DarkCyan</font>                         | <font color="#008B8B">#008B8B</font> | rgb(0, 139, 139)  
<font color="DarkGoldenRod">DarkGoldenRod</font>               | <font color="#B8860B">#B8860B</font> | rgb(184, 134, 11)
<font color="DarkGray">DarkGray</font>                         | <font color="#A9A9A9">#A9A9A9</font> | rgb(169, 169, 169)
<font color="DarkGreen">DarkGreen</font>                       | <font color="#006400">#006400</font> | rgb(0, 100, 0)    
<font color="DarkKhaki">DarkKhaki</font>                       | <font color="#BDB76B">#BDB76B</font> | rgb(189, 183, 107)
<font color="DarkMagenta">DarkMagenta</font>                   | <font color="#8B008B">#8B008B</font> | rgb(139, 0, 139)  
<font color="DarkOliveGreen">DarkOliveGreen</font>             | <font color="#556B2F">#556B2F</font> | rgb(85, 107, 47)  
<font color="Darkorange">Darkorange</font>                     | <font color="#FF8C00">#FF8C00</font> | rgb(255, 140, 0)  
<font color="DarkOrchid">DarkOrchid</font>                     | <font color="#9932CC">#9932CC</font> | rgb(153, 50, 204)
<font color="DarkRed">DarkRed</font>                           | <font color="#8B0000">#8B0000</font> | rgb(139, 0, 0)    
<font color="DarkSalmon">DarkSalmon</font>                     | <font color="#E9967A">#E9967A</font> | rgb(233, 150, 122)
<font color="DarkSeaGreen">DarkSeaGreen</font>                 | <font color="#8FBC8F">#8FBC8F</font> | rgb(143, 188, 143)
<font color="DarkSlateBlue">DarkSlateBlue</font>               | <font color="#483D8B">#483D8B</font> | rgb(72, 61, 139)  
<font color="DarkSlateGray">DarkSlateGray</font>               | <font color="#2F4F4F">#2F4F4F</font> | rgb(47, 79, 79)   
<font color="DarkTurquoise">DarkTurquoise</font>               | <font color="#00CED1">#00CED1</font> | rgb(0, 206, 209)  
<font color="DarkViolet">DarkViolet</font>                     | <font color="#9400D3">#9400D3</font> | rgb(148, 0, 211)  
<font color="DeepPink">DeepPink</font>                         | <font color="#FF1493">#FF1493</font> | rgb(255, 20, 147)
<font color="DeepSkyBlue">DeepSkyBlue</font>                   | <font color="#00BFFF">#00BFFF</font> | rgb(0, 191, 255)  
<font color="DimGray">DimGray</font>                           | <font color="#696969">#696969</font> | rgb(105, 105, 105)
<font color="DodgerBlue">DodgerBlue</font>                     | <font color="#1E90FF">#1E90FF</font> | rgb(30, 144, 255)
<font color="Feldspar">Feldspar</font>                         | <font color="#D19275">#D19275</font> | rgb(209, 146, 117)
<font color="FireBrick">FireBrick</font>                       | <font color="#B22222">#B22222</font> | rgb(178, 34, 34)  
<font color="FloralWhite">FloralWhite</font>                   | <font color="#FFFAF0">#FFFAF0</font> | rgb(255, 250, 240)
<font color="ForestGreen">ForestGreen</font>                   | <font color="#228B22">#228B22</font> | rgb(34, 139, 34)  
<font color="Fuchsia">Fuchsia</font>                           | <font color="#FF00FF">#FF00FF</font> | rgb(255, 0, 255)  
<font color="Gainsboro">Gainsboro</font>                       | <font color="#DCDCDC">#DCDCDC</font> | rgb(220, 220, 220)
<font color="GhostWhite">GhostWhite</font>                     | <font color="#F8F8FF">#F8F8FF</font> | rgb(248, 248, 255)
<font color="Gold">Gold</font>                                 | <font color="#FFD700">#FFD700</font> | rgb(255, 215, 0)  
<font color="GoldenRod">GoldenRod</font>                       | <font color="#DAA520">#DAA520</font> | rgb(218, 165, 32)
<font color="Gray">Gray</font>                                 | <font color="#808080">#808080</font> | rgb(128, 128, 128)
<font color="Green">Green</font>                               | <font color="#008000">#008000</font> | rgb(0, 128, 0)    
<font color="GreenYellow">GreenYellow</font>                   | <font color="#ADFF2F">#ADFF2F</font> | rgb(173, 255, 47)
<font color="HoneyDew">HoneyDew</font>                         | <font color="#F0FFF0">#F0FFF0</font> | rgb(240, 255, 240)
<font color="HotPink">HotPink</font>                           | <font color="#FF69B4">#FF69B4</font> | rgb(255, 105, 180)
<font color="IndianRed">IndianRed</font>                       | <font color="#CD5C5C">#CD5C5C</font> | rgb(205, 92, 92)  
<font color="Indigo">Indigo</font>                             | <font color="#4B0082">#4B0082</font> | rgb(75, 0, 130)   
<font color="Ivory">Ivory</font>                               | <font color="#FFFFF0">#FFFFF0</font> | rgb(255, 255, 240)
<font color="Khaki">Khaki</font>                               | <font color="#F0E68C">#F0E68C</font> | rgb(240, 230, 140)
<font color="Lavender">Lavender</font>                         | <font color="#E6E6FA">#E6E6FA</font> | rgb(230, 230, 250)
<font color="LavenderBlush">LavenderBlush</font>               | <font color="#FFF0F5">#FFF0F5</font> | rgb(255, 240, 245)
<font color="LawnGreen">LawnGreen</font>                       | <font color="#7CFC00">#7CFC00</font> | rgb(124, 252, 0)  
<font color="LemonChiffon">LemonChiffon</font>                 | <font color="#FFFACD">#FFFACD</font> | rgb(255, 250, 205)
<font color="LightBlue">LightBlue</font>                       | <font color="#ADD8E6">#ADD8E6</font> | rgb(173, 216, 230)
<font color="LightCoral">LightCoral</font>                     | <font color="#F08080">#F08080</font> | rgb(240, 128, 128)
<font color="LightCyan">LightCyan</font>                       | <font color="#E0FFFF">#E0FFFF</font> | rgb(224, 255, 255)
<font color="LightGoldenRodYellow">LightGoldenRodYellow</font> | <font color="#FAFAD2">#FAFAD2</font> | rgb(250, 250, 210)
<font color="LightGrey">LightGrey</font>                       | <font color="#D3D3D3">#D3D3D3</font> | rgb(211, 211, 211)
<font color="LightGreen">LightGreen</font>                     | <font color="#90EE90">#90EE90</font> | rgb(144, 238, 144)
<font color="LightPink">LightPink</font>                       | <font color="#FFB6C1">#FFB6C1</font> | rgb(255, 182, 193)
<font color="LightSalmon">LightSalmon</font>                   | <font color="#FFA07A">#FFA07A</font> | rgb(255, 160, 122)
<font color="LightSeaGreen">LightSeaGreen</font>               | <font color="#20B2AA">#20B2AA</font> | rgb(32, 178, 170)
<font color="LightSkyBlue">LightSkyBlue</font>                 | <font color="#87CEFA">#87CEFA</font> | rgb(135, 206, 250)
<font color="LightSlateBlue">LightSlateBlue</font>             | <font color="#8470FF">#8470FF</font> | rgb(132, 112, 255)
<font color="LightSlateGray">LightSlateGray</font>             | <font color="#778899">#778899</font> | rgb(119, 136, 153)
<font color="LightSteelBlue">LightSteelBlue</font>             | <font color="#B0C4DE">#B0C4DE</font> | rgb(176, 196, 222)
<font color="LightYellow">LightYellow</font>                   | <font color="#FFFFE0">#FFFFE0</font> | rgb(255, 255, 224)
<font color="Lime">Lime</font>                                 | <font color="#00FF00">#00FF00</font> | rgb(0, 255, 0)    
<font color="LimeGreen">LimeGreen</font>                       | <font color="#32CD32">#32CD32</font> | rgb(50, 205, 50)  
<font color="Linen">Linen</font>                               | <font color="#FAF0E6">#FAF0E6</font> | rgb(250, 240, 230)
<font color="Magenta">Magenta</font>                           | <font color="#FF00FF">#FF00FF</font> | rgb(255, 0, 255)  
<font color="Maroon">Maroon</font>                             | <font color="#800000">#800000</font> | rgb(128, 0, 0)    
<font color="MediumAquaMarine">MediumAquaMarine</font>         | <font color="#66CDAA">#66CDAA</font> | rgb(102, 205, 170)
<font color="MediumBlue">MediumBlue</font>                     | <font color="#0000CD">#0000CD</font> | rgb(0, 0, 205)    
<font color="MediumOrchid">MediumOrchid</font>                 | <font color="#BA55D3">#BA55D3</font> | rgb(186, 85, 211)
<font color="MediumPurple">MediumPurple</font>                 | <font color="#9370D8">#9370D8</font> | rgb(147, 112, 216)
<font color="MediumSeaGreen">MediumSeaGreen</font>             | <font color="#3CB371">#3CB371</font> | rgb(60, 179, 113)
<font color="MediumSlateBlue">MediumSlateBlue</font>           | <font color="#7B68EE">#7B68EE</font> | rgb(123, 104, 238)
<font color="MediumSpringGreen">MediumSpringGreen</font>       | <font color="#00FA9A">#00FA9A</font> | rgb(0, 250, 154)  
<font color="MediumTurquoise">MediumTurquoise</font>           | <font color="#48D1CC">#48D1CC</font> | rgb(72, 209, 204)
<font color="MediumVioletRed">MediumVioletRed</font>           | <font color="#C71585">#C71585</font> | rgb(199, 21, 133)
<font color="MidnightBlue">MidnightBlue</font>                 | <font color="#191970">#191970</font> | rgb(25, 25, 112)  
<font color="MintCream">MintCream</font>                       | <font color="#F5FFFA">#F5FFFA</font> | rgb(245, 255, 250)
<font color="MistyRose">MistyRose</font>                       | <font color="#FFE4E1">#FFE4E1</font> | rgb(255, 228, 225)
<font color="Moccasin">Moccasin</font>                         | <font color="#FFE4B5">#FFE4B5</font> | rgb(255, 228, 181)
<font color="NavajoWhite">NavajoWhite</font>                   | <font color="#FFDEAD">#FFDEAD</font> | rgb(255, 222, 173)
<font color="Navy">Navy</font>                                 | <font color="#000080">#000080</font> | rgb(0, 0, 128)    
<font color="OldLace">OldLace</font>                           | <font color="#FDF5E6">#FDF5E6</font> | rgb(253, 245, 230)
<font color="Olive">Olive</font>                               | <font color="#808000">#808000</font> | rgb(128, 128, 0)  
<font color="OliveDrab">OliveDrab</font>                       | <font color="#6B8E23">#6B8E23</font> | rgb(107, 142, 35)
<font color="Orange">Orange</font>                             | <font color="#FFA500">#FFA500</font> | rgb(255, 165, 0)  
<font color="OrangeRed">OrangeRed</font>                       | <font color="#FF4500">#FF4500</font> | rgb(255, 69, 0)   
<font color="Orchid">Orchid</font>                             | <font color="#DA70D6">#DA70D6</font> | rgb(218, 112, 214)
<font color="PaleGoldenRod">PaleGoldenRod</font>               | <font color="#EEE8AA">#EEE8AA</font> | rgb(238, 232, 170)
<font color="PaleGreen">PaleGreen</font>                       | <font color="#98FB98">#98FB98</font> | rgb(152, 251, 152)
<font color="PaleTurquoise">PaleTurquoise</font>               | <font color="#AFEEEE">#AFEEEE</font> | rgb(175, 238, 238)
<font color="PaleVioletRed">PaleVioletRed</font>               | <font color="#D87093">#D87093</font> | rgb(216, 112, 147)
<font color="PapayaWhip">PapayaWhip</font>                     | <font color="#FFEFD5">#FFEFD5</font> | rgb(255, 239, 213)
<font color="PeachPuff">PeachPuff</font>                       | <font color="#FFDAB9">#FFDAB9</font> | rgb(255, 218, 185)
<font color="Peru">Peru</font>                                 | <font color="#CD853F">#CD853F</font> | rgb(205, 133, 63)
<font color="Pink">Pink</font>                                 | <font color="#FFC0CB">#FFC0CB</font> | rgb(255, 192, 203)
<font color="Plum">Plum</font>                                 | <font color="#DDA0DD">#DDA0DD</font> | rgb(221, 160, 221)
<font color="PowderBlue">PowderBlue</font>                     | <font color="#B0E0E6">#B0E0E6</font> | rgb(176, 224, 230)
<font color="Purple">Purple</font>                             | <font color="#800080">#800080</font> | rgb(128, 0, 128)  
<font color="Red">Red</font>                                   | <font color="#FF0000">#FF0000</font> | rgb(255, 0, 0)    
<font color="RosyBrown">RosyBrown</font>                       | <font color="#BC8F8F">#BC8F8F</font> | rgb(188, 143, 143)
<font color="RoyalBlue">RoyalBlue</font>                       | <font color="#4169E1">#4169E1</font> | rgb(65, 105, 225)
<font color="SaddleBrown">SaddleBrown</font>                   | <font color="#8B4513">#8B4513</font> | rgb(139, 69, 19)  
<font color="Salmon">Salmon</font>                             | <font color="#FA8072">#FA8072</font> | rgb(250, 128, 114)
<font color="SandyBrown">SandyBrown</font>                     | <font color="#F4A460">#F4A460</font> | rgb(244, 164, 96)
<font color="SeaGreen">SeaGreen</font>                         | <font color="#2E8B57">#2E8B57</font> | rgb(46, 139, 87)  
<font color="SeaShell">SeaShell</font>                         | <font color="#FFF5EE">#FFF5EE</font> | rgb(255, 245, 238)
<font color="Sienna">Sienna</font>                             | <font color="#A0522D">#A0522D</font> | rgb(160, 82, 45)  
<font color="Silver">Silver</font>                             | <font color="#C0C0C0">#C0C0C0</font> | rgb(192, 192, 192)
<font color="SkyBlue">SkyBlue</font>                           | <font color="#87CEEB">#87CEEB</font> | rgb(135, 206, 235)
<font color="SlateBlue">SlateBlue</font>                       | <font color="#6A5ACD">#6A5ACD</font> | rgb(106, 90, 205)
<font color="SlateGray">SlateGray</font>                       | <font color="#708090">#708090</font> | rgb(112, 128, 144)
<font color="Snow">Snow</font>                                 | <font color="#FFFAFA">#FFFAFA</font> | rgb(255, 250, 250)
<font color="SpringGreen">SpringGreen</font>                   | <font color="#00FF7F">#00FF7F</font> | rgb(0, 255, 127)  
<font color="SteelBlue">SteelBlue</font>                       | <font color="#4682B4">#4682B4</font> | rgb(70, 130, 180)
<font color="Tan">Tan</font>                                   | <font color="#D2B48C">#D2B48C</font> | rgb(210, 180, 140)
<font color="Teal">Teal</font>                                 | <font color="#008080">#008080</font> | rgb(0, 128, 128)  
<font color="Thistle">Thistle</font>                           | <font color="#D8BFD8">#D8BFD8</font> | rgb(216, 191, 216)
<font color="Tomato">Tomato</font>                             | <font color="#FF6347">#FF6347</font> | rgb(255, 99, 71)  
<font color="Turquoise">Turquoise</font>                       | <font color="#40E0D0">#40E0D0</font> | rgb(64, 224, 208)
<font color="Violet">Violet</font>                             | <font color="#EE82EE">#EE82EE</font> | rgb(238, 130, 238)
<font color="VioletRed">VioletRed</font>                       | <font color="#D02090">#D02090</font> | rgb(208, 32, 144)
<font color="Wheat">Wheat</font>                               | <font color="#F5DEB3">#F5DEB3</font> | rgb(245, 222, 179)
<font color="White">White</font>                               | <font color="#FFFFFF">#FFFFFF</font> | rgb(255, 255, 255)
<font color="WhiteSmoke">WhiteSmoke</font>                     | <font color="#F5F5F5">#F5F5F5</font> | rgb(245, 245, 245)
<font color="Yellow">Yellow</font>                             | <font color="#FFFF00">#FFFF00</font> | rgb(255, 255, 0)  
<font color="YellowGreen">YellowGreen</font>                   | <font color="#9ACD32">#9ACD32</font> | rgb(154, 205, 50)

## 背景色

由于 style 标签和标签的 style 属性都被和谐了（这让Markdown虽然有HTML的躯体，却没有HTML的灵魂！），所以这里只能是借助 table, tr, td 等表格标签的 bgcolor 属性来实现背景色的功能。[CSDN-markdown编辑器语法——背景色](http://blog.csdn.net/testcs_dn/article/details/45766819)

```
<table><tr><td bgcolor=#7FFFD4>这里的背景色是：Aquamarine，  十六进制颜色值：#7FFFD4， rgb(127, 255, 212)</td></tr></table>
```

<table><tr><td bgcolor=#7FFFD4>这里的背景色是：Aquamarine，  十六进制颜色值：#7FFFD4， rgb(127, 255, 212)</td></tr></table>

### 背景色列表

颜色名 | 十六进制颜色值 | 颜色                
-------------------------------------------------------------- | ------------------------------------ | ------------------
<font color="AliceBlue">AliceBlue</font>                       | <font color="#F0F8FF">#F0F8FF</font> | rgb(240, 248, 255)
<font color="AntiqueWhite">AntiqueWhite</font>                 | <font color="#FAEBD7">#FAEBD7</font> | rgb(250, 235, 215)
<font color="Aqua">Aqua</font>                                 | <font color="#00FFFF">#00FFFF</font> | rgb(0, 255, 255)  
<font color="Aquamarine">Aquamarine</font>                     | <font color="#7FFFD4">#7FFFD4</font> | rgb(127, 255, 212)
<font color="Azure">Azure</font>                               | <font color="#F0FFFF">#F0FFFF</font> | rgb(240, 255, 255)
<font color="Beige">Beige</font>                               | <font color="#F5F5DC">#F5F5DC</font> | rgb(245, 245, 220)
<font color="Bisque">Bisque</font>                             | <font color="#FFE4C4">#FFE4C4</font> | rgb(255, 228, 196)
<font color="Black">Black</font>                               | <font color="#000000">#000000</font> | rgb(0, 0, 0)      
<font color="BlanchedAlmond">BlanchedAlmond</font>             | <font color="#FFEBCD">#FFEBCD</font> | rgb(255, 235, 205)
<font color="Blue">Blue</font>                                 | <font color="#0000FF">#0000FF</font> | rgb(0, 0, 255)    
<font color="BlueViolet">BlueViolet</font>                     | <font color="#8A2BE2">#8A2BE2</font> | rgb(138, 43, 226)
<font color="Brown">Brown</font>                               | <font color="#A52A2A">#A52A2A</font> | rgb(165, 42, 42)  
<font color="BurlyWood">BurlyWood</font>                       | <font color="#DEB887">#DEB887</font> | rgb(222, 184, 135)
<font color="CadetBlue">CadetBlue</font>                       | <font color="#5F9EA0">#5F9EA0</font> | rgb(95, 158, 160)
<font color="Chartreuse">Chartreuse</font>                     | <font color="#7FFF00">#7FFF00</font> | rgb(127, 255, 0)  
<font color="Chocolate">Chocolate</font>                       | <font color="#D2691E">#D2691E</font> | rgb(210, 105, 30)
<font color="Coral">Coral</font>                               | <font color="#FF7F50">#FF7F50</font> | rgb(255, 127, 80)
<font color="CornflowerBlue">CornflowerBlue</font>             | <font color="#6495ED">#6495ED</font> | rgb(100, 149, 237)
<font color="Cornsilk">Cornsilk</font>                         | <font color="#FFF8DC">#FFF8DC</font> | rgb(255, 248, 220)
<font color="Crimson">Crimson</font>                           | <font color="#DC143C">#DC143C</font> | rgb(220, 20, 60)  
<font color="Cyan">Cyan</font>                                 | <font color="#00FFFF">#00FFFF</font> | rgb(0, 255, 255)  
<font color="DarkBlue">DarkBlue</font>                         | <font color="#00008B">#00008B</font> | rgb(0, 0, 139)    
<font color="DarkCyan">DarkCyan</font>                         | <font color="#008B8B">#008B8B</font> | rgb(0, 139, 139)  
<font color="DarkGoldenRod">DarkGoldenRod</font>               | <font color="#B8860B">#B8860B</font> | rgb(184, 134, 11)
<font color="DarkGray">DarkGray</font>                         | <font color="#A9A9A9">#A9A9A9</font> | rgb(169, 169, 169)
<font color="DarkGreen">DarkGreen</font>                       | <font color="#006400">#006400</font> | rgb(0, 100, 0)    
<font color="DarkKhaki">DarkKhaki</font>                       | <font color="#BDB76B">#BDB76B</font> | rgb(189, 183, 107)
<font color="DarkMagenta">DarkMagenta</font>                   | <font color="#8B008B">#8B008B</font> | rgb(139, 0, 139)  
<font color="DarkOliveGreen">DarkOliveGreen</font>             | <font color="#556B2F">#556B2F</font> | rgb(85, 107, 47)  
<font color="Darkorange">Darkorange</font>                     | <font color="#FF8C00">#FF8C00</font> | rgb(255, 140, 0)  
<font color="DarkOrchid">DarkOrchid</font>                     | <font color="#9932CC">#9932CC</font> | rgb(153, 50, 204)
<font color="DarkRed">DarkRed</font>                           | <font color="#8B0000">#8B0000</font> | rgb(139, 0, 0)    
<font color="DarkSalmon">DarkSalmon</font>                     | <font color="#E9967A">#E9967A</font> | rgb(233, 150, 122)
<font color="DarkSeaGreen">DarkSeaGreen</font>                 | <font color="#8FBC8F">#8FBC8F</font> | rgb(143, 188, 143)
<font color="DarkSlateBlue">DarkSlateBlue</font>               | <font color="#483D8B">#483D8B</font> | rgb(72, 61, 139)  
<font color="DarkSlateGray">DarkSlateGray</font>               | <font color="#2F4F4F">#2F4F4F</font> | rgb(47, 79, 79)   
<font color="DarkTurquoise">DarkTurquoise</font>               | <font color="#00CED1">#00CED1</font> | rgb(0, 206, 209)  
<font color="DarkViolet">DarkViolet</font>                     | <font color="#9400D3">#9400D3</font> | rgb(148, 0, 211)  
<font color="DeepPink">DeepPink</font>                         | <font color="#FF1493">#FF1493</font> | rgb(255, 20, 147)
<font color="DeepSkyBlue">DeepSkyBlue</font>                   | <font color="#00BFFF">#00BFFF</font> | rgb(0, 191, 255)  
<font color="DimGray">DimGray</font>                           | <font color="#696969">#696969</font> | rgb(105, 105, 105)
<font color="DodgerBlue">DodgerBlue</font>                     | <font color="#1E90FF">#1E90FF</font> | rgb(30, 144, 255)
<font color="Feldspar">Feldspar</font>                         | <font color="#D19275">#D19275</font> | rgb(209, 146, 117)
<font color="FireBrick">FireBrick</font>                       | <font color="#B22222">#B22222</font> | rgb(178, 34, 34)  
<font color="FloralWhite">FloralWhite</font>                   | <font color="#FFFAF0">#FFFAF0</font> | rgb(255, 250, 240)
<font color="ForestGreen">ForestGreen</font>                   | <font color="#228B22">#228B22</font> | rgb(34, 139, 34)  
<font color="Fuchsia">Fuchsia</font>                           | <font color="#FF00FF">#FF00FF</font> | rgb(255, 0, 255)  
<font color="Gainsboro">Gainsboro</font>                       | <font color="#DCDCDC">#DCDCDC</font> | rgb(220, 220, 220)
<font color="GhostWhite">GhostWhite</font>                     | <font color="#F8F8FF">#F8F8FF</font> | rgb(248, 248, 255)
<font color="Gold">Gold</font>                                 | <font color="#FFD700">#FFD700</font> | rgb(255, 215, 0)  
<font color="GoldenRod">GoldenRod</font>                       | <font color="#DAA520">#DAA520</font> | rgb(218, 165, 32)
<font color="Gray">Gray</font>                                 | <font color="#808080">#808080</font> | rgb(128, 128, 128)
<font color="Green">Green</font>                               | <font color="#008000">#008000</font> | rgb(0, 128, 0)    
<font color="GreenYellow">GreenYellow</font>                   | <font color="#ADFF2F">#ADFF2F</font> | rgb(173, 255, 47)
<font color="HoneyDew">HoneyDew</font>                         | <font color="#F0FFF0">#F0FFF0</font> | rgb(240, 255, 240)
<font color="HotPink">HotPink</font>                           | <font color="#FF69B4">#FF69B4</font> | rgb(255, 105, 180)
<font color="IndianRed">IndianRed</font>                       | <font color="#CD5C5C">#CD5C5C</font> | rgb(205, 92, 92)  
<font color="Indigo">Indigo</font>                             | <font color="#4B0082">#4B0082</font> | rgb(75, 0, 130)   
<font color="Ivory">Ivory</font>                               | <font color="#FFFFF0">#FFFFF0</font> | rgb(255, 255, 240)
<font color="Khaki">Khaki</font>                               | <font color="#F0E68C">#F0E68C</font> | rgb(240, 230, 140)
<font color="Lavender">Lavender</font>                         | <font color="#E6E6FA">#E6E6FA</font> | rgb(230, 230, 250)
<font color="LavenderBlush">LavenderBlush</font>               | <font color="#FFF0F5">#FFF0F5</font> | rgb(255, 240, 245)
<font color="LawnGreen">LawnGreen</font>                       | <font color="#7CFC00">#7CFC00</font> | rgb(124, 252, 0)  
<font color="LemonChiffon">LemonChiffon</font>                 | <font color="#FFFACD">#FFFACD</font> | rgb(255, 250, 205)
<font color="LightBlue">LightBlue</font>                       | <font color="#ADD8E6">#ADD8E6</font> | rgb(173, 216, 230)
<font color="LightCoral">LightCoral</font>                     | <font color="#F08080">#F08080</font> | rgb(240, 128, 128)
<font color="LightCyan">LightCyan</font>                       | <font color="#E0FFFF">#E0FFFF</font> | rgb(224, 255, 255)
<font color="LightGoldenRodYellow">LightGoldenRodYellow</font> | <font color="#FAFAD2">#FAFAD2</font> | rgb(250, 250, 210)
<font color="LightGrey">LightGrey</font>                       | <font color="#D3D3D3">#D3D3D3</font> | rgb(211, 211, 211)
<font color="LightGreen">LightGreen</font>                     | <font color="#90EE90">#90EE90</font> | rgb(144, 238, 144)
<font color="LightPink">LightPink</font>                       | <font color="#FFB6C1">#FFB6C1</font> | rgb(255, 182, 193)
<font color="LightSalmon">LightSalmon</font>                   | <font color="#FFA07A">#FFA07A</font> | rgb(255, 160, 122)
<font color="LightSeaGreen">LightSeaGreen</font>               | <font color="#20B2AA">#20B2AA</font> | rgb(32, 178, 170)
<font color="LightSkyBlue">LightSkyBlue</font>                 | <font color="#87CEFA">#87CEFA</font> | rgb(135, 206, 250)
<font color="LightSlateBlue">LightSlateBlue</font>             | <font color="#8470FF">#8470FF</font> | rgb(132, 112, 255)
<font color="LightSlateGray">LightSlateGray</font>             | <font color="#778899">#778899</font> | rgb(119, 136, 153)
<font color="LightSteelBlue">LightSteelBlue</font>             | <font color="#B0C4DE">#B0C4DE</font> | rgb(176, 196, 222)
<font color="LightYellow">LightYellow</font>                   | <font color="#FFFFE0">#FFFFE0</font> | rgb(255, 255, 224)
<font color="Lime">Lime</font>                                 | <font color="#00FF00">#00FF00</font> | rgb(0, 255, 0)    
<font color="LimeGreen">LimeGreen</font>                       | <font color="#32CD32">#32CD32</font> | rgb(50, 205, 50)  
<font color="Linen">Linen</font>                               | <font color="#FAF0E6">#FAF0E6</font> | rgb(250, 240, 230)
<font color="Magenta">Magenta</font>                           | <font color="#FF00FF">#FF00FF</font> | rgb(255, 0, 255)  
<font color="Maroon">Maroon</font>                             | <font color="#800000">#800000</font> | rgb(128, 0, 0)    
<font color="MediumAquaMarine">MediumAquaMarine</font>         | <font color="#66CDAA">#66CDAA</font> | rgb(102, 205, 170)
<font color="MediumBlue">MediumBlue</font>                     | <font color="#0000CD">#0000CD</font> | rgb(0, 0, 205)    
<font color="MediumOrchid">MediumOrchid</font>                 | <font color="#BA55D3">#BA55D3</font> | rgb(186, 85, 211)
<font color="MediumPurple">MediumPurple</font>                 | <font color="#9370D8">#9370D8</font> | rgb(147, 112, 216)
<font color="MediumSeaGreen">MediumSeaGreen</font>             | <font color="#3CB371">#3CB371</font> | rgb(60, 179, 113)
<font color="MediumSlateBlue">MediumSlateBlue</font>           | <font color="#7B68EE">#7B68EE</font> | rgb(123, 104, 238)
<font color="MediumSpringGreen">MediumSpringGreen</font>       | <font color="#00FA9A">#00FA9A</font> | rgb(0, 250, 154)  
<font color="MediumTurquoise">MediumTurquoise</font>           | <font color="#48D1CC">#48D1CC</font> | rgb(72, 209, 204)
<font color="MediumVioletRed">MediumVioletRed</font>           | <font color="#C71585">#C71585</font> | rgb(199, 21, 133)
<font color="MidnightBlue">MidnightBlue</font>                 | <font color="#191970">#191970</font> | rgb(25, 25, 112)  
<font color="MintCream">MintCream</font>                       | <font color="#F5FFFA">#F5FFFA</font> | rgb(245, 255, 250)
<font color="MistyRose">MistyRose</font>                       | <font color="#FFE4E1">#FFE4E1</font> | rgb(255, 228, 225)
<font color="Moccasin">Moccasin</font>                         | <font color="#FFE4B5">#FFE4B5</font> | rgb(255, 228, 181)
<font color="NavajoWhite">NavajoWhite</font>                   | <font color="#FFDEAD">#FFDEAD</font> | rgb(255, 222, 173)
<font color="Navy">Navy</font>                                 | <font color="#000080">#000080</font> | rgb(0, 0, 128)    
<font color="OldLace">OldLace</font>                           | <font color="#FDF5E6">#FDF5E6</font> | rgb(253, 245, 230)
<font color="Olive">Olive</font>                               | <font color="#808000">#808000</font> | rgb(128, 128, 0)  
<font color="OliveDrab">OliveDrab</font>                       | <font color="#6B8E23">#6B8E23</font> | rgb(107, 142, 35)
<font color="Orange">Orange</font>                             | <font color="#FFA500">#FFA500</font> | rgb(255, 165, 0)  
<font color="OrangeRed">OrangeRed</font>                       | <font color="#FF4500">#FF4500</font> | rgb(255, 69, 0)   
<font color="Orchid">Orchid</font>                             | <font color="#DA70D6">#DA70D6</font> | rgb(218, 112, 214)
<font color="PaleGoldenRod">PaleGoldenRod</font>               | <font color="#EEE8AA">#EEE8AA</font> | rgb(238, 232, 170)
<font color="PaleGreen">PaleGreen</font>                       | <font color="#98FB98">#98FB98</font> | rgb(152, 251, 152)
<font color="PaleTurquoise">PaleTurquoise</font>               | <font color="#AFEEEE">#AFEEEE</font> | rgb(175, 238, 238)
<font color="PaleVioletRed">PaleVioletRed</font>               | <font color="#D87093">#D87093</font> | rgb(216, 112, 147)
<font color="PapayaWhip">PapayaWhip</font>                     | <font color="#FFEFD5">#FFEFD5</font> | rgb(255, 239, 213)
<font color="PeachPuff">PeachPuff</font>                       | <font color="#FFDAB9">#FFDAB9</font> | rgb(255, 218, 185)
<font color="Peru">Peru</font>                                 | <font color="#CD853F">#CD853F</font> | rgb(205, 133, 63)
<font color="Pink">Pink</font>                                 | <font color="#FFC0CB">#FFC0CB</font> | rgb(255, 192, 203)
<font color="Plum">Plum</font>                                 | <font color="#DDA0DD">#DDA0DD</font> | rgb(221, 160, 221)
<font color="PowderBlue">PowderBlue</font>                     | <font color="#B0E0E6">#B0E0E6</font> | rgb(176, 224, 230)
<font color="Purple">Purple</font>                             | <font color="#800080">#800080</font> | rgb(128, 0, 128)  
<font color="Red">Red</font>                                   | <font color="#FF0000">#FF0000</font> | rgb(255, 0, 0)    
<font color="RosyBrown">RosyBrown</font>                       | <font color="#BC8F8F">#BC8F8F</font> | rgb(188, 143, 143)
<font color="RoyalBlue">RoyalBlue</font>                       | <font color="#4169E1">#4169E1</font> | rgb(65, 105, 225)
<font color="SaddleBrown">SaddleBrown</font>                   | <font color="#8B4513">#8B4513</font> | rgb(139, 69, 19)  
<font color="Salmon">Salmon</font>                             | <font color="#FA8072">#FA8072</font> | rgb(250, 128, 114)
<font color="SandyBrown">SandyBrown</font>                     | <font color="#F4A460">#F4A460</font> | rgb(244, 164, 96)
<font color="SeaGreen">SeaGreen</font>                         | <font color="#2E8B57">#2E8B57</font> | rgb(46, 139, 87)  
<font color="SeaShell">SeaShell</font>                         | <font color="#FFF5EE">#FFF5EE</font> | rgb(255, 245, 238)
<font color="Sienna">Sienna</font>                             | <font color="#A0522D">#A0522D</font> | rgb(160, 82, 45)  
<font color="Silver">Silver</font>                             | <font color="#C0C0C0">#C0C0C0</font> | rgb(192, 192, 192)
<font color="SkyBlue">SkyBlue</font>                           | <font color="#87CEEB">#87CEEB</font> | rgb(135, 206, 235)
<font color="SlateBlue">SlateBlue</font>                       | <font color="#6A5ACD">#6A5ACD</font> | rgb(106, 90, 205)
<font color="SlateGray">SlateGray</font>                       | <font color="#708090">#708090</font> | rgb(112, 128, 144)
<font color="Snow">Snow</font>                                 | <font color="#FFFAFA">#FFFAFA</font> | rgb(255, 250, 250)
<font color="SpringGreen">SpringGreen</font>                   | <font color="#00FF7F">#00FF7F</font> | rgb(0, 255, 127)  
<font color="SteelBlue">SteelBlue</font>                       | <font color="#4682B4">#4682B4</font> | rgb(70, 130, 180)
<font color="Tan">Tan</font>                                   | <font color="#D2B48C">#D2B48C</font> | rgb(210, 180, 140)
<font color="Teal">Teal</font>                                 | <font color="#008080">#008080</font> | rgb(0, 128, 128)  
<font color="Thistle">Thistle</font>                           | <font color="#D8BFD8">#D8BFD8</font> | rgb(216, 191, 216)
<font color="Tomato">Tomato</font>                             | <font color="#FF6347">#FF6347</font> | rgb(255, 99, 71)  
<font color="Turquoise">Turquoise</font>                       | <font color="#40E0D0">#40E0D0</font> | rgb(64, 224, 208)
<font color="Violet">Violet</font>                             | <font color="#EE82EE">#EE82EE</font> | rgb(238, 130, 238)
<font color="VioletRed">VioletRed</font>                       | <font color="#D02090">#D02090</font> | rgb(208, 32, 144)
<font color="Wheat">Wheat</font>                               | <font color="#F5DEB3">#F5DEB3</font> | rgb(245, 222, 179)
<font color="White">White</font>                               | <font color="#FFFFFF">#FFFFFF</font> | rgb(255, 255, 255)
<font color="WhiteSmoke">WhiteSmoke</font>                     | <font color="#F5F5F5">#F5F5F5</font> | rgb(245, 245, 245)
<font color="Yellow">Yellow</font>                             | <font color="#FFFF00">#FFFF00</font> | rgb(255, 255, 0)  
<font color="YellowGreen">YellowGreen</font>                   | <font color="#9ACD32">#9ACD32</font> | rgb(154, 205, 50)

# 图床

- [微博图床CHROME插件](https://chrome.google.com/webstore/detail/%E6%96%B0%E6%B5%AA%E5%BE%AE%E5%8D%9A%E5%9B%BE%E5%BA%8A/fdfdnfpdplfbbnemmmoklbfjbhecpnhf)
- [免费图床推荐](https://www.zybuluo.com/yexiaoqi/note/210029)

# 制作PPT

> [如何用 Markdown 做幻灯](http://blog.sciencenet.cn/home.php?mod=space&uid=377709&do=blog&id=1157738)
]]></content>
      <categories>
        <category>Software</category>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
        <tag>MathJax</tag>
      </tags>
  </entry>
  <entry>
    <title>Matlab并行计算</title>
    <url>/matlab-parallel/</url>
    <content><![CDATA[
在利用matlab进行计算时，会遇到循环次数过大，或者是单次计算量过大的问题，比如需要计算的数值阵列数据量过大，利用传统的编程方式，跑一次程序几个小时。如果遇到这种情况，则可以尝试一下MATLAB并行计算，传统的计算方式都是串行计算。并行计算之所以可行，取决于两方面因素：a)现在大家的计算机是多核的，至少也是双核了吧，有的可能8核都有，这是很重要的硬件基础。b)MATLAB本身提供了很好的并行计算函数，加上你的聪明智慧，设计合理的软件，这样就有了软件基础了。

<!--more-->

> [加速matlab运行的三重境界](https://sites.google.com/site/seanzhuxf/personal-page/matlab/matlab)，[提高MATLAB运行效率](http://blog.sciencenet.cn/blog-388372-687651.html)。

# 如何并行计算

并行运算其实就是主线程和子线程的一个任务分配和汇总的实现。这种实现过程需要三个基本步骤：1、需要创建几个workers。2、把任务划分，然后分配给workers。3、整合结果，释放workers。

首先打开MATLAB命令窗口，输入`matlabpool open`就OK了。当然也可以配置使用核心数：`matlabpool open local 4`。最好就是有几个核心就开几个，这样效率比较高。

当程序运行完成后，释放workers：`matlabpool close`。

# 并行编程方法

具体实现parallel program主要是通过parfor（parallel for）和SPMD（single program, multiple data）完成的。parfor，spmd不可以相互或者自身嵌套。其他关于spmd vs. parfor的可以参考这个[帖子](http://stackoverflow.com/questions/12385534/spmd-vs-parfor)。

## parfor（parallel for）

parfor只用于matlab并行循环。当你需要简单计算的多次循环迭代时，例如蒙特卡洛(Monte Carlo)模拟，parfor循环就很有用。parfor将循环迭代分组，那么每个worker执行迭代的一部分。当迭代耗时很长的时候parfor循环也是有用的，因为workers可以同时执行迭代。这种循环代替有几点说明：

1. 使用parfor前提必须开启matlabpool，否则等于for。

1. 要求各个循环的内容是独立的（independent）。parfor不能像for一样多层内嵌。parfor不能调用与上一个循环结果相关的变量，否则就等与for了。

    ```
    % 都可以把for循环改成parfor
    total = 0.0;
    big = - Inf;
    for i = 1 : n
      total = total + x(i);
      big = max ( big, x(i) );
    end
    for i = 1 : n
      angle = ( i - 1 ) * pi / ( n - 1 );
      t(i) = cos ( angle );
    end

    % 这种依赖前一个循环的结果则不能转换成parfor
    % 还有有用到break continue return 这些类型都不能使用parfor
    dx = 0.25;
    x = zeros (1,n);
    for i = 2 : n
      x(i) = x(i-1) + dx;
    end
    ```

1. 所谓透明（transparency），即指parfor循环体中不能出现类似eval一类的函数。一个程序并行时要共享内存，而eval语句可能使程序进入错误的workspace，因此不要用eval，改用不同index赋值。

    ```
    % 不能出现类似eval一类的函数
    parfor i=1:10
    eval(['disp(num2str(i))'])
    end

    %改用不同index赋值
    matlabpool local 2;  
    c = 1:5;  
    parfor i = 1:length(c)  
        a(i) = c(i);  
    end  
    ```

1. 当parfor的循环体中存在对同一个矩阵的不同部分的操作时，会报错。原因在于matlab的parfor功能不允许循环体中出现对矩阵的某些部分独立地计算。 笼统说来，解决方法是将循环体中计算或者修改的内容记录在一个temp矩阵中，parfor循环全部完成后，再简单地用for将temp中的内容赋值给实际需要的矩阵即可[^UsingparforLoops]。

    ```
    %% 直接将for改称parfor是会出错的。
    clear
    A1=magic(6);
    x=unique(ceil(rand(1,10)*36));
    parfor i=1:length(x)
        A1(x(i))=1000+round(rand(1)*36);
    end

    %%　对这个特定问题，甚至不需要循环
    clear
    A1=magic(6);
    x=unique(ceil(rand(1,10)*36));
    A1(x)=A1(x)+1000+round(rand(1,length(x))*36);

    %% 解决方法是将循环体中计算或者修改的内容记录在一个temp矩阵中
    matlabpool local 2
    clear
    A2=magic(6);
    x=unique(ceil(rand(1,10)*36));
    temp=[];
    parfor i=1:length(x)
        temp=[temp [x(i);round(rand(1)*36)+1000]];
    end
    for i=1:length(x)
        A2(temp(1,i))=temp(2,i);
    end
    matlabpool close
    ```


[^UsingparforLoops]: [using parfor Loops: Getting Up and Running ](http://blogs.mathworks.com/loren/2009/10/02/using-parfor-loops-getting-up-and-running/)

### 案例

```
tic
%传统方式计算
c1=1;
for i = 1:500
c1 = c1+max(eig(rand(i,i)));
end
t1 = toc;

matlabpool open local 12;
%parfor并行方式计算
tic
c2=1;
parfor ii = 1:500
c2 = c2+max(eig(rand(ii,ii)));
end
t2 = toc;
matlabpool close;

display(strcat('parfor并行计算时间：',num2str(t2),'秒'));
display(strcat('客户端串行计算时间：',num2str(t1),'秒'));
```

## SPMD（single program, multiple data）

Spmd中的“Single program”方面指的是同一段代码运行在不同的多个lab上，<font color=blue>就是说同一段程序应用于不同的样本（数据），所以一般针对随机抽样的并行</font> 。你在一个Matlab客户端上运行一个程序，被标志为spmd模块的其他部分运行在其他lab上。当这些块运行完毕后，你的程序继续在客户端运行。 “Multiple data”方面指的是虽然spmd语句在所有的lab上运行相同的代码，但每一个lab可以有不同的，独有的数据。所以多数据集可以在多个lab上同时被容纳。

```
%% SPMD  
%example 1  
spmd   
A = rand(3,2); %generate a matrix A for each lab(worker)  
end  
for i = 1:length(A)  
    figure; imagesc(A{i});   
end  

%example 2  
a = 3;  
b = 4;  
spmd  
    c = labindex();  
    d = c+a;  
end  
c{2} = 5;  
spmd  
    f = c*b;  
end  
for i = 1:length(f)  
    fprintf('%d\t',f{i});%access the value of each lab  
end  
```

另外，SPMD也可以用于可替代parfor的块并行，在不同lab（worker）上对相同或不同的数据执行不同的并行操作。

```
%example3 - deal with same Data by different parameters  
%add different values to same array Data  
Data = 1:100;  
spmd  
    switch labindex  
        case 1  
            Data = Data+1;  
        case 2  
            Data = Data+2;  
    end  
end  
% print Data{1} & Data{2} for checking  

%example4   
%add different values for different parts of array Data  
% [1:50]+1  
% [51:100]+2  
spmd  
    if labindex == 1  
        Data(1:50) = Data(1:50)+1;  
    else  
        Data(51:100) = Data(51:100)+2;  
    end  
end  
```


# BUG调试

1. `matlabpool Java exception occurred: java.net.UnknownHostException:  
Your_Host_Name  at java.net.InetAddress.getLocalHost(Unknown Source)`： 在`/etc/hosts`这个文件里增加一行我们本地ip和主机名即可：`127.0.0.1   Your_Host_Name`，Your_Host_Name这个每个人电脑都不同。
]]></content>
      <categories>
        <category>Programming</category>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>MATLAB使用指南</title>
    <url>/matlab/</url>
    <content><![CDATA[
MATLAB（矩阵实验室）是MATrix LABoratory的缩写，是一款由美国The MathWorks公司出品的商业数学软件。MATLAB是一种用于算法开发、数据可视化、数据分析以及数值计算的高级技术计算语言和交互式环境。除了矩阵运算、绘制函数/数据图像等常用功能外，MATLAB还可以用来创建用户界面及与调用其它语言（包括C,C++,Java,Python和FORTRAN）编写的程序。本文主要介绍MATLAB中常用命令，方便规范使用。

<!--more-->

MATLAB 的替代品：

- Python是一门完全免费的通用编程语言，以开源的方式提供了大量各类用途的库与包，如 Numpy （数值计算）、 SciPy （数学、科学和工程计算）、 Matplotlib （类似MATLAB中plot的绘图工具）等等。
- Octave是GNU项目成员之一，提供了与MATLAB语法兼容的开放源代码科学计算及数值分析的工具。
- 对于航天器轨道计算、任务分析等，可以尝试General Mission Analysis Tool (GMAT)。GMAT提供了图像化界面或脚本两种接口，相比于STK，GMAT的深空探测相关功能更加强大，可配置的资源也更多。
- GNU Radio是一个对学习，构建和部署软件定义无线电系统的免费软件工具包，可通过Python或类似于Simulink/Labview的图形化界面调用。 紫丁香、龙江等卫星的业余无线电接收解调软件就是在GNU Radio基础上开发并开源发布的。
- Robot Operating System (ROS)是一种针对于满足不同机器人软件协同工作的灵活软件框架。目的在于提高软件模块化能力和复用能力，并实现不同任务间的数据/信号量的有效共享，方便多种机器人平台之间创建复杂和鲁棒的机器人行为，同时它也是一种工具库的约定与集合。

> 下载链接: https://www.iemblog.com/?s=matlab

# 随机数

Matlab中的rand()函数产生的是伪随机数，但一般用来也可以接受。但是，如果我们知道伪随机数的初始状态，那么产生的伪随机数是唯一确定的。问题来了，Matlab每次启动会重置rand()和randn()的初始状态(重置为0)，也就是说，你产生的随机数会出现两次随机数一模一样的情况。

```
>> rand('state',0)
>> rand(3,1)

ans =

    0.9501
    0.2311
    0.6068

>> rand(3,1)

ans =

    0.4860
    0.8913
    0.7621

>> rand('state',0)
>> rand(3,1)

ans =

    0.9501
    0.2311
    0.6068
```

设定初始状态的好处是，只需要保存那时的初始状态再运行一遍程序你就可以重现之前的计算过程和结果。缺点是虽然程序使用了随机数，但由于(每次启动后)初始状态一样，实际运行出来却是相同的重复过程，你需要人工设定一个保证随机性的初始状态。

## 设置初始状态

设置随机数初始状态有三种语法形式：

```
rand('seed', S)
```

S是表示初始状态的整数。seed、state、twister就比较奇怪，令人捉摸不透，不知道该选用哪个。这实际上是产生随机数的不同算法。seed表示采用v4版本的随机数产生器，state是v5版本的随机数产生器，最后的twister用的则是Mersenne Twister随机数产生器。前两个随机数产生器都是“flawed”，推荐大家使用twister随机数产生器。

新版的Matlab默认采用Mersenne Twister随机数产生器，rng(S) 函数表示设定初始状态，rng('shuffle') 表示随机分配一个初始状态。所以现在只需要记住rng()函数设置初始状态，然后用rand产生随机数就可以了。

```
rng(1);
A = rand(2,2)
```

## 产生非重复的随机数

2012版本之后的用户比较方便，在产生随机数之前使用`rng('shuffle')`洗一下就可以(shuffle是洗牌的意思)。

以前推荐的是`rand('state',sum(100*clock))`来根据当前时间设定初始状态，但时间始终是递增的，而且变化幅度相对来说很小，效果不是很好。有很多人用别的方式设定初始状态（如`rand('twister', fix(mod(1e11*(sum(clock)-2009), 2^31)));）`，为简便起见，个人推荐采用[新版Matlab中`rng`函数语法](http://cn.mathworks.com/help/matlab/math/generate-random-numbers-that-are-different.html)，即

```
rand('twister',mod(floor(now*8640000),2^31-1));
```

# 添加路径

```
% 添加绝对路径, 并未添加其子文件夹
addpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master');
% 添加绝对路径，其子文件夹进搜索路径
addpath(genpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master'));
% 移除绝对路径
rmpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master')
% 移除多个绝对路径
rmpath(genpath('D:\Workspace\Matlab\DL\DeepLearnToolbox-master'))
```

# 数据集划分

划分数据集，产生训练集和测试集。

```
% Split training-testing data
rate = 0.5;
rand('seed',12345);
randn('seed',12345);
[n d] = size(X);
% random index
r = randperm(n);

% training samples           
ntrain = round(rate*n);          
Xtrain = X(r(1:ntrain),:);
Ytrain = Y(r(1:ntrain),:);

% test set
Xtest  = X(r(ntrain+1:end),:);
Ytest  = Y(r(ntrain+1:end),:);
```

# 矩阵除法求逆运算

如果要Moore-Penros广义逆的话可以用pinv(A)； 如果只需要解方程Ax=b的一个解，可以直接x=A\b； 如果对精度要求比较高，不要用LU、QR，最好用SVD分解，根据需求来截断小奇异值。

inv：Y=inv(X)返回方阵X的逆矩阵，如果X病态或者高度奇异，则会显示警告信息。实际上，很少需要真的把矩阵的逆求出来，常见的使用失误主要出现在求解线性方程组AX=b。一种求解方法为`x=inv(A)*b`，但如要达到更快，更稳定，就得用X=A\b。这个算法使用高斯消去法，因此不产生逆矩阵。

如果A矩阵是非奇异方阵，则A\B是A的逆矩阵乘B，即inv(A)\*B。而B/A是B乘A的逆矩阵，即B*inv(A)。具体计算时可不用逆矩阵而直接计算。使用符号“/”或“\”会避免求逆，加速运算效率。换句话，（1/A）可以表示A的逆，这个算法**使用高斯消去法**，因此不产生逆矩阵。如果A矩阵不是方阵，可由以列为基准的Householder正交分解法分解，这种分解法可以解决在最小二乘法中的欠定方程或超定方程，结果是m×n的x矩阵。m是A矩阵的列数，n是B矩阵的列数。每个矩阵的列向量最多有k个非零元素，k 是A的有效秩。

> “\”：反斜线符号，矩阵左除。如果A是方阵，A\B近似等于inv(A)\*B，只是他们的算法不一样。如果A是n\*n的方阵，B是n\*1的列向量，或n\*?的矩阵，那么X=A\B是AX=B的解。如果A很病态或者很奇异，很会显示警告信息。A\EYE(SIZE(A))计算A的逆，参见mldivide可得到更多信息。如果A是m\*n的矩阵，m!=n，B是m\*1或m\*?的列向量，那么X=A\B就是线性方程组AX=B（超定或者欠定）的最小二乘解。A的有效秩（effective rank）k有选主元的QR分解决定。Asolution X is computed that has at most k nonzero componentspercolumn。如果K<N，结果通常和`pinv(A)*B`不一样，后者是最小范数解。A\EYE(SIZE(A))用来求解A的广义逆。

> mldivide(A,B)：等价于A\B，A和B必须有一样多的行，除非A是个标量（这时就等于.\）。如果A是个方阵，A\B近似等于inv(A)\*B，只是两者算法不一样。如果A是m*n的矩阵，那么X=A\B求解AX=B（超定或欠定）的最小二乘解，即（AX-B）的范数极小。


奇异矩阵求逆用pinv。经查证，inv是matlab的built-in函数。而pinv则可以看到其源码，不长，其实就是调用另外一个built-in函数SVD进行奇异值分解，再截断奇异值进行求解而已。所以pinv实际上就是截断奇异值求逆。

```
假定拟计算一般矩阵A的Moore-Penrose广义逆A+,
1)对A做SVD:
A = U S V, 其中 U, V为酉方阵, S为一般对角阵;
2)将S非零元取逆, 零元不变, 然后专置得到一个一般对角阵T;
3)则广义逆为A+ = V* T U*, 其中 * 表示取矩阵的复共轭.
```

奇异矩阵如何处理：奇异矩阵求逆，给矩阵主对角线每一个元素加一个很小的量，如1e-6；强制可逆。

<div id="matlab-plot"></div>

# PLOT设置

> [Matlab画图（一）：生成高质量的供发表和展示用的图](http://blog.sciencenet.cn/blog-3854-760545.html)  
> [matlab绘图命令汇总](http://blog.sciencenet.cn/blog-72586-764570.html)

以下从一幅图可能涉及的多个方面进行罗列和演示：

```
close all

% 窗口初始最大化，推荐此命令
figure
set(gcf,'outerposition',get(0,'screensize'));
% 或者
set(gcf,'Position',get(0,'ScreenSize'))
% 或者
a=get(0);
figure('position',a.MonitorPositions);

% whitebg(1,'w') % 设置背景灰度

% 画图建议使用handle，方便命令调整

handle1=plot(a,'--pr','linewidth',1.5,'MarkerEdgeColor','r','MarkerFaceColor','m','MarkerSize',10)
% MarkerEdgeColor 标记点边框线条颜色颜色字符，如’g’, ’b’等
% MarkerFaceColor 标记点内部区域填充颜色颜色字符
% MarkerSize 标记点大小   数值，单位为points

% 或者使用RGB颜色，更多查看matlab绘图命令汇总
handle1=plot(x,y,'Color',[152 245 255]/256,'Linewidth',2);
handle1=plot(x,y,'Color','r','Linewidth',2);

hold on

% 有时候需要更改坐标轴刻度显示
set(gca, ’XTick’, [0 1 2]) % X坐标轴刻度数据点位置
set(gca,'XTickLabel',{'a','b','c'}) % X坐标轴刻度处显示的字符

% 待补充
set(gcf,'paperpositionmode','auto');

% 不采用
% 画图外观设置，type案例1，
set(gcf,'Position',[100 100 260 220]);
set(gca,'Position',[.13 .17 .80 .74]);
figure_FontSize=8;
set(get(gca,'XLabel'),'FontSize',figure_FontSize,'Vertical','top');
set(get(gca,'YLabel'),'FontSize',figure_FontSize,'Vertical','middle');
set(findobj('FontSize',10),'FontSize',figure_FontSize);
set(findobj(get(gca,'Children'),'LineWidth',0.5),'LineWidth',2);

% 采用
% 画图外观设置，type案例2。
% set(gca,'FontName','Times New Roman','FontSize',14) % 设置坐标轴刻度字体名称，大小
set(gca, 'fontsize', 14);
set(gca, 'XMinorTick', 'on');
set(gca, 'YMinorTick', 'on');
set(gca, 'XGrid', 'on');
set(gca, 'YGrid', 'on');
set(gca, 'LineWidth', 1.5);

% label设置
xlabel('Time (Second)', 'fontsize', 16);
ylabel('Amplitude', 'fontsize', 16);
ylabel('a','FontName','Times New Roman','FontSize',14,'Rotation',0)

% 坐标轴范围axis
ymin=**;
ymax=**;
xmin=**;
xmax=**;
% box = [-10.1 10.1 1.1*[min(t) max(t)]];
axis([xmin xmax ymin ymax]) % 设置坐标轴在指定的区间

% 同handle1命令
handle2=...
handle3=...

% legend说明
% LEGEND(string1,string2,string3, ...)
% LEGEND(...,'Location',LOC) 来指定图例标识框的位置

% 一个图例，可以直接放置
legend('First','Second','Third');
legend('First','Second','Third','Location','NorthEastOutside')
legend('First','Second','Third','Location','best') % 图例位置放在最佳位置

% 多个图例
handle_1=axes('position',get(gca,'position'),...
    'visible','off');
handle_11=legend(handle_1,[handle_name handle_name handle_name handle_name handle_name],...
    'legend_name',...
    'legend_name',...
    'legend_name',...
    'legend_name',...
    'legend_name');
handle_11.FontSize=6;
set(handle_11, 'Position', [0.45 0.8 0.1 0.1]); %位置属性，0-1设置

handle_2=axes('position',get(gca,'position'),...
    'visible','off');
handle_21=legend(handle_2,[handle_name handle_name handle_name handle_name handle_name],...
    'legend_name',...
    'legend_name',...
    'legend_name',...
    'legend_name',...
    'legend_name');
handle_21.FontSize=6; % 高版本使用
% set(handle_21,'fontsize',10) % 低版本使用
set(handle_21, 'Position', [0.6 0.8 0.1 0.1]); %位置属性，0-1设置

text(x,y,'Failure threshold','FontSize',16)
...

% title案例1
title('a','FontName','Times New Roman','FontWeight','Bold','FontSize',16)

% title案例2
string_1 = {'Predicting outcomes using SVR with linear kernel';
['Training Set: mse = ' num2str(error_1(2)) ' R^2 = ' num2str(error_1(3))];
['Testing Set mse = ' num2str(error_2(2)) ' R^2 = ' num2str(error_2(3))]};
title('标题Title','fontname','Times New Roman','Color','b','FontSize',20);

% title案例3
line1 = '适应度曲线MSE[ABCmethod]';
line2 = ['终止代数=', ...
     num2str(iter-1),',种群数量NP=', ...
     num2str(ABCOpts.ColonySize),')'];
line3 = ['Best c=',num2str(GlobalParams(1)),' g=',num2str(GlobalParams(2)), ...
    ' MSE=',num2str(GlobalMin)];
title({line1;line2;line3},'FontSize',20);


% 保存
% print函数原本不是用来进行图像保存了，而是操作打印机的，但是这里我们可以借用下
% print 可作为日常绘图的首选。对格式，分辨率等各项指标做非常细致的定义，适合直接出图。
% print(figure_handle,fileformat,filename)

print(gcf, '-depsc2', 'file_name.eps');
print('-depsc2','-r1000','file_name.eps');
% print('-dpsc','file_name.eps'); % 不采用，产生的图像在中间，tex中呈现漂浮在文字之上。
print(gcf, '-dpng', '-r280', 'file_name.png');
print(gcf,'-r300','-dpdf','file_name.pdf');
print(gcf,'-r300','-djpeg','file_name.jpeg');

% Matlab提供直接的saveas函数可以将指定figure中的图像或者simulink中的框图进行保存
% saveas可以保存matlab自认的fig格式的图像，用来最后细修很有意义。
% saveas(figure_handle,filename,fileformat)

saveas(gca,'file_name.eps','psc2')
% Matlab保存eps分成2个level，在使用saveas(gca,'**.eps')调用的level1的保存eps方式，所以彩色图像变成黑白的了。如果在命令中加入'psc2'，此时，保存的图像是level2的，保存的图片就是eps格式的彩色图像。
saveas(gca,'file_name','png')
%saveas(gcf,file_name,'-r1000','epsc'); %错误

% 典型常用的带变量保存命令（推荐使用）
if save_figures
    filenm = ['file_name_' num2str(variable_name)];
    print('-depsc2','-r1000',['file_path',filenm]); %1000dpi，产生的图像在左下角，tex中正常显示。
    saveas(gcf,['file_path',filenm], 'fig')
end
```
> print()  
用法:print(图形句柄,存储格式,文件名);  
图形句柄，如果图形窗口标题栏是“Figure 3”,则句柄就是3.用gcf可以获取当前窗口句柄。    
指定存储格式。常用的有：  
png格式：'-dpng‘ (推荐这一种，与bmp格式一样清晰，文件也不大)  
jpeg: ‘-djpeg‘(文件小,较清晰)
tiff: ‘-dtiff‘  
bmp: ‘-dbitmap‘(清晰，文件极大)  
gif: ‘-dgif‘(文件小但不清晰)   
文件名：自己给定   
注意:：print函数必须紧跟在plot函数之后使用。添加循环可以自动生成文件名。

## 局部放大

利用 [magnify.m](http://www.mathworks.com/matlabcentral/fileexchange/5961-magnify) 实现局部放大[^78073203]。

[^78073203]: [matlab-figure图形（ 局部放大&变坐标）](https://blog.csdn.net/miracle_fans/article/details/78073203)

1. 将 `magnify.m`加载到 matlab 的安装路径中
2. 运行程序，输出 figure
3. 在 command window 中运行命令: `magnify`
4. 在 figure 中编辑图形
    - 按ctrl键，拖动鼠标左键，（也可以不按ctrl键，拖动鼠标右键）就可以放大局部图像了
    - ctrl+左键固化，也可右键固化，‘<’和‘>’缩放方法范围（看细节-放大或者缩小细节）
    - ‘+’和‘-’缩放放大比例 （确定需要放大的区域 ‘+’ 选取更大的区域，‘-’号，选取小区域）
1. 在 figure 中编辑图形，使用 标记‘2’处的图形‘edit’或者使用Tools > Edit plot,鼠标选中目标如图中标记‘1’处的框，或者外面的放大区域。 进一步可以执行目标删除、放缩+上下左右移动等
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g0bun0hk5zj20f20d3q3f.jpg)
1. 此时标记‘1’处的框已经被删除，上下左右调整放大框的位置，使用‘1’处的 insert 插入方框和箭头。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g0bunkxcq7j20fe0dst9g.jpg)
1. 方框和箭头的位置，重回 edit 环境，在背景处右键-选择 show -property editor。选择‘white’在右面的三角号选择 ’ close ‘。或者如下图，使用背景-右键-color-white （方便快捷-推荐使用）。
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g0buohyd2cj20fm0dadgl.jpg)
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g0bupjoi0bj20ir0aet9t.jpg)

# fill填充

[对matlab中colormap的解释及fill、imshow的用法说明
](http://blog.csdn.net/WhoisPo/article/details/49913513)

# Legend控制

> 涉及到版本兼容问题，有些比较新的句柄属性在老版本Matlab中就用不起来，比如lineseries中的Annotation属性在我使用的R14SP1中就无法使用。


## Legend位置

LEGEND(...,'Location',LOC) 来指定图例标识框的位置

>
      'North'             图例标识放在图顶端  
      'South'            图例标识放在图底端  
      'East'               图例标识放在图右方  
      'West'              图例标识放在图左方  
      'NorthEast'       图例标识放在图右上方（默认）  
      'NorthWest      图例标识放在图左上方  
      'SouthEast'      图例标识放在图右下角  
      'SouthWest'     图例标识放在图左下角  
(以上几个都是将图例标识放在框图内）  
      'NorthOutside'          图例标识放在图框外侧上方  
      'SouthOutside'         图例标识放在图框外侧下方  
      'EastOutside'           图例标识放在图框外侧右方  
      'WestOutside'          图例标识放在图框外侧左方  
      'NorthEastOutside'   图例标识放在图框外侧右上方  
      'NorthWestOutside' 图例标识放在图框外侧左上方  
      'SouthEastOutside'   图例标识放在图框外侧右下方  
      'SouthWestOutside' 图例标识放在图框外侧左下方  
（以上几个将图例标识放在框图外）  
      'Best'            图标标识放在图框内不与图冲突的最佳位置  
      'BestOutside'    图标标识放在图框外使用最小空间的最佳位置

利用位置属性进行精确设置

```
gca=legend( 'sinx', 4 );   
set( gca, 'Position', [0.1,0.1,0.9,0.9] );
```
[0.1,0.1,0.9,0.9] 分别为axes在figure中的左边界，下边界，宽度，高度，最小为0，最大为1（左边界，下边界为0，上边界，右边界为1）

```
figure
set (gca,'position',[0.1,0.1,0.9,0.9] );
x=1:0.1:10;
y=sin(x);
plot(x,y)
```

## 图例说明m条 （m < n）

如果一个图中我们画了n条曲线，但是我们只想加图例说明（legend）的只有m条 （m < n）。例如你有25条曲线，想显示其中1，6，11，16，21的legend，则

### Annotation命令

```
x = -3.14:0.1:3.14;
y1 = sin(x);
y2 = cos(x);
y3 = .1*exp(x);
y4 = y1.*y3;
hold on
h1 = plot(x, y1, 'r');
h2 = plot(x, y2, 'g');
h3 = plot(x, y3, 'k');
h4 = plot(x, y4, 'm');
hold off
xlim auto
set(get(get(h2, 'Annotation'), 'LegendInformation'), 'IconDisplayStyle', 'off');
set(get(get(h4, 'Annotation'), 'LegendInformation'), 'IconDisplayStyle', 'off');
legend('sin', 'exp');
```


EG.
```
for i = [2:5 7:10 12:15 17:20 22:25]
     set(get(get(H(i),'Annotation'),'LegendInformation'),'IconDisplayStyle','off');
end
legend('1','6','11','16','21');
```

## legend命令

把想要标注的图形命令给个变量名，然后再legend命令中指定。

```
x = -3.14:0.1:3.14;
y1 = sin(x);
y2 = cos(x);
y3 = .1*exp(x);
y4 = y1.*y3;
hold on
h1 = plot(x, y1, 'r');
h2 = plot(x, y2, 'g');
h3 = plot(x, y3, 'k');
h4 = plot(x, y4, 'm');
THETA=linspace(0,2*pi,1000);
RHO=ones(1,1000)*2;
[X,Y] = pol2cart(THETA,RHO);
X=X+10;
Y=Y+10;
h5=plot(X,Y,'r--');

axis square;
hold off
xlim auto
legend([h1,h3,h5],'sin', 'exp','circle');
```

EG.
```
H = plot(data);
legend(H([1 6 11 16 21],'1,'6','11’,'16','21');
```


## 多列legend


```
t=0:pi/100:2*pi;
y1=sin(t);
y2=cos(t);
y3=y1.*y2;
y4=0.5*(y1+y2);
hold on
h1=plot(t,y1,'-r')
%h11 = plot(t(1:10:end),y1(1:10:end),'o','MarkerFaceColor','r','MarkerEdgeColor','r');
h11 = plot(t(1:20:end),y1(1:20:end),'ro');
h2=plot(t,y2,'b-');
%h22 = plot(t(1:10:end),y2(1:10:end),'^','MarkerFaceColor','b','MarkerEdgeColor','b');
h22 = plot(t(1:20:end),y2(1:20:end),'b^')
h3=plot(t,y3,'c');
h4=plot(t,y4,'g');
hold off
[legh,objh,outh,outm]=legend([h1,h2],'y1','y2',1);
legend boxoff

% matlab 6.5.1
%set(objh(3),'marker','*');
%set(objh(5),'marker','.');

% matlab7
set(objh(4),'marker','o');
set(objh(6),'marker','^');


legh2=copyobj(legh,gcf);
[legh2,objh2]=legend([h3,h4],'y3','y4',2);
legend boxoff
```

只有第二个legend可拖动，而第一个legend不可拖动，原因不明。

## 避免legend覆盖曲线

给出的legend经常覆盖了某些曲线，这样就需要把legend分成几个，相对独立，这样可以使用鼠标随意移动，确保不遮挡曲线。

```
a=linspace(0,2*pi,100);
y1=100*sin(a);
y2=50*cos(a);
y3=tan(a);
y4=log(a);
y=[y1;y2;y3;y4];
figure
p=plot(a,y)
legend(p(1:2),'sin','cos');
ah=axes('position',get(gca,'position'),...
            'visible','off');
legend(ah,p(3:4),'tan','log','location','west');
```


## legend横排

```
hl = legend(H([1 6 11 16 21],'1,'6','11’,'16','21');
set(hl,'Orientation','horizon')
```

## legend不显示方框

```
hl = legend(H([1 6 11 16 21],'1,'6','11’,'16','21');
set(hl,'Box','off');
```
# errorbar

```
ERRORBAR(X,Y,L,U)，X是自变量，Y是因变量，L是Y的变动下限，U是Y的变动上限
errorbar(X,Y,E)  X是自变量，Y是因变量，E是Y的变动绝对差值。
```

# 柱状图

## 带有误差线（误差标记）的柱状图  errorbar

```
% 生成示例数据
x=1:10;
y=cumsum(randn(1,10));
lower = y - (rand(1,10));
upper = y + (rand(1,10));

% 由于errorbar函数使用相对差值在图形上绘图，所以
% 需要将绝对差值转变为相对差值。
L = y - lower;
U = upper -y;

% 绘图时需要设定 hold on
% 柱状图
clf;
figure(1);
hold on;
bar(x,y);
% 此处需要隐藏折线
errorbar(x,y,L,U,'Marker','none','LineStyle','none');

% 折线图
figure(2);
hold('on');
plot( x, y);
errorbar( x, y, L, U);
```

![](http://bio-spring.info/wp-content/uploads/2011/02/errorbar.png)
![](http://bio-spring.info/wp-content/uploads/2011/02/errorbar2.png)

## 直方图的绘制

```
%% 直方图图的绘制
%直方图有两种图型：垂直直方图和水平直方图。而每种图型又有两种表现模式：累计式：分组式。
figure;
z=[3,5,2,4,1;3,4,5,2,1;5,4,3,2,5]; % 各因素的相对贡献份额
colormap(cool);% 控制图的用色
subplot(2,3,1);
bar(z);%二维分组式直方图,默认的为'group'
title('2D default');
subplot(2,3,2);
bar3(z);%三维的分组式直方图
title('3D default');
subplot(2,3,3);
barh(z,1);%分组式水平直方图，宽度设置为1
title('vert width=1');
subplot(2,3,4);
bar(z,'stack');%累计式直方图，例如:1,1+2,1+2+3构成了第一个bar
title('stack')
subplot(2,3,5);
bar3h(z,0.5,'stacked');%三维累计式水平直方图
title('vert width=1 stack');
subplot(2,3,6);
bar3(z,0.8,'grouped');%对相关数据的颜色进行分组，默认的位'group'
title('width=0.8 grouped');
```

![](http://images.cnitblog.com/blog/573996/201310/26131739-f34c796c7c314e4385176ce65f715f4d.png)

## 柱状图的进阶

```
%% =========柱状图的进阶==========
figure;
y=[300 311;390 425; 312 321; 250 185; 550 535; 420 432; 410 520;];
subplot(1,3,1);
b=bar(y);
grid on;
set(gca,'XTickLabel',{'0','1','2','3','4','5','6'})
legend('算法1','算法2');
xlabel('x axis');
ylabel('y axis');
%使仅有的一组柱状图呈现不同颜色，默认的位相同颜色
data = [1.0, 1.0, 0.565, 0.508, 0.481, 0.745];
subplot(1,3,2);
b = bar(data);
ch = get(b,'children');
set(ch,'FaceVertexCData',[4;2;3;1;5;6]);%使用Indexed形式指定每组bar的颜色
set(gca,'XTickLabel',{'C0','C1','C2','C3','C4','C5'})
axis([0 7 0.0 1.0]);
ylabel('micro F-measure');
%使每个bar颜色不同,默认的是每个元素在不同组的颜色相同
data = [3, 7, 5, 2;4, 3, 2, 9;6, 6, 1, 4];
subplot(1,3,3);
b = bar(data);
ch = get(b,'children');
set(ch{1},'FaceVertexCData',[1;2;3]);%设置第一个元素在不同组的颜色
set(ch{2},'FaceVertexCData',[1;2;3]);%设置第二个元素在不同组的颜色
set(ch{3},'FaceVertexCData',[1;2;3]);
set(ch{4},'FaceVertexCData',[1;2;3]);
```

![](http://images.cnitblog.com/blog/573996/201310/26131907-dd344d7b67ae4370855b6718d4ce4e77.png)


## 彩色柱状图

```
%% 彩色柱状图
%用到的数据
n = 8;
Z = rand(n,1);
figure;
%默认图片
subplot(1,3,1);
bar(Z);
%简单的作图
% 这个图根据数据列中值的大小着色。每列中的值越大，颜色越突出
subplot(1,3,2);
h=bar(Z);
colormap(summer(n));
ch = get(h,'Children');
fvd = get(ch,'Faces');%针对矩阵时，只能用fvd=get(ch{col},'Faces'),下同
fvcd = get(ch,'FaceVertexCData');
[~, izs] = sortrows(Z,1);
for i = 1:n
    row = izs(i);
    fvcd(fvd(row,:)) = i;
end
set(ch,'FaceVertexCData',fvcd)
%图片会以渐变的方式着色，效果非常不错
subplot(1,3,3);
h=bar(Z);
ch = get(h,'Children');
fvd = get(ch,'Faces');
fvcd = get(ch,'FaceVertexCData');
[zs, izs] = sortrows(Z,1);
k = 128; % 准备生成128 *3 行的colormap
colormap(summer(k)); % 这样会产生一个128 * 3的矩阵，分别代表[R G B]的值
% 检视数据
whos ch fvd fvcd zs izs
%   Name       Size            Bytes  Class     Attributes
%
%   ch         1x1                 8  double
%   fvcd      66x1               528  double
%   fvd       13x4               416  double
%   izs       13x1               104  double
%   zs        13x1               104  double
%
shading interp % Needed to graduate colors
for i = 1:n
    color = floor(k*i/n); % 这里用取整函数获得color在colormap中行
    row = izs(i); % Look up actual row # in data
    fvcd(fvd(row,1)) = 1; % Color base vertices 1st index
    fvcd(fvd(row,4)) = 1;
    fvcd(fvd(row,2)) = color; % Assign top vertices color
    fvcd(fvd(row,3)) = color;
end
set(ch,'FaceVertexCData', fvcd); % Apply the vertex coloring
set(ch,'EdgeColor','k');
```

![](http://images.cnitblog.com/blog/573996/201310/26131918-bc3ce5ef389f45b6941965c186c89c6c.png)

## 绘制统计直方图

```
%% 绘制统计直方图
%hist(y)：如果y是向量，则把其中元素放入10个条目中，且返回每条中的元素的个数；如果y为矩阵，则分别对每列进行处理，显示多组条形。
%[n,xout]=hist(y,x)：非递减向量x的指定bin的中心。向量xout包含频率计数与条目的位置。
x=-10:.1:10;
y1=randn(2008,1);
y2=randn(2008,3);
figure;
colormap(winter);
subplot(2,2,1);
hist(y1);%把其中元素放入10个条目中
title('y1为向量，default,n=10');
subplot(2,2,2);
hist(y2);%分别对每列进行处理，显示多组条形
title('y2为矩阵');
subplot(2,2,3);
hist(y1,x);%用户也可以使用[n,xout]=hist(y1,x);bar(xout,n)绘制条形直方图
title('向量x指定条目');
subplot(2,2,4);
hist(y2,1000);%第二个参数为标量时指定bin的数目
title('nbins=1000');
```

![](http://images.cnitblog.com/blog/573996/201310/26131927-02a7b6995d604619bc828fbf1bda5db8.png)

## 均值方差直方图

```
%% ========均值方差直方图========
a=[8 9 10 7 8 9];%mean
b=[1 1 1 1 1 1];%std
figure();
h=bar(a);
ch=get(h,'children');
set(ch,'FaceVertexCData',[4;2;3;1;5;6]);%使用Indexed形式指定每组bar的颜色
hold on;
errorbar(a,b,'k','LineStyle','none');
```

![](http://images.cnitblog.com/blog/573996/201310/26131934-5e951516c87e4d70895420ce4f51080e.png)

## 散点图

```
%% =======散点图scatter , scatter3 , plotmatrix======
%scatter3(X,Y,Z,S,C):在由向量X、Y和Z指定的位置显示大小和颜色分别由S和C决定的离散点
figure;
[x,y,z] = sphere(16);
X = [x(:)*.5 x(:)*.75 x(:)];
Y = [y(:)*.5 y(:)*.75 y(:)];
Z = [z(:)*.5 z(:)*.75 z(:)];
S = repmat([10 2 5]*10,numel(x),1);
C = repmat([1 2 3],numel(x),1);
subplot(1,2,1);
scatter(X(:),Y(:),S(:),C(:));
title('scatter');
subplot(1,2,2);
scatter3(X(:),Y(:),Z(:),S(:),C(:),'filled'), view(-60,60);
title('scatter3');
%plotmatrix(X,Y)绘出X(p*M)与Y(p*N)的列组成的散度图(N,M)
figure;
X=randn(100,2);Y=randn(100,2);
subplot(1,3,1),plotmatrix(X);%等价于plotmatrix(X,X),除了对角上的图为X每一列的直方图hist(X(:,col))
title('plotmatrix(X)');
subplot(1,3,2),plotmatrix(X,X);
title('plotmatrix(X,X)');
subplot(1,3,3),plotmatrix(X,Y);
title('plotmatrix(X,Y)');
```


## 绘制区域图

```
%% =========绘制区域图===========
%区域图特点是：在图上绘制多条曲线时，每条曲线（除第一条外）都是把“前”条曲线作基线，再取值绘制而成。因此，该指令所画的图形，能醒目地反映各因素对最终结果的贡献份额。
figure;
x=1:2:9;% 注意：自变量要单调变化
y=magic(5);% 各因素的相对贡献份额，每一列相当于一个因素
colormap(spring);% 控制图的用色
area(x,y,4);%area(y)则以列下标作为自变量,第三个参数为基准线(默认为0)
set(gca,'layer','top');%图层设置为top层，显示网格
title('basevalue=4');
legend(' 因素 A',' 因素 B',' 因素 C','因素D','因素E');
grid on;
```

![](http://images.cnitblog.com/blog/573996/201310/26132009-c539171f835945f1a021826da9f246e7.png)

## 绘制饼状图

```
%% =========绘制饼状图=========
%饼图指令pie和pie3用来表示各元素占总和的百分数。该指令第二个参数为与第一参数等长的 0-1
%向量，1使对应扇块突出。第三个参数指定个扇区的label
figure;
colormap(summer);% 控制图的用色
x=[16 17 21 25 21];
subplot(1,2,1);
pie(x,[0 0 0 0 1],{'0-10岁儿童','10-20岁儿童','20-35岁青年','35-55岁中年','55岁以上老年'});
subplot(1,2,2);
pie3(x,[0 0 0 0 1],{'0-10岁儿童','10-20岁儿童','20-35岁青年','35-55岁中年','55岁以上老年'});
```

![](http://images.cnitblog.com/blog/573996/201310/26132021-52c70d6c801340398f6b7d32f69b7ac7.png)

## 绘制填色多边形

```
%% 绘制填色多边形。若每列的首尾元素不重合，则将默认把最后一点与第一点相连，强行使多边形封闭。
%fill和fill3用于绘制填色多边形
%fill(X1,Y1,C1,X2,Y2,C2,...)
%fill3(X1,Y1,Z1,C1,X2,Y2,Z2,C2,...)
%参数1和2为等长向量时,多边形的节点数由项链长度决定；而当其为矩阵时，每一列对应一个多边形
%参数3为颜色(用颜色字符r/g/b/c或[r g b]表示)
figure;
colormap(autumn);% 控制图的用色
n=10; % 多边形的边数
dt=2*pi/n;t=0:dt:2*pi;
t=[t,t(1)]; %fill 指令要求数据向量的首位重合，使图形封闭。
x=sin(t);y=cos(t);
subplot(1,2,1);
fill(x,y,[1 1 0]);axis off % 画填色多边形，隐去坐标轴。
X=[0.5 0.5 0.5 0.5;0.5 0.5 0.5 0.5;0 1 1 0];
Y=[0.5 0.5 0.5 0.5;0.5 0.5 0.5 0.5;0 0 1 1];
Z=[1 1 1 1;0 0 0 0;0 0 0 0];
C=[1 0 0 1;0 1 0 1;0 0 1 0];
subplot(1,2,2);
fill3(X,Y,Z,C);
view([-10 55]);
xlabel('x'),ylabel('y');box on;grid on;
```

![](http://images.cnitblog.com/blog/573996/201310/26132030-5f47877fc0ac497ebdeff34aeeb5791a.png)

## 绘制离散数据杆状图

```
%% =======绘制离散数据杆状图===========
%stem和stem3函数用于绘制二维或三维的离散数据杆状图
%stem(Y)可以理解成绘制离散点的plot(y)函数
%stem(X,Y)可以理解成绘制离散点的plot(x,y)函数
%stem(...,'filled')改变数据点显示的空、实状态。
%stem(...,'LINESPEC')Linespec代表直线属性设置参量。
x=1:.1:10;
y=exp(x.*sin(x));
figure;
subplot(1,3,1);
plot(x,y,'.-r');
title('plot(x,y)');
subplot(1,3,2);
stem(x,y,'b');
subplot(1,3,3);
stem(x,y,':g','fill');
%绘制三维离散杆状图
th=(0:127)/128*2*pi;% 角度采样点
x=cos(th);
y=sin(th);
f=abs(fft(ones(10,1),128)); %对离散方波进行 FFT 变换，并取幅值
stem3(x,y,f','cd','fill');%绘制图形
view([-65 30]);
xlabel('Real'); %图形标注
ylabel('Imaginary');
zlabel('Amplitude');
title('FFT example');
```

![](http://images.cnitblog.com/blog/573996/201310/26132039-156dac680a4244c9b02f36ff0aea3990.png)

## 绘制方向和速度矢量图

```
%% =======绘制方向和速度矢量图=======
%compass-绘制罗盘图
%feather-绘制羽毛图
%quiver-绘制二维箭头图
%quiver3-绘制三维箭头图

%绘制罗盘图
figure;
wdir=[45 90 90 45 360 335 360 270 335 270 335 335];
knots=[6 6 8 6 3 9 6 8 9 10 14 12];
rdir=wdir*pi/180;
[x,y]=pol2cart(rdir,knots);% 极坐标转化为直角坐标
compass(x,y);
title('风向和风力')
%绘制羽毛图
figure;
alpha=90:-10:0;
r=ones(size(alpha));
m=alpha*pi/180;
n=r*10;
[u,v]=pol2cart(m,n);% 极坐标转化为直角坐标
feather(u,v);
title('羽毛图')
%罗盘图和羽毛图的比较
figure;
t=-pi/2:pi/12:pi/2; % 在 区间，每 取一点。
r=ones(size(t)); % 单位半径
[x,y]=pol2cart(t,r); % 极坐标转化为直角坐标
subplot(1,2,1),compass(x,y),title('Compass')
subplot(1,2,2),feather(x,y),title('Feather')
%绘制箭头图
figure;
[x,y] = meshgrid(-2:.2:2,-1:.15:1);
z = x .* exp(-x.^2 - y.^2);
[px,py] = gradient(z,.2,.15);
subplot(1,2,1);
contour(x,y,z), hold on
quiver(x,y,px,py), hold off, axis image
title('quiver示例');
[x,y,z]=peaks(15);
[nx,ny,nz]=surfnorm(x,y,z);%surfnorm求平面的法向量
subplot(1,2,2)
surf(x,y,z);
hold on;
quiver3(x,y,z,nx,ny,nz);
title('quiver3示例');
```

![](http://images.cnitblog.com/blog/573996/201310/26132049-46609aeb473b45aca3ac92bba03c928e.png)

![](http://images.cnitblog.com/blog/573996/201310/26132100-b23e560023b44f10980eea2ba3c3db53.png)

## 轮廓线图的绘制

```
%% ==========轮廓线图的绘制==========
%clabel-利用轮廓矩阵生成标签并在当前图形中显示
%contour-利用矩阵所给的值生成二维轮廓线
%contour3-利用矩阵所给的值生成三维轮廓线
%contourf-显示二维轮廓图并用色彩填充个轮廓线的间隙
%contourc-计算被其他轮廓函数占用的轮廓矩阵的低层函数
[x,y,z]=peaks;
n=15;% 等高线分级数
figure;
subplot(1,3,1);
h=contour(x,y,z,n);%绘制20条等高线
clabel(h);%当前图形中显示标签,标签前有'+'号且标签会根据轮廓线旋转，每条轮廓线仅有一个标签
title('simple contour,n=20');
subplot(1,3,2);
z=peaks;
[c,h]=contour(z,n);%绘制15条等高线
clabel(c,h);%标签前无'+'号,每天轮廓线可能有多个标签
title('调用clabel函数标注轮廓图')
subplot(1,3,3);
z=peaks;
[c,h]=contourf(z,n);
clabel(c,h,'FontSize',15,'Color','r','Rotation',0);%自定义标签
colorbar;
title('使用自定义标注并彩色填充轮廓线的间隙');
```

![](http://images.cnitblog.com/blog/573996/201310/26132140-c0a6586a75004d8a9e1e111254bdc974.png)

## Voronoi图和三角剖分

```
%% ========= Voronoi图和三角剖分========
%用Voronoi多边形勾画每个点的最近邻范围。Voronoi多边形在计算几何、模式识别中有重要应用。三角形顶点所在多边形的三条公共边是剖分三角形边的垂直平分线。
n=30;
A=rand(n,1)-0.5;
B=rand(n,1)-0.5; % 产生 30 个随机点
T=delaunay(A,B); % 求相邻三点组
T=[T T(:,1)]; %为使三点剖分三角形封闭而采取的措施
voronoi(A,B) % 画 Voronoi 图
hold on;axis square
fill(A(T(10,:)),B(T(10,:)),'y'); % 画一个剖分三角形
voronoi(A,B) % 重画 Voronoi 图，避免线被覆盖
title('Voronoi图和三角剖分');
```

![](http://images.cnitblog.com/blog/573996/201310/26132148-31721e5822454dacbd916a2dd515e84e.png)

## 三角网线和三角曲面图

```
%% =========三角网线和三角曲面图========
figure;
X=6*pi*(rand(20,10)-0.5);Y=6*pi*(rand(20,10)-0.5);
R=sqrt(X.^2+Y.^2)+eps;Z=sin(R)./R;
tri=delaunay(X,Y); % 进行三角剖分
subplot(1,2,1),trimesh(tri,X,Y,Z);
title('三角网线');
subplot(1,2,2),trisurf(tri,X,Y,Z);
title('三角曲面图');
colormap(copper);brighten(0.5) % 增强亮度
```

![](http://images.cnitblog.com/blog/573996/201310/26132158-54d61b0361144b93b2487d3ee211edea.png)

## 彩带图ribbon

```
%% ============彩带图ribbon========
%ribbon(X,Y,WIDTH)和plot(X,Y)一样的,只不过每一列在三维中以分开的ribbon绘制
figure;
x=0:pi/100:2*pi;
x=repmat(x',1,10);
y=sin(x);
ribbon(x,y,0.4);% 画彩带图
% 至此彩带图已经生成。以下指令都是为了使图形效果更好、标识更清楚而用。
view([150,50]),shading interp,colormap(hot)% 设置视角、明暗、色图
light,lighting phong,box on % 设置光源、照射模式、坐标框
```

![](http://images.cnitblog.com/blog/573996/201310/26132206-b963f24878f04023810a9abe93d53f84.png)

## 在特殊坐标系中绘制特殊图形

```
%% ==========在特殊坐标系中绘制特殊图形。=======
%利用polar函数在极坐标系中绘制图形
figure;
theta=0:.1:pi;
rho1=sin(theta);
rho2=cos(theta);
subplot(1,3,1);
polar(theta,rho1,'.-r');
hold on;
polar(theta,rho2,'--g');
title('极坐标系中绘图');
%另外一种和极坐标有关系的坐标系就是柱坐标系了
theta=0:pi/100:3*pi;
rho=sin(theta)+cos(theta);
[t,r]=meshgrid(theta,rho);
z=r.*t;
subplot(1,3,2);
[x,y,z]=pol2cart(t,r,z);%极坐标系向柱坐标系转化
mesh(x,y,z);%柱坐标系中进行绘图
title('柱坐标系中绘图');
view([-65 30]);
%将球坐标系转换为柱面坐标系
subplot(1,3,3);
delta=pi/100;
theta=0:delta:pi; % theta is zenith angle
phi=0:delta:pi; % phi is azimuth angle
[t p]=meshgrid(theta,phi);
r=ones(size(t));
[x,y,z]=sph2cart(t,p,r);%球坐标向柱坐标转化
mesh(x,y,z);%球坐标系中进行绘图
title('球坐标系中绘图');
```

![](http://images.cnitblog.com/blog/573996/201310/26132216-1123722b3a3f4a0f85a91357df844f5a.png)

## 四维表现

```
%% ======四维表现========
%用色彩表现函数的特征
%当三维网线图、曲面图的第四个输入宗量取一些特殊矩阵时，色彩就能表现或加强函数的某特征，如梯度、曲率、方向导数等。
x=3*pi*(-1:1/15:1);y=x;[X,Y]=meshgrid(x,y);
R=sqrt(X.^2+Y.^2)+eps;Z=sin(R)./R;
[dzdx,dzdy]=gradient(Z);dzdr=sqrt(dzdx.^2+dzdy.^2); % 计算对 r 的全导数
dz2=del2(Z); % 计算曲率
figure;
subplot(1,2,1),surf(X,Y,Z),title('No. 1 surf(X,Y,Z)');
shading faceted,colorbar( 'horiz') ,brighten(0.2);
subplot(1,2,2),surf(X,Y,Z,R),title('No. 2 surf(X,Y,Z,R)');
shading faceted;colorbar( 'horiz');
%色彩分别表现函数的高度和半径特征
figure;
subplot(1,2,1),surf(X,Y,Z,dzdx) ;
shading faceted;brighten(0.1);colorbar( 'horiz');
title('No. 3 surf(X,Y,Z,dzdx)');
subplot(1,2,2),surf(X,Y,Z,dzdy);
shading faceted;colorbar( 'horiz');
title('No. 4 surf(X,Y,Z,dzdy)');
%色彩分别表现函数的 x 方向和 y 方向导数特征
figure;
subplot(1,2,1),surf(X,Y,Z,abs(dzdr)) ;
shading faceted;brighten(0.6);colorbar( 'horiz');
title('No. 5 surf(X,Y,Z,abs(dzdr))');
subplot(1,2,2),surf(X,Y,Z,abs(dz2));
shading faceted;colorbar( 'horiz');
title('No. 6 surf(X,Y,Z,abs(dz2))');
```

![](http://images.cnitblog.com/blog/573996/201310/26132244-69b6447eef2c48328753961c0520b5f2.png)

## 切片图和切片等位线图

```
%% ======切片图和切片等位线图=======
%利用 slice 和 contourslice 表现 MATLAB 提供的无限大水体中水下射流速度数据 flow 。 flow 是一组定义在三维空间上的函数数据。
%在本例中，从图中的色标尺可知，深红色表示“正速度”（向图的左方），深蓝表示“负速度”（向图的右方）。
% 以下指令用切面上的色彩表现射流速度
[X,Y,Z,V]=flow; % 取 4 个 的射流数据矩阵， V 是射流速度。
x1=min(min(min(X)));x2=max(max(max(X))); % 取 x 坐标上下限
y1=min(min(min(Y)));y2=max(max(max(Y))); % 取 y 坐标上下限
z1=min(min(min(Z)));z2=max(max(max(Z))); % 取 z 坐标上下限
sx=linspace(x1+1.2,x2,5); % 确定 5 个垂直 x 轴的切面坐标
sy=0; % 在 y=0 处，取垂直 y 轴的切面
sz=0; % 在 z=0 处，取垂直 z 轴的切面
figure;
slice(X,Y,Z,V,sx,sy,sz); % 画切片图
view([-12,30]);shading interp;colormap jet;axis off;colorbar;
% 以下指令用等位线表现射流速度
v1=min(min(min(V)));v2=max(max(max(V))); % 射流速度上下限
cv=linspace(v1,v2,15); % 在射流上下限之间取 15 条等位线
figure;
contourslice(X,Y,Z,V,sx,sy,sz,cv);view([-12,30]);
colormap jet;colorbar;box on;
```

## 动态图形

```
%% =======动态图形=========
%简单二维示例-彗星状轨迹图
figure;
n=10;t=n*pi*(0:0.0005:1);x=sin(t);y=cos(t);
plot(x,y,'g');axis square;hold on
comet(x,y,0.01);hold off
%卫星返回地球的运动轨线示意
figure;
R0=1; % 以地球半径为一个单位
a=12*R0;b=9*R0;T0=2*pi; %T0 是轨道周期
T=5*T0;dt=pi/100;t=[0:dt:T]';
f=sqrt(a^2-b^2); % 地球与另一焦点的距离
th=12.5*pi/180; % 卫星轨道与 x-y 平面的倾角
E=exp(-t/20); % 轨道收缩率
x=E.*(a*cos(t)-f);y=E.*(b*cos(th)*sin(t));z=E.*(b*sin(th)*sin(t));
plot3(x,y,z,'g') % 画全程轨线
[X,Y,Z]=sphere(30);X=R0*X;Y=R0*Y;Z=R0*Z; % 获得单位球坐标
grid on,hold on,surf(X,Y,Z),shading interp % 画地球
x1=-18*R0;x2=6*R0;y1=-12*R0;y2=12*R0;z1=-6*R0;z2=6*R0;
axis([x1 x2 y1 y2 z1 z2]) % 确定坐标范围
view([117 37]),comet3(x,y,z,0.02),hold off % 设视角、画运动轨线
%色彩变幻‘在 256 色情况下,才可被正确执行.图片刷新可能会卡,单独执行spinmap可查看到效果
figure;
peaks;
spinmap;
```

## 影片动画

```
%% =======影片动画 =======
%三维图形的影片动画
figure;
shg,x=3*pi*(-1:0.05:1);y=x;[X,Y]=meshgrid(x,y);
R=sqrt(X.^2+Y.^2)+eps; Z=sin(R)./R;
h=surf(X,Y,Z);colormap(cool);axis off
n=12;mmm=moviein(n); %预设画面矩阵。新版完全可以取消此指令 。
for i=1:n
rotate(h,[0 0 1],25); %是图形绕 z 轴旋转 25 度 / 每次
mmm(:,i)=getframe; %捕获画面。新版改为 mmm(i)=getframe 。
end
movie(mmm,5,10) %以每秒10帧速度，重复播放5次
```


# MATLAB数据导出origin画图

数据导出：
```
save afile.txt -ascii a
```

> [3D柱形图（3D Bars）的绘制](http://www.cappchem.com/Html/798.html)，[使用Origin2017带误差棒的三维柱状图](https://zhuanlan.zhihu.com/p/25027577)


---
]]></content>
      <categories>
        <category>Programming</category>
        <category>MATLAB</category>
      </categories>
      <tags>
        <tag>MATLAB</tag>
      </tags>
  </entry>
  <entry>
    <title>模型选择</title>
    <url>/model-selection/</url>
    <content><![CDATA[
在机器学习中，有一种叫做“没有免费的午餐”的定理，即没有任何一种ML算法在处理所有问题的时候都适合。不同ML算法的性能很大程度上取决于数据的大小和结构。模型的预测能力通常也被称作模型的泛化能力，表示模型在新的、独立的测试数据上的预测能力。

<!--more-->

可能不少人觉得此处获取较好模型是指模型评价，但是模型评价与模型选择是两个不同的概念，代表两个不同的阶段：

- **模型选择**：根据一组不同复杂度的模型表现，即从某个模型空间中挑选最好的模型；
- **模型评价**：选择一个（最好）模型后，在新的数据上来评价其预测误差等评价指标。

从定义看，两者的目标不同，模型评价是模型选择的后一步。换句话说，模型选择是在某个模型类中选择最好的模型，而模型评价对这个最好的模型进行评价。

模型评价可以比较多个模型类中的最佳模型，然后从中挑选出最佳模型，亦或者进行模型融合再进行评价。

随着机器学习普及，大家都有了 “训练 - 验证 - 评价” 的思维，这其实就是完整重现模型选择、模型评价的过程。如下图我们将数据集分成三个不相交的集合来做模型选择和模型评价：

- 训练集：获得模型及其训练误差，用来训练不同模型；
- 验证集：与训练集相对独立，获取训练模型在该集上的预测误差，用来做模型选择；
- 测试集：与训练集和验证集独立，获得真实的测试误差和其他模型评价指标，用来评价已选择出的模型。

使用训练集、验证集目的就是做模型选择，测试集自然是做模型评价。这三个集合的划分，并没有严格的准则，根据样本大小不同而做不同的选择，但是一个原则是测试集需要保持未知和与训练集、验证集的**独立性**。

# 为什么需要模型选择

1. 训练误差和测试误差的波动是由训练样本的变化带来的。在理想的实验条件下，为了能公正地衡量模型的预测能力，通常需要**多换几组训练集和测试集来综合评价模型的预测能力**，这样的结果才可能让人更信服模型的预测能力，而不是偶然结果。实际情况中，我们手边通常可能只有一个训练集，实际的需求是在此训练集上模型做到最好，即希望在当前训练集下获取最佳的预测能力。换句话说，很多时候人们给你一个训练集就希望你能够给他一个相对最稳定的预测模型，这个目标相对获取平均预测误差来说更难，后续模型选择方法比如 CV 法、bootstrap 法、Cp 法等其实都是估计测试误差的期望。
1. 随着模型复杂度增加，训练误差波动降低，平均训练误差降低趋向于 0，而测试误差波动上升，平均测试误差先降低后升高。这个现象说明**训练误差不能代替测试误差**来作为模型选择和评价的手段。[造成预测误差变化趋势的原因是什么？](https://cosx.org/2015/08/some-basic-ideas-and-methods-of-model-selection/)
1. 用更通俗的话说，复杂的模型可能在训练集上拟合的很好，但是面对新的测试集，预测误差不降反升，发生了所谓的 “**过拟合**” 现象。如果一个模型在不同的测试集上测试结果不仅波动性大，而且预测误差也比较大，就要警惕发生了过拟合现象，此时不妨将模型的复杂度降低些（关于模型的复杂度含义下文会做更细致的说明），即使用变量更少的简单模型，比如线性模型。
    - 过拟合的原因有很多，其中一个很可能的原因是，随着模型复杂度升高，对于训练数据刻画的很细，但是训练数据中可能某些特征仅出现过一次或者很少，信息不足，而测试集中该特征却出现了很多其他的值，虽然模型在训练集上刻画的足够细致，但是由于测试集的变动，模型反而往测试机上的迁移性能下降，训练误差变化并不正比于测试误差。

最标准的方法自然在训练集上训练模型，然后在验证集上获取预测误差，该误差也被称作“样本外（extra-sample）误差”，可真实反映出模型的样本外的预测能力，最后选择最小预测误差所对应的模型作为最佳模型即可。但通常而言，**独立的验证集我们也没有，手头仅有的信息就是训练集**，那么要想估计测试误差或者其期望曲线，就只能在训练集上做文章，一般而言可能仅有两种思路：

- 从训练集划分点数据出来形成验证集来近似测试误差；
  - 只要对训练集进行合适的划分，我们就有可能近似出预测误差。但是对原始训练集划分为新的训练集和验证集，不同的划分比例可能使得新训练集与原训练集相差较大，进而使得差异很大，因此用这种划分的方式来估计条件期望形式的预测误差比较困难。那么此时我们**可以不估计转为估计其期望**，即平均预测误差，通过重复抽样的方式来多次估计预测误差，然后取其平均即可，这种方式我们可以称其为“**重复抽样法**”：通过训练集多次切分、抽样来模拟训练集、验证集，计算多个“样本外误差”，然后求其平均预测误差，这是一种密集计算型方法，比如交叉验证（Cross Validation）、自助法（bootstrap）等。
- 对训练误差进行某种转化来近似测试误差。
  -  更加考虑计算效率，因为重复抽样需要计算多次估计，因此做一次模型选择可能需要花费不少时间，如果单单从训练集的训练误差就可以近似出测试误差，那么模型选择效率便会大大提高。这种方式**以统计学中的 AIC、BIC 等为代表，深刻剖析训练误差与之前提到的 “样本内（in-sample）误差”、预测误差间的关系，给出了预测误差估计的解析式**，因此第二种思路我们可以称之为 “解析法”。


# 模型选择

对模型选择和模型评价的指导可以凝缩为一句话：**根据已知的训练集和验证集在特定模型空间中进行模型选择，获取合适复杂度的模型，然后在多种模型空间做模型选择获取多种模型，最后的最优模型需要通过多个独立未知的测试集来做模型评价决定，否则很容易导致模型过拟合**。（这实际上就是一个完整而规范的机器学习过程。）

从 “偏移 - 方差” 分解可以看到，在有限的模型空间中，对某个模型类控制好模型的复杂度非常重要，否则不容易获取较好（包含稳定与预测误差小两方面）的预测模型，这便是模型选择阶段的工作。

- 如果你的数据集是多个混合变量，那么你就不应该选择自动模型选择方法，因为你应该不想在同一时间把所有变量放在同一个模型中。
- 它也将取决于你的目的。可能会出现这样的情况，一个不太强大的模型与具有高度统计学意义的模型相比，更易于实现。
- 回归正则化方法（Lasso，Ridge和ElasticNet）在高维和数据集变量之间多重共线性情况下运行良好。


## 评价指标

在模型选择阶段，比较适合于不同模型的优点，我们可以**分析不同的指标参数**，如统计意义的参数，R-square，Adjusted R-square，AIC，BIC以及误差项，另一个是**Mallows’Cp准则**。这个主要是通过将模型与所有可能的子模型进行对比（或谨慎选择他们），检查在你的模型中可能出现的偏差。常见的指标有 AIC 准则、BIC 准则、CV 值、结构风险上界等比较普适的准则。

而在模型评价阶段，我们可以根据分类、回归、排序等不同问题关心的问题选择不同的评价指标，多与模型选择时的损失不同：（1）分类：ROC、AUC、TPR、FPR、F1 score；（2）排序：DCG、NDCG；（3）回归：RMSE、MAE、Deviance。

根据具体业务，实际的评价指标有很多种，最好的方式当然是模型选择时即设计其损失函数即为评价指标，但是通常而言这些指标包含了某些非线性变化，优化起来难度颇大，因此实际模型选择仍是选用经典的那些损失函数，而模型评价则会与其略有不同。

一般而言模型选择准则有如下几种：

- 重复抽样与预测稳定性角度：CV、GCV、Boostrap。**交叉验证** 是评估预测模型最好方法。在这里，将你的数据集分成两份（一份做训练和一份做验证）。使用观测值和预测值之间的一个简单均方差来衡量你的预测精度。
- 似然与模型复杂度角度：AIC、AICc、BIC、EBIC
- VC 维与风险上界控制角度：SRM

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>追剧助手</title>
    <url>/movies/</url>
    <content><![CDATA[
{% centerquote %}网络影视资源的查找、观看和下载方法，教你免会员追剧。{% endcenterquote %}

<!--more-->

# 在线看剧

- 手机端和电视端推荐使用[FongMi影视/OK影视](https://fongmitvdown.github.io/)。

- [华科校内高清TV](http://210.42.97.5/)，[东北大学IPv6视频直播测试站](https://hdtv.neu6.edu.cn/)，[A站](http://www.acfun.tv/v/list163/index.htm)，[B站](http://www.bilibili.com/)等。

- 使用搜索引擎搜索关键词：资源名字+在线观看，一个个尝试播放。

- 百度网盘（已失效）：寻找影视资源的**电驴链接（ed2k）或磁力链接（magnet）**。登录自己的[百度网盘](https://pan.baidu.com)，然后找到`离线下载`功能，单击`离线下载`后，选择`新建链接任务`。然后在弹出的对话框中**输入复制的链接地址**，**点击确定**，然后就会出现你要下载的资源的相关信息，**选择存储目录** 之后，**点击下载** 之后，一般正常资源能 **瞬间存到你的百度云盘** 里面了。

免费资源站广告严重，强烈建议使用广告屏蔽软件：

- 电脑端推荐使用[广告终结者](http://www.adtchrome.com/)（[广告终结者CHROME插件](https://chrome.google.com/webstore/detail/%E5%B9%BF%E5%91%8A%E7%BB%88%E7%BB%93%E8%80%85/fpdnjdlbdmifoocedhkighhlbchbiikl)），[点击查看](https://sli1989.github.io/windows-use/#adblock)更多屏蔽软件介绍。
- 手机端推荐使用[夸克浏览器](http://www.myquark.cn/)。

# 影视下载

建议使用搜索引擎（[如何使用google](https://sli1989.github.io/windows-use/#google)）寻找影视的电驴链接（ed2k）、磁力链接（magnet）、BT种子文件、迅雷链接（thunder）。搜索关键词：资源名字+磁力链。 

---

本网站所有内容都是在互联网上搜集而来，仅供学习交流。若侵犯了您的权益，请及时发邮件通知博主，万分感谢！

---
]]></content>
      <categories>
        <category>Life</category>
        <category>Movies</category>
      </categories>
      <tags>
        <tag>Movies</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐视频外链</title>
    <url>/music/</url>
    <content><![CDATA[
{% centerquote %}音乐下载与音乐播放器的设置方法。{% endcenterquote %}

<!--more-->

# 音乐下载

## 浏览器插件

推荐使用浏览器插件，可以直接在音乐网址进行下载。详细说明查看插件脚本教程即可。

- [百度音乐助手chrome插件](https://chrome.google.com/webstore/detail/%E7%99%BE%E5%BA%A6%E9%9F%B3%E4%B9%90%E5%8A%A9%E6%89%8B/bmpmbghoaffenclbcoogkijdibolklka)，突破百度音乐会员限制，突破百度账号限制，网页端直接下载高品质音乐，百度音乐助手带您畅享高品质音乐。

- 安装[Tampermonkey 插件](https://tampermonkey.net/?ext=dhdg&browser=chrome)（Chrome 、 Firefox、Safari、Microsoft Edge、Opera 等常见浏览器都可以用）：
    - 安装[百度音乐助手](https://greasyfork.org/zh-CN/scripts/483-%E7%99%BE%E5%BA%A6%E9%9F%B3%E4%B9%90%E5%8A%A9%E6%89%8B)
    - 安装[百度音乐盒去广告脚本](https://greasyfork.org/zh-CN/scripts/2248-%E7%99%BE%E5%BA%A6%E9%9F%B3%E4%B9%90%E7%9B%92%E5%8E%BB%E5%B9%BF%E5%91%8A)
    - 安装[网易云音乐高音质下载](https://greasyfork.org/zh-CN/scripts/23222-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%AB%98%E9%9F%B3%E8%B4%A8%E4%B8%8B%E8%BD%BD-%E6%94%B9%E8%87%AA-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E4%B8%8B%E8%BD%BD-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%AB%98%E9%9F%B3%E8%B4%A8%E6%94%AF%E6%8C%81)，安装脚本后 `Shift+1` 开启后即可正常播放。`Shift+2` 关闭
    - 安装[网易云音乐高音质支持](https://greasyfork.org/zh-CN/scripts/10582-%E7%BD%91%E6%98%93%E4%BA%91%E9%9F%B3%E4%B9%90%E9%AB%98%E9%9F%B3%E8%B4%A8%E6%94%AF%E6%8C%81)

- [download mp3 files/albums from xiami.com and music.163.com](https://github.com/sk1418/zhuaxia)

- A Flask Music Project：~~[163music-APlayer-you-get-docker 支持 HTTPS 解析方法](https://github.com/YUX-IO/163music-APlayer-you-get-docker)~~。如果希望下载更多歌曲或视频，请参考[you-get](https://you-get.org/)[^you-get]。

[^you-get]: [You-Get – 支持 41+ 家国内视频/音频网站的命令行式下载工具](http://www.appinn.com/you-get/)

<div id="music-download"></div>

## 外链获取

对于下载音乐，以下网站均可使用[^yuweining]：[HHTJim's部落格](http://link.hhtjim.com/)，[多站合一音乐下载](http://music.liuzhijin.cn/)。

[^yuweining]: [音乐外链 - 不死鸟 - 分享为王](https://hao.su/mp3.html)

<div id="music-cover"></div>

- 获取唱片封面：百度图片

<div id="music-zhilian"></div>

这里主要讲博客的永久外链获取。如果需要将音乐外链应用到博客中，<font color=blue>外链形式应该尽可能固定，不包含日期、KEY等，建议按照以下顺序进行获取</font> ，最好试听一下得到的音乐链接。

### 全网音乐

- **首推**[HHTJim's部落格](http://link.hhtjim.com/)。还是可能存在失效情况（2020年3月10日更新）。
- ~~[170MV](http://www.170mv.com/song)~~

<div id="163music"></div>

### 网易云音乐

- 使用`http://music.163.com/song/media/outer/url?id=ID数字.mp3`固定连接，其中`ID数字`是网易云音乐歌曲的ID，如`https://music.163.com/#/song?id=29095562`。

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="http://music.163.com/song/media/outer/url?id=29095562.mp3" type="audio/mpeg">  </audio></center>

- ~~进去[网址](https://music.liuli.lol/song)获取音乐地址，部分歌曲无法获取。~~

<div class="note warning"><p>已失效</p></div>

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="https://p2.music.126.net/6Cf7_yosMAmcfrqtpeoZFw==/18940187300173672.mp3" type="audio/mpeg">  </audio></center>

<div id="qqmusic"></div>

### QQ音乐

> 参考链接：[y.qq.com-php获取QQ音乐外链源码](https://www.hhtjim.com/y-qq-com-php-source-obtains-qq-music-chain.html)，QQ 音乐外链php 源码 [百度网盘下载](http://pan.baidu.com/s/1mhY3fEo)。

- 使用代理外链：
    1. 在[QQ音乐](https://y.qq.com)搜索歌曲，网页链接可以得到`songmid`，点击“更多-分享-复制链接”（或者右键查看“网页源代码”，查找`songid`），得到`songid`。
    1. 然后代入替换如下测试链接中的ID，如无法试听及下载，说明该方法失效。

        ```
        http://thirdparty.gtimg.com/C100{songmid}.m4a?fromtag=46
        http://ws.stream.qqmusic.qq.com/{songid}.m4a?fromtag=46
        http://cc.stream.qqmusic.qq.com/{songid}.m4a?fromtag=52
        ```

<div class="note warning"><p>已失效</p></div>

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="http://thirdparty.gtimg.com/C100003BNTQM11ZSPt.m4a?fromtag=46" type="audio/mpeg">  </audio></center>

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="http://ws.stream.qqmusic.qq.com/200732348.m4a?fromtag=46" type="audio/mpeg">  </audio></center>

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="http://cc.stream.qqmusic.qq.com/109925411.m4a?fromtag=52" type="audio/mpeg">  </audio></center>


- QQ音乐加油站](http://www.qqmusic.cc/somusic)，也可获取唱片封面地址。

<div class="note warning"><p>已失效</p></div>

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="http://mp3.qqmusic.cc/yq/8128063.mp3" type="audio/mpeg">  </audio></center>

### 网盘外链

<div id="onedrivemusic"></div>

- OneDrive外链：

    > ~~[微软OneDrive网盘直链获取工具](https://github.com/ChIaSg/OneDrive-ShareLinks)，[OneDrive 网盘文件永久外链获取](http://www.benpig.com/skydrive/)，已失效，现分享前缀为`https://1drv.ms/u/s!APlDl45Z7AV8gQg`。~~

    1. 点击访问[获取OneDrive直链](https://mapaler.github.io/GetOneDriveDirectLink/)([测试链接](http://storage.live.com/items/3525C57BFAC5CDE9!222))。
    1. 点击`从OneDrive选择文件`按钮，等待打开新窗口。
    1. 在新窗口中登陆OneDrive对应的账户并授予需要的权限。
    1. 进入OneDrive“公开”文件夹内选择需要获取直链的文件（同一文件夹内可多选），点击打开。选择需要输出的掩码格式，输出面板内会自动生成对应的格式。一般选择`最短链接`形式即可，<font color=blue> 歌曲可能存在延时</font>。

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="http://storage.live.com/items/3525C57BFAC5CDE9!222" type="audio/mpeg">  </audio></center>

- Cloudup外链：国外[Cloudup](https://cloudup.com)网盘（需要[谷歌访问配置](https://sli1989.github.io/windows-use/#google)）支持全格式文件上传，单文件限制大小为 200M 可以上传 1000 个文件，支持直接外链。

<div class="note warning"><p>已失效</p></div>

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="https://cloudup.com/files/i9wChzfh-64/download" type="audio/mpeg">  </audio></center>

- [石墨文档](https://shimo.im)附件，建立修改文件名为英文和数字，可能存在延迟或者不能连续读取问题。

<div class="note warning"><p>已失效</p></div>

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="https://dn-shimo-attachment.qbox.me/946QhECb088a9kDb/I-Feel-It-Coming.mp3" type="audio/mpeg">  </audio></center>

<div id="xiamimusic"></div>

### 虾米音乐

<div class="note warning"><p>已失效</p></div>

1. 首先进入[虾米音乐](http://www.xiami.com)，搜索自己想要的音乐，在页面查看源代码找到`http://m.xiami.com/song/`，后面的数字就是音乐ID。
1. 然后进入[在线获取真实的虾米 mp3 音乐地址](http://xiamirun.avosapps.com/run?song=http://www.xiami.com/song/1774205606)（[源地址](https://github.com/naoyeye/xiamiRun)）对应修改后面的ID回车，即可获取音乐地址（非mp3格式）等其他信息。

<center><audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="http://om5.alicdn.com/165/88165/564328/1771534242_4027332_l.mp3?auth_key=b38c4198808a2e53cd2624c0b26e15ab-1497582000-0-null" type="audio/mpeg">  </audio></center>

<div id="musicplayer"></div>

# 音乐播放器

> Github Pages 一般开启了 https ， http 播放器会无法显示，但是可以使用mp3直链方式插入。当然，如果把Github Pages绑定第三方域名（http环境）后也可以直接使用。

博客侧边栏播放器暂时推荐[虾米外链播放器](#xiamiplayer)（外观可控）。

## 外链模式

1. 首先获取[永久外链](#music-zhilian)：获取[网易云音乐外链](#163music)，或获取[QQ音乐外链](#qqmusic)，或获取[Onedrive外链](#onedrivemusic)等。

1. 使用`<audio>`标签播放器，设置自动播放，循环播放，隐藏播放器等属性加入即可：`<audio controls="controls" height="100" width="100%" autoplay loop  hidden="true"...> `。

    ```
    <audio controls="controls" playsinline="" webkit-playsinline="">  
    <source src="http://other.web.nf01.sycdn.kuwo.cn/resource/n2/40/14/3065311430.mp3" type="audio/mpeg">  </audio>
    ```

<center> <audio controls="controls" playsinline="" webkit-playsinline="">  
<source src="http://other.web.nf01.sycdn.kuwo.cn/resource/n2/40/14/3065311430.mp3" type="audio/mpeg">  </audio></center>

<div id="xiamiplayer"></div>

## 虾米音乐插件播放器

进入[虾米外链播放器](http://www.xiami.com/widget)设置后复制代码即可。（[我的播放器设置](http://www.xiami.com/widget/imulti-dynamic/id/277625635/type/collect?spm=0.0.0.0.XhJxRk)）

`<embed>`标签举例：flash plyer模式，https环境测试失效，http环境测试成功。

```
<embed src="http://www.xiami.com/widget/0_1775449134/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent"></embed>
```

<embed src="http://www.xiami.com/widget/0_1775449134/singlePlayer.swf" type="application/x-shockwave-flash" width="257" height="33" wmode="transparent"></embed>

`javascript`标签举例：flash plyer模式，https环境测试失效，http环境测试成功。<font color=red>不建议使用该模式，与next主题冲突，渲染失败。</font>

```
<script type="text/javascript" src="http://www.xiami.com/widget/player-single?uid=0&sid=1775449134&mode=js"></script>
```

<div id="163player"></div>

## 网易云音乐插件播放器

> https环境测试失效，http环境测试成功。

先通过[网易云音乐](https://music.163.com)搜索歌曲，点击“生成外链播放器”，复制`<iframe>`标签代码即可。当网页提示：由于版权保护，无法生成外链。其实原因是里面有受版权保护的歌曲。此时在页面右键“查看框架源代码”或“审查元素”，找到含有“outchain”的部分如`"/outchain/0/35402755/"`，得到外链`http://music.163.com/#/outchain/0/24972133/`，打开即可看到插件设置页。但是受版权保护的歌曲依然还是不能播放。

> 注意，如果使用iframe直接显示出代码，而不会显示播放器的。把iframe的width和height标签的值加上双引号就可以了。

- 使用`<iframe>`标签

```
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="100" src="http://music.163.com/outchain/player?type=2&id=247415&auto=0&height=66"></iframe>
```

<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="300" height="100" src="http://music.163.com/outchain/player?type=2&id=247415&auto=0&height=66"></iframe>

- 使用`<object>`标签，flash plyer模式。

```
<object width="340" height="86" data="http://music.163.com/style/swf/widget.swf?sid=247415&type=2&auto=0&width=320&height=66"
type="application/x-shockwave-flash"></object>
```

<object width="340" height="86" data="http://music.163.com/style/swf/widget.swf?sid=247415&type=2&auto=0&width=320&height=66"
type="application/x-shockwave-flash"></object>

<div id="hexo-music"></div>

## HEXO音乐插件播放器

1. ~~为了快速添加音乐，可以在hexo主题blog中安装[网易云音乐标签插件](https://github.com/qinyuanpei/hexo-tag-cloudmusic)：你只需要在页面或者文章中使用输入代码，就可以在网页中展示一个网易云音乐的widget，这里的sid可以是单曲的ID或者是歌单的ID。~~

    ```
    安装
    npm install hexo-tag-cloudmusic --save

    使用
    {% cloudmusic 20744792 %}
    ```

<div id="videopalyer"></div>

# 视频播放器

大部分音乐/视频网站都可以直接生成播放器代码，直接粘贴到 Markdown 文档中即可使用。**不过在 https 下，可能无法正常使用**。**目前只支持HTML的`<vedio>`标签的直链播放**。另外，似乎优酷对flash的dll插件有冲突，火狐和chrome浏览器直接访问视频页面也无法加载视频，而IE却能正常打开。

推荐使用腾讯视频外链模式`<embed>`标签和音悦台视频外链模式`<embed>`标签，、<font color=red>注意`width=`的设置对应于手机的适配</font> ，可以设置为百分比`width="100%"`的。点击查看[HTML-embed标签](https://segmentfault.com/a/1190000004603069)使用方法。

```
该属性规定音频或视频文件是否在下载完之后就自动播放。
autostart=true：音乐文件在下载完之后自动播放；
autostart=false：音乐文件在下载完之后不自动播放。

说明：该属性规定音频或视频文件是否循环及循环次数。
loop=正整数:音频或视频文件的循环次数与正整数值相同；
loop=true:音频或视频文件循环；
loop=false:音频或视频文件不循环。

volume 音量大小
该属性规定音频或视频文件的音量大小，值为0-100之间的整数。未定义则使用系统本身的设定。

controls 外观设置
该属性规定控制面板的外观。默认值是console。
controls=console：一般正常面板；
controls=smallconsole：较小的面板；
controls=playbutton：只显示播放按钮；
controls=pausebutton：只显示暂停按钮；
controls=stopbutton：只显示停止按钮；
controls=volumelever：只显示音量调节按钮。

align 对齐方式
该属性规定控制面板和当前行中的对象的对齐方式。
align=center：控制面板居中；
align=left：控制面板居左；
align=right：控制面板居右；
align=top：控制面板的顶部与当前行中的最高对象的顶部对齐；
align=bottom：控制面板的底部与当前行中的对象的基线对齐；
align=baseline：控制面板的底部与文本的基线对齐；
align=texttop：控制面板的顶部与当前行中的最高的文字顶部对齐；
align=middle：控制面板的中间与当前行的基线对齐；
align=absmiddle：控制面板的中间与当前文本或对象的中间对齐；
align=absbottom：控制面板的底部与文字的底部对齐。
```

## 外链播放器

进去[网易云音乐](https://music.163.com/)搜索相应的MV的ID，然后进去[MV 直链获取](http://tools.hbtech.ml/163music/mv.php?id=)获取直链地址，然后运用`<vedio>`标签。

`<vedio>`标签举例：

```
<video width="480" height="320" controls>
<source src="movie.mp4">
</video>
```

```
<video id="video" controls="" preload="none" poster="http://media.w3.org/2010/05/sintel/poster.png">
      <source id="mp4" src="http://media.w3.org/2010/05/sintel/trailer.mp4" type="video/mp4">
      <source id="webm" src="http://media.w3.org/2010/05/sintel/trailer.webm" type="video/webm">
      <source id="ogv" src="http://media.w3.org/2010/05/sintel/trailer.ogv" type="video/ogg">
      <p>Your user agent does not support the HTML5 Video element.</p>
    </video>
```

## 优酷视频插件播放器

 `<embed>`标签举例：https环境测试失效，http环境测试成功。在 http+Github Pages 环境下，火狐和chrome浏览器无法加载视频，IE正常打开。**推荐使用 `<embed>`标签**，外链外观大小合适。

```
<embed src="http://player.youku.com/player.php/sid/XNzQxMjU2ODI0/v.swf" allowFullScreen="true" quality="high" width="100%" height="100" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed>
```

<embed src="http://player.youku.com/player.php/sid/XNzQxMjU2ODI0/v.swf" allowFullScreen="true" quality="high" width="100%" height="100" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed>


`<iframe>`标签举例：https环境测试失效，http环境测试成功。在 http+Github Pages 环境下，火狐和chrome浏览器无法加载视频，IE正常打开。

```
<iframe height=100 width=100% src="http://player.youku.com/embed/XNzQxMjU2ODI0==&isAutoPlay=false" frameborder=0 allowfullscreen></iframe>
```

<iframe height=100 width=100% src="http://player.youku.com/embed/XNzQxMjU2ODI0==&isAutoPlay=false" frameborder=0 allowfullscreen></iframe>

## 音悦台插件播放器

进入[音悦台](http://www.yinyuetai.com/)搜索视频分享即可，只有`<embed>`标签，**会自动播放视频**。

```
<embed src="http://player.yinyuetai.com/video/player/2533337/v_0.swf" autostart="false" quality="high" width="480" height="334" align="middle"  allowScriptAccess="sameDomain" allowfullscreen="true" type="application/x-shockwave-flash"></embed>
```

## 爱奇艺插件播放器

进入[爱奇艺](http://www.iqiyi.com/)搜索视频分享即可，推荐使用`<embed>`标签，`<iframe>`标签外观异常，而且会自动播放视频。

```
<embed src="http://player.video.qiyi.com/1b7b600614117e3f268b83e08f5c29eb/0/0/w_19rtcso3bp.swf-albumId=5130708409-tvId=5130708409-isPurchase=0-cnId=5" allowFullScreen="true" quality="high" width="100%" height="100" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed>
```

<embed src="http://player.video.qiyi.com/1b7b600614117e3f268b83e08f5c29eb/0/0/w_19rtcso3bp.swf-albumId=5130708409-tvId=5130708409-isPurchase=0-cnId=5" allowFullScreen="true" quality="high" width="100%" height="100" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed>

```
<iframe src="http://open.iqiyi.com/developer/player_js/coopPlayerIndex.html?vid=1b7b600614117e3f268b83e08f5c29eb&tvId=5130708409&accessToken=2.f22860a2479ad60d8da7697274de9346&appKey=3955c3425820435e86d0f4cdfe56f5e7&appId=1368&height=100%&width=100%" frameborder="0" allowfullscreen="true" width="100%" height="100%"></iframe>
```

## 腾讯视频插件播放器

进入[腾讯视频](https://v.qq.com/)搜索视频分享即可，推荐使用`<embed>`标签。

```
<embed src="http://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=m0178qd1etl&auto=0" allowFullScreen="true" quality="high" width="100%" height="100" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed>
```

<embed src="http://imgcache.qq.com/tencentvideo_v1/playerv3/TPout.swf?max_age=86400&v=20161117&vid=m0178qd1etl&auto=0" allowFullScreen="true" quality="high" width="100%" height="100" align="middle" allowScriptAccess="always" type="application/x-shockwave-flash"></embed>

```
<iframe frameborder="0" width="100%" height="100" src="http://v.qq.com/iframe/player.html?vid=m0178qd1etl&tiny=0&auto=0" allowfullscreen></iframe>
```

<iframe frameborder="0" width="100%" height="100" src="http://v.qq.com/iframe/player.html?vid=m0178qd1etl&tiny=0&auto=0" allowfullscreen></iframe>


## Hexo视频插件播放器

- Hexo 的 Tag Plugins 提供直接插入 Youtube 视频的方法。这种方式得到的视频框是 responsive 的，即视频框大小随浏览器窗口自动调节。如果想要得到固定大小的视频框，例如视频框大小为 320x180, 相应的代码为 (直接插入 html 代码，视频框还可以居中。

    ```
    {% youtube zm_ztEhOB48 %}
    ```

{% youtube zm_ztEhOB48 %}


    ```
    <iframe width="100%" height="100" src="https://www.youtube.com/embed/zm_ztEhOB48" frameborder="0" allowfullscreen></iframe>
    ```

<iframe width="100%" height="100" src="https://www.youtube.com/embed/zm_ztEhOB48" frameborder="0" allowfullscreen></iframe>

- [hexo-tag-tencent](https://www.npmjs.com/package/hexo-tag-tencent)提供了快速插入腾讯视频的方式。
]]></content>
      <categories>
        <category>Software</category>
        <category>Music</category>
      </categories>
      <tags>
        <tag>外链播放器</tag>
      </tags>
  </entry>
  <entry>
    <title>神经网络</title>
    <url>/neural-network/</url>
    <content><![CDATA[
在机器学习和认知科学领域，人工神经网络（英文：artificial neural network，缩写ANN），简称神经网络（英文：neural network，缩写NN）或类神经网络，是一种模仿生物神经网络(动物的中枢神经系统，特别是大脑)的结构和功能的数学模型或计算模型，用于对函数进行估计或近似。神经网络由大量的人工神经元联结进行计算。大多数情况下人工神经网络能在外界信息的基础上改变内部结构，是一种自适应系统。现代神经网络是一种非线性统计性数据建模工具。

<!--more-->

> [Neural Networks and Deep Learning](http://neuralnetworksanddeeplearning.com/index.html)

前向算法的作用是计算输入层结点对隐藏层结点的影响，也就是说，把网络正向的走一遍：输入层—->隐藏层—->输出层,计算每个结点对其下一层结点的影响。

例如，我们要算结点h1的值，那么就是：

$$net_{h_{1}}=i_{1}\times w_{1}+i_{2}\times w_{2}+b_{1} \times 1$$

是一个简单的加权求和。这里稍微说一下，偏置项和权重项的作用是类似的，不同之处在于权重项一般以乘法的形式体现，而偏置项以加法的形式体现。

而在计算结点$o_1$时，结点$h_1$的输出不能简单的使用$net_{h1}$的结果，必须要计算激活函数，激活函数，不是说要去激活什么，而是要指“激活的神经元的特征”通过函数保留并映射出来。以sigmoid函数为例，$h_1$的输出：

$$out_{h_{1}}=\frac{1}{1+e^{-net_{h_{1}}}}$$

$$net_{o_{1}}=out_{h_{1}}\times w_{5}+out_{h_{2}}\times w_{6}+b_{2}\times 1$$

$$out_{o_{1}}=\frac{1}{1+e^{-net_{o_{1}}}}$$

按照上面的步骤计算出$out_{o_{2}}$，则$[out_{o_{1}},out_{o_{2}}]$就是整个网络第一次前向运算之后得到的结果。

在实际情况中，因为是随机给定的权值，很大的可能（几乎是100%）得到的输出与实际结果之间的偏差非常的大，这个时候我们就需要比较我们的输出和实际结果之间的差异，将这个残差返回给整个网络，调整网络中的权重关系。这也是为什么我们在神经网络中需要后向传播的原因。其主要计算步骤如下：

1. 计算总误差
$$E_{total}=\sum \frac{1}{2}(target-output)^{2}$$
2. 隐藏层的权值更新
3.
在要更新每个边的权重之前，必须要知道这条边对最后输出结果的影响，可以用整体误差对$w_{5}$求偏导求出$\frac{\partial E_{total}}{\partial_{w_{5}}}$。具体计算的时候，可以采用链式法则展开，在计算的时候一定要注意每个式子里面哪些自变量是什么，求导千万不要求错了。需要讲出来的一个地方是，在计算$w_{1}$的权重时，$E_{total}$中的两部分都需要对它进行求导，因为这条边在前向传播中对两个残差都有影响。
$$\frac{\partial E_{total}}{\partial out_{o_{1}}} \times \frac{\partial out_{o_{1}}}{\partial net_{o_{1}}} \times \frac{\partial net_{o_{1}}}{\partial w_{5}}$$
3. 更新权重 这一步里面就没什么东西了，直接根据学习率来更新权重：
$$w_5^+=w_5-\eta \times \frac{\partial E_{total}}{\partial_{w_{5}}}$$
4. 至此，一次正向+反向传播过程就到此为止，接下来只需要进行迭代，不断调整边的权重，修正网络的输出和实际结果之间的偏差（也就是training整个网络）。
  

# 归一化

为什么要归一化？不同的算法，在归一化中得到的好处各不相同。不过目前大部算法，都比较需要归一化，特别是常用的梯度下降法（或梯度下降的衍生方法）。

- 使网络快速的收敛，更方便的求解。
- 无容置疑，归一化的确可以避免一些不必要的数值问题。
- 避免神经元饱和：与权值阈值相乘后，才是sigmoid的输入值，初始化得好的话，并不会饱和输出。若果使用“把权值和阈值随机初始化为[-1，1]之间的值”这种初始化方法，那不归一化就会引起神经元输出饱和现象。
- 大数吞小数：若果我们找到适合的权值，是不会吞掉的。

关于使用matlab工具箱：

1. Matlab2012b已经会自动将输入数据归一化，所以不必再自己去做数据的预处理，直接用原始数据建立网络就可以。
2. 使用matlab神经网络工具箱，而又要用梯度下降法的话，输出一定要做归一化。因为工具箱计算误差的时候，使用的是原始数据的误差，因此误差数量级可能很大，这样一来梯度就很大了，在学习率还没来得及自适应减小的时候，梯度就一下子把原来初始化好的权重给吞掉了，使网络的权重掉到一个离最优解非常远的地方。
3. 使用matlab2012b（或以上）工具箱得到的网络权值，是面向作了归一化后的数据的。所以使用时，需要先对数据进行归一化，再将归一化后的输入数据放到网络中计算网络输出，再将输出反归一化，才是真正的预测结果。由于归一化和反归一化都是线性运算，而权值阈值与输入输出也是线性运算，能否将[它们合并成一个线性运算](http://www.nnetinfo.com/nninfo/showText.jsp?id=32)？答案当然是可以的！

# 梯度消失

> [神经网络梯度与归一化问题总结](http://blog.csdn.net/jzrita/article/details/72732037)

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>NeuralNetwork</tag>
      </tags>
  </entry>
  <entry>
    <title>正态分布为什么常见？</title>
    <url>/normal-distribution/</url>
    <content><![CDATA[
正态分布为什么常见？真正原因是中心极限定理（central limit theorem）。

> "多个独立统计量的和的平均值，符合正态分布。"

<!--more-->

根据中心极限定理，如果一个事物受到多种因素的影响，不管每个因素本身是什么分布，它们加总后，结果的平均值就是正态分布。

举例来说，人的身高既有先天因素（基因），也有后天因素（营养）。每一种因素对身高的影响都是一个统计量，不管这些统计量本身是什么分布，它们和的平均值符合正态分布。（注意：男性身高和女性身高都是正态分布，但男女混合人群的身高不是正态分布。）

许多事物都受到多种因素的影响，这导致了正态分布的常见。

但是很多真实世界的分布是不对称的。比如，财富的分布就是不对称的，富人的有钱程度（可能比平均值高出上万倍），远远超出穷人的贫穷程度（平均值的十分之一就是赤贫了），即财富分布曲线有右侧的长尾。相比来说，身高的差异就小得多，最高和最矮的人与平均身高的差距，都在30%多。这是为什么呢，财富明明也受到多种因素的影响，怎么就不是正态分布呢？

原来，正态分布只适合各种因素累加的情况，如果这些因素不是彼此独立的，会互相加强影响，那么就不是正态分布了。

统计学家发现，如果各种因素对结果的影响不是相加，而是相乘，那么最终结果不是正态分布，而是对数正态分布（log normal distribution），即x的对数值log(x)满足正态分布。

---

- [Why isn’t everything normally distributed?](https://www.johndcook.com/blog/2015/03/09/why-isnt-everything-normally-distributed/)
- [Why isn’t everything normally distributed?](https://www.johndcook.com/blog/2015/03/09/why-isnt-everything-normally-distributed/)

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>NormalDistribution</tag>
      </tags>
  </entry>
  <entry>
    <title>国家自然科学基金</title>
    <url>/nsfc/</url>
    <content><![CDATA[
[国家自然科学基金](http://www.nsfc.gov.cn/)是20世纪80年代初，为推动我国科技体制改革，变革科研经费拨款方式，中国科学院89位院士（学部委员）致函党中央、国务院建议的。自然科学基金坚持支持基础研究，逐渐形成和发展了由研究项目、人才项目和环境条件项目三大系列组成的资助格局。

<!--more-->

# 基金介绍

基金委项目允许失败，需要把看不见的东西变成看得见的东西，虽然是理论，需要添加一个应用背景，从应用背景中升华思想。着重理论创新。

其中基金申请书相当于博士论文的开题报告，函评则需要体现创新点，年度报告对应于博士论文的中期进展报告。

# 基金类型

国家自然科学基金委员会公布了集中接收申请的项目类型包括：面上项目、重点项目、部分重大项目、部分重大研究计划项目、青年科学基金项目、优秀青年科学基金项目、国家杰出青年科学基金项目、创新研究群体项目、地区科学基金项目、海外及港澳学者合作研究基金项目、部分联合基金项目、国家重大科研仪器研制项目（自由申请）、数学天元基金项目、重点国际（地区）合作研究项目和外国青年学者研究基金项目等。通过亚类说明、附注说明还可将一些资助类别进一步细化。所有这些资助类别各有侧重，相互补充，共同构成当前的自然科学基金资助体系。

## 青年科学基金项目

青年基金一个人一辈子只能获批一次，项目3年，总共给25万左右的经费/资助强度。

## 面上项目

面上项目，要高级职称（副教授、教授）才可以申请。资助强度80万左右（我都说的是理工科实验性的课题），时间4年。面上是大多数教授主要申请的。

## 重点项目


# 基金申请

- [基金申请-科学网](http://fund.sciencenet.cn/?id=781)，[基金申请-小木虫](http://muchong.com/html/f234.html)
- [项目综合检索|国家自然科学基金委员会](https://isisn.nsfc.gov.cn/egrantindex/funcindex/prjsearch-list#)，[2018国家自然基金重点项目资助情况汇总](http://blog.sciencenet.cn/home.php?mod=space&uid=45&do=blog&id=1129759)，[2018基金完整数据查询分析+资助统计系列报告](http://blog.sciencenet.cn/home.php?mod=space&uid=45&do=blog&id=1130045)，[2019国家自然基金最新政策](https://zhuanlan.zhihu.com/p/45283337)
- [国家自然科学基金申请指导与技巧-徐长庆](http://blog.sciencenet.cn/home.php?mod=space&uid=69051&do=blog&id=1148205)，[申请国家自然科学基金项目的一点体会](http://blog.sciencenet.cn/blog-52727-1060219.html)，[一步一步教你如何写国家基金申请书](http://zmtt.bao.ac.cn/zatan/NSFCapplication.html)，[国家自然科学基金申请书的若干建议](http://blog.sciencenet.cn/blog-63255-1091734.html)，[百份国自然标书的专家评审意见](https://mp.weixin.qq.com/s/XnKIaF5NdWAxwSoxJjY3lg)

- 准备自然基金申请材料过程是一个很好的充电过程。
- 自然基金撰写过程也是思考下一年度研究生们研究课题的很好过程。思考这个领域哪些东西是他人没有做过的，哪些东西又是具有创新意义的。我们要思考采用什么样的高科技手段去解决哪些重要的未知科学问题。与此同时，我们还需要思考这些研究内容是否可以顺利完成。
- 撰写自然基金过程也是深入学习、了解国家科技政策最新发展趋势的一个好机会。清晰地知道国家未来评价学术科研人员的走向。

## 政策分析

申请者在准备之前，

- 要重点关注《项目指南》中的“申请须知”和“限项规定”。
- 要认真阅读并准确解读《项目指南》中与申请内容有关的学部和科学处的论述部分，尤其是学科的资助范围，最好对前几年《项目指南》的相关部分都有所了解，以便比较全面地了解申请者所在学科的资助范围、资助特点等信息。
- 应仔细阅读并准确理解《基金条例》、《基金管理办法》、《基金经费管理办法》中的相关内容，重点了解包括各类基金的申请x条件、限项要求、推荐要求、经费预算要求等，尤其是管理费、国际合作与交流费以及劳务费的比例和使用范围，切实做到心中有数。

## 流程

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fxfp88lsv1j20k00f0dhe.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/083255mazh7cir7xyy3x9s.png)


1. 3月份申请书交上去，然后基金委会分发给领域内相关专家审查，然后评分，决定是否进入审查会议。上会的本子再有若干比例被刷掉，剩下的获得资助，年底的时候资助决定下来（青年基金各学科资助率都是大概20%）。
1. 申请书一般是从4月下旬开始陆陆续续送到评审专家手中，进入到**专家评审**的环节。杰青，优青和重点项目是六位评委，面上，青年和地区基金五位评委。
    - 审稿专家：获得过基金并在基金委的系统中登记了信息的人，并实时更新个人在专家库的信息。
    - 基金委的综合局根据申请书的关键词，排除师生关系、当年度是否申请基金以及本单位等回避因素后，从专家库中随机挑选的。
3. 量化评价：A优、B良、C中，D差，同时还要提出资助意见：A优先资助，B同意资助和不给资助。除了这些意见外，每个评委都会要求写成书面意见。基金委对于不负责的评审意见，特别是哪种字数少于20个字的意见，会将这类评委列入黑名单，今后不再劳其大驾。
    - 客观地评判每一份申请书。
    - 有些本子连续几年都没有拿到，一定要冷静下来，在自己身上找原因。
1. 五月下旬到六月中旬，评审意见陆续返回到基金委。这两年又多了个网评的环节，基金委收到的同行专家的评价意见后又选择一些专家进行网络评审。
2. 基金委根据评审意见，提出是否进入会评（二评）的名单。
    - 基金委的各学科处按照当年的指标，提出推荐项目数（正选项目）和一定数量的候选项目数。选择的依据仍然是同行评价的意见。
    - 申请书网评意见至少为三份，最多四份。排名前12%（大体如此，分成两种情况）的为A类项目，12%到35%的为B类项目，其他为C类项目。项目分级和是否上会讨论，由计算机自动给出，并没有人为干预。
    - 所有的项目根据网络评审意见自动分级，根据每一个项目的评审意见，给予相应分值。比如，优先资助4分，资助3分，不予资助-3分，最后按照公式自动计算每一个项目的得分。综合评分=（A*4+B*3+C*2+D*1）/ 评议份数，资助建议=（A*4+B*2）/ 评议份数
3. 基金委选择专家组成，进行各学科的会评（二评）。所有的项目都要进行表决，表决过半的项目才能给予资助。
    - 会评的重点就是决定哪些A类项目有没有异常，哪些B类项目应该得到资助。
    - 如果有会评专家认为每个落选的项目非常好，那么他也是可以提出将这份申请书上会评议的。这个时候，他需要写出意见，并约另外一名专家推荐并上网公示。
    ![函评结果和获得资助的相关性](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fxfpp54etsj20rs0kujua.jpg)
    - 在当年有三位评委的时候，没有不同意资助的本子（3A、2A1B、1A2B、3B）百分之百要推荐上会的。评审意见有较大冲突，但正面意见为主的本子（2A1C）的本子也基本上是百分之百的被推荐上会了。有一些不好也不坏的本子（1A1B1C）也有机会被推荐上会。从评审结果看，绝大部分3A的本子能够拿到项目，2A1C的本子拿到项目的比例也不小，相反是平庸的本子（3B）在评审中最危险，仅有70%的本子能够拿到项目。

面上项目：总分大于5.5分的项目上会,上会率一般为30%。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190529182456.png)

青年项目：总分大于5分的项目上会,上会率一般为30%

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190529182520.png)

会评结果不容乐观的5种情况[^1181382]：

1. 个别创新点重复，如果有意见明确指出了可能与申请书创新点重复的文献，会评一般难以通过；
1. 申请人在某些可疑的杂志上刊登论文，被网评意见指出，基本不会通过。所以建议朋友们投稿时一定要谨慎，不要投机取巧。
1. 有些创新点被指出不可行，并给出明确意见，不会通过。如果评审给出一些非常专业而具体的意见，比如明确指出了技术路线的不可行，只要出现这样的很硬的负面意见，该项目即便打分较高，也可能不予资助。
1. 争议比较大，多数网评中的负面意见具体详细，一般不会通过。有些项目虽然网评分数较高，有上会资格，但如果出现集中具体的负面意见，也可能得不到资助。
1. 部分内容缺失，如技术路线、可行性分析等缺失情况严重。很多基金申请人的基础较好，课题也是比较热门的课题，但是申请书撰写的不够严谨，缺少必要部分，特别是技术路线不详细，可行性论证不扎实，这些都算是申请书的硬伤，如果出现这种情况，得不到资助的概率就偏大。

[^1181382]: [国自然函审结束，抢先了解上会标准](http://blog.sciencenet.cn/home.php?mod=space&uid=475824&do=blog&id=1181382)

# 基金检索

国家自然科学基金官网提供了 [结题报告检索](http://output.nsfc.gov.cn/projectQuery) 的功能，可以结合 [NSFC_conclusion_downloader](https://github.com/Rhilip/NSFC_conclusion_downloader/releases) 实现PDF文件的下载。

1. 下载 `nsfc_conclusion_downloader.zip`，并解压。
1. 在 [国家自然科学基金查询系统-medsci](https://www.medsci.cn/sci/nsfc.do) 获取项目信息，在 [结题报告检索](http://output.nsfc.gov.cn/projectQuery) 页面检索得到对应的项目，并复制相关项目网址。
1. 复制到软件地址栏，点击下载，完成后自动打开生成的PDF文件（存储在本程序放置的根目录）。

# 基金书写

> [高质量国基金申请书的必备要素](https://mp.weixin.qq.com/s/DDJ5xl-cQdgJkBBrZL2uoA)，[2021年国家自然科学基金NSFC标书撰写要点详述](https://mp.weixin.qq.com/s/-4N0t6kEhAmwqJgOnvSvgg)

用以自己熟悉的方式，说清楚四个问题，最为关键。

- 1）为什么要做这个事情，这就是**立项依据**；
- 2）做些什么事情可以解决你提出来的科学问题，实现预期目标，这就是**研究内容**；
- 3）如何去做这些事情，这就是**技术路线和研究方法**；
- 4）**为什么我能做这个事情**，这就是**研究基础**。

一个好的申请书必须在上述四者间建立一条**完整的逻辑链**，做到环环相扣。研究内容支撑立项依据，研究方法和技术路线服务于研究内容，已有的基础保证项目成功的可靠性。

总体原则：

- 消除所有的低级错误。
- 通读性。专有名词和概念解释清楚，让大同行看懂。小同行认为有水平。
    - 通读性。一方面要尽量少用那些特别难理解的专业术语，一方面要努力拓宽自身的专业知识面，使自己能在更宽的学术视野中描绘自己研究工作的科学意义，以更好地说服那些大同行。
- 一定还要注意各部分之间的**合理衔接**。科学问题、研究内容、技术路线、研究基础、研究队伍和经费预算等各方面，应当思路连贯、互相支撑。例如，研究内容中欲开展某方面的工作，在技术路线中应有相应的具体实施方案（使用仪器设备、实验流程和达到的技术指标等），而在研究队伍中，就应有相关的人员分工该项工作，而经费预算中也需列入相关的开支。
- 立项依据和研究方案中涉及到的要素、核心内涵及其价值必须给予足够**坚实和充分的论述**。在提出新思路、新想法之后，论述过程演进的逻辑线必须是连续的，不能有破点，论据必须是坚固的，不能有断点；方案的制订能够体现针对性、整体性、完整性，思路上的独到性和可行性，还要特别注意技术上的细节是否能够支撑得起整个方案，不要因小失大而留下遗憾。
- 可以利用“其他需要说明的问题”这个栏目答复一下评审人的评审意见，但是这个答复必须是心平气和，有理有据的。

## 选题

申请基金之前，申请人需得把大量时间花在课题调研、构思和学术积累上。

> [国家自然科学基金委各科学部优先发展领域及主要研究方向-2020](https://mp.weixin.qq.com/s/k_Ott0nqTfxcrtrUbVYk6A)

如何选题，选择什么题目，开展什么研究是来自科研人员自己的学术积累、经验和兴趣，要靠自己通过大量阅读文献结合自己从研究去领悟和选择。千万注意要避开“大牛的研究方向”，一来容易撞车，二来在比较中落后(原因自明)。再者，选题属于当前的热点，有一定积累为佳。

- 务必认真阅读基金申请指南。
- 查阅以往资助的《资助项目汇编》，避免重复。
- 没有人做过的课题不能做为立项的依据，但NSFC资助的项目必须是国际上没人做过的，而不是国内空白。
- <font color=red>提倡面向“小而精”的科学问题</font>。建议理顺下思路，找出个可行的、小的、且是瓶颈的科学问题开展研究，方能说服评审专家。
- 选题不能太窄，太小，自然科学的选题要有一定科学意义，要尽可能地去**接近国际前沿**，要有一定的挑战性，要敢于去选择那些有一定难度和关注度比较大的科学问题去研究。
- 选题最好以问题为导向，不要以技术为导向，找到问题了，课题就找到了。好课题是对学科深刻理解的条件下产生的，大量翻阅文献吧，汲取知识的同时千万别忘了思考，你发现别人存在漏洞的时候，好课题就离你不远了。
- 一定要到NSFC检索一下类似课题的历年资助情况，太多、太少都不好，最好是最近二年逐渐增加的资助领域。
- 问自己以下几个问题：1）拟申请项目的核心科学问题是什么？2）解决这个问题的意义何在？3）你要做的问题，是否有同行（国内外）在做？如果在做，做到什么程度，已经解决什么样的问题，还有什么问题没有解决？
- 有针对性的准备工作：
    - 1）做一点预研究，试试自己想法的可行性，找找实验的难点，获得一点初步的结果，这样在基金的申请书中对问题的阐述会更加深刻和准确。
    - 2）收集必要的材料和样品，
    - 3）学术思想和科学假说是基金申请书的核心和闪光点，如果能够在申请基金前写一篇综述文章，把自己的假说和观点也展示出来，然后在申请书中引用这篇文献，这样你的观点更容易被评审人所接受。

## 简表部分

题目、中英文摘要、申请人及团队，就是你给评审人的第一印象。

- 项目名称要确切、醒目，主题明了，让别人一看题目就能明了你干哪方面的具体研究，对象是什么，用什么研究方法，解决什么具体问题。
    - 申请题目要力求简短，有学术高度且适度。将关键词进行有序和合乎逻辑的组合，用最少的文字表达最重要和最清晰的信息。
    - 没有必要在题目中加上基础研究或应用基础研究等修饰字样，
- 报送学科要准确，勿将学科代码当指南。
    - 如果你的申请内容涉及多个学科，你就要比较各相关学科的项目指南，看一看你的研究重点与哪个学科更接近
- 项目属性应明确，科学基金不支持应用开发。
- **务必写好400个字摘要**，项目的科学意义（立项依据，科学问题，150字）；研究内容与拟采用的方法（150字）；预期结果（100字）。
    - 摘要通常有7个句子，分别描述不同的内容。其中1个句子描述背景、1个句子描述研究现状、1-2个句子描述科学问题、2-3个句子描述研究内容及技术方法、1个句子描述结果、结论及意义（落脚到特定对象）。即针对特定对象，体现特色。
    - 让别人可以看明白申请项目研究的对象是什么，采用什么研究方法，准备解决什么关键性的科学问题等等。高度浓缩地回答为什么、做什么、怎么做及本工作意义等问题。
    - 不建议使用语气连接词，多使用定语，逻辑紧密，一气呵成。
- 通常5个关键词中可能有2（或3）个描述科学问题，1个描述研究内容，1个描述技术方法，1个描述预期结果和意义。另外，关键词要依照关键词的内涵及逻辑关系进行排列。
- 项目组主要成员。
    - 要注意培养自己较为稳定的科研团队，为施展你的科研才华奠定人力资源基础。一个好的科研团队应该是：除了研究生，其他成员具有较好的学术经历（基础）和一定成果显示；学科结构合理（尤其对于涉及多学科交叉团队）；年龄结构合理（以中青年为主）；学缘结构较好。
    - 尽早建立研究团队，就相关问题开始合作研究，并商议确定主要研究课题。
    - 成员避免出现超项申请问题
    - 研究队伍的组成合理。组成不能太少，**只谈科研的身份**，每项内容都应该有相关研究背景的人员负责。
    - 在基金申请书完成之后，应该将申请书送给每位参与人阅读，获得项目组成员的认可，同时要求每位项目组成员在申请书上**亲笔签名**。实在是拿不准电话请教基金委的管理人员。


## 科学问题属性

> [国家自然科学基金委发布八大学部四类科学问题83个典型案例](https://mp.weixin.qq.com/s/7chuiIlS3m8ULZyQXG44Qw)，[国家自然科学基金委更新四类科学问题属性案例（2021版）](https://mp.weixin.qq.com/s/GDMHAUgakfDYmgt3ITbKRQ)

> 摘录于火行的文章“[到底800字科学问题属性怎么写？](https://mp.weixin.qq.com/s/DoccQKi7JHg7JEpJ2G_GAw)”

科学问题属性指的是：“鼓励探索，突出原创”、“聚焦前沿，独辟蹊径”、“需求牵引，突破瓶颈”、“共性导向，交叉共融” 这四个属性。同时这个四点属性，更像是：（1）纯原创 （2）再创新 （3）应用型（4）跨界型。

第一类（鼓励探索，突出原创）：那么就说明相关的课题是纯原创，目前均未做过或实现过，重点落在从无到有表述上；

第二类（聚焦前沿、独辟蹊径）：这块要说明当下前沿研究有哪些欠缺或者需要优化，申请人的想法比已有的突破、拓展在哪里；

第三类（需求牵引，突破瓶颈）：这个要着重说明研究内容符合实际国家需求且应具体产业化前景，但目前的效能并未得到解决，而申请人的研究成果可能会有效地促进相关产业、技术迭代等；

第四类（共性导向，交叉融通）：表述上要着重阐明自己的研究是在相关学科内的理念、技术下通过一定程度的交叉，解决共同的需求导向问题，且相应的融合会促进知识体系的发展与延伸。

假设项目研究是在再创新，是对于相应技术的优化创新，同时我的文章代表作，相应的研究基础，支撑申报的材料都更偏向于基础研究类型，这里比较符合选第二个。在回答的具体操作上，要阐明：为什么我觉得这个课题是前沿的，你的依据什么，与最前沿的相关性多大，同时也要着重说明自己的研究内容是偏应用还是基础。

举例，项目属性适合“聚焦前沿、独辟蹊径”，假设研究内容是：机器翻译（下列分布、字数，来源等仅供参考）

（1）简明扼要的讲清研究主体前沿、热点、已有研究成果（国内外研究摘选100字左右，这部分是为了后边凸显你的再创新）；
（2）然后对比性的论述目前研究的欠缺或者亟待优化的点：技术、对象等？（摘选创新点，100字左右）；
（3）具体的实现的意义：相应的算法、技术识别仍有提升空间包括但不限于优化、缺陷、拓展等 （着重落笔，整合技术路线、可行性、关键科学问题等；备注：需求产业化的，要说明对于实际产业界有什么预期经济效益，400字左右）；
（4）当前的工作，与自己的背景是偏向于基础研究还是应用需求（这部分务必点明一下，尽可能的说清自己的情况，这部分依据自己的个人简历背景，支撑材料情况，50字左右）；
（5）总结性概况，你解决了什么科学问题，点一下属性(70字左右）。


## 立项依据与研究内容

凝练、明确的、新颖的、吸引人的、科学的、有逻辑地、技术路线的清晰性、排列的规整性、布局的合理性

### 立项依据

> [科学基金申请：如何写好立项依据和研究方案](http://blog.sciencenet.cn/blog-38899-1088051.html)

项目的立项依据包括研究意义、国内外研究现状及发展动态分析，需结合科学研究发展趋势来论述科学意义；或结合国民经济和社会发展中迫切需要解决的关键科技问题来论述其应用前景。附主要参考文献目录。

研究者需明确拟开展的研究究竟是个什么样的问题（what），为什么要研究它（why），从何处入手（where），有什么对策、如何破解（how），谁来做最合适（who）。使审稿人明确课题的科学问题、研究假说、研究思路及科学意义，并赞同选题的创新性、科学性、可行性和重要性。

1. 为什么值得做？研究意义，应用价值和前景。以说明这个科学问题是必须突破而尚没有解决的瓶颈问题为论证的主线。是否会对所在领域做出新的贡献？是否会增进所在领域的知识？是否有明确的研究目的和长远的目标？
    - 简要地以科学研究发展和国民经济、社会发展为背景，点出本课题的理论价值和潜在的应用价值。
    - 要学会勤于观察和思考，深度挖掘藏在表象背后的本质，发现和理解事物之间的关联和区别，
	- 有效凸显：① 领域/行业重要性—>② 现状及问题—>③ 解决以上问题的意义这三点一线的脉络，需高度凝练。在意义上建议重点突出：① 社会效应、② 学科发展、③ 方向引领以及④ 科学普适贡献等方面；
1. 别人做的如何？围绕针对的对象，国内外研究现状、发展动态、及分析，提出问题。
    - 以问题为导向，高屋建瓴且精炼地归纳已有的发现和贡献（已解决的问题，既往研究背景），指出研究的缺失以及尚未解决的关键科学问题（本项目的科学研究目标）。
        - 认真调研研究方向的历史沿革，客观认真地评述同行成果（汇总前言、评论内容），并在此基础上提出项目选题。
        - 国外动态，国内研究情况，应包括申请者自己的研究工作，最好事先发表相应的综述文章。
        - 特别是**近五年**的国内外研究进展，突出前沿和热点
        - 建议分成若干个方面分别阐述，做到重点突出，归纳而不罗列。
        - 引用有争议的材料，务必确保对产生该争议的原因有所了解。并要直接阐明观点的不同之处。
    - 展开论述申请人是如何认识和理解这个问题的（有什么理由做这个）。把研究的问题所涉及因素的本质和因素之间的关系梳理清楚。
1. 你要解决哪个科学问题，有何创新。
    - 解决该问题的新想法，准备用什么方法研究什么、有望解决什么问题、有什么重要的意义和价值。落脚到对象和普适性，对应于研究内容。
        - 研究思路是要陈述申请者解决科学问题和验证研究假说的研究线路框架，体现出申请者对如何解决科学问题的一个致密的思考过程。
1. 为什么我们最适合做？证明自己是项目的最佳实施者
    - 简述申请人团队的研究优势，对于一些竞争性项目这一点尤其重要，似乎“非我莫属”，或者我的团队是目前这个方向做的相对最好。
    - 申请人在这个领域做过哪些工作？取得什么重要结果？
        - 如果我们把一个项目的整个研究内容划作100%，前期工作基础应该要完成了30-50%。
        - 论述预研的来龙去脉，如何思考的，并在预实验的基础上提出“研究假说”。不但提出的科研思路更可行，而且研究方案更符合实际、更形象，也显得申请人更有自信。
        - 相关的**前期工作**，展示出初步的实验数据、图表。可视化的表达会吸引评阅人的眼球。
1. 参考文献。
    - 直接相关的文献、国内同行的文献、**权威性文献**、**前沿性文献**、**顶级期刊**。中文文献占比1/3。
    - 考虑是否每个观点都值得引用，考虑是否每篇论文都需要被引用
    - 说明背景时引用少量的综述
    - 众人皆知的事实没有必要做大量的引证，与项目相关性不大的话题没有必要做大量的引证，

立项依据要紧紧围绕着**关键科学问题的提出、分析和解决**的主线进行写作。从简要的研究背景介绍，自然的过渡到项目要解决的重要科学问题，以及针对该科学问题开展的前期工作基础是否支持科学问题可行，在此基础上还存在哪些小的科学问题（或者说需要进一步深入的研究细节）需要提出本项目继续开展研究。

**按照研究内容设置段落数**，如果有3个内容，立项依据有5段。第一段，总括表述研究的意义，2-4段分别对应3个研究内容进行阐述，5段总结提出科学问题/科学假设。

通过已有的文献和自己的想法结合，引出研究思路。比如，某因子A对某通路B的影响，可能是直接的，也可能是涉及中间某些其他因子C，从而起作用。需要理顺的是：① A与B的研究现状如何，和自己的研究对象有没有新意的地方，从而建立研究目标一；② A与C是否有关联，如果有，具有什么样的关联，并且A与C是否可以对B产生影响，这些都是需要明确现状，引出可能的研究思路。在明确上面的研究背景和可能性的推测之后，就是后面的思路整理，细节打磨了。

### 研究内容、研究目标以及拟解决的关键问题

项目的研究内容、研究目标，以及拟解决的关键科学问题是申请书应该重点阐述的内容。推荐的撰写模式是先目标后内容的描述，使研究目标、内容、方案、技术路线这一系列内容的撰写符合由简到繁的**逻辑关系**（形成塔形结构）。

- 科学问题体现的是内涵，名词表达；
- 研究目标体现的是关键问题的解决，动宾结构，是成果体现但不涉及具体工作；
- 研究内容体现是的具体的工作，包括实验、测试、分析、模拟、推导等过程的描述，可以有各自的小目标，但是不能体现大的研究目标；

比如科技园的建设项目立项：

- 终极使命：河南理工大学高质量发展中科研能力系统提升模式（名词形式的表达，是所有工作需要解决的背后深层次问题）；
- 核心任务：形成特色创新团队；打造优势平台；突破国家人才（科学构架，动宾结构，关键成果）；
- 具体工作：成立分析测试中心；建立人才孵化环境；搭建平台培育基地；聚合优势研究力量；引入科研奖惩制度；制定分配资源补给动态（具体工作及过程）。

#### 研究目标

研究目标指这个项目最终要达到的目的（解决的问题）和基本要求，要清晰地显示项目预期成果及其意义，并从逻辑上详细阐明清楚。

> 针对某一个选定的体系，围绕着什么关键科学问题，用什么方法开展研究，准备理清什么规律，揭示什么机理，解决什么科学问题和学术性问题。

一般研究目标最好为一段精辟的、宏观的用专业术语表达的文字，而不具体分点。对于某些规模较大项目，研究目标也可以分成几点：理论方面要达到什么目的（建立了...）；应用方面要达到的要求（解决了...）；涉及研发类型的方法技术方面要达到的指标等。

- 只写研究目标，不用再重复研究意义、研究方法
- 研究目标不能过大，也不能“虚”，而要适中（可实现）、简洁明了（实实在在）。体现特色。
- 正确处理“抽象”与“实体”内容之间关系。
- 同研究内容一致，一项研究内容，必定对应一项研究目标。


#### 研究内容

设计研究内容应当**紧密围绕**项目选题中的科学问题或关键技术问题，组织设计具体、细化的研究框架。不仅写“做什么”，更应该写出“怎么研究”及“具体的研究思路”。

- 注意研究内容与研究方案、研究目标的**一致性原则**
- 不要再重复研究意义，不需要写研究方法，也不用写预期得到什么成果。
- 面面俱到，既要避免小题大致，也要避免大题小做。
- 针对解决关键的科学问题，把研究内容分为几个组成部分，适当的展开以及详细的描述，表达这个内容的特色及与项目核心内容关联。
    - 一个基金面上项目只要求解决一两个科学问题，3～5个方面的内容应该足够了。不等于科研工作的整体规划，避免内容过多。
    - 把捏好前期研究基础与研究内容的关系
    - 层层深入，突出重点。建议分层次、分标题、分点罗列，同时注意**逻辑关系**
        - 不要写成平行的子课题
        - 是否是解决科学问题的最佳选择，是否足以解决提出的科学问题，是否可行和能否完成，是否具有创新性
- 描述明确、言之有物。对于某些专业词汇，必须要详细的描述。
- 研究结果要有力度，不要泛泛的，什么都做。

#### 拟解决的关键科学问题

拟解决的关键科学问题是项目申请书的核心所在，必然具有一定的深度。对于拟解决的关键问题和技术瓶颈要有清晰的认识，抓准要研究的1～3个关键问题，设想好解决步骤。

> [关键科学问题的内涵是什么呢](http://blog.sciencenet.cn/home.php?mod=space&uid=575926&do=blog&id=1164670)？在我看来，得满足：（1）若向前推进一步或解决之，有重要意义；（2）属于制约某具体学科领域科学发展的“瓶颈”问题，一旦找到正确的“突破口”或开启“那把锁”的“钥匙”，则势若破竹，能深入揭示隐藏在“黑暗”中的自然现象演化奥秘。虽然自然现象的演化受多种因素影响，但往往“万变不离其宗”，找到了这个“宗”，就等于找到了“突破口”或“钥匙”。

- 拟解决的关键问题指项目的关键、难点之所在。针对具体对象，阐述为什么难，克服之后其他问题迎刃而解。
- 表观的实验现象并不是关键科学问题
- 力求写得清楚、准确，反复推敲、仔细提炼，鲜明地亮出来。
- 科学问题一般用不太长的一句话表示较好。
- 不要与解决的若干具体问题混淆。具体问题一般是由围绕科学问题延伸出来一个或几个组成，且相互之间具有逻辑关系。
- 所以需要在随后的研究方案部分给出解决关键问题的方案和对方案思路的可行性分析。

### 拟采取的研究方案及可行性分析

#### 拟采取的研究方案

撰写研究方案应围绕研究内容（紧扣研究内容），聚焦关键科学问题（能圆满解答关键科学问题），以清晰的研究思路（指导思想），从研究方法、技术路线、实验手段、关键技术等方面，详述步骤、高招、窍门、可行性等。

申请人需要对方案的**总体设想和具体细节**两方面都要有所把握。充分体现务实态度和切实可行性。

- 洞察到研究的命门所在，并给出方案对策（针对性要强）；
- **要体现独一无二的特性**，不能让评议人读起来感觉张三的研究能用，李四的研究也能用，从而失去了研究方案的应有独特价值。
- 研究方法、技术路线、实验方案之间逻辑关系明确，一环扣一环。
- 具体技术细节的把握则重在高招、窍门和另辟蹊径；
- 条理清晰、层次分明、突出主干，图文并茂（淡雅、整洁、大方）。使评审人确信申请人知道该如何开展研究，并且已经准备好开展研究。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20210312130217.png)
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20210312130244.png)

**研究方案和研究内容对应**。拟采取的研究方案比研究内容**更加具体**，类似于科研论文的实验部分，但比科研论文的实验部分更加笼统（没那么细），涵盖的工作量也更大。

- 拟采用的研究方法是否正确和新颖？
- 技术路线是将研究方案细化，与研究方能否保证目标的实现？案密切相关，其实有时两者合在一起。它是具体实施采用的方法步骤细节（分析测试，计统分析，计算模拟等），
    - 通常用文字和框图表示，可以很好展示研究路线中的层次关系。
    - 要注意设计研究路线时步骤的分级和层次之间的逻辑关系，一环扣一环。
- 实验手段。
    - 对于实验过程中所涉及的细节也需要深思熟虑
- 关键技术属于达到研究目标，完成设定的研究内容时需要使用的若干研究方法技术中相对最为重要的技术，或属于要达到目标的某些“技术瓶颈”。
    - 要注意若干个关键技术之间的逻辑关系（主次和重要性），分清楚层次关系。

#### 可行性分析

可行性分析可以从理论可行、方法可行、实验室保障、人员保障主要4个方面介绍。项目的可行性分析要有论点、论据和论证，阐明你的设计方案、研究方法、技术路线能否实现预期的研究目标。

项目可行性大致由两部分组成：

- 项目本身可行性，多从学术思路角度进行论证
    - 阐述立项依据是否充分，
    - 科学问题是否准确可靠可行，
    - 是否具有相关基础；
        - 列举申请人的初步实验结果，则能证明实验方案在实际上是可行的。
    - 通过引用、分析别人或者申请人的文献并结合理论推导，来证明实验思路在理论上是可行的。
- 实施条件可行性
    - 申请人和团队的软硬件条件的可行性，不能过度依赖外部条件。
    - 研究队伍、研究条件和学术思想方面的综合优势

### 特色与创新之处

创新点应在充分查阅文献资料的基础上提出，<font color=red>认真思考、仔细鉴别、深入挖掘</font>课题的区别、特色和创新性，切记不要想当然。

客观实际的将创新归并到如下几类：理论创新、方法创新、应用创新、集成创新。主要集中于方法的创新、理论的创新和预期结果的创新，主要体现在“选题”和“研究方法路线”两方面，强调“科学性”（学术性）方面的创新或“应用价值”方面的创新性。

- 创新点是动宾结构；
- 创新点实事求是，否则会失去真实性，或被认为实施困难。
- 避免用“填补空白、首次，率先”等词汇，填补国内外空白不是特色与创新。
- 不需要洋洋洒洒写一大堆文字，直接把项目的研究特色和创新点说出来。
- 如果属于学科交叉项目，必须阐明交叉点在哪儿。
- 用词客观。既要体现项目相对目前同行研究的类似项目有点进步，体现“站在前人肩膀上”，但也不能为了抬高自己贬低别人。

### 年度研究计划及预期研究结果

#### 年度研究计划

年度研究计划是指列出在每年度拟开展的实验、数据分析、论文撰写、国际合作和学术交流等工作。

- 这要与项目的研究内容和研究方案一致，并且注意不同研究板块的先后顺序和合理分布，不应出现新的工作，也不能遗漏前面已经列出的重要工作。
- 要尽量具体一点，要留有余地，便于评审专家了解申请人安排的研究进度是否合理。
- 表述需要一目了然，最好能一条一条地罗列。
- 在时间的分段方面，不宜太长，也不宜太短。应充分规划每一部分研究内容可能花费的时间，做到合情合理。

#### 预期研究结果

预期研究结果通常分成两部分描述：

- 预期研究结果则要与研究目标吻合，即针对某关键科学问题，用什么方法开展什么研究，预期能理清什么规律，阐明什么机理，解决什么问题，并预期在本学科主流刊物发表相关的（哪方面的）论文篇数。
- 预期研究结果要有力度，有数量，更重质量。

## 研究基础与工作条件

### 研究基础

研究基础是指与本项目相关的研究工作积累和已取得的研究工作成绩。展示自己在相关研究领域以及在这个课题上的学术积累，指出学术研究思路，证明自己在该领域开展了大量系统研究，发表了系列论文（并且这些论文得到同行的正面引用），在国际学术会议作了邀请报告，有能力做好申请的课题，即要回答“为何我能做”。

没有研究基础，可以通过这一部分的适当阐述获得基础。比如，我申请方向没有已发表成果，那我就要找在这方面发表成果的学者作为我的参与者。

- 不要和立项依据部分介绍申请人前期工作的段落重复，而要根据不同部分的功能和具体的语境调整表述方法和简略程度。
- 申请人简历包括申请者和项目组主要成员的学历和研究工作简历，近期已发表与**本项目有关的**主要论著和获得学术奖励情况，及在本项目中承担的任务。
    - 要有目的地凝练，不相关的论文可以不提
- 尤其对于重点基金项目需要认真总结整个团队成员成果基础上，逻辑性地阐明这些基础与本项目之间关系。让评审人看到这个团队成员学科分布较为合理，年龄结构合理，成员学术经历较好，成果有特色，整体处在国内同行中的先进行列。

### 工作条件

工作条件包括已具备的实验条件，尚缺少的实验条件和拟解决的途径，包括利用国家实验室、国家重点实验室和部门重点实验室等研究基地的计划与落实情况。

工作条件涉及软硬件条件：

- 软件条件涉及申请人团队的学术条件，例如国内外合作条件等。
- 硬件条件主要为分析仪器和计算平台两大类。最好能依托相关国家实验室、重点实验室和工程中心研究基地。那样一方面显示项目研究平台优秀，另一方面也表明这些国家平台发挥了作用，是一个双赢表现。
    - 需要根据研究方案部分涉及的主要仪器列出个清单，指出哪些仪器是申请人实验室拥有的，哪些是可以在公共研究平台使用的（都需要列出仪器型号），而哪些是准备添置的。这样就会让评审人感到一目了然。

### 正在承担的与本项目相关的科研项目情况

正在承担的与本项目相关的科研项目情况是指申请人正在承担的与本项目相关的科研项目情况，包括国家自然科学基金的项目和国家其他科技计划项目，要注明项目的名称和编号、经费来源、起止年月、与本项目的关系及负责的内容等。

- 介绍时要注明项目的名称和编号、经费来源、起止年月、与本项目的关系及负责的内容等。这将有助于评审人判断申请人是否有执行项目的经历，并判断申请课题和正在承担课题的相关性。
    - 但如果申请人申请的课题和他/她正在承担的课题过于类似，那么评审人有可能会建议申请人先完成他/她正在承担的课题再申请新的课题。
- 最好能注明获得什么奖励，发表多少论文，引用情况如何，培养了几名研究生，研究生的现状等等。

### 完成国家自然科学基金项目情况

完成国家自然科学基金项目情况是指对申请人负责的前一个已结题科学基金项目（项目名称及批准号）完成情况、后续研究进展及与本申请项目的关系加以详细说明。另附该已结题项目研究工作总结摘要（限500字）和相关成果的详细目录。这将有助于评审人判断申请人负责的前一个已结题科学基金项目是否达到了预期的效果，以此来预测申请人这次如果获得资助，能否取得预期的成绩。

一方面，研究者应执行好每一个获批的自然科学基金项目，多出成果；另一方面，研究者应撰写好结题报告，包括工作总结摘要。

## 经费预算

- 认真编撰经费预算。在申请项目时，就要在预算上多花一点时间，做一个真正执行的预算。
- 除了常规经费（旅差费，材料费，燃料费，分析测试和计算经费及少量设备费，出版费等），要重视学术交流项目经费的预算（在政策允许前提下留足）。
    - 例如团队成员，包括研究生参加国内外学术活动和邀请国际同行访问经费。这些活动对于确保项目产出高水平成果非常重要。


# 人才计划

人才计划分国家的、部委的、地方的等几个级别。国家的嘛，主要是青年千人（小千人）、千人计划（大千人）、百人计划、长江、杰青、优青、新世纪人才等等。地方上还会有一些省市级的杰出青年、学术带头人、某某人才、某某学者。

- 青年千人申请40周岁；国家优秀青年基金男38周岁、女40周岁；万人计划青年拔尖人才自然、工程男35周岁女37周岁；青年长江自然、工程38周岁，人文社科45周岁；国家杰出青年基金 45周岁

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>科研经验</tag>
        <tag>基金</tag>
      </tags>
  </entry>
  <entry>
    <title>在线学习</title>
    <url>/online-learning/</url>
    <content><![CDATA[
机器学习算法可以分成两类。离线学习和在线学习。在线机器学习指每次通过一个训练实例学习模型的学习方法。

<!--more-->

> Gama J, Žliobaitė I, Bifet A, et al. A survey on concept drift adaptation[J]. ACM computing surveys (CSUR), 2014, 46(4): 44.  
> Shalev-Shwartz S. Online learning and online convex optimization[J]. Foundations and Trends® in Machine Learning, 2012, 4(2): 107-194.  
> Žliobaitė I, Pechenizkiy M, Gama J. An overview of concept drift applications[M]//Big data analysis: new algorithms for a new society. Springer, Cham, 2016: 91-114.


> [A Gentle Introduction to Concept Drift in Machine Learning](https://machinelearningmastery.com/gentle-introduction-concept-drift-machine-learning/)

Concept Drift:

# 离线学习与在线学习

We can distinguish two learning modes: offline learning and online learning.

## 离线学习

In offline learning the whole training data must be available at the time of model training. Only when training is completed the model can be used for predicting.

不同理解方式：

- 也称批量学习（batch learning）：一个batch训练完才更新权重，这样的话要求所有的数据必须在每一个训练操作中（batch中）都是可用的，这样不会因为偶然的错误把网络带向极端。在监督学习的批量方法中，多层感知器的突出权值的调整在训练样本集合的所有N个例子都出现后进行，这构成了训练的一个回合。换句话说，批量学习的代价函数是由平均误差能量定义的。多层感知器的突触权值的调整是以回合-回合为基础的。相应地，学习曲线的一种实现方式是通过描绘平均误差能量对回合数的图形而得到，对于训练的每一个回合，训练样本集合的样例是随机选取的。学习曲线通过对足够大量的这样实现的总体平均来计算，这里每次实现是在随机选取不同初始条件下完成的。这一特点符合交叉验证的规律，实验中的实验集、验证集、测试集一般都是批量处理的典例。
    - 只有训练完成了之后，模型才能被拿来用。简而言之，先训练，再用模型，不训练完就不用模型。
- 你有一个样本，你把第一条带入训练，调整权重，然后带入下一条，直至跑完整个样本，这个时候的误差率可能不让你满意，于是你把整个样本又做了上述操作，直到误差很小。
    ```
    initialize all weights to random value
    repeat:
      for t in training_set:
        compute train_error for t
        adjust weights base on train_error
    until error rate is very small or error rate variation stops
    ```

优点：

1. 消除样本顺序的影响
1. 对梯度向量的精确估计，因此，在简单条件下，保证了这一方法最速下降到局部极小点的收敛性。
1. 学习的并行性。

缺点：

1. 有着存储需求


## 在线学习

不同理解方式：

- online and batch learning：在线算法按照顺序处理数据，一个数据点训练完了直接更新权重。它们产生一个模型，并在把这个模型放入实际操作中，而不需要在一开始就提供完整的训练数据集。随着更多的实时数据到达，模型会在操作中不断地更新。In contrast, online algorithms process data sequentially. They produce a model and put it in operation without having the complete training data set available at the beginning. The
model is continuously updated during operation as more training data arrives. Less restrictive than online algorithms are incremental algorithms that process input examples one by one (or batch by batch) and update the decision model after receiving each example. Incremental algorithms may have random access to previous examples or representative/selected examples. In such a case, these algorithms are called incremental algorithms with partial memory. Typically, in incremental algorithms, for any new presentation of data, the update operation of the model is based on the previous one. Streaming algorithms are online algorithms for processing high-speed continuous flows of data. In streaming, examples are processed sequentially as well and can be examined in only a few passes (typically just one). These algorithms use limited memory and limited processing time per item.
    - 通常来讲，一种Online learning算法对于一个序列进行一系列处理可以分为三步[^a-brief-talk-about-online-learning]：第一步，算法获得一个训练实例；第二步，算法预测训练实例的类别；第三步，算法获得正确类别，并根据预测类别与正确类别更新模型假设。
    - 我们无法得知这一次的更新权重是正确的还是错误的，如果恰恰是错误的一次更新，那么我们的模型会有可能渐渐地走向错误方向，残差出现。
- 你有一个样本，你把第一条带入训练，调整权重，再把这一条带进去一次，重复多次，直至误差率很小，然后再带入下一条，直至跑完整个样本。
    ```
    initialize all weights to random value
      for t in training_set:
        repeat:
        compute train_error for t
        adjust weights base on train_error
      until error rate is very small or error rate variation stops
    ```

[^a-brief-talk-about-online-learning]: [浅谈在线机器学习算法](http://yjliu.net/blog/2012/07/14/a-brief-talk-about-online-learning.html)

在监督学习的在线方法下，对于多层感知器突触权值的调整是以样例-样例为基础的，用来最小化的代价函数是全体瞬时误差能量。和批量学习一样，在线学习的学习曲线是通过足够大量的随机选取的初始条件上的总体平均来计算的。对于给定的网络结构，在线学习下获得的学习曲线和批量学习下获得的学习曲线有着很大的不同。

给定训练样本以随机的方式呈现给网络，在线学习的使用使得在多维权值空间中的搜索事实上是随机的；正是由于这个原因，在线学习方法有时被称为随机方法。

优点：

1. 容易执行
1. 对于大规模和困难模式分类问题它提供有效解。
1. 随机性使得不容易陷入局部极值点
1. 存储量少得多

# 增量式算法

增量式算法就是每当新增数据时，并不需要重建所有的知识库，而是在原有知识库的基础上，仅做由于新增数据所引起的更新，这更加符合人的思维原理。一个增量学习算法应同时具有以下特点：

- 可以从新数据中学习新知识；  
- 以前已经处理过的数据不需要重复处理；
- 每次只有一个训练观测样本被看到和学习；
- 学习新知识的同时能保存以前学习到的大部分知识；
- —旦学习完成后训练观测样本被丢弃；
- 学习系统没有关于整个训练样本的先验知识；

# 减量式算法

decremental learning，即抛弃“价值最低”的保留的训练样本。这两个概念在incremental and decremental svm这篇论文里面可以看到具体的操作过程。

> Cauwenberghs G, Poggio T. Incremental and decremental support vector machine learning[C]//Advances in neural information processing systems. 2001: 409-415.  
> Gâlmeanu H, Andonie R. Implementation issues of an incremental and decremental SVM[C]//International Conference on Artificial Neural Networks. Springer, Berlin, Heidelberg, 2008: 325-335.

# 实例

两种典型在线机器学习算法：Perceptron、MIRA，他们都属于线性分类算法族，它们具有相同的模型形式。在学习阶段，算法对于每个类别，通过训练数据估计一个参数向量w。在推理阶段，算法在给定一组参数向量w和数据x的条件下，以w和x的乘积作为数据与该类的相似度度量。

## 在线学习的二值分类

> [机器学习番外篇之在线学习(I):Online Learning与感知器](https://qingyuanxingsi.github.io/tag/perception.html)

假设样例按照到来的先后顺序依次定义为$((x^{(1)},y^{(1)}),(x^{(2)},y^{(2)}),\cdots,(x^{(m)},y^{(m)}))$。$X$为样本特征，$y$为类别标签。我们的任务是到来一个样例$x$，给出其类别结果$y$的预测值，之后我们会看到$y$的真实值，然后根据真实值来重新调整模型参数，整个过程是重复迭代的过程，直到所有的样例完成。

我们的假设函数为:

$$
\begin{equation} h_{\theta}(x) = g(\theta^T x) \end{equation}
$$

其中$x$是$n+1$维特征向量,最后一维为常量$1$，$\theta$是$n+1$维参数权重,最后一维表示Bias。函数$g$用来将$\theta^Tx$计算结果映射到$-1$和$1$上。具体公式如下：

$$
\begin{equation} \begin{split} g(z) = \left \lbrace \begin{array}{cc} 1 & \text{if} \ z \geq 0 \\ -1 & \text{if} \ z < 0 \end{array} \right. \end{split} \end{equation}
$$

这个也是logistic回归中$g$的简化形式。

现在我们提出一个在线学习算法如下：

新来一个样例$(x,y)$，我们先用从之前样例学习到的$h_{\theta}(x)$来得到样例的预测值$y$，如果$h_{\theta}(x) = y$（即预测正确），那么不改变$\theta$，反之

$$
\begin{equation} \theta := \theta + yx \end{equation}
$$

也就是说，如果对于预测错误的样例，$\theta$进行调整时只需加上（实际上为正例）或者减去（实际负例）样本特征$x$值即可。$\theta$初始值为向量0。这里我们关心的是$\theta^Tx$的符号，而不是它的具体值。调整方法非常简单。然而这个简单的调整方法还是很有效的，它的错误率不仅是有上界的，而且这个上界不依赖于样例数和特征维度。

下面定理阐述了**错误率上界**：

> 定理（Block and Novikoff）:
> 给定按照顺序到来的$(x^{(1)},y^{(1)}),(x^{(2)},y^{(2)},\cdots,(x^{(m)},y^{(m)}))$样例。假设对于所有的样例$||x^{(i)} \leq D$，也就是说特征向量长度有界为$D$。更进一步，假设存在一个单位长度向量$u$且$y^{(i)}(u^Tx^{(i)})\geq \gamma$。也就是说对于$y=1$的正例，$u^Tx^{(i)} \geq \gamma$，反例$u^Tx^{(i)} \leq -\gamma$，$u$能够有$\gamma$的间隔将正例和反例分开。那么感知算法的预测的错误样例数不超过$({D \over \gamma})^2$。

根据对SVM的理解，这个定理就可以阐述为：如果训练样本线性可分，并且几何间距至少是$\gamma$，样例样本特征向量最长为$D$，那么感知算法错误数不会超过$({D \over \gamma})^2$。这个定理是62年提出的，63年Vapnik提出SVM，可见提出也不是偶然的，感知算法也许是当时的热门。

<div class="note info"><p>定理证明</p></div>

感知算法只在样例预测错误时进行更新，定义$\theta^{(k)}$是第$k$次预测错误时使用的样本特征权重，$\theta^{(1)} = \vec{0}$ 初始化为$\vec{0}$向量。假设第$k$次预测错误发生在样例$(x^{(i)},y^{(i)})$上，利用$\theta^{(k)}$计算$y^{(i)}$值时得到的结果不正确。也就是说下面的公式成立：

$$
\begin{equation} (x^{(i)})^T\theta^{(k)}y^{(i)} \leq 0 \end{equation}
$$

根据感知算法的更新方法，我们有$\theta^{(k+1)} = \theta^{(k)} + y^{(i)}x^{(i)}$。这时候，两边都乘以$u$得到:

$$
\begin{equation} \begin{split} (\theta^{(k+1)})^Tu &= (\theta^{(k)})^u + y^{(i)}(x^{(i)})^Tu \\ &\geq (\theta^{(k)})^Tu + \gamma \end{split} \end{equation}
$$

这个式子是个递推公式，就像等差数列一样$f_{n+1}=f_n+d$。由此我们可得

$$
\begin{equation} (\theta^{(k+1)})^Tu \geq k\gamma \end{equation}
$$

因为初始$\theta$为$\vec{0}$。

下面我们利用前面推导出的$(x^{(i)})^T\theta^{(k)}y^{(i)} \leq 0$和$||x^{(i)}|| \leq D$得到

$$
\begin{equation} \begin{split} ||\theta^{(k+1)}||^2 &= ||\theta^{(k)} + y^{(i)}x^{(i)}||^2 \\ &= ||\theta^{k}||^2 + ||x^{(i)}||^2 + 2y^{(i)}(x^{(i)})^T\theta^{(i)} \\ &\leq ||\theta^{k}||^2 + ||x^{(i)}||^2 \\ &\leq ||\theta^{k}||^2 + D^2 \end{split} \end{equation}
$$

也就是说$\theta^{(k+1)}$的长度平方不会超过$\theta^{(k)}$与$D$的平方和。

又是一个等差不等式，得到：

$$
\begin{equation} ||\theta^{k+1}||^2 \leq kD^2 \end{equation}
$$

两边开根号得：

$$
\begin{equation} \begin{split} \sqrt{k}D & \geq ||\theta^{(k+1)}|| \\ & \geq (\theta^{(k+1)})^Tu \\ & \geq k\gamma \end{split} \end{equation}
$$

其中第二步可能有点迷惑，我们细想$u$是单位向量的话:

$$
\begin{equation} z^Tu = ||z||||u||cos \phi \leq ||z||||u|| \end{equation}
$$

因此上面的不等式成立，最后得到：

$$
\begin{equation} k \leq (D/\gamma)^2 \end{equation}
$$

也就是预测错误的数目不会超过样本特征向量$x$的最长长度除以几何间隔的平方。实际上整个调整过程中$\theta$就是$x$的线性组合。

# 代码资源

- [Shai Shalev-Shwartz](https://www.cs.huji.ac.il/~shais/)
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>OnlineLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>优化算法系列</title>
    <url>/optimization-algorithm/</url>
    <content><![CDATA[
优化技术是一种以数学为基础，用于求解各种工程问题优化解的应用技术。作为一个重要的科学分支，它一直受到人们的广泛重视，并在诸多工程领域得到迅速推广和应用，如系统控制、人工智能、模式识别、生产调度、VLSI技术和计算机工程等。

<!--more-->

梯度为基础的传统优化算法具有较高的计算效率、较强的可靠性、比较成熟等优点，是一类最重要的、应用最广泛的优化算法。但是，传统的最优化方法在应用于复杂、困难的优化问题时有较大的局限性。一个优化问题称为是复杂的，通常是指具有下列特征之一：（1）目标函数没有明确解析表达；（2）目标函数虽有明确表达，但不可能恰好估值；（3）目标函数为多峰函数；（4）目标函数有多个，即多目标优化。一个优化问题称为是困难的，通常是指：目标函数或约束条件不连续、不可微、高度非线性，或者问题本身是困难的组合问题。传统优化方法往往要求目标函数是凸的、连续可微的，可行域是凸集等条件，而且处理非确定性信息的能力较差。这些弱点使传统优化方法在解决许多实际问题时受到了限制。

鉴于实际工程问题的复杂性、约束性、非线性、多极小、建模困难等特点，寻求一种适合于大规模并行且具有智能特征的算法已成为有关学科的一个主要研究目标和引人注目的研究方向。

> [最优化计算课程总结](http://wulc.me/2017/02/01/%E6%9C%80%E4%BC%98%E5%8C%96%E8%AE%A1%E7%AE%97%E8%AF%BE%E7%A8%8B%E6%80%BB%E7%BB%93/)

# 爬山算法

爬山算法是一种简单的贪心搜索算法，该算法每次从当前解的临近解空间中选择一个最优解作为当前解，直到达到一个局部最优解。爬山算法实现很简单，其主要缺点是会陷入局部最优解，而不一定能搜索到全局最优解。

如图所示：假设C点为当前解，爬山算法搜索到A点这个局部最优解就会停止搜索，因为在A点无论向那个方向小幅度移动都不能得到更优的解。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fnf7kojxwrj30go0b4gli.jpg)

# 模拟退火

模拟退火[^1911614]其实也是一种贪心算法，但是它的搜索过程引入了随机因素。模拟退火算法以一定的概率来接受一个比当前解要差的解，因此有可能会跳出这个局部的最优解，达到全局的最优解。

[^1911614]: [大白话解析模拟退火算法](http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html)

以上图为例，模拟退火算法在搜索到局部最优解A后，会以一定的概率接受到E的移动。也许经过几次这样的不是局部最优的移动后会到达D点，于是就跳出了局部最大值A。

```
/*
* J(y)：在状态y时的评价函数值
* Y(i)：表示当前状态
* Y(i+1)：表示新的状态
* r： 用于控制降温的快慢
* T： 系统的温度，系统初始应该要处于一个高温的状态
* T_min ：温度的下限，若温度T达到T_min，则停止搜索
*/
while( T > T_min )
{
　　dE = J( Y(i+1) ) - J( Y(i) ) ;

　　if ( dE >=0 ) //表达移动后得到更优解，则总是接受移动
Y(i+1) = Y(i) ; //接受从Y(i)到Y(i+1)的移动
　　else
　　{
// 函数exp( dE/T )的取值范围是(0,1) ，dE/T越大，则exp( dE/T )也
if ( exp( dE/T ) > random( 0 , 1 ) )
Y(i+1) = Y(i) ; //接受从Y(i)到Y(i+1)的移动
　　}
　　T = r * T ; //降温退火 ，0<r<1 。r越大，降温越慢；r越小，降温越快
　　/*
　　* 若r过大，则搜索到全局最优解的可能会较高，但搜索的过程也就较长。若r过小，则搜索的过程会很快，但最终可能会达到一个局部最优值
　　*/
　　i ++ ;
}
```

# 遗传算法

遗传算法[^1914725]是模拟生物在自然环境中优胜劣汰、适者生存的遗传和进化过程而形成的一种具有自适应能力的，全局性的概率搜索算法。遗传算法将问题的每一个可能性解看作是群体中的一个个体（染色体），并将每一个染色体编码成串的形式，再根据预定的目标函数对每个个体进行评价，给出一个适应值。算法将根据适应度值进行它的寻优过程。遗传算法的寻优过程是通过选择、杂交和变异三个遗传算子来具体实现的。

[^1914725]: [遗传算法入门](http://www.cnblogs.com/heaad/archive/2010/12/23/1914725.html)

```
基本遗传算法伪代码

/*
* Pc：交叉发生的概率
* Pm：变异发生的概率
* M：种群规模
* G：终止进化的代数
* Tf：进化产生的任何一个个体的适应度函数超过Tf，则可以终止进化过程
*/
初始化Pm，Pc，M，G，Tf等参数。随机产生第一代种群Pop

do
{
　　计算种群Pop中每一个体的适应度F(i)。
　　初始化空种群newPop
　　do
　　{
　　　　根据适应度以比例选择算法从种群Pop中选出2个个体
　　　　if ( random ( 0 , 1 ) < Pc )
　　　　{
　　　　　　对2个个体按交叉概率Pc执行交叉操作
　　　　}
　　　　if ( random ( 0 , 1 ) < Pm )
　　　　{
　　　　　　对2个个体按变异概率Pm执行变异操作
　　　　}
将2个新个体加入种群newPop中
} until ( M个子代被创建 )
用newPop取代Pop
}until ( 任何染色体得分超过Tf， 或繁殖代数超过G )
```

优化遗传算法的性能：

- 精英主义(Elitist Strategy)选择：是基本遗传算法的一种优化。为了防止进化过程中产生的最优解被交叉和变异所破坏，可以将每一代中的最优解原封不动的复制到下一代中。
- 插入操作：可在3个基本操作的基础上增加一个插入操作。插入操作将染色体中的某个随机的片段移位到另一个随机的位置。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>OptimizationAlgorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>论文接收</title>
    <url>/paper-accepted/</url>
    <content><![CDATA[
经历过Under review，Minor revision/Major revision和Revision Submitted to Journal之后，Congratulations!享受accept后的小幸福和快乐。当然，还有一些其他事情需要关注。

<!--more-->

1. 了解稿件接受后期的其他相关问题主要有：作者信息和地址的准确性、版权转让、校样proof、单行本、版面费等。

2. 动态关注邮箱情况，注意查收邮件，编辑会要求尽快完善copyright transfer agreement的，后面的工作就会转给出版商了。清样proof的时间不定，短的一两周，长的半年都有，但一般情况下都是4~6周左右。后面还会陆续提及版面费（若你所投期刊免版面费除外）、彩图费、单行本等问题。

# 较样

> [审校英文论文校样的重点和关键](http://blog.sciencenet.cn/blog-4600-13085.html)

从接受到寄proof要说个特定时间还真不能确定，各个期刊出版社效率不一。较样（proof）是出版社寄的，由其负责，与杂志编辑无关。如果只是收到e-proof的话，应该是可以更改的，如果已经proof sent，肯定就不行了。但是必须给编辑和出版社足够的理由，证明更改是合理的，一般最好不要做这种事情。 只要不牵涉到学术不端，没有嫌疑，就和出版社说一下，一般情况多是接受小小修改的，修改只是说明你是一个很严谨的人，在校稿时候就是要作者发现错误，以便出版时候错误更少。但有的让改，有的不行。当然改动也是在一定范围内处理的，不是任何问题都能改。

文章在proof reading阶段，主要是看拼写错误、语法错误、参考文献错误等。涉及到文章的科学性，如数据、讨论等，一般是不能修改的，因为已经通过peer review了。proof的工作通常包括两个主要内容：（1）完成编辑部指出的问题，例如补充缩写的全称，补充试剂的产地，修改一些语法错误，同意或确认编辑部的少量修改等。（2）自己发现的需要更改的地方，例如错别字，标点符号错误等，要求作者列出一个勘错清单，标名位置及更改。校样阶段一般是不允许进行作者调整以及大量的正文内容的改动。通常校样要求作者在两个工作日内完成，否则有可能影响出版。**涉及文章数据的内容，如发现有误，应与杂志编辑联系，切误私自修改，否则后果严重**。

当通讯作者收到文章的proof（校样）后，可以修改作者信息、联系方式、增添作者、调换作者顺序、添加基金等，如果删除作者、调换作者，尤其是第一作者和通讯作者时，大多期刊编辑会要求提供变更说明并签字的证明。随proof附件的，大多期刊还有query和annotate文件（有的期刊没有annotate文件）。

Proof还有内容的修改，包括期刊编辑校对时给你的pdf标注，有的期刊没有pdf标注，直接将排版好的proof发给你校对。不管怎样，作者可以在编辑发给你的proof中直接进行修改错误的内容，一定要注意按照proof修改的要求进行删除、增添、批注等操作。没有annotate文件的，就按照pdf工具栏里的各个图标所表示的意思或功能进行操作，在proof中，为了区别排版编辑对你稿件的修改，作者修改proof时除了删除、增添、批注等操作外，还可以对这些删除、增添、批注等进行黄色加亮显示。修改好后，在文档文件名后加上`_corrected`字样，然后将附件回复到编辑邮箱，记得要提醒编辑收到后给你回信。

Query文档里，response的内容可以在下方填上（针对query，一条条列出修改页数和行数、修改内容和备注说明）；如果已经在proof中修改了（修改信息对Query进行了回答），可以在response里指出修改页和行数、备注说明。Query文档写好后打印传真给指定的传真号。同样，记得提醒编辑给你回信。


```
Dear Sir/Madam,

The attached document is the corrected proof. All corrections are highlighted in yellow. Please give me a reply when you receive the attachment. Thank you very much.
Best Regards,
Dongming Fang
```

```
Dear Editor,
Thank you for your useful comments and suggestions on the language and structure of our manuscript. We have modified the manuscript accordingly, and detailed corrections are listed below point by point:

1) Figures should be embedded in the article in the correct position. In addition, please supply separate source files for each figure at the end of the article.
We have revised the whole manuscript carefully, embedded Figures in the article in the correct position and supplied separate source files for each figure.

2) Graphical abstract provided should contain a short description (no more than 25-30 words) directly under the figure.
A short description of Graphical abstract have been added

.....

The manuscript has been resubmitted to your journal. We look forward to your positive response.

Thank you very much!

Please contact me by E-mail: ***  if there is any question.

Sincerely yours,
***
```

现在springer推出更方便的proof修改方法，就是e-proof，可以在线修改proof，当然这种在线修改proof方法其它一些出版社投稿系统也有，但springer的e-proof修改可以在线一边查看你的proof（和pdf一样，在窗口左栏），还可以一边进行正常的在线修改（比如引用proof的行/公式编号，列出错误的地方，给出正确的修改。

```
Please make sure you do the following before you submit:

Check that the author last names (highlighted in teal) have been identified correctly. If our highlighting is incorrect, please indicate any necessary changes by using the “Instruct” button.

Check copyeditor edits, highlighted in the text in green (inserted) or red (deleted). Click on 'Edit Log', and choose 'Copy Editor' tab to see the list of changes. To reject a change, select the change and Undo. To accept a change, no action is needed.

Respond to all queries. Please note that proof corrections cannot be submitted until all queries have been answered.

Annotate the graphics or upload the revised figure if necessary, and we will edit or replace them as instructed. Click on the upper right corner of a figure to open the high-resolution version. High-resolution versions will be used in the final publication.

To view the article with your changes incorporated, please click on Proof. The Proof view will show your text edits, but not any instructions, attachments, or query responses (these will be addressed in the final publication). Please also note that the formatting and layout of the Proof will differ from those of the final published product, although the data are the same.

Note

Formatting and layout (page breaks, table layout, and placement of tables and figures) are for proofing purposes only and will be optimized for publication in the final version.
Images are downsampled to a lower resolution for web viewing. In Edit mode, click on  in the upper right corner of a figure to open the high-resolution version. High-resolution versions will be used in the final publication.
Proof mode automatically paginates your proof. Please request assistance if your proof contains major pagination errors (e.g., incorrect display of formulas, misalignment of columns, etc.). Contact details can be found in the Help section.
```



# Copyright Tansfer

文章接收后，作者面临版权协议法律文书的签署。版权协议的主要内容是有关文章版权的转让。目前都是格式条款，而且多是霸王条款，必须同意转让。需要特别指出的是所有作者要亲自签名。

你只需要打印一份下来，**手写填写、签字**、扫描，系统上传或者邮件寄发即可。注意：如果有的作者不是同一个单位，可以打印多份，分别给他们签字，然后扫描各自签字的几份，上传电子图片即可。如果明确要求邮寄hard copy了，着急就快递，不急就国际航空信吧，一般也就1－2周就行了。

版权转让协议书一般是通讯作者代表，签名写英文，Contributor name应该是所有作者，即对文章有贡献的人。co-contributor可写第一作者和其他作者签名和日期。Title：Professor, Doctor, Miss, Mr, etc.

Date：就是签写日期，在这里需要注意：英国和美国的日期格式是不一样的，比如今天中国的说法是2011年1月21日，而英国写法是 21nd January, 2011， 而美国的写法是January 21, 2011，所以引申过来就是如果你投欧洲的杂志建议你用英式签字，如果你投北美杂志就用美式签字。

Name（print）print 翻译过来是打印名字，引申意思就是说让你不要用草书，整整齐齐的写你必须让看你名字的人看清楚你的字，主要便于别人识别，可以手写，比如张三，San Zhang（当然中文名字也有好多种格式就不多说啦）。

signature 就是你自己平时的签名，关键是能够代表你身份的独特性和可分辨性就可以，如果画个圈就是你的平时的签名的话，你就可以画个圈，这个当然用中文啦，因为你平时在病历上签字不可能用英文啊。

![](http://img.dxycdn.com/upload/2011/01/21/25836613.snap.jpg)

![](http://img.dxycdn.com/upload/2011/01/21/69418067.jpg)

Authors' contributions：

RY, RL and ZZ were responsible for the conception and design of the study. RY and SM performed the data analysis. All authors participated in interpretation of the findings. RY and SM drafted the manuscript. RL and ZZ revised and commented on the draft and all authors read and approved the final version of the paper. All authors confirm that the content has not been published elsewhere and does not overlap or duplicate their published work.

Competing interests：

The authors declare that they have no competing interests.



# 版面费

关于版面费，有的杂志可以在接收后申请减免，有的杂志必须在投稿时附信中即有希望能申请减免版面费的说明，如EBM（experimental biology and medicine）杂志。  

相当一部分杂志不收版面费，但是可能要收彩图费。文章投稿过程用的彩图，accept后转给出版商处理，会有邮件就发表相关事宜进行商量，如清样proof有无问题？彩图费多少及如何交付？是否需要将彩图转成黑白图？订购单行本offprint的数量？是否开放获取open access？由于诸多科研工作者获取全文都是通过在线阅读pdf文献，而那些订阅纸质版的读者对你的文章图片十分感兴趣的话，也可以通过网上数据库获取，以进一步了解。由于彩图的电子版免费，纸质版收费。故对于彩图费的问题，你完全可以跟出版商如是说明“我们选择电子版用彩图，纸质版用黑白图”。此过程不影响文章接收和发表，不必担心。  

一般来说，online version的彩图都是免费的；而print version的彩图有些杂志需要收费。就你投稿的杂志，它可以允许你将彩图转换成黑白图片免费放在印刷版中（在不影响效果的情况下），但是如一些染色的组织图片，可能就必需以彩图的形式呈现给读者。因此你可以根据你的实际情况，选择你文中的图片以什么样的形式出现在印刷版中。

考虑到费用问题，如果你要将彩图转换成黑白图片，最好自己作好黑白图后发给杂志社，并且说明你的意愿。一般来说，杂志社是不会强行要求你使用彩图的，这些都可以好好商量。

# 单行本订单

在论文被接受后不久会收到杂志（出版社）寄来的校样(Proof),往往同时附有一份表（Reprint 或Offprint order，也就是单行本订单)。

单行本有时分两种：有封面的和没有封面的。有封面的在封面上带有该杂志本期的封面以及该论文的题目、作者等信息。 没有的则仅有论文本身。两种单行本纸质都比较好。

时过境迁，现在网络发达，绝大多杂志已有全文(pdf)网上刊登，下载很方便。pdf文档同杂志上发表的几乎一模一样，得到广泛认同。所以，许多作者不再定购单行本。纸质的单行本会逐渐成为历史！

Offprint是选印本的意思，说的通俗一点，类似于国内刊物的单册，就是只有杂志封面加上你这篇文章。你投稿的杂志会免费给你一份带水印的PDF文档，有些还会带上杂志封面。一般这种版本上面会写上Author's personal copy，说明只能作者使用。而一般这种a watermarked PDF file和25 free offprints是互换的，就是你可以在两者之中取其一，都是免费的（25份offprints是纸质版的，如果你选择了这个，将来要是用完了就没有了；而a watermarked PDF file是电子版的，你可以随时去打印。）。我们一般推荐选择a watermarked PDF file，有了这个，你可以打印出N份。

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>科研经验</tag>
        <tag>论文接收</tag>
      </tags>
  </entry>
  <entry>
    <title>审稿意见回复信</title>
    <url>/paper-response-letter/</url>
    <content><![CDATA[
论文由作者提交后，期刊编辑对他／她觉得合适的文章（不合适的就直接拒稿了，这叫desk rejection），根据论文内容，把稿件发给几位领域内的专家评审。专家们在百忙之中抽时间义务审稿，并把其意见发还给期刊编辑。此时由期刊编辑根据专家的意见再做如下三种决定。一是直接采纳（accept as submitted），这是皆大欢喜的结局。二是拒稿（reject），这对作者来说是凄凉的结果，对期刊本身，也并不是好事，因为大家都要继续付出精力去定下合适发表的文章。一般比较常见的，是建议作者修改文章然后重新提交（revise and resubmit）。这种情况下，期刊编辑会把评审专家（reviewer）的评审意见（comments）一并发给作者，以为改稿之基础。

<!--more-->

作者根据评审专家意见修改稿件之后，在重新提交时，除了修改的文章（revised manuscript），还要包括一封response letter，对所有评审专家的意见一条一条的答复。请注意，**这封答复信和修改的稿件几乎一样重要**！期刊编辑会把二者发送给原评审专家，由他／她们评定作者的修改是否已经令人满意，达到可以发表的水平。之后，期刊编辑再次根据这些评审专家的意见决定是否采纳稿件。

关于如何回复审稿人的问题，有两个网站值得参考，一个是[欧洲地球科学联盟旗下的开源期刊](https://www.egu.eu/publications/open-access-journals/)，一个是开源期刊[PeerJ](https://peerj.com/reviews/)，它们都公开了同行评议的过程，包括很多已发表的论文，审稿人问了什么问题，作者如何回复的，里面都有，对我这样的 SCI 文章菜鸟很有帮助。

# response letter

第一次阅读评审意见后，你应该对审稿人提出的主要问题有所了解。接着再次通读意见，确保找到重点。所以尝试总结这些评论并按重要性排序。最终应该产生一个行动计划，为了解决这些问题你打算做的事情清单。

在这里用问答式一一列出每个审稿人的意见并且一一作答。下面几点注意事项能帮助你撰写：遵循Williams（2004年）提出的流程：礼貌回应，逐条回应，有理有据。

1. **不遗漏任何意见**，不管是期刊编辑或是同行评审员提出的：完整复制所有意见到信里面，在每一条意见后面加上你的回复，一定要确认编辑和审稿人提出的所有意见都有回复到，即便是不同意或是没有采纳修改的意见也要说明原因。
1. **回复必须尊重有礼**：所有的审稿人都花费了一定时间来评估你的论文，即使有些意见可能不是那么正面，但也绝对不是针对个人，他们的意见是为了给你的工作带来附加价值，也许会有你不喜欢或是觉得不合理的意见，回复时语调还是要维持礼貌，信的语调是很重要的。
1. **将段落式的评审意见拆成点列式**：如果审稿意见是长长的段落，那么不妨将它分离成点，个别回应，如果有不确定的意见，可以在回复前解释你的理解再进行回复。
1. **逐点回复**：可以将审稿意见进行编号，然后顺序回复，标示论文中进行的修改，或是指出修改前后的页码与行数，另外，为了更好区别意见和回复，审稿意见可以使用粗体字。
1. **分类审稿意见**：如果审稿意见很多，可以进行分类，比如与方法相关的归成一类、语言相关一类等等，如果进行分组的话，记得要在信里说明。
1. **审稿误解了？可以礼貌地厘清**
    - 同行评审员通常是领域内的专家，如果你觉得审稿人误解论文里的任何段落，很多时候有可能是表达不够清楚，所以在处理误解的时候，可以礼貌性的指出，然后提供必要说明。
    - 在并不同意评审专家意见的情况下，不要含蓄的兜圈子让编辑去猜测意会。而是应该礼貌但明确地指出你不同意该条意见，理由是哪些（比如I do not agree with the reviewer, because of the following reasons）。
1. **遇有无法处理的意见，记得说明原因**：有时候审稿人会要求额外的数据或是补做实验，而作者会认为没有必要，即使如此，还是要说明不做的原因，类似经费不够或没有时间这种私人的理由要尽量避免，也不要表现出负面的天都，回复是要表现出你对意见的重视和尊重，感谢审稿人的分析和意见，然后说明你为何无法完全同意审稿意见，回复必须有理有据。
1. **新添加的数据或图片，指出它们的位置**：论文修改的时候如果加入了新的数据、表格、图片等资料，记得指出它们的位置，如果有必要，可以另外附在修回信后给审稿人和编辑，如此他们就不用一个一个的搜寻。
1. 审稿人推荐的文献一定要引用，并讨论透彻。  
1. **做出适当结语**：注意信的结尾，像“Since all the corrections have been made, we hope the manuscript will now be accepted without any further changes”这样的结尾可能会过于自负，如果要直接又不失礼，可以这么说：We look forward to hearing from you regarding our submission. We would be glad to respond to any further questions and comments that you may have，这样的结尾正式有礼也表达了愿意在必要的情况下进行更多修改的意愿。
1. **修回后投稿一定要核对初稿中改正的地方**：作者的一般信息和各种联系方式、标题、摘要、图片编号、数据值、cover letter等。版权协议和利益冲突表格要谨慎填写。签名时尽量不要代签。  

<div class="note info"><p>建议把回复标记为其他颜色，如蓝色。</p></div>

其他说明：

- 在逐条答复中，适当感谢是可以也是应该的，但是不用太过。关键是表达清楚你是否同意评审专家的意见，并做了什么样的改动，让事实说话。
- 对于文字的修改要求，直接接受就行了。有的审稿人要求增加参考文献，也许这是审稿人唯一显示他私心的地方——比如要求引用他的文章，不是很离谱的情况下也可以照办，或者打个折嘛，要求引用三篇最后加上一篇嘛。回答问题的时候，最好简洁和就事论事，不要拖泥带水。要注意不要为了回答某个问题而导致更多的疑问，尽量将讨论局限在有限的范围内。
- 有的审稿人与文章的研究方向有差异，或者没有认真读文章，导致对文章的理解有误，从而提出一些莫名其妙的问题。回答这些问题的时候，可以首先引用一下文章的相关句子，然后指出文章的真正意思。接着承认是自己的表达出现问题了，让审稿人曲解了意思，最后指出句子已经重写，表达的意思已经更准确了。这样的回答，既巧妙地回答了该问题，也避免了让审稿人尴尬。
- 如果遇到了非常难回答的问题，比如审稿人质疑文章的创新性有限，价值不大。这些是文章的硬伤，是没有办法修改的。赞同审稿人的意见肯定不好，但是用回避的方式不回答更不好，既不礼貌也侧面赞同了审稿人。这个问题尽管很难回答，但是还是要去争取一下，比如再强调一下文章里面相关的几个句子。要知道每个人的见解不同，虽然一个审稿人觉得意义不大，但是决定权毕竟是在编辑手里，只要编辑在综合多个审稿人意见之后还觉得文章有可取之处，也就没有问题。而response letter是所有审稿人都可以看到的，诚恳的回答会获得其他审稿人的好感。
- 审稿意见里面经常出现的问题是要求补充信息，比如更多的实验结果或者与该文章相关的另外的一些信息。这样的问题需要仔细斟酌一下，如果仅仅是审稿人出于自己的好奇，是可以选择在response letter 里提供而不是直接添加到文章里面。而如果对所有读者都有用，则需要加到文章里面。对于审稿人提出的不合理的建议，可以心平气和地找个客观的理由委婉地拒绝或者提供一些参考资料，不要让审稿人觉得你对他的问题视而不见。
- 另外，需要注意的是——揣摩审稿人的态度强硬程度，其他审稿人的好评程度，编辑的倾向性。如果总体是好评，其他审稿人和编辑也倾向于修，那么尽量往小补实验+论辩思路走。倘若审稿人主要是刁难，编辑也不太看好本文，那么还是要尽全力补充实验，毕竟补了后发表机会会更大些，人家审稿也会看你的修稿态度的。  

**对于要求增补实验的问题**：

- 一般而言，审稿人提出要补充的实验，如果实验难度不大，建议尽量补充。如果不是非做不可的，还是可以进行解释。有时审稿人即使想接受你的文章，总还要提出一些不足之处。如果你真的不想补充实验或者补充很困难，可以合理的解释，一般没问题的。最重要的是逐条回答，老实交代。绝大部分实验是不要真追加的，除非你受到启发，而想该投另外高档杂志。  
- 如果实验不可能重新再做一遍，不可能全部换个造模方式把动物再杀一道，经费和时间不允许重来.....eg：1）.指出你文章中所用的细胞是本研究所主要关注的，目前已研内容可基本证明研究目的和问题所在，说明.....  2）.如果找到相关的文献依据（近年份、分数稍高于你所投杂志）也只是用了某一种细胞，会更好。  3）.务必十分感谢审稿人的意见，我们将遵从您的指导，在后继研究中继续探讨，用其他细胞进一步验证结论，并与目前的研究进行对比，继续投稿。  

# cover letter

提交文章修改后要附上一个cover letter。里面包含这些内容：（1）感谢编辑安排审稿以及审稿人提出的宝贵意见。（2）作者已经认真按照审稿人的要求对问题一一作答，并对文章进行了仔细的修改，文章的所有修改都着重标出。（3）因为你们的建议，经过修改后的文章变得更好，读者们可以获得更有价值的信息。（4）再次感谢编辑和审稿人的帮助。

Dear Editor, Dear reviewers,

Thank you for your letter dated February 22. We were pleased to know that our work was rated as potentially acceptable for publication in Journal, subject to adequate revision.We thank the reviewers for the time and effort that they have put into reviewing the previous version of the manuscript. Their suggestions have enabled us to improve our work. Based on the instructions provided in your letter, we uploaded the file of the revised manuscript. Accordingly, we have uploaded a copy of the original manuscript with all the changes highlighted by using the track changes mode inMS Word.

Appended to this letter is our point-by-point response to the comments raised by the reviewers. The comments are reproduced and our responses are given directly afterward in a different color (red).

We would like also to thank you for allowing us to resubmit a revised copy of the manuscript.

We hope that the revised manuscript is accepted for publication in the Journal of Mountain Science.

Sincerely,

XXXXXXX

> - 在信的开头称呼一栏，很多中国作者习惯写：“尊敬的编辑（Dear Editor）”。不是说这个称呼有什么错误，但是按英语母语国家的习惯，感觉有些太笼统，不亲切。每个期刊的编辑都是有姓名的！直接以对方的姓或名称呼，会比较好。至于是称呼姓（Dr. XX）还是名，这里有个小诀窍：可以参考期刊编辑所发信件的落款。有些编辑会用正式落款（全名，Ph.D.），那么回信时就最好用Dr. XX。有一些编辑性格随和，可能会以自己的名字（given name）落款，那么作者在回信的时候也可以考虑直接称呼对方的名字（比如 Dear Alice），同时在落款的时候也只写自己的名字（比如，Xiaoming）。
> - 在提头之后，一般作者会对期刊编辑和评审专家表示由衷的感谢，这个是应该的。接着可以大致介绍一下文章所作的比较大的比较重要的改动。之后进入最关键的部分，就是对评审意见的逐条答复：是否同意评审专家的观点，或者回答评审专家的问题，并做了怎样的修改，改动在重新提交稿的什么部分。

其他参考：

- Besides the above changes, we have corrected some expression errors. Thank you very much for the excellent and professional revision of our manuscript.

# 常用语句

> [如何高效地回复审稿意见或写反驳信](http://blog.sciencenet.cn/home.php?mod=space&uid=2961180&do=blog&id=1152632)

总结了一部分万能的套话[^blog-314423-975061]，以体现我们对杂志社编辑和审稿人的尊重。

[^blog-314423-975061]: [展示一封作者对审稿人意见的回复信](http://blog.sciencenet.cn/blog-314423-975061.html)

<div class="note info"><p>[审稿意见回复模板](http://bbs.sciencenet.cn/home.php?mod=attachment&filename=Annotated-Template-Journal-Submissions-Rebuttal-Letter1.docx&id=297695)</p></div>

- The authors appreciate the reviewer’s comments on this manuscript.
- We thank the reviewer for the very interesting comment.
- We are grateful for the suggestion.
- Thanks very much for your valuable suggestions.
- Thank you for the title suggested.
- Thank you for the suggestion.
- Thank you for underlining this deficiency.
- Thank you for your interesting comment.
- Thanks for this thoughtful comment.
- Thank you for this good comment.
- Thanks for this valuable comment.
- Thanks for your comments here.
- We are sorry for ...
- We are very sorry for our negligence of …
- We are very sorry for our incorrect writing …
- As Reviewer suggested that…
- As you suggested, ...
- Considering the Reviewer’s suggestion, we have …
- Following the reviewer’s suggestion, we discussed ...
- We have made correction according to the Reviewer’s comments.
- We have re-written this part according to the Reviewer’s suggestion.
- We  did  not  think  that  it  is  important  to ...
- Special thanks to you for your good comments. Hopefully we have addressed all of your concerns.

同意审稿或期刊编辑意见

- We agree with you and have incorporated this suggestion throughout our paper.
- We have reflected this comment by… (p. #, lines #-#).
- We have incorporated your comments by… (p. #, lines #-#).
- We agree that…
- We have now [X] (p. #, lines #-#) and [Y] (p. #, lines #-#). We think these changes now better [Z]. We hope that you agree.

不同意评审或期刊编辑意见

- You have raised an important point; however, we believe that [X] would be outside the scope of our paper because…
- This is a valid assessment of…; however, we believe that [X] would be more appropriate because…
- We agree that…; however, due to [X], we believe that…
- In our revisions, we have attempted to [X] (p. #, lines #-#); however, we have retained some of our arguments because…
- We acknowledge that [X] has certain limitations; however,…

解释澄清

- We have clarified that… means… (p. #, lines #-#) throughout the paper.
- We have redrafted the [X] section (p. #, lines #-#) to establish a clearer focus.
- We have revised the text (p. #, lines #-#) to reflect…
- We removed [X] (from p. #, lines #-#) and hope that the deletion clarifies the points we attempted to make.
- We have replaced the term [X] throughout the paper with [Y] to use more precise terms.
- We have rewritten [X] (p. #, lines #-#) to be more in line with your comments. We hope that the edited section clarifies…
- We have elaborated on [X] (p. #, lines #-#) and expanded our consideration of [Y]. We hope these revisions provide a more [balanced][thorough] discussion.

额外的信息与解释

- We have included a new Figure # (p. #) to further illustrate…
- We have added a new Table # (p. #), which outlines…
- We have supplemented the [X] section with explanations of [Y] (p. #, lines #-#).
- There are multiple reasons/approaches to…, including [our scenario]. We have included an acknowledgment regarding this point in the [X] section (p. #, lines #-#).
- We have not done… However, we believe that [doing X] (p. #, lines #-#) would address this issue because…
- We have not done…; however, our sense is that…

回答多题 (当你的一个回复回答许多问题时)

- Please see point # above. [e.g., "Please see point 2(a) above."]
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>科研经验</tag>
        <tag>ResponseLetter</tag>
      </tags>
  </entry>
  <entry>
    <title>论文投稿</title>
    <url>/paper-submission/</url>
    <content><![CDATA[
针对投稿前的准备工作与事项、各种投稿后状态、对拒稿后的处理或者接受后期的一些相关问题，做了一个专门的细致总结，并附有投稿经历和经验总结。

<!--more-->

> [【交流】SCI投稿过程总结、投稿状态解析、修稿处理、拒稿后对策及接受后总结等全程荟萃](http://www.dxy.cn/bbs/thread/19342437#19342437)  
> [为您分享SCI论文检索、阅读、写作、投稿的干货](https://zhuanlan.zhihu.com/p/22217306)  
> [科学网首页 > 全部专题 > 投稿与审稿](http://news.sciencenet.cn/news/sub18.aspx?id=717)


# 选投期刊经验

[学术期刊影响因子及分区表 - 2014年版](http://tool.yovisun.com/journal/)

投稿时不要海投。在投稿前应该对所有可投期刊的发文范畴、发文传统、发文重点以及投稿方式、评审周期认真研究。一些期刊，特别是大学学报，从名字上很难把握他们的发文重点，但实际上每一种期刊都会有自己的侧重点，纯粹意义上的综合性期刊几乎没有。所以，作者在投稿前有必要对期刊的特点有所了解，以便在投稿时“有的放矢”。作者可以圈定比较适合自己论文方向的3-4种期刊，并将这几种期刊分出梯队和层次，一般可以先投那些评审周期快的期刊，如果没有录用，马上开始向第二种期刊投稿。在投稿时，可以根据各刊的发文重点，对文章的题目和结构进行微调，以便能提高“命中率”。

1. ISSN号和CN号。判断期刊质量首先要确定他是不是正规的期刊，首先要看它有没有ISSN号和CN号。ISSN号是国际标准刊号(International standard serial numbering)，它有8位数字组成，XXXX-XXXX中间由“—”连接，其中前七位是纯数字序号，最后一位是校验位。CN号是国内统一刊号，如中国图书馆学报CN号是 11-2746/G2，前两位11是地区号，2746是序号，由报刊登记所在的省、自治区、直辖市新闻出版管理部门分配。斜线后是期刊分类号，可以参加中图分类法。国内期刊只有具有CN号的期刊才是合法的正规期刊，有些期刊只有ISSN号，没有CN号，那么它们可能是非法期刊，或者不公开发行供内部参阅的内刊，评职称什么的有些机构是不算数的。

2. 影响因子。影响因子（Impact Factor，IF）是汤森路透（Thomson Reuters）出品的期刊引证报告（Journal Citation Reports，JCR）中的一项数据。即某期刊前两年发表的论文在该报告年份（JCR year）中被引用总次数除以该期刊在这两年内发表的论文总数。（百度百科）影响因子是目前运用广泛的评价期刊质量的指标，虽然它饱受争议，但现在还没有一个比它更令人信服的评价指标。

3. SCI、EI、ISTP、SSCI、A&HCI、CSSCI和CSCD。判断期刊质量，很重要的一个方法是判断该期刊是否被以上数据库（检索）收录。对于SCI分区，靠的是期刊引证报告JCR（Journal Citation Reports）提供的期刊影响因子，目前有两种分区方法，一是JCR自身分区，按照某一学科期刊影响因子从高到低排列，然后平均四等分；另一种是中科院的JCR分区，中科院分区参考3年平均IF，一分区是某学科影响因子前5%的期刊，二分区取5%-20%，3分区为20%-50%，4分区50%以后。

    a. 除SCI以外，俗称的国际三大检索还有EI和ISTP。EI《工程索引》(Engineering Index，EI)，1884年创刊，由美国工程信息公司出版，报道工程技术各学科的期刊、会议论文、科技报告等文献。ISTP《科技会议录索引》(Index to Scientific & Technical Proceedings，ISTP)，也是由ISI出版，1978年创刊，报导世界上每年召开的科技会议的会议论文。

    a. 以上主要是自然科学，人文社会科学领域著名的数据库有SSCI和A&HCI，SSCI是美国《社会科学引文索引》的一个简称。《社会科学引文索引》（Social Science Citation Index，简称SSCI）为美国科学情报研究所建立的综合性社科文献数据库，涉及经济、法律、管理、心理学、区域研究、社会学、信息科学等。A&HCII（Arts & Humanities Citation Index，艺术与人文科学引文索引），创刊于1976年，是艺术与人文科学领域重要的期刊文摘索引数据库。

    a. 国内方面如果期刊被CSCD、中文核心期刊目录、CSSCI，那么就可以认为期刊在它所属的领域是较为优秀的期刊。CSCD是《中国科学引文数据库》（Chinese Science Citation Database）的简称，学科范围：数学，物理学，力学，化学，天文，地球科学，生物学，农林科学，医药卫生，工程技术，环境，管理科学。中国科学引文数据库（CSCD）分为核心库和扩展库。核心库的来源期刊经过严格的评选，是各学科领域中具有权威性和代表性的核心期刊。扩展库的来源期刊也经过大范围遴选，入选者是我国各学科领域较优秀的期刊。与CSCD容易混淆的是中国科技论文与引文数据库（CSTPCD），目前，许多学术期刊在申请基金、重要成果报奖时，一般对方单位要求提供的是CSTPCD检索系统的结果，CSTPCD也是我国最重要的检索系统之一。

    a. CSSCI为《中文社会科学引文索引》(Chinese Social Science Citation Information)英文名称首字母缩写，是由南京大学研制成功的、我国人文社会科学评价领域的标志性工程。也就是我们常说的C刊，在国内社会科学领域一年能发几篇C刊就属于比较牛的作者了。


# 稿件初审

> [稿件正式发表前的检查和修改要求](http://blog.sciencenet.cn/home.php?mod=space&uid=314423&do=blog&id=1112261)

很多期刊的稿件初审都是由编辑部的人员来做。个人认为，初审应从以下几个方面入手：

1. 稿件是否符合期刊的刊稿范围。
2.  稿件是否符合期刊的标准规范：如果不符合期刊的标准规范，请作者按照期刊的格式重新撰写。
3. 数据是否充分：做了哪些试验，得到了什么样的结果，通过阅读题目、摘要、方法、结果、结论，看提供的数据是否能够充分说明文章要达到的目的。
4. 方法是否清楚明了：作者采用什么方法，怎样得到的结果。如果作者在这部分有意疏忽，则有可能被退稿。
5.  图表：图表的呈现是否恰当、美观。有些文章没有侧重点，一下放几十个图,有些文章图片质量差，让人一看心里就不舒服。即使文章内容不错，如果图的质量较差，我们会要求作者修改后再投。
6. 文献引用：文献引用最能看出一个作者的功底和认真程度。是否只引用本国文献？是否遗漏重要的学术论著？是否大部分抄袭某篇已发表的文章的文献？最后这一条通过我们期刊的稿件系统中嵌入的Crosscheck防抄袭系统可以检测出来。

# 稿件定稿


**合理应用一些小技巧**

- 了解所投杂志刊登文章的主要方向，投其所好；  
- 阅读目标期刊的征稿说明，按要求逐一修改；  
- 从文章内容到投稿格式最好都能量身定做。比如，在文章的页眉、页脚标上所投期刊的名称，这些细节会让编辑感受到你的诚意；
- 参考文献要有1-2篇来自该期刊或者审稿人；  
- 请在该期刊发表过较多文章的同行或朋友修改一下文章。  

**重视审稿人较为关注的问题，对照修改自己的稿件最后定稿**

- 有的审稿人特别重视是否有比较明确的假说和意义凸显点存在（我之前投shock有位审稿人就是抓住这个不放，重投杯具原因之一就在于此）；  
- 论证是否合乎逻辑，讨论和结论是否合理；  
- 参考文献引用是否妥当；  
- 内容是否新颖、重要；  
- 文字表达是否正确、简明、清楚；  
- 实验描述部分是否清楚并且能被读者重复、实验数据是否真实、可靠；  
- 论题是否适合于相应的期刊；  
- 图表的使用和设计是否必要、规范、清楚；  
- 摘要、引言、体例是否合适。  


# 稿件相关材料准备

1. Manuscript.doc、Tables.doc、Figures、Cover letter，有时还有Title page、Copyright agreement、Conflicts of interest等。
1. 一个pdf的手稿，还有一个cover letter，还有一个 **Highlights** 文件。
1. 如果你是几次修改的呢，最好还是传源文件，比如word和LaTex。既然是修改后的稿子，必然会有revise note，也就是你回答审稿人和编辑的response，文档格式选成revise note就行。
1. 重点是manuscript那一项，都传什么呢，.tex必不可少，参考文献.bib也不能少，最后格式文件.sty其实也是要传的，那么.bst和.cls系统中本来有，你传了也是会fail的，这个就不需要传了。
1. 这些都统统选成manuscript就OK。而文章中的图呢，也就是.eps统统上传一个不能少，都弄成Figure项，这些都弄好之后呢，系统会编译然后build PDF，等一会，下下了看看，没什么问题approve就好了。
1. [Data in Brief](https://www.journals.elsevier.com/data-in-brief)，就是把supplementary另外弄上标题和解释部分，另发一篇OA的小文章，要500还是600刀。Elsevier用来赚点钱的东西。一般supplementary直接用word或者ppt挂在文章后面其实挺好的，当然你要是不在乎那点钱也可以把投到data in brief，别人看你supplementary的时候会看到一篇排版过的文章。[数据库介绍文章的写作和投稿](https://zhuanlan.zhihu.com/p/24974537)
1. [MethodsX article](https://www.journals.elsevier.com/MethodsX)

# 挑选审稿人

很多SCI杂志都需要作者自己提出该篇论文的和您研究领域相关的审稿人，比较常见的是三名左右，也有的杂志要求5-8人。

- 只推荐那些目前还活跃在该领域的审稿人，即在过去3年中发表过关相关主题文章的专家。
- 最好国内外专家混搭、资深专家和初级专家相结合。
- 推荐一个你的研究领域中的行业大牛。虽然他们可能太忙而无法接受邀请，但它可以让编辑知道你的文章研究领域。
- 推荐你投稿期刊水平相当的学者作为审稿人是比较合适的选择。
- 关注正处于职业生涯中期的学者，例如高级讲师，助理教授或副教授，甚至是初级教师和博士后。年轻的研究人员往往会成为最佳审稿人，因为他们渴望建立声誉，并有更多时间提供全面的审查。
- 避免可能存在的利益冲突，比如推荐的审稿人是其中一位作者的导师或者现同事，或与第一作者/通讯作者在近五年内有过合作项目的学者，都要避嫌；另外也尽可能避免推荐太多国内同行给予审稿。
- 提供的推荐审稿人联系邮箱是其工作邮箱，尤其是edu域名下的邮箱。

从期刊编辑角度，合适的审稿人需要哪些条件？第一，推荐审稿人的专业领域一定要和稿件涉及的内容密切相关；第二，推荐审稿人仍在继续从事科研工作；第三，对投稿文章从不同角度进行评价。

通过上述方式列好候选名单之后，下一步就是提供推荐审稿人的精准信息。

1. 找到候选人的最新联系方式。在数据库中重新搜索这些作者的相关信息，以确认他（她）们仍然活跃在相关科研领域，并找到其最近的联系方式（科研工作者读研期间、做博后期间、做PI期间、或者在不同科研机构做PI期间会有不同的联系地址，请找到最近使用的一个）。
2. 逐一核对作者其他信息，尤其是名(first name)和姓(last name)一定要分清。另外，也尽可能提供作者的科室和单位，这些都有助于编辑确认是否采用这个推荐。
1. 还有需要注意的是，如果是从参考文献中找到的审稿人，一定要确认推荐审稿人的文章被准确引用。
1. 清晰说明推荐理由。在论文提交系统的推荐审稿人提交中，大部分系统都会留出推荐理由这一栏。如果按照前述步骤选择的推荐审稿人，这个根本不是困难。可以列出该推荐审稿人的专业领域，显示适合审稿的因素；也可以指出该推荐审稿人是稿件参考文献中的文章作者。如上所述，如果你的论文内容涵盖了不止一个领域，则需要确保在每一个领域都推荐有至少一名审稿人。


# 投稿状态

> [当期刊说 Under Review，他们在说什么](http://blog.sciencenet.cn/home.php?mod=space&uid=769813&do=blog&id=1128359)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fyrej6pm1nj20sg0jw7co.jpg)

1. **Submitted to Journal**：刚提交的状态

    一般的步骤是这样的： 网上投稿-Submit a manuscript：先到每个杂志的首页，打开submit paper一栏，先以通讯作者的身份register一个账号，然后以author login身份登录，按照提示依次完成：Select Article Type、Enter Title、Add/Edit/Remove Authors、Submit Abstract、Enter Keywords、Select Classifications、Enter Comments、Request Editor、Attach Files，最后下载pdf，查看无误后，即可到投稿主页approve submission或直接submit it。当上传结束后，显示的状态是Submitted to Journal，这个状态是自然形成的无需处理。

    **总结提示语：**

    对于投稿之前和提交确认投稿过程，这里还需要对投稿新手强调以下几点。因为这些小问题被编辑评个低印象分不划算，被打回也浪费了时间和精力。一条条说来：  
    1)大多数系统是要求word投稿正文内容的，pdf多不为接受格式。但也有很少数要求用pdf格式的，务必注意细看稿约。  
    2)文献格式是否按拟投杂志标准要求核准？有的投稿系统是可以直接检查的。  
    3)引用文献条数是否符合该杂志要求？有的杂志不特别要求，有的还是非常重视的。如我之前投shock杂志，编辑和一位审稿人都提到参考文献不要超过35条。如果你文章写完后，能够适当精简文献条数，那么，请删减几条吧。  
    4)很多系统要求勾选同意一些如伦理道德的声明文件  
    5)提交后可能会有一个小栏目提示对提交图片的质量做了初步审查（不合格的最好重新作图再上传）  
    6)绝大多数投稿完成后需要view submission和最后确认（approve submission）。view submission 就是要求你再整体看看投稿填写的这些资料信息+cover letter+正文+图片表格，所生成的pdf全文是否满意、合格，也是你投稿完成前最后一次检查的机会了。  
    PS：有的新手可能不注意这点，提交后就不管了，还开开心心以为自己投稿成功，殊不知结果邮箱里一直没有收到投稿后的邮件回执和稿号，直到最后纳闷几天了才回去看系统状态。

2. **Manuscript received by Editorial Office**：文章到了编辑手里了，证明投稿成功  

3. **With editor**

    若投稿时未要求选择编辑，则先到主编处，主编会分派给副主编或者其他编辑。这当中就会有另状态：  
    - Awaiting Editor Assignment指派责任编辑  
    - Editor assigned 是把你的文章分给一个编辑处理了。  
    - Editor Declined Invitation 如果编辑接手处理了就会邀请审稿人了。  
    - Reviewer(s) invited 找到审稿人了，就开始审稿  
    - Decision Letter Being Prepared 就是编辑没找审稿人就自己决定了，一般而言此时很危险。一可能是英文太差，需要语言润色。 二可能是内容太差。 除非被大牛们直接接收。


    **总结提示语：**

    一般情况下，投稿（submit）状态后一个星期内会出现编辑处理稿件（with editor）这个状态。很多老外编辑很不能理解中国人喜欢催稿，绝大多数情况下，他们不会像国内某些期刊一样能拖上一年半载再给屁大点修回意见。要适当给编辑一点时间处理，他们也很忙的。不要轻易催稿，也有人因为催稿而立马收到杯具消息——不知是编辑不耐烦了，还是一种巧合。当然，如果submit四个星期后网上投稿系统还没出现with editor状态信息，就要询问主编了，要注意委婉用语。不过要注意，也有期刊没有with editor状态。  


5. **Under review**：此过程的等待较为漫长。当然之前各步骤也可能很慢，要看编辑的处理情况。

    **总结提示语**： 一般来说，根据这个杂志通常审稿周期来定。具体审稿周期不建议询问，但可以参考一些投稿系统和公司的查询网页。这个过程也不要轻易催稿，一般都是已邀请审稿人和已送审等过程中。如果被邀请审稿人不想审，就会decline，编辑会重新邀请别的审稿人。写信一定要委婉，否则你的催稿信就可能成拒稿信了。

6. **Required Reviews Completed**：表示审稿意见已经返回给编辑，等编辑处理。

    **总结提示语**：这个状态大多情况下不会持续太久，几小时到几天为多，基本上根据最初投稿后分配的稿件编号数量可以预测到这个过程的处理时间。稍安勿躁，安心等待吧。  

7. **Evaluating Recommendation**：评估审稿人的意见，随后你将收到编辑给你的decision。

8. **Decision in process**：到了这一步就快要有结果了，编辑开始考虑是给修改还是直接拒，当然也有可能直接接受的。

    **总结提示语**：这时候应该全部审稿人意见回来了，编辑开始斟酌意见、处理稿件。有的稿子评价都很好，一般都很快就决定accept或者小修；有的稿件审稿评价均很差，则无一例外会reject；  
    值得重视的是：相当一部分情况是等待时间一周以上的，多是由于审稿人意见不统一，有好有坏，这时候编辑可能会自己决定此文章的命运，可能充分尊重审稿人意见而拒稿（这种情况处理也很快的），可能编委会讨论决定是再修（major revision可能性较大，否则就直接Reject），也可能会找一位审稿人。这时要根据不同的状态而出现等待时间不一了。  

9. **Minor revision/Major revision**：小修或大修。至此问题一般不会太大，充分尊重审稿人和编辑的意见，谦虚谨慎是不可少的。

    **总结提示语**：能有条件就尽量补实验，是在不行就认真考虑理由申辩，但谦虚谨慎的语气必不可少。毕竟大修的也存在一定的拒稿率，而小修的绝大多数是能够最后搞定的。  

10. **Revision Submitted to Journal**：又开始了一个循环。  

1. **Accepted**：接受（这是最开心的时候了）。如果不要再审，只是小修改，编辑看后会马上显示这个状态，但如果要再审也会有上面的部分状态。一步会比较快，但也有慢的。

1. **reject**  

    **总结提示语**：这里就不必多说了。对于我们广大的硕士博士研究生而言，绝大多数人是有着杯具经历的，那种心情大多体会过，一定要振奋精神。希望大家整理好心情，重新上路。  

13. 其他相对少见的或细分的状态(期待大家补充)：  

    **Initial QC Started**：QC=quality control, Initial QC Started就是说编辑刚开始初审，还没有提交给审稿人。  
    这个是编辑部会有个对文章格式、附图等的检查，等着就行了。如果有问题他们会联系你的，关注邮箱或系统吧。  

    **pending**：如投稿后editor assigment pending 等待责任编辑处理  
    审稿后decision pending 目前已外审结束，等待编辑决定（写评论意见ing）  

    with editorial office 编委会讨论决定  
    Transfer copyright form 签版权协议  
    uncorrected proof 等待校对样稿  
    In Press, Corrected Proof 文章在印刷中，清样已校对  
    Manuscript Sent to Production 排版  
    in production 出版中

# Reject & resubmit后的对策和处理

审稿人直接给出意见，或者几位审稿人意见不统一，编辑可能直接拒稿reject，或者处理为拒稿可重投（Reject and resubmit）。  

如果是reject了，那么就只能改投别的杂志了。当然也不能盲目投稿，如果还期待投个IF比较合意的杂志，那么还是要认真考虑审稿人的拒稿意见，针对修改。而如果是reject & resubmit，相当于是给了次机会再修改投稿，务必珍惜。  

一定要充分考虑是否能达到全部审稿人的所有要求，尤其是对待那个别持反对、尖锐意见的审稿人。  

要根据意见逐一修改所有问题，否则此番再投，审稿人还是会觉得没有达到其期望值和满意度，文章必然凶多吉少。我先前投过shock（五年来IF在2.87~3.5之间），经历有些坎坷，是重投后三位审稿人通过两位（有位审稿人纠缠初投时提出的两点意见不放，认为我的回答和修改不满意），编辑拒掉了。当然，如果觉得难度较大，初投被拒可重投时就果断地另外考虑其他杂志投算了。  

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125419.png)

处理被拒：  

1. 理解被国际权威期刊拒稿是一件正常的事情(70%以上被拒)，保持良好心态。
1. 感谢编辑和Reviewer的意见和工作。
1. 询问副主编，自己可以怎样处理这篇论文最合适(重投/改投/撤回)。
1. 继续新的研究或补充修改后改投其他杂志。

# 撤稿

即使文章已经发表了，也有可能会被撤销。在以下几种情况下，我们会给已经发接收函的文章作者发信说明文章不予发表：

1. 稿件接收后，发现作者有一稿多投的情况。一般情况下，在正式发表前，我们会对稿件再作一次Crosscheck检测，一稿多投并且已经发表的文章很容易就被检测出来。

2. 稿件接收后，通过crosscheck检测发现文章存在抄袭行为。检测系统会显示与本文相似度较高的相关文献,一旦与其它文献的相似度达到一定量或者文章抄袭了他人重要的学术思想。

3. 给作者发接收函以后，编辑人员会对文章进行细致的编辑，然后会要求作者进一步修改，如果作者拒绝修改或者修改后仍然无法达到发表要求，编辑部会作出撤销稿件接收决定（这种情况相对来说比较少）。

4. 稿件接收后，发现作者投稿时的邮箱和最终版稿件的邮箱不一致，并且在投稿时使用的邮箱在网上和数据库中均无法查到。

投稿本身就是一件很严肃的事情，撤稿则相当不严肃。实际上，撤稿，除非极特殊的原因，是很坏的行为。不能把稿子发现问题，要重新修改等作为撤稿的借口。你每次投稿，以及相关的行为和结果，都是有记录的。撤稿会严重影响你们课题组的credit。最后导致你们组的稿件会受到特殊“照顾”，可能你以后不投那个杂志了，但可能对今后的师弟师妹投稿造成不良影响。  


---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>科研经验</tag>
        <tag>论文投稿</tag>
      </tags>
  </entry>
  <entry>
    <title>论文写作</title>
    <url>/paper-writing/</url>
    <content><![CDATA[
简单的谈一谈一篇合格的文章应具备的条件，倘若要从合格到优秀，还有很长一段路。坚持即是胜利，科研之路漫漫。一篇合格的SCI论文，甚至说一篇优秀的论文总有几点是必不可少的，如合格的排版、一门编程语言、理论与数学化的描述、专业化的术语与合格的分析结果、模型图及结果的绘制和整理、对比试验、无错误的英语表述等。

<!--more-->

> [LetPub SCI论文写作辅导材料](http://www.letpub.com.cn/index.php?page=sci_writing)

[Deepmind 和纽约大学研究科学家一起作了一场关于如何撰写一篇优秀的研究论文的专题会议](http://www.sohu.com/a/254967611_473283)，从研究人员、审稿人和读者的角度来探讨写作过程，值得研究人员细细品味。

1. 不要等待：要写
2. 确定你的主要想法
3. 讲一个故事
4. 打磨你的贡献点
5. 相关工作：稍后再写
6. 把你的读者放在首位
7. 倾听读者的意见

# 论文作者

**第一作者和通信作者的区别**  

文章的成果是属于通讯作者的，说明思路是通讯作者的，而不是第一作者。第一作者仅代表是你做的，且是最主要的参与者！通信作者（Corresponding author)通常是实际统筹处理投稿和承担答复审稿意见等工作的主导者，也常是稿件所涉及研究工作的负责人。通信作者的姓名多位列于论文作者名单的最后（使用符号来标识说明是Corresponding author)，但其贡献不亚于论文的第一作者。通讯作者往往指课题的总负责人，负责与编辑部的一切通信联系和接受读者的咨询等。  

通信作者标注名称：Corresponding author，To whom correspondence should be addressed,或 The person to whom inquiries regarding the paper should be addressed  
若两个以上的作者在地位上是相同的，可以采取“共同第一作者”（joint first author)的署名方式，并说明These authors contributed equally to the work。  

**作者地址的标署**  

尽可能地给出详细通讯地址，邮政编码。有二位或多位作者，则每一不同的地址应按之中出现的先后顺序列出，并以相应上标符号的形式列出与相应作者的关系。如果第一作者不是通讯作者，作者应该按期刊的相关规定表达，并提前告诉编辑。期刊大部分以星号（\*）、脚注或者致谢形式标注通讯联系人。  

<div id="cover-letter"></div>

# Cover letter

投稿信应该简明扼要，着重描述你研究的重要性和新颖性，以及它们适合目标期刊的范围。

在撰写投稿信之前要在目标期刊的作者指南里确认对投稿信的要求，比如特定的陈述内容。无论你要增加其他什么内容，一定要确保你的投稿信中包含目标期刊作者指南中要求的所有内容。

除了目标期刊要求的所有内容之外，[每封投稿信都应该包含以下几个方面](http://blog.sciencenet.cn/home.php?mod=space&uid=3297845&do=blog&id=1173614)：

- 介绍稿件标题和所投期刊。
- 投稿文章的类型（Letter, communications, article, review还是comments）
- 阐明你所研究课题的重要性，以及与该期刊领域的相关性。
- 列出研究问题。
- 说明主要实验结果和总体发现。
- 提出研究中可以得出的最重要的结论。
- MANDATORY AUTHOR DECLARATION
  - 声明文稿没有发表，也没有考虑在其他期刊上发表，
  - 声明所有作者同意发表该文稿，且同意投往本期刊。
- 增加任何有利于说服编辑将你的文稿送审的详细内容。
- 如果合适的话，你还可以加上一两句话，把你的发现与期刊读者的兴趣联系起来。要考虑到“我的文稿能为期刊带来什么好处?”实事求是地向阅读该期刊的研究人员阐明你所研究课题的新颖性，相关性和趣味性。

```
Dear Editor,

We would like to submit the enclosed manuscript entitled "GDNF Acutely Modulates Neuronal Excitability and A-type Potassium Channels in Midbrain Dopaminergic Neurons", which we wish to be considered for publication in Nature Neuroscience.

GDNF has long been thought to be a potent neurotrophic factor for the survival of midbrain dopaminergic neurons, which are degenerated in Parkinson’s disease. In this paper, we report an unexpected, acute effect of GDNF on A-type potassium channels, leading to a potentiation of neuronal excitability, in the dopaminergic neurons in culture as well as in adult brain slices. Further, we show that GDNF regulates the K+ channels through a mechanism that involves activation of MAP kinase. Thus, this study has revealed, for the first time, an acute modulation of ion channels by GDNF. Our findings challenge the classic view of GDNF as a long-term survival factor for midbrain dopaminergic neurons, and suggest that the normal function of GDNF is to regulate neuronal excitability, and consequently dopamine release. These results may also have implications in the treatment of Parkinson’s disease.

I testify on behalf of all co-authors that our article submitted to Solid State Ionics – Diffusion and Reactions:

1) this material has not been published in whole or in part elsewhere;
2) the manuscript is not currently being considered for publication in another journal;
3) all authors have been personally and actively involved in substantive work leading to the manuscript, and will hold themselves jointly and individually responsible for its content.

Sincerely yours,

...

```

<div id="paper-structure"></div>

# 文章结构

写作即交流。因此，读者体验是首等重要的，所有的写作服务于这一目标。当你写作时，心中要时时有读者。以下四条规则是关于如何赢取读者[^jiqizhixin]。

[^jiqizhixin]: [从标题到反馈：写好一篇论文的十条基本原则](https://www.jiqizhixin.com/articles/2017-10-30-6)

- 规则 1：论文有一个中心主旨，并体现在标题中
- 规则 2：假设写作对象对论文内容一无所知
- 规则 3：坚持原因、内容和结论（Context-Content-Conclusion／C-C-C）结构
- 规则 4：避免委婉，使用并行优化的逻辑流
- 规则 5：在摘要中总结所有要点
- 规则 6：在介绍中讨论这篇论文的重要性
- 规则 7：用多个逻辑相关的陈述句（可辅以图表）给出支持论文中心思想的结果
- 规则 8：讨论如何填补差距、论文的局限性和论文与该领域的相关性
- 规则 9：把时间花费到关键的地方：题目、摘要、图和大纲
- 规则 10：获取反馈，然后简化、重新使用、再次构造这个故事

整体性是指问题提出、解决方法、结果验证之间的强逻辑性，即，**立意要明确有效，证据要丝丝入扣，讨论要引人入胜，结论要坚实确定**。

- 审稿人最感兴趣的是领域内的共性问题。如果没有瞄准共性问题，这个立意就有不明确之嫌。明确的立意之后就是立意的有效，也就是你想要解决的这个问题是不是还是问题，如果已经被别人解决了，那么就是无效的立意。

- 证据绝对是要进行认真排列组合和取舍的，排列的原则就是讨论的逻辑性需要，就像西餐里上菜的顺序。有的作者分不清重要证据和次要证据，二者同等对待的结果就是该说的问题没说清楚，一目了然的问题却在咄咄不休。

- 如果说立意是文章的骨架，证据是文章的肌肉，那么讨论就是文章的神经，讨论部分要让肌肉协调起来，拥立一个骨架。过去有些知名的老期刊要求结果和讨论分开写，这其实是一个很高的要求，讨论可以体现作者的思考深度。

- 当你做好以上三部分，结论自然就非常坚实。结论很容易被忽视，很容易被当做摘要的复述，这是有问题的。好的结论是作者通过这个研究对某种规律、方法有了更深的认识，或者澄清了一个迷惑的问题，如果能有一些预测则更好，但这个预测要客观而谨慎。



## Abstract

学术论文常犯问题之一：**摘要与结论几乎重合**。

大家牢记“起承转合”的四步心法，就能轻松驾驭Abstract的逻辑框架结构。对自己工作及其贡献的总结，a）阐述问题；b）说明自己的解决方案和结果。常用一般现在时和一般过去时。具体来说，一般现在时用于研究背景、目的、结果、结论时，在讨论前景和意义时，也可以用到情态动词can, could, may, would等等。一般过去时用于作者过去的工作、成果的发现和研究过程。

- 起：①研究背景、意义、现状
    - contribute to, major cause, essential, profound impact, play central/important roles in
    - XX have been intensively studied for their role in
    - XX has attracted enormous interest in YY owing to its ZZ actions
- 承：②引出研究对象（为什么做这个研究）
    - XX is a highly attractive candidate for developing YY.
    - XX has been reported to YY.
    - but less is known about their potential role in YY.
- 转：③研究目的或者研究待解决，④研究方法和结果（最重要结果，而不是所有的结果，与结论部分可能重复，作者需要采用不同的句子去描述，而不能够直接拷贝。）
    - The aim of present study was to investigate/Toward this aim, we have examined the role of
    - Better understanding the mechanisms for XX will benefit YY.
    - However, the mechanism through which XX remains virtually/largely controversial/ unknown/unclear/elusive/much less explored/surprisingly limited/less understood, unsolved/scarcely understood
    - On the other hand, moreover, in addition, furthermore, finally
    - In this/current study,
    - We found/demonstrated/observed that
    - Therefore, our study used XX技术/方法/策略
    - XX技术/方法/策略 was used to detect/identify
    - The effects/ roles of XX were determined/analyzed/examined by YY
- 合：⑤研究结论（重点讨论了一个什么现象）
    - Taken together, the findings/results of this study/our data indicate /show /suggest /demonstrate that…..,potentially representing a novel marker/therapeutic target/ XXX may yield therapeutic benefits in the treatment of XX/ have potential as a target for/ providing new insight into developing YY

{% note warning %}
Abstract在撰写中的“五不要”：①不要使用主观情感的词汇，如optimistic，nice, kind; 不要在Abstract中含有作者主观的解释、评论，总之一切要客观如实。②不要使用缩写，代称，在摘要中第一次出现的专业词汇要使用规范化的名称术语的全称表达。③不要在摘要中引用他人文献，如果是背景介绍需要引文，可以在introduction部分体现。④不要把细节问题写得过多，比如数学公式、图表、研究过程、例证，这些内容只需要在正文中来论述，不需要体现在abstract中。⑤不要机械重复文章题目中已经说明的信息或者简单地对题目进行注解，应该在摘要中补充题目中没有提到的必要信息。
{% endnote %}


## Key words

学术论文常犯问题之一：**关键词过于随意**。最常见的问题是：关键词不是实词、关键词由很多单词组成、关键词中包含不少缩写、关键词在前言中没有出现过。

## Introduction

通常情况下，引言可以占到论文的四分之一到三分之一比重。在引言中，作者需要告诉论文评审人、读者这篇论文的意义，让人们看完引言，就能够对作者为什么开展这个研究有大致的了解。使审稿人相信：这个研究工作很重要，值得发表。

文章的“引言”普遍包含以下几个重要环节[^1119692]。

- 环节1：对所研究的大领域进行陈述，这样的陈述提供了一个背景，使读者对研究的问题及其重要性有一个大致了解。
- 环节2：前人对相同问题在不同方面做过的研究，要对这些已有研究做更加具体的陈述，从而建立一个包含已有知识和信息的基础。
- 环节3：指出需要更多的研究来弥补空白，或者拓展已有的研究。
- 环节4：非常具体的陈述指出本文的研究目的，主要的研究工作或结果。
- 环节5：对于开展本研究的作用和重要性的陈述（这点不是所有的文章引言都有）。
- 环节6：对文章接下来内容的概述，这在某些研究领域是必需的。

[^1119692]: [怎样写“引言”才能引人入胜](http://blog.sciencenet.cn/home.php?mod=space&uid=517486&do=blog&id=1119692)

在写作之前，先问问自己如果这篇文章写好以后给整个领域（community）的贡献是什么，这实际上是整个文章的灵魂，也就是你解决某个问题（problem）的方案（idea）。想清楚以后把它（们）按照重要性顺序写下来，这些就是你在Introduction里面告诉读者包括审稿人的contributions。贡献可能是新算法，新架构，新实现或者是前人没有的insights。你在写contributions的时候面向的读者很有可能是自己，所以可能忽略了problem背景和定义，这些就可以慢慢在Introduction里面填充。这样Introduction就写好了，比如说：某某问题是实际中存在的一个问题，这个问题重要性是blah，blah，blah。之前发表的论文针对这个问题提出了三个有代表性的解决方案（此处引用可能至少三篇论文）。第一个解决方案甲大概做了一二三，但是没做四；第二个解决方案乙做了一四，但是没做二三；第三个解决方案丙做了一二三四，但是性能比较差。在这篇文章中，我们提出一个性能比较好并且同时做一二三四的解决方案。接下来写我们这个解决方案是如何实现同时支持一二三四的情况下提升性能的。比如说用了新算法，新架构或者新的实现，都可以。讲完基本技术创新点以后就是contributions，把之前想好的贴上去就可以了。最后在Intro里面加上后续内容组织，比如说第二章是相关工作，第三章是综述[^answer/81787300]。

[^answer/81787300]: [如何写好一篇高质量的IEEE/ACM Transaction级别的计算机科学论文?](https://www.zhihu.com/question/22790506/answer/81787300)

首先，我们要告诉他们这是怎样的一个领域，主要研究的对象是什么，研究方法是什么，近些年取得了怎样的发展；简称为：**做什么+怎么做+新鲜事**。

其次，我们要告诉他们这样一个领域它的研究目的是什么；简称为：**什么用**。

再次，我们要告诉他们，我的研究在这样一个研究背景下着重那一部分，以及我选择这样一个研究重点有什么意义/原因，而研究的意义多跟研究现状的不足相关；简称为：**着重点+为什么**。

最后，我们要告诉他们，接下来我会跟大家以什么样的顺序讲哪些内容。让读者有一个鲜明的预期；简称为：**列目录**。

因此，引言叙说要客观有逻辑（所谓客观，就是要引用现有研究成果来组织叙说，最好每句话都有出处，有已经得到验证的学术理论支持，而不是自己在那里主观叙说），[倒三角叙说](http://blog.sciencenet.cn/home.php?mod=space&uid=3316383&do=blog&id=1252506)从大的主题范围(general background and broad topic）逐步缩小到你的主题（specific background and topic）, 相关研究回顾和目前的知识差距（related works and their contributions to the literature, knowledge gap），最终引出自己要研究的问题(research question(s))或假设(hypothesis or hypotheses)以及本文将如何展示这个研究结果。

学术论文常犯问题之一：**前言引文不科学**。引言常出现的问题主要包括：1）引言过短。2）重要文献缺失。3）文献引用只是简单的罗列，而引文之间没有太多逻辑。4）引言中同一位置引用文献过多。

> a）题X是重要的；b）前人的工作A、B曾经研究过这个问题；c）A、B有一些缺，A法只能求解特殊X问题，B法原则上适用于所有各种缺陷分布，但是求解中遇到问题；d）我们提出了方法D；D，克服问题，e）D的基本特征，和A、B进行比较；f）实验证明D比A、B优越；数值实验证明D达到A的精度，同时可以求解A不能处理的X问题。由于克服问题，D的精度也大大提高。g）文章的基本结构，大纲。

区分引言与结论最简单的方法是把引言看作是你研究之前的知识状态，而结论是研究之后的知识状态。

##  Previous Work

说明自己与前人的不同。a）将历史上前人的工作分成类别；b）对每项重要的历史工作进行简短的回顾(一到几句)，注意要回顾正确，抓住要点，避免歧义；c）和自己提出的工作进行比较；d）不要忽略前人的重要工作，要公正评价前人的工作，不要过于苛刻；e）强调自己的工作和前人工作的不同，最好举出各自适用例子。

从最Related的论文开始写起，比如说以上提到的三篇。这里需要着重讲的是，Related Work不是记流水账（e.g.，甲用了idea A，乙用了idea B，丙用了idea C），而是要比较这些论文，阐述她们各自的优缺点。

##  Our Work

描述自己的工作，可分成多个部分。

a）从读者角度阐明定义和表示法；
b）提供算法的伪码，图解和相应解释；
c）用设问的方式回答读者可能提出的潜在问题；
d）复杂的冗长的证明和细节可以放在附录中，这里关键是把问题阐述清楚；
e）特例和例外应该在脚注中给予说明。

##  Experiments

验证提出的方法和思路[^3344631/1142237]。

- 合理地设计实验（简洁的实验和详尽的实验步骤）；
- 必要的比较，突出科学性；
- 讨论，说明结果的意义。您必须对所展示的数据提供一个很好的解释说明。在行文讨论的时候，请尽量避免写过长的句子。如果你觉得讨论部分很难写，建议你按如下四点展开反复论述：
    - 重申你的重要研究发现；
    - 解释这个发现结果；
    - 这个研究内容的局限性；
    - 这个研究内容的意义；
- 给出结论。您的结论应该建立在数据的基础上。**确保您的结论与您所展示的数据直接相关**，而不是建立在未被阐明的（或未被证明的）假设上。

[^3344631/1142237]: [关于论文方法、讨论和结论的写作要点](http://blog.sciencenet.cn/home.php?mod=space&uid=3344631&do=blog&id=1142237)

在一篇论文中，实验描述的比重虽然不是很大，但是还是需要尽可能地表达清晰，目的是告诉读者，你所使用的试验方法、技术手段而获得的结果是可靠的。确保您彻底地回答这一问题。如果内容过多，将重点放在最相关／重要的方法上，额外的实验细节可以通过补充材料（仅限于线上）章节或参考资料来介绍。

一方面，读者看到这篇论文的时候，如果他们想重复做一次，他们能够按照步骤重复出来。另一方面，实验条件变化一点，结论就可能完全不一样。

学术论文常犯问题之一：**结果部分逻辑比较混乱**。具体常见的问题包括：1）研究结果只是简单的罗列，而没能把里面的关系弄清楚。2）到底先写那一部分，作者没有计划。3）实验部分说做了某某研究，但是，在研究结果中就完全没有看到这些结果。还有的情况是在结果部分写了某一些结果，但是就是不知道这些结果从哪里冒出来的，在研究方法中没有提及。

论文图表常出现的问题如下：1）图片中字特别小，要用放大镜才能够看清晰。2）多个图片放在一起。3）实验曲线，不增加误差棒。4）图片比例值不统一。

##  Conclusion

总结、前景及结文。a）快速简短的总结；b）未来工作的展望；c）结束全文。

正常情况下，一篇学术论文只需要围绕一个核心问题即可。也因此，论文的结论写上3-4条就很多了。

对于论文的结论部分，不再需要把为什么做这个研究、怎么做这个研究说一遍了。正常情况下，应该**直接明白**地概述所发现的现象、结果（1）、（2）、（3）。在阅读完您的文章后，读者应该明确的知道他们为什么应该在意您的研究，让人一看就知道论文发现了哪些现象、提出了哪些观点。不要让他们思考为什么您的研究有相关性。

- 哪些是你通过研究获得的成果？这些内容为什么重要？
- 你的论文是否证实或否定了其他已发表的成果？
- 你的研究提出了什么问题，是否还有进一步研究的潜力？

如果写到这里你还有充足页面可用，你可以试图写一个discussion章节来讨论你的方案的缺点，以及未来有可能的改进情况。不要怕展示缺点，你越诚恳审稿人对你印象越好。如果你是故意遗漏新方法的一个很显然的缺点，这会给审稿人非常不好的印象。你也可以提一些你的方案的其他应用等等。

##  References

对相关重要背景文献的全面引用。a）选择引文（众所周知的结论不必引用，其他人的工作要引用）；
b）与前文保持一致。

##  Others

致谢、附录、脚注。

以上就是关于一篇合格论文所需要素的内容，可以看出，仅仅要完成一篇合格的论文就需要这些套路，并不容易。

<div id="paper-tense"></div>

# 文章时态

英语谓语动词时态共有16种，在英文科技论文中用得较为频繁的主要有三种：即一般现在时、一般过去时和将来时。正确地使用动词时态是科研写作的基本功，我们在撰写英文论文时，如不能正确选用时态，常常会改变文章所要表达的意思，从而影响评审专家与读者的理解。

一篇典型的科技论文有一个[基本的框架结构](#paper-structure)：Abstract (综述科研背景，提出研究的问题和假设(hypothesis))，Materials and Methods (描述自己的研究方法)，Results (分析所得的研究结果)，Discussion (深入讨论研究结果的意义并简要指出将来的研究方向)。我们现根据这个论文框架，就一些规律性问题做些探讨，希望对大家有所帮助[^page=sci_writing_2]。

[^page=sci_writing_2]: [如何在科技论文中使用时态 - LetPub SCI论文写作系列2](http://www.letpub.com.cn/index.php?page=sci_writing_2)

首先应该把握以下三个基本要点：

- 一般现在时：主要用于不受时间限制的客观存在事实的描述，或发生或存在于写论文之时的感觉、状态、关系等的描述或致谢的表述等。值得注意的是，出于尊重，凡是他人已经发表的研究成果作为"previously established knowledge"，在引述时普遍都用一般现在时。
- 一般过去时：用于写论文中作者自己所做工作的描述。例如描述自己的材料、方法和结果。
- 一般将来时：用于撰写论文之后发生的动作或存在的状态。例如提出下一步的研究方向。

## 摘要（Abstract）

在摘要部分，会总结所做的实验，展示结果和总体结论。在大多数生命科学论文中，这些信息都是用**过去时**来表示的。在物理科学论文中，有时会使用现在时。如果提及到计划中的后续实验，您也可以使用将来时。

## 概述（Introduction）

引言这个部分，主要展示前人研究的事实和信息，使用现在时的情况最多。然而，有时过去时才是合适的。

- 概述中的研究背景通常会引用相关学科中广为接受的原理或事实，以及你所做研究的重要性，这些通常采用**现在时**。例如：Genomics provides crucial information for rational drug design.

- 在概述中也可能引用与你从事项目相关的一些研究结果，为表达你对该研究结果仍坚信其正确性及相关性，即使已经是很久以前的研究结果，可使用**现在时**。

    - Many of the lakes and wetlands in the region are located in craters or valleys blocked by early Pliocene lava flows (Ollier & Joyce, 1964).
    - Garcia (1993) suggested that under certain conditions, an individual’s deposit income is the same as the income from purchased national debt, thus changes in the amount of bank loans and deposits caused by changes in the amount of reserves will eventually affect the bond price.


- 你可能会说某些作者说的某事是真实的。比如，“X et al. showed (过去时) that DNase I cleaves (现在时) DNA.”在这种情况中，过去时是用来表明研究是在现在之前进行的。而现在时用来表明他们所发现的事物，现在是并且将一直是正确的。

- 如果引用的是**一些已经过时或失效的科研结果，动词要使用过去时**。
  - Nineteenth-century physicians held that women got migraines because they were "the weaker sex," but current research shows that the causes of migraine are unrelated to gender.（注意这里从过去时态过渡到现在时态）

## 材料与方法（Materials and Methods）

对写论文之前自己所做工作的描述，通常采用**一般过去时**，因为这个实验是在手稿准备前做的（希望如此！）。在某些领域，比如工程学，也可能使用现在时。

- （例1） Total phosphorous (TP) and total nitrogen (TN) were measured in the laboratory using standard procedures.
- （例2）The standard protocol was followed for the preparation of the media from stock solutions.

## 结果（Results）

1. 结果部分描述了研究中的发现，通常情况下，发现是在过去完成的。对自己得出的研究结果，采用**过去时**进行详细的阐述。

    - （例1）Overall, more than 70% of the insects collected were non-phytophagous.
    - （例2） Following activation of NT oocytes with strontium, the cell cycle resumed in both groups.

1. 当提及图表时，必须使用**现在时**，因为现在图片表格在文中是可见的，读者是可以看到的。。

    - （例1） Figure 1 displays the comparative variation in the morphology of donor chromatin in both age groups of oocytes.  
    - （例2） Table 1 below shows the stream flows calculated for each stream using Equation 1.

## 讨论（Discussion）

1. 在呈现研究界普遍接受的众所周知的事实或信息时，采用**现在时**表达。

    - Removal of vegetation for agricultural purposes appears to negatively affect the water quality of streams.

1. 在讨论部分，分析现有结果，并与以往研究做比较。这部分大部分应该用**过去时**来写，并采用**现在时**对研究结果进行讨论与解释。

    - （例1）Weight increased as the nutritional value of feed increased. These results suggest that feeds higher in nutritional value contribute to greater weight gain in livestock.（注意这里用过去时描述了实验发现，但在讨论这个发现的意义时用的是现在时。）  
    - （例2）Leaf carbon and phenolic content did not differ across sites, indicating that the response of
    secondary plant chemicals such as phenolics to water is complex.（这句的描述几乎没有假设的意思，表示作者坚信其研究结果和结论的正确性及相关性）

1. 如果在本节讨论如何改进实验或概括未来的实验时，也可以用到**将来时**。

## 结论（Conclusion）

可用多种时态，使用**过去时**强调过去的研究成果，并可采用**现在时或将来时**表达未来的研究方向或研究前景。

- Although the study found evidence of tillage and irrigation within the study area, from the data collected it was not possible to determine if the effects of agriculture upstream cause (or caused) higher levels of total nitrogen downstream. Further studies are therefore necessary to determine the effects of agriculture on the health of Stringybark Creek.

<div id="paper-words"></div>

# 单词和短语

如果英语不是你的母语，那么用英文写作已经够难了，但用英文写科技相关的内容更难。有那么多的词汇听起来都一样，却意指完全不同的事物。亦或是短语，如果不正确使用，可能会使原本合理的工作变得看起来是错误的。但是，别让用词混淆变成习惯！请查看以下[关于科技写作中一些经常遇到的词汇和短语的正确使用列表](http://blog.sciencenet.cn/home.php?mod=space&uid=1232242&do=blog&id=1089253)。

# 改写技巧

重新叙述或改写(Paraphrasing)是将别人的话重新用自己的话叙述，而不是直接引用。

使用以下的方法来精进你的改写技巧：

- 更换句子主被动语态时(主被动互换)，你可以改变你改写时使用的一般结构并替换进你自己常使用的字。
- 使用[thesaurus](https://www.thesaurus.com/)找同义词或相关短语
- 利用明确的动词来提醒。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fyree8bivdj20sg067q5e.jpg)
- 使用特定的明确动词来表示你的立场
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fyreeoxo2cj20sg06vtcs.jpg)
- 尽量使用自己的语气陈述并搭配从原文当中撷取的关键字，整合原文的三四个句子成一句或两句。

# 拼写检查

- [Grammarly](https://www.grammarly.com/): Free Writing Assistant
- [Linggle](https://linggle.com/)
- [Typely](http://typely.com/) - free online proofreading
- [Writefull](https://writefullapp.com/) | A new way of writing with confidence
- [Ginger Software](https://www.gingersoftware.com/) | English Grammar & Writing App

<div id="paper-plot"></div>

# 制作漂亮的插图

> [论文怎样做图才算清晰？](http://blog.sciencenet.cn/home.php?mod=space&uid=758188&do=blog&id=1088930)

强烈推荐 Python 的绘图模块 [matplotlib: python plotting](http://matplotlib.org/) 。画出来的图真的是高端大气上档次，低调奢华有内涵~ 适用于从 2D 到 3D，从标量到矢量的各种绘图。能够保存成从 eps, pdf 到 svg, png, jpg 的多种格式。并且 Matplotlib 的绘图函数基本上都与 Matlab 的绘图函数名字都差不多，迁移的学习成本比较低。开源免费[^story/8831559]。

[^story/8831559]: [想在论文中画出漂亮的插图，介绍一个利器](http://daily.zhihu.com/story/8831559)
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>科研经验</tag>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>Parameter Selection</title>
    <url>/parameter-selection/</url>
    <content><![CDATA[
模型的参数可分成两类：参数与超参数，前者是模型通过自身的训练学习得到的参数数据；后者则需要通过自身经验设置，以提高模型训练的效果。如神经网络中的隐层个数、每个隐层神经元个数、采用什么激活函数及学习算法、学习率以及正则化系数等都属于超参数。

<!--more-->

一个模型的落地流程如下：

1. 收集日志，并从日志中抽象出特征，再把特征喂给模型，模型在初始的超参数指导下学习第一类参数；
1. 通过离线效果指标评估超参数的设定是否合适；
1. 若不合适则继续不断调整。

在这个调参过程中主要有 2 个难点：

1. 参数空间大，尝试成本高。在工业界往往数据规模巨大、模型复杂，计算成本很高，并且每个类型的超参数都有众多选择。
2. 目标模型是黑盒。在搜索超参数的过程中只能看到模型的输入和输出，无法获取模型内部信息（如梯度等），亦无法直接对最优超参数组合建立目标函数进行优化。

# 超参数选择方法

业界常用的搜索超参数方法主要有网格搜索、随机搜索和贝叶斯优化。

## 网格搜索

网格搜索（Grid Search）是指在所有候选的参数选择中，通过循环遍历尝试每一种可能性，表现最好的参数就是最终的结果。

举个例子，有两类超参数，每类超参数有 3 个待探索的值，对它们进行笛卡尔积后得到 9 个超参数组合，通过网格搜索使用每种组合来训练模型，并在验证集上挑选出最好的超参数。

网格搜索算法思路及实现方式都很简单，但经过笛卡尔积组合后会扩大搜索空间，并且在存在某种不重要的超参数的情况下，网格搜索会浪费大量的时间及空间做无用功，因此它只适用于超参数数量小的情况。

## 随机搜索

针对网格搜索的不足，Bengio 等人提出了随机搜索（Random Search）方法[^volume13/bergstra12a]。随机搜索首先为每类超参数定义一个边缘分布，通常取均匀分布，然后在这些参数上采样进行搜索。

[^volume13/bergstra12a]: http://www.jmlr.org/papers/volume13/bergstra12a/bergstra12a.pdf

随机搜索虽然有随机因素导致搜索结果可能特别差，但是也可能效果特别好。总体来说效率比网格搜索更高，但是不保证一定能找到比较好的超参数。

## 贝叶斯优化

举个简单的例子，假设关于模型最优超参数组合的函数是一维曲线，由于它是一个黑盒无法直到具体的函数形式，但是可以输入某些值并得到输出。我们随机尝试了 4 个超参数，并得到了对应的性能指标，如下图所示[^slides/LancasterMasterclass]。

[^slides/LancasterMasterclass]: http://gpss.cc/gpmc17/slides/LancasterMasterclass_1.pdf

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125349.png)

那么问题来了，最优超参数可能在哪里？下一个待探索的超参数是哪个？而每个人猜测的是不一样的，因此每次生成的函数也不同：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmacy1g1j20e4099mz6.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmb4x4o7j20e9097aev.jpg)

可以看到大部分都认为最优超参数是在第 3 个点附近， 由于开始时在右侧采点的离线指标是最差的，所以先验认为最优超参数在这里的可能性不大。接着把这个过程取极限，就会得到一个关于最优超参数的概率分布。假设每个分布都是高斯分布，那么得到的是一个高斯过程，其中高斯分布的均值为 0，方差大概为 5。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmbqiit1j20dk08tgnh.jpg)

这样无论我们猜测最优超参数是取哪个值，总能得到一个关于超参数好坏的描述，即是均值和方差，这里实际上我们用一个无限维的高斯过程来模拟黑盒的超参数搜索的目标函数形式。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmclb1caj20er05n0v9.jpg)

总结来说，超参数搜索问题其实是一个黑盒优化问题，贝叶斯优化通过无限维的高斯过程来描述黑盒，在这个高斯过程中可以得到每一组输入超参数的均值和方差。

得到了均值和方差则解决了上文提到的第一个问题：「最优超参数可能在哪里？」，那么下一个待探索的超参数是哪个？这其实是一个 E&E 问题（探索与利用问题），是稳妥地在目前已有的最大值附近搜索还是在不确定性大的地方搜索？后者效果可能很差，但也可能有意想不到的收获。而 Acquisition function 正是平衡 E&E 问题的方式。

- Upper (lower) Confidence Band 方法用线性加权的方式直接对 E&E 采样进行平衡，第一项是当前最好的超参数值，在当前最好的结果附近稳妥的搜索；第二项是方差，表示去探索更未知的空间，beta 参数用来控制力度，这种方法简单有效。
- Maximum Probability of Improvement 方法的目的是下一个待搜索的值能最大限度提升概率，假设当前最好的是 y_best, 那么 MPI 表示的是下一个待搜索的点能比 y_best 小的概率，这种方法容易陷入在局部最小值附近。
- Expected Improvement 描述的是下一个待搜索的点能比当前最好的值更好的期望，因为是高斯过程，这里的后验概率是高斯形式，积分有闭式解，实现起来较为简单，因此这种方法也较为常用。

可以看出贝叶斯优化（Bayesian Optimization）是通过 acquisition function 平衡均值和方差，做 E&E 问题探索下一个可能的最优超参数。

### 实例1

如上方图所示，虚线代表关于最优超参数的真实函数形式（但实际上它是个黑盒，不知道其具体形式），实线代表当前最好的超参所在位置，两条浅灰线表示的是当前点的方差。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmklr1ldj20eg09g75w.jpg)

下方图表示已知的和待探索超参数的 Expected Improvement，此时很多地方都有希望能取得比当前最好值更好的超参数，主要需要探索，我们首先选择 0.0 点作为下一个待探索的超参数。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmkvex6sj20eh09fabx.jpg)

可以看到，此时 0.0 点的方差变为 0。继续寻找下一个待探索的超参数，选择 1.0。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmla95ztj20ej09ggnr.jpg)

如图，1.0 点的方差变为 0，经过两次探索我们注意到不需要再探索右侧区域，因为我们在右边得到的超参数效果比左边的差。继续选择下一个超参数位置，选择 0.25 点左右的位置。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmlkta65j20er09kdi8.jpg)

按照 EI 方法，依次寻找下一个待探索的超参数，这次我们选择的超参数位置大概在 0.7 点。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmluu7daj20en09jdi0.jpg)

选择 0.7 点的超参数效果比之前选择的更好，此时 Expected Improvement acquision 建议应该加大在 0.7 附近搜索的力度。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmm44e8dj20en09i0un.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmmdy6doj20eq09lq4t.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fwsmmjijpij20er09kjt6.jpg)

经过几轮探索之后发现最优超参数应该在 0.8 点附近。

# SVM Parameter Selection

Support Vector Regression, which evolved from the support vector classification for doing regression tasks by introduction of the $\varepsilon$-insensitive loss function, is a data-driven machine learning methodology.

The parameter $C$ controls the trade-off between the complexity of the function and the frequency in which errors are allowed. The parameter $\sigma$ affects the mapping transformation of the input data to the feature space and controls the complexity of the model, thus, it is important to select suitable parameters, and the value of parameter $\sigma$ should be selected more carefully than $C$ .

<div class="note info"><p>Li, S., Fang, H. & Liu, X., 2018. Parameter optimization of support vector regression based on sine cosine algorithm. Expert Systems with Applications, 91, pp.63–77. Available at: http://dx.doi.org/10.1016/j.eswa.2017.08.038.  </p></div>

<div class="note info"><p>Li, S., Fang, H., 2017. A WOA-based algorithm for parameter optimization of support vector regression and its application to condition prognostics. 2017 36th Chinese Control Conference (CCC). Available at: http://dx.doi.org/10.23919/chicc.2017.8028516.</p></div>

## Metaheuristics

- [libsvm matlab implement](https://github.com/faruto/Libsvm-FarutoUltimate-Version)
- [Metaheuristics implement in Matlab&Python](http://yarpiz.com/category/metaheuristics)

The matlab samples for svm parameter selection can be found in my [Source repository](https://github.com/sli1989/svm-parameter-selection).

To be continued...
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>OptimizationAlgorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>粒子滤波</title>
    <url>/particle-filter/</url>
    <content><![CDATA[
粒子滤波就是指：通过寻找一组在状态空间中传播的随机样本来近似的表示概率密度函数，用样本均值代替积分运算，进而获得系统状态的最小方差估计的过程，这些样本被形象的称为“粒子”，故而叫粒子滤波。

<!--more-->

> [Particle Filter Tutorial 粒子滤波：从推导到应用（一）到（ 四 ）](http://blog.csdn.net/u012211419/article/details/49819883)  
> [粒子滤波原理](https://zhangquan1995.github.io/2017/07/20/粒子滤波原理/)

# 贝叶斯滤波

假设有一个系统，我们知道它的状态方程和测量方程如下：

$$
\left\{ \begin{array}{l}
{x_k} = f\left( { {x_{k - 1}}} \right){\rm{ + }}{\omega _ {k - 1}}\\
{z_k} = h\left( { {x_k}} \right){\rm{ + }}{\upsilon _ k}
\end{array} \right. \tag{1}$$

其中$x$为系统状态，$z$为测量到的数据，$f$,$h$是状态转移函数和测量函数（有界非线性映射函数），$w$,$v$为过程噪声和测量噪声，噪声都是独立同分布的。

贝叶斯估计的主要目的是在已知系统初始状态、噪声特性以及测量信息$z_{1:k}$的条件下，递推出$k$时刻状态变量$x_k$的可信度。实际上，贝叶斯原理的实质是通过**预测和更新**系统状态变量的先验概率密度来得到后验概率密度（可信度）$p(x_k|z_{1:k})$ ，这是一个将先验知识与测量数据加以综合的过程，由此获得状态的最优估计。

- 预测过程是利用系统模型$(1)$预测状态的先验概率密度，也就是通过已有的先验知识对未来的状态进行猜测，即$p(x_k|x_{k-1})$。
- 更新过程则利用最新的测量值对先验概率密度进行修正，得到后验概率密度，也就是对之前的猜测进行修正。


一般都先假设系统的状态转移服从一阶马尔科夫模型，即当前时刻的状态$x_k$只与上一个时刻的状态$x_{k-1}$有关。时，假设$k$时刻测量到的数据$z_k$只与当前的状态$x_k$有关，如上面的状态方程$(1)$。

# 基于粒子滤波的故障预报

对于动态系统的状态空间模型，剩余寿命预测问题转化为一个已知系统未来状态的估计问题。采用数据驱动的方法预测未来一段时间内对象系统的监测信息，从而将未来时刻状态变量的先验分布的预测问题转化为一个求解后验分布的
估计问题[^REF1]。

[^REF1]: 基于油液光谱分析和粒子滤波的发动机剩余寿命预测研究


# 多步预报

多步预测是基于前期预测结果对系统状态进行长期前向预测，并根据系统噪声模型不断调整其概率，目的是对系统的剩余寿命进行估计。$p$步前向预测以当前$k$时刻的系统状态估计为始点，预 测$k+p$时 刻 动 态 系 统 状 态 的 概 率 密 度。基于PF算法 获 得 当 前$k$时 刻 状 态 变 量 的 概 率 密 度估计值以后，就可以对未来$k+p$时 刻 系 统 状 态 的 先 验概率密度函数进行预测。

$k+p$时刻系统的剩 余 寿 命 预 测 是 利 用 多 步 前 向 预 测 的结果，对设备剩余寿命的概率密度函数进行预测。对系统的剩余寿命进行预测，必须确定一个具体的风险域，在此风险域内认为设备具有非常高的故障概率。风险域一般是通过对历史故障数据的分析，并 结 合 装 备 维 修 人 员 的 建 议 确 定 的。一旦确定了风险域，就可以利用后验概率密度预测值对装备系统的剩余寿命概率密度函数进行估计.
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>StateEstimation</tag>
      </tags>
  </entry>
  <entry>
    <title>相空间重构</title>
    <url>/phase-space-reconstruction/</url>
    <content><![CDATA[
一般的时间序列主要是在时间域中进行模型的研究，而对于混沌时间序列，无论是混沌不变量的计算，混沌模型的建立和预测都是在所谓的相空间中进行，因此相空间重构就是混沌时间序列处理中非常重要的一个步骤。

<!--more-->

所谓混沌序列，可以看作是考察混沌系统所得到的一组随着时间而变化的观察值。假设时间序列是 $\{ x(i): i=1,\cdot \cdot \cdot, n\}$，那么吸引子的结构特性就包含在这个时间序列之中。为了从时间序列中提取出更多有用的信息，1980年Packard等人提出了时间序列重构相空间的两种方法：导数重构法和坐标延迟重构法。而后者的本质则是通过一维的时间序列$\{x(i)\}$的不同延迟时间 $\tau$ 来建$d$维的相空间矢量

$$y(i)=(x(i),...,x(i+(d-1)\tau)), 1\leq i\leq n-(d-1)\tau$$

1981年Takens提出嵌入定理：对于无限长，无噪声的$d$维混沌吸引子的一维标量时间序列$\{x(i): 1\leq i \leq n\}$都可以在拓扑不变的意义下找到一个$d$维的嵌入相空间，只要维数$d\geq 2d^{'}+1$。根据Takens嵌入定理，我们可以从一维混沌时间序列中重构一个与原动力系统在拓扑意义下一样的相空间，混沌时间序列的判定，分析和预测都是在这个重构的相空间中进行的，因此相空间的重构就是混沌时间序列研究的关键。

# 嵌入维数和延迟时间

> 参考文献：[时间序列模型之相空间重构模型](https://zr9558.com/2015/09/14/phasespacereconstruction/)

关于嵌入维数$d$和延迟时间$\tau$的取值，通常有两种观点：第一种观点认为$d$和$\tau$是互不相关的，先求出延迟时间之后再根据它求出合适的嵌入维数。求出延迟时间$\tau$比较常用的方法主要有自相关法，平均位移法，复自相关法和互信息法等，关键的地方就是使得原时间序列经过时间延迟之后可以作为独立的坐标来使用。同时寻找嵌入维数的方法主要是几何不变量方法，虚假最临近法(False Nearest Neighbors)和它改进之后的Cao方法等。第二种观点则是认为延迟时间和嵌入维数是相关的。1996年Kugiumtzis提出的时间窗长度则是综合考虑两者的重要参数。1999年，Kim等人提出了C-C方法，该方法使用关联积分同时估计出延迟时间和时间窗。

延迟时间的确定：自相关系数法，交互信息法

嵌入维数的确定：几何不变量法，虚假最临近点法，虚假最临近点法的改进Cao方法

## C-C

```
%% 计算嵌入维数 Num_m 和延迟时间 Num_tau
[Num_Smean,Num_Sdeltmean,Num_Scor,Num_tau,Num_m]=C_CMethod_inf(Y_series,20);
```


# 构造相空间矩阵

## 方法1

```
% 默认tau=1

x=data1;
learnlength=800;% 已知数据集长度
trainlength=700;% 训练数据集长度
testlength=learnlength-trainlength;% 测试数据集长度
xlearn=x(1:learnlength);

%% 训练step_to_predict步预测的模型
xtrain=x(1:trainlength);
% 对于一维数据，必须列向量
step_to_predict=10;
embdim=70; % embedding dimension
%构造全输入输出矩阵
X=windowize(xtrain,1:embdim+step_to_predict);
%inputs of the training data，取embedding dimension维数
Xtrain = X(:,1:embdim);
%outputs of the training data，取最后一列
Ytrain= X(:,end);
%  1,...,70－－－－>80
%  2,...,71－－－－>81
%  629,...,690－－－－>700

%% 测试
% 能够预测的个数
ntest=testlength-step_to_predict+1;
for j=1:1:ntest
    % 从trainlength开始向前预测
    test_matrix=xlearn(trainlength-embdim+j:trainlength+j-1);
    %  691,...,700－－－－>710
    %  692,...,701－－－－>711
    %  790,...,799－－－－>800
    Xt=test_matrix';
    Yt=simlssvm({Xtrain,Ytrain,type,gam,sig2,'RBF_kernel','preprocess'},{alpha,b},Xt);
    Ytest(j)=Yt;
end
```

## 方法2

训练集调用 PhaSpaRecon 函数。

```
input_data = ; % 需为行向量 <1 x n double>
n_all_temp=length(input_data);
step_ahead = ; % 定义测试集长度
n_train_temp=n_all_temp-step_ahead;
Num_tau= 1; % 定义重构时延
Num_m= 10; % 定义重构维数
[x,y]=PhaSpaRecon(input_data(:,1:n_train_temp),Num_tau,Num_m);
p_train=x'; % 输入，注意预测模型的输入维度，是否转置
t_train=y';% 输出，注意预测模型的输入维度，是否转置
```

测试集调用 PhaSpaRecon 函数。
```
%% 测试
step_to_predict=1; %预测长度
% 能够预测的个数
ntest=step_ahead-step_to_predict+1;
for j=1:1:ntest
    % 从n_train_temp开始向前预测，真实input_data作为输入
    p_test=input_data(n_train_temp-Num_m+j:n_train_temp+j-1);
    %  691,...,700－－－－>710
    %  692,...,701－－－－>711
    %  790,...,799－－－－>800
    p_test=p_test'; % 输入，注意预测模型的输入维度，是否转置
	t_test= ; % 预测模型输出
    Ytest(j)=t_test;
end
```


```
function [xn,dn] = PhaSpaRecon(s,tau,m)

% 混沌序列的相空间重构 (phase space reconstruction)
% [xn,dn] = PhaSpaRecon(s,tau,m)
% 输入参数：    s          混沌序列
%               tau        重构时延
%               m          重构维数
% 输出参数：    xn         相空间中的点序列(每一列为相空间中一个点)
%               dn         一步预测的目标

len = length(s);
if (len-1-(m-1)*tau < 1)
    disp('err: delay time or the embedding dimension is too large!')
    xn = [];
    dn = [];
else
    xn = zeros(m,len-1-(m-1)*tau);
    for i = 1:m
        xn(i,:) = s(1+(i-1)*tau : len-1-(m-i)*tau);   % 相空间重构，每一列为一个点
    end
    dn = s(2+(m-1)*tau : end);    % 预测的目标

    % 举例分析
    % xn的列向量作为输入，dn的列向量作为输出
    % 相空间重构，每一列为一个点
    % len=100,tau=1,m=10
    % xn(1,:)=s(1:90)
    % xn(2,:)=s(2:91)
    % xn(10,:)=s(10:99)
    % dn=s(11:end)
    %  1,2,...,10－－－－>11
    %  2,3,...,11－－－－>12
    %  90,91,...,99－－－－>100

    % len=100,tau=3,m=10
    % xn(1,:)=s(1:72)
    % xn(2,:)=s(4:75)
    % xn(10,:)=s(28:99)
    % dn=s(29:end)
    %  1,4,...,28－－－－>29
    %  2,5...,29－－－－>30
    %  72,75,...,99－－－－>100

end
```

构造训练数据集、测试数据集。

```
interval = 4;
[xn_train,dn_train,xn_test,dn_test] = TrainTestSample(interval,xn,dn);

% 相空间中点的轨迹分解成：训练样本与测试样本
% 在所有样本中，每隔 interval 个样本为训练样本，其余为测试样本
```

```
function [TrainFeature,TrainKnnTarget,...
          TestFeature, TestKnnTarget]...
           = TrainTestSample(interval,FeatureArray,KnnTarget);
% 将特征矩阵分解成：训练样本与测试样本

[row,column] = size(FeatureArray);
TrainColumn = 1:interval:column;       % 训练样本的列数
Column = 1:column;                        
Column(TrainColumn) = [];              % 删除训练样本的列数,余下的是测试样本列数
TestColumn = Column;                   % 测试样本的列数

%========= 训练样本 ========%        

TrainFeature = FeatureArray(:,TrainColumn);       % 训练样本
TrainKnnTarget = KnnTarget(:,TrainColumn);        % 训练目标

%========= 测试样本 ========%        

TestFeature = FeatureArray(:,TestColumn);         % 测试样本
TestKnnTarget = KnnTarget(:,TestColumn);          % 测试目标
```

## 方法3

```
function Data=reconstitution(data,N,m,tau)
%该函数用来重构相空间
% m为嵌入空间维数
% tau为时间延迟
% data为输入时间序列
% N为时间序列长度
% Data为输出,是m*n维矩阵
M=N-(m-1)*tau;%相空间中点的个数
Data=zeros(m,M);
for j=1:M
  for i=1:m           %相空间重构
    %Data(i,:)=data(((i-1)*tau+1):1:((i-1)*tau+M));
    Data(i,j)=data((i-1)*tau+j);
  end
end
```

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>PhaseSpaceReconstruction</tag>
      </tags>
  </entry>
  <entry>
    <title>华中科技大学博士毕业流程</title>
    <url>/phd/</url>
    <content><![CDATA[
在[Michael Duan](http://www.52souji.net/about.html) 的个人博客基础上介绍华中科技大学博士毕业全过程，并修改为**自动化学院**毕业流程。

<!--more-->

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1fkbsqhztkaj20wh0haq4b.jpg)

<div class="note info"><p>[华中科技大学博士毕业文档](https://pan.baidu.com/s/1leAhAlmzs21r3ftsZVtgAA)集合（提取码：rchs）
</p></div>

# 预答辩

部分学院学术委员会初步筛选，避免结果不顺利导致记录档案。

## 补各种报告和表

> 该生研究工作顺利，符合要求，通过考核。

这里提到的报告有4个研究生报告，包括**开题报告**、**文献综述报告**、**中期进展报告**、**学术会议报告**（可能不需要了）。这些报告有统一的模板，具体形式和格式都不作要求，像那么回事儿就可以了。打印的时候要用B5的纸。上面的4个报告打印好了之后，都要找导师签字。

> 为什么叫“补”呢，因为这些报告原本是要在博士的各个阶段完成，比如博士开题的时候完成开题报告和文献综述报告，博士中期的时候有一个中期进展报告。但我们院的博士基本上都是拖到快毕业的时候才开始补写这些报告。如果你们院传统优良，已经在各个阶段把这些都完成了，那么就不需要再考虑这一步了。

除了上面的4个报告，还有两个表：**研究生科研能力评议表**和**中期筛选考核表**。这两个表都要用A4纸打印，其中能力评议表要打印5份。然后按着要求把相关内容填上。注意5份评议表是代表5个不同的评议结果，所以其中的“评分”不能都填成一样的了。“备注”可以留空。中期考核表也是一样的填，只是要找相关老师签字。

## 流程

> 自动化学院的预答辩时间一般安排在每月的最后一天，可能会有变动。每年的2月和8月不安排预答辩。2018年6月、7月、8月均每月安排预答辩，<font color=red>请提前确认信息</font>。

1. 自动化学院20号之前提交预答辩材料：
    - 博士学位论文预答辩审批表-1份：按照答辩会员会的信息填写，表中`论文评议人`不填。答辩委员会列表暂空，后期通过答辩信息填写。
    - 论文预答辩决议表-双面-1份
    - 论文预答辩评议书-5份
    - 简装毕业论文-7/8份
1. 与学院教务科老师联系，确定预答辩时间和地点，借会议室并提前取得会议室钥匙。
2. 打电话（或发短信）提醒各位老师答辩的时间和地点。
1. 一般学院教务科老师会将论文（将评议书夹在论文中）放进学院邮箱。如果必要，可自行将论文送各位老师审阅。
1. 提前布置好答辩的会场（水果、花生，瓜子，瓶装水，面巾纸等），调试好设备。
1. 在预答辩开始前将预答辩决议表（空表）交给秘书。

预答辩修改完成后，**准备档案袋并将预答辩评议书（5份）和决议表（1份，含有预答辩主席签字及预答辩通过字样）装入**，封面写上：姓名、学号、联系方式、导师、论文题目。

<div id="duplicate-checking"></div>

<div class="note warning"><p>论文查重和盲审顺利请提前咨询教务科老师！</p></div>

# 论文查重

流程：

1. 进入[研究生系统（导师研究生）](http://gs.hust.edu.cn/)的`学位综合服务-论文重复率检测申请`，填写论文相关信息，提交`导师审核`。
1. 学位办导入查重结果。等待一天后，查看查重结果（没有具体的查重报告）。
1. 联系学院教务科老师，进行`院系审核`。
1. 如果没有通过，继续对论文进行修改，也许你可以从教务员那里打听到一些有用的信息。改好后再送出去查重，直到通过为止。

> 如果参考文献导致重复率很高，可以通过与研究生院的老师沟通而通过博士论文的查重环节。

一般来说，在将自己的博士论文交给学校查重之前，自己需要先进行查重和修改，如果查重率在20%以下就差不多了。也没有必要过早对博士论文进行查重，对`根据预答辩意见修改后的版本`进行查重是比较合适的。

现在市面上用的比较多的查重系统有三个：

1. [中国知网查重](http://check.cnkicheck.org/)：图书馆提供查重服务，200元每次（注意核对格式），但会记录查重结果，一般不影响。中国知网在查重时，会将博士论文拆分成很多个部分（不一定是按着章节进行拆分），对每一部分进行查重，并给出每一部分的重复率。
2. [paperpass查重](http://www.paperpass.com/index.aspx?f=1a5bc6)是一个商业化的查重系统，数据库也很丰富，所以它查重的重复率会相对比较高，甚至高于中国知网的查重率。它的报价是1元/千字。
3. [万方查重](http://check.wanfangdata.com.cn/)也是一个常用的查重系统，但其数据库相对较少，所以它查重的重复率会相对较低。但它的价格较便宜，网上的报价不统一，有时甚至能够达到1元/万字。

总结一下：就重复率来说，paperpass>知网>万方；就价格来说，知网>paperpass>万方。如果你想初步了解自己论文的重复率，你可以用万方查重；而如果你不想多花钱，又希望能够获得比较准确的查重反馈结果，那么建议你选用paperpass。如果你使用paperpass或万方对论文进行查重，最好是将博士论文拆分成很多章节逐一进行查重。当然，你不一定要查重整篇博士论文，对于你很有把握的部分，实际上是没有必要进行查重的。

# 盲审

流程：

1. 论文查重通过后，与学院教务科老师联系获取盲审标准文件；
1. 整理盲审材料并将电子版盲审材料通过导师发给学院教务科老师；
1. 然后进入[研究生系统（导师研究生）](http://gs.hust.edu.cn/)的`学位综合服务-论文评阅申请`进行盲审申请，提交`导师审核`后等待盲审结果。

<div class="note info"><p>[华中科技大学博士毕业文档](https://pan.baidu.com/s/1leAhAlmzs21r3ftsZVtgAA)集合（提取码：rchs）
</p></div>

华科的论文盲审总共需要两个文件，为了方便介绍，我把它们分别叫盲审文件A和盲审文件B。将盲审文件A和盲审文件B发给学院的教务员，就算是送出盲审了。剩下的事情就是等盲审结果。

- 盲审论文会送给三个校外专家评阅，一般时间在一个月以内，具体时间不等。时间比较快的可能2~3个星期就能拿到全部盲审结果。盲审消息可以自己勤快点去大活研究生院学位办（027-87542352，大活A317）问，进入[研究生系统（导师研究生）](http://gs.hust.edu.cn/)的`学位综合服务`-`论文评阅申请`也可以查看结果。
- 还有一点就是就是盲审时间的问题。在任何时候，当然最好是工作日，只要你准备好了你的盲审材料，就可以将它们提交给教务员，他们就会为你送出盲审。因为盲审时间有长有短，结果有好有坏（A-B-C-D-E五个层次，具体根据学院盲审规则评定），所以最好提前二个月送出盲审，不然按时拿学位就很悬了。
- 更多参考[研究生院学位管理](http://gs.hust.edu.cn/xwgl.htm)。

## 盲审文件A

盲审文件A是由两个文件组合成的一个pdf文件，这两个文件分别是创新点文件和用于盲审的博士论文。该文件的命名规则是：单位代码_二级学科代码_学号_LW。比如：`10487_081100_D201077555_LW`。

- 创新点文件。创新点文件有固定的格式，可以从如下的链接下载到模板：[华科博士论文创新点文件](https://pan.baidu.com/s/1leAhAlmzs21r3ftsZVtgAA)（提取码：rchs）
- 用于盲审的博士论文。用于盲审的博士论文与正常的博士论文的主要区别就是里面要隐去所有的作者和导师信息。这也就要求你至少注意以下几点：
    * 封面上的`学位申请人`和`指导教师`留空，包括中英文
    * 致谢留空或直接删除
    * 发表论文或专利只保留论文名称和期刊号，删除作者信息，写第几作者
    另外说明一下，用于盲审的论文并不要求完美，后面还有很多修改的机会。当然，如果你有时间，把盲审论文做到完美那自然最好不过了。
- 对于软件麻瓜，给你推荐[PDF工具](https://sli1989.github.io/windows-use/#pdf)。

## 盲审文件B

这个文件按着学校的说法叫做`院（系）博士学位论文双盲审名单汇总表`，是一个`excel`文件。该文件的命名规则是：`单位代码_院系代码_HZSJB`，如：`10487_011_HZSJB`。最后一串代码`HZSJB`不知道是什么意思，似乎不需要改变。

# 正式答辩

自动化学院等待院系老师打电话通知你的盲审结果。通过盲审之后，就可以开始张罗正式毕业答辩了。下面，我按着顺序介绍毕业答辩前要做的事儿。

<div class="note info"><p>[华中科技大学博士毕业文档](https://pan.baidu.com/s/1leAhAlmzs21r3ftsZVtgAA)集合（提取码：rchs）
</p></div>

流程：

1. 打印`博士学位论文答辩审批表`（3份）、`博士学位论文定稿表`（2份）、`博士学位论文答辩评审表`（7份，**提前盖学院行政章**）并按照程序找导师、系主任（系主任徐，东二楼220；副主任李，东二楼309）、副院长盖章（王），方可正式答辩。
1. 草拟评议书中的答辩决议，并打印七份。**陈述不要多于四个工作要点，尽可能简单，避免使用修饰语，每条不要超过三行字**。
1. 确定答辩委员、时间及地点（一般是导师决定，学生自己联系时间），并借会议室。建议在联系答辩老师之前，先跟导师确定几个答辩的备选时间。
1. 制作简装版论文（不少于七份），可能的话给每个答辩老师送一份博士论文。这时候的博士论文有点小瑕疵也问题不大。另外，最好能够在里面夹一张纸，告诉具体的答辩时间和地点。
1. 差不多在答辩前5天左右制作和张贴答辩海报。[答辩海报模板](https://pan.baidu.com/s/1leAhAlmzs21r3ftsZVtgAA)（提取码：rchs）
1. 答辩费和聚餐。
    - 答辩费是要跟导师商量定的。一般来说，塞在信封里，答辩当天给各位老师。至于是你还是答辩秘书给，视情况而定。
    - 可以提前订个吃饭的地方，答辩完了如果需要可以一块儿吃个饭。
1. 准备答辩。
    - 答辩PPT：40~50分钟左右，不一定要按着你的博士论文从前到后逐一讲解。你可以对内容有一定的选择性，好让你的PPT成为一个完整的故事，让他们尽可能多的明白你做了什么。所以，在答辩PPT的逻辑上，你还是要好好斟酌一下。你还可以增加一些博士论文里没有的内容。相对来说，答辩PPT的内容要比毕业论文要随意一些。
    - 正装。作为对自己博士几年生涯的一个总结，你最好还是庄重一点，不是吗？这样做，也会让答辩老师们觉得你很重视这个答辩。
    - **提前半天获取会议室钥匙**（周），答辩会场布置：答辩评审表、笔、白纸、水果、干果等，再调试一下音响设备。检查PPT播放是否正常，色彩搭配是否合理。
1. 答辩当天不要紧张。
    - 讲PPT的时间一般是40~50分钟，自己适当控制下。
    - 然后是各个答辩老师提问，你做出回应。
    - 盲审意见综合与答复。
    - 结束之后，你离场，答辩老师们一起商量结果。
    - 最后再叫你回去，宣布结果。
1. 答辩委员会主席宣布“建议授予博士学位”的同时，答辩研究生在心理上是一个质的变化。多年的奋斗，多年的期待，终于有了明确的结果，应该有很多话要说，也会有很多故事想分享。所以，如果早一点认真准备几分钟的“感言”，效果是很不错的，也会让答辩专家们进一步加深印象。

# 答辩后事宜

答辩之后还有些要做的事儿，列举如下。

## 填写学位申请材料

将预答辩中的4个报告和2个表交给学院教务员后，Ta会给你`华中科技大学博士研究生学位申请及评定书`2本；学信网提供的照片；为你打印两份成绩单用来贴在学位申请及评定书上的，并盖章。

- 学位申请及评定书需要手写（可打印粘贴），注意答辩主席和答辩秘书要骑缝签字。另外，要把页边空白裁剪一下，在贴的时候不要超出评议书上的黑色边线。
- 其他表格可以直接在电脑上填写后打印。
- 对于评阅意见书，只需要把盲审结果夹在学位申请及评定书中间就可以了。

## 研究生系统流程

1. 联系学院教务科老师进入[研究生系统（导师研究生）](http://gs.hust.edu.cn/)的`学位综合服务-论文评阅申请`进行`院系审核`，然后等待或提醒`研究生院审核`后联系学院教务科老师进行`学院终审`。
1. 进行`答辩申请`（包括了学位信息采集，答辩准备信息录入和成果信息。按一级学科授予，上传学信网照片），等待`导师审核`。联系学院教务科老师进行`院系审核`并告知答辩秘书。同时联系答辩秘书并提供最终的答辩会议相关材料。
1. 答辩秘书录入完成后进行`归档论文上传`，上传`印刷版学位论文`（建议红头，第一章的前面部分保证奇数页放置）和`原创性说明/学位论文版权使用授权书的PDF扫描件`，最后`待院系确认`-`待学位办抽查`-`已归档`。

## 上交材料

将如下学位申请材料一起交给教务员。

- 华中科技大学博士研究生学位申请及评定书2本（分开放）；
- 华中科技大学博士学位论文评阅意见书(盲审)3份（夹入1本评定书里）；
- 华中科技大学博士学位论文修订报告书2份（如评阅意见书都同意，写答辩疑问；如评阅意见书小修，一一对应答复）；
- 华中科技大学博士定稿表2份；
- 华中科技大学博士学位论文答辩审批表3份；
- 华中科技大学博士学位论文答辩评审表5份；
- 华中科技大学拟授予博士学位人员（学位研究生）登记表1份（硕博连读是直接攻读博士学位）；
- 华中科技大学授予博士学位人员（学位研究生）基本信息表1份；
- 学位论文4本（其中有一份要求是**红头版**，每份由导师和本人签字）； 当然，你最好是为自己和导师再多打印2本。
- 发表学术论文复印件一套并**标注索引号**；
- 电子材料以`184_学号_姓名`格式命名打包交到自动化学院教务科老师：`学位论文电子版`、`答辩决议.jpg`、`原创性说明/学位论文版权使用授权书.jpg`、`信息统计表.xls`、`已发表论文.xls`。

## 上传论文到图书馆

学院学术委员会议通过后，进入学校[图书馆网站](http://202.114.9.36/Thesis/Thesis/ThesisSubmit/Sumbit_DBList.aspx)，点击`本校学位论文`--`论文提交`，录入个人论文的相关信息，完成论文提交。

## 离校手续

到这里，恭喜你顺利毕业啦！

1. 一般在月底，离校通知单和检索报告（图书馆查新站）到王老师处签字，宋老师处盖章。
2. 梁导处领取双证。填写毕业生登记表并提交。
3. 李导处办理报到证申请。在毕业去向那里上传三方，填写薪资。
4. 如果需要即时获取报到证，复印学位证到研究生院三楼学位办公室盖章，校园服务中心办理报到证手续（领取“删除2019年生源”证明（务必领取），档案馆307领取录取名册），同时领取调档函。复印双证，打印学信网验证报告，最后到省就业中心领取报到证。
5. 填写调档通知单、毕业生登记表，分别在导员、宋老师、校史馆、研工部盖章。将上述材料和报到证白联提交导员处。等待院系报送档案后凭报到证红联原件复印件、调档通知单，到档案馆调档。
6. 凭报到证红联原件复印件（非本人需要委托书）到校史馆办理户口迁移。
7. 获取党组织关系转移的抬头和去处，联系王导办理。

# 在线签约

1. [研究生就业信息网](http://career.hust.edu.cn/default.html)
2. 生源信息自审。联系辅导员审核，未审核无法网签。审核通过会有红色“审核通过”标记。
	- 每年9月底提交生源信息自审，如不提交申请，只能是下届毕业生。毕业季度不影响当年，毕业生辅导员会统一修改为03季度派遣。
3. 博士生协议书申请。打印，导师签字，拍照上传，等待学院学校两级审核。
4. 推荐表管理。完成后“提交”给辅导员审核。审核后可自行打印推荐表。
5. 网上签约。
	- 涉及到派遣，跟用人单位确定好户档信息。
	- 仔细核对后“接受”签约。一旦生成协议，需要走“违约申请流程”。
1. 签约完成后，补充完善“毕业生去向登记”。
2. 拍照上传协议书。提交辅导员审核。

# 退费问题

- 获取[答辩通过证明](http://gs.hust.edu.cn/info/1039/9164.htm)（导师签字-学院教务科盖章-研究生院学位办盖章，或者大活一楼自助打印机在召开校学术委员会当月的月初可以自动提供），找辅导员拿收据，最后去财务中心3楼退学费。
- 宿舍剩余电费不退钱，只能转让，需要写个申请，找片区主管签字，然后交到冲电费的地方。

---
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>HUST</tag>
        <tag>PHD</tag>
      </tags>
  </entry>
  <entry>
    <title>Python</title>
    <url>/python/</url>
    <content><![CDATA[
Python是著名的“龟叔”Guido van Rossum在1989年圣诞节期间，为了打发无聊的圣诞节而编写的一个编程语言。Python就为我们提供了非常完善的基础代码库，覆盖了网络、文件、GUI、数据库、文本等大量内容，被形象地称作“内置电池（batteries included）”。用Python开发，许多功能不必从零编写，直接使用现成的即可。除了内置的库外，Python还有大量的第三方库，也就是别人开发的，供你直接使用的东西。当然，如果你开发的代码通过很好的封装，也可以作为第三方库给别人使用。

<!--more-->

> python拥有matplotlib、Numpy、sklearn、keras等大量的库，像pandas、sklearn、matplotlib这些库都是做数据处理、数据分析、数据建模和绘图的库，基本上机器学习中对数据的爬取（scrapy）、对数据的处理和分析（pandas）、对数据的绘图（matplotlib）和对数据的建模（sklearn）在python中全都能找到对应的库来进行处理。

# 资源

[**Beginner resources**](https://code-love.com/2019/06/03/49-essential-resources-to-learn-python/#beginner) for those just starting with programming and Python

**[Intermediate resources](https://code-love.com/2019/06/03/49-essential-resources-to-learn-python/#intermediate)** for those looking to apply the basics of Python knowledge to fields like data science and web development

[**Advanced resources**](https://code-love.com/2019/06/03/49-essential-resources-to-learn-python/#advanced) for those looking to get into concepts like deep learning and big data with Python

**[Exercises](https://code-love.com/2019/06/03/49-essential-resources-to-learn-python/#exercises)** that help practice and cement Python skills in practice

[**1- Welcome to Python.org**](https://www.python.org/)

The official Python site offers a good way to get started with the Python ecosystem and to learn Python, including a place to register for upcoming events, and documentation to get started.

[**2-Learn Python the Hard Way**](https://learnpythonthehardway.org/book/)

An online book with a paid and a free version. The free version goes into an outline of the content and can be a useful to-do list.

[**3-Basic Data Types in Python – Real Python**](https://realpython.com/python-data-types/)

RealPython dives into the different data types in Python in detail. Learn the difference between floating point and integers, what special characters can be used in Python and more.

[**4-How to Run Your Python Scripts – Real Python**](https://realpython.com/run-python-scripts/)

This simple intro to Python scripts through the command line and text editors will get you up and running for your first Python experiments — a handy tool to get you started as you learn Python.

[**5-Python Tutorial: Learn Python For Fre**](https://www.codecademy.com/learn/learn-python)**[e](https://www.codecademy.com/learn/learn-python)**[ **| Codecademy**](https://www.codecademy.com/learn/learn-python)

Codecademy offers a free interactive course that helps you practice the fundamentals of Python while giving you instant, game-like feedback. A great device for learning Python for those who like to practice their way to expertise.

[**6-Google’s Python Class | Python Education | Google Developers**](https://developers.google.com/edu/python/)

The official Python development class from Google’s developers. This tutorial is a mix of interactive code snippets that can be copied and run on your end and contextual text. This is a semi-interactive way to learn Python from one of the world’s leading technology companies.

**[7-Learn Python – Free Interactive Python Tutorial](https://www.learnpython.org/)**

This interactive tutorial relies on live code snippets that can be implemented and practiced with. Use this resource as a way to learn interactively with a bit of guidance.

[**8-Jupyter Notebook: An Introduction – Real Python**](https://realpython.com/jupyter-notebook-introduction/)

Want an easy, intuitive way to access and work with Python functions? Look no further than Jupyter Notebook. It’s much easier to work with than the command line and different cobbled together scripts. It’s the setup I use myself. This tutorial will help you get started on your path to learn Python.

**[9-Python Tutorial – W3Schools](https://www.w3schools.com/python/)**

W3Schools uses the same format they use to teach HTML and others with Python. Practice with interactive and text snippets for different basic functions. Use this tutorial to get a firm grounding in the language and to learn Python.

**[10-Python | Kaggle](https://www.kaggle.com/learn/python)**

Kaggle is a platform which hosts data science and machine learning competitions. Competitors work with datasets and create as accurate of a predictive model as possible. They also offer interactive Python notebooks that help you learn the basics of Python. Choose the daily delivery option to have it become an email course instead.

**[11-Learning Python: From Zero to Hero – freeCodeCamp.org](https://medium.freecodecamp.org/learning-python-from-zero-to-hero-120ea540b567)**

This text-based tutorial aims to summarize all of the basic data and functional concepts in Python. It dives into the versatility of the language by focusing on the object and class portions of the object-oriented part of Python. By the end of it, you should have a neat summary of objects in Python as well as different data types and how to iterate or loop over them.

**[12-BeginnersGuide – Python Wiki](https://wiki.python.org/moin/BeginnersGuide)**

This simple tutorial on the official Python Wiki is chock-full of resources, and even includes a Chinese translation for non-English speakers looking to learn Python.

**[13-Python Tutorial – Tutorialspoint](https://www.tutorialspoint.com/python/)**

Set up in a similar fashion to W3Schools, use Tutorialspoint as an alternative or a refresher for certain functions and sections.

**[14-Python (programming language) – Quora](https://www.quora.com/topic/Python-programming-language-1)**

The Quora community is populated with many technologists that learn Python. This section devoted to Python includes running analysis and pressing questions on the state of Python and its practical application in all sorts of different fields, from data visualization to web development.

**[15-Python – DEV Community – Dev.to](https://dev.to/t/python)**

Dev.to has user-submitted articles and tutorials about Python from developers who are working with it every day. Use these perspectives to help you learn Python.

**[16-Python Weekly: A Free, Weekly Python E-mail Newsletter](https://www.pythonweekly.com/)**

If you’re a fan of weekly newsletters that summarize the latest developments, news, and which curate interesting articles about Python, you’ll be in luck with Python Weekly. I’ve been a subscriber for many months, and I’ve always been pleased with the degree of effort and dedication placed towards highlighting exceptional resources.

**[17-The Ultimate List of Python YouTube Channels – Real Python](https://realpython.com/python-youtube-channels/)**

For those who like to learn by video, this list of Youtube channels can help you learn in your preferred medium.

**[18-The Hitchhiker’s Guide to Python](https://docs.python-guide.org/)**

Unlike the rest of the resources listed above, the Hitchhiker’s guide is much more opinionated and fixated on finding the best way to get set up with Python. Use it as a reference and a way to make sure you’re optimally set up to be using and learning Python.

**[19-Python: Online Courses from Harvard, MIT, Microsoft | edX](https://www.edx.org/learn/python)**

edX uses corporate and academic partners to curate content about Python. The content is often free, but you will have to pay for a verified certificate showing that you have passed a course.

**[20-Python Courses | Coursera](https://www.coursera.org/courses?query=python)**

Coursera’s selection of Python courses can help you get access to credentials and courses from university and corporate providers. If you feel like you need some level of certification, similar to edX, Coursera offers a degree of curation and authentication that may suit those needs.

**[21-Getting started with Django | Django](https://www.djangoproject.com/start/)**

The official Django framework introduction will help you set up so that you can do web development in Python.

**[22-LEARNING PATH: Django: Modern Web Development with Django](https://www.oreilly.com/learning-paths/learning-path-django/9781788998703/)**

This resource from O’Reilly helps fashion a more curated path to learning Django and web development skills in Python.

**[23-A pandas cookbook – Julia Evans](https://jvns.ca/blog/2013/12/22/cooking-with-pandas/)**

I learned how to clean and process data with the Pandas Cookbook. Working with it enabled me to clean data to the level that I needed in order to do machine learning and more.

It works through an example so you can learn how to filter through, group your data, and perform functions on it — then visualize the data as it needs be. The Pandas library is tailor-built to allow you to clean up data efficiently, and to work to transform it and see trends from an aggregate-level basis (with handy one-line functions such as head() or describe).

The Pandas cookbook is the perfect intro to it.

**[24-Newest ‘python’ Questions – Stack Overflow](https://stackoverflow.com/questions/tagged/python)**

The Stack Overflow community is filled with pressing questions and tangible solutions. Use it a resource for implementation of Python and your path to learn Python.

[**25-Python – R**](https://www.reddit.com/r/Python/)**[e](https://www.reddit.com/r/Python/)**[**ddit**](https://www.reddit.com/r/Python/)

The Python subreddit offers a bunch of different news articles and tutorials in Python.

**[26-Data Science – Reddit](https://www.reddit.com/r/datascience/)**

The Data Science subreddit offers tons of resources on how to use Python to work with large datasets and process it in interesting ways.

**[27-Data science sexiness: Your guide to Python and R](https://thenextweb.com/dd/2016/04/08/start-using-python-andor-r-data-science-one-best/)**

I wrote this guide for The Next Web in order to distinguish between Python and R and their usages in the data science ecosystem. Since then, Python has pushed ever-forward and taken on many of the libraries that once formed the central basis of R’s strength in data analysis, visualization and exploration, while also welcoming in the cornerstone machine learning libraries that are driving the world. Still, it serves as a useful point of comparison and a list of resources for Python as well.

**[28-Data Science Tutorial: Introduction to Using APIs in Python – Dataquest](https://www.dataquest.io/blog/python-api-tutorial/)**

One essential skill when it comes to working with data is to access the APIs services like Twitter, Reddit and Facebook use to expose certain amounts of data they hold. This tutorial will help walk you through an example with the Reddit API and help you understand the different code responses you’ll get as you query an API.

**[29-Introduction to Data Visualization in Python – Towards Data Science](https://towardsdatascience.com/introduction-to-data-visualization-in-python-89a54c97fbed)**

Once you’re done crunching the data, you need to present it to get insights and share them with others. This guide to data visualization summarizes the data visualization options you have in Python including Pandas, Seaborn and a Python implementation of ggplot.

**[30-Top Python Web Development Frameworks to Learn in 2019](https://hackernoon.com/top-python-web-development-frameworks-to-learn-in-2019-21c646a09a9a)**

If you want a suite of options beyond Django to develop in Python and learn Python for web applications, look no further than this compilation. The Hacker Noon publication will often feature useful resources on Python outside of this article as well. It’s worth a follow.

[**31-Beginner’s Guide to Machine Learning with Python**](https://towardsdatascience.com/beginners-guide-to-machine-learning-with-python-b9ff35bc9c51)

This text-based tutorial helps introduce people to the basics of machine learning with Python. Towards Data Science, the Medium outlet with the article in question, is an excellent source for machine learning and data science resources.

**[32-Free Machine Learning in Python Course – Springboard](https://www.springboard.com/resources/learning-paths/machine-learning-python/)**

This free learning path from Springboard helps curate what you need to learn and practice machine learning in Python.

**[33-Machine Learning – Reddit](https://www.reddit.com/r/MachineLearning/)**

The Machine Learning subreddit oftentimes focuses on the latest papers and empirical advances. Python implementations of those advances are discussed as well.

**[34-Python – KDnuggets](https://www.kdnuggets.com/tag/python)**  

KDNuggets offers advanced content on data science, data analysis and machine learning. Its Python section deals with how to implement these ideas in Python.

**[35-Learn Python – Beginner through Advanced Online Courses – Udemy](https://www.udemy.com/topic/python/)**

Udemy offers a selection of Python courses, with many advanced options to teach you the intricacies of Python. These courses tend to be cheaper than the certified ones, though you’ll want to look carefully at the reviews.

**[36-A Brief Introduction to PySpark – Towards Data Science](https://towardsdatascience.com/a-brief-introduction-to-pyspark-ff4284701873)**

This introduction to PySpark will help you get started with working with more advanced distributed file systems that allow you to deal and work with much larger datasets than is possible under a single system and Pandas.

**[37-scikit-learn: machine learning in Python](https://scikit-learn.org/)**

The default way most data scientists use Python is to try out model ideas with scikit-learn: a simple, optimized implementation of different machine learning models. Learn a bit of machine learning theory then implement and practice with the scikit-learn framework.

**[38-The Next Level of Data Visualization in Python – Towards Data Science](https://towardsdatascience.com/the-next-level-of-data-visualization-in-python-dd6e99039d5e)**

This tutorial walks through more advanced versions of data visualizations and how to implement them, allowing you to take a preview of different advanced ways you can slice your data from correlation heatmaps to scatterplot matricies.

**[39-Machine Learning with Python | Coursera](https://www.coursera.org/learn/machine-learning-with-python)**

Coursera’s selection of courses on machine learning with Python are veryw well-known. This introduction offered with IBM helps to walk you through videos and explanations of machine learning concepts.

[**40-Home – deeple**](https://www.deeplearning.ai/)**[a](https://www.deeplearning.ai/)**[**rning.ai**](https://www.deeplearning.ai/)

Deeplearning.ai is Andrew Ng’s (the famous Stanford professor in AI and founder of Coursera) attempt to bring deep learning to the masses. I ended up finishing all of the courses: they offer certification and are a refreshing mix of both interactive notebooks where you can work with the different concepts and videos from Andrew Ng himself.

**[41-fast.ai · Making neural nets uncool again](https://www.fast.ai/)**

This curated course on deep learning helps break down section-by-section aspects of machine learning. Best of all, it’s completely free. I often use fast.ai as a refresher or a deep dive into a deep learning idea I don’t quite understand.

**[42-Learn and use machine learning | TensorFlow Core | TensorFlow](https://www.tensorflow.org/tutorials/keras)**

This tutorial helps you use the high-level Keras component of TensorFlow and Google cloud infrastructure to do deep learning on a set of fashion images. It’s a great way to learn and practice your deep learning skills.

[**43-Datasets | Kagg**](https://www.kaggle.com/datasets)**[l](https://www.kaggle.com/datasets)**[**e**](https://www.kaggle.com/datasets)

Kaggle offers a variety of datasets with user examples and upvoting to guide you to the most popular datasets. Use the examples and datasets to create your own data analysis, visualization, or machine learning model.

**[44-Practice Python](https://www.practicepython.org/)**

Practice Python has a bunch of beginner exercises that can help you ease into using Python and practicing it. Use this as an initial warmup exercise before you tackle different projects and exercises.

**[45-Python Exercises – W3Schools](https://www.w3schools.com/python/python_exercises.asp)**

The Python exercises on W3Schools follow the sections in their tutorials, and allow you to get some interactive practice with Python (though the exercises are in practice very simple).

**[46-Solve Python | HackerRank](https://www.hackerrank.com/domains/python)**

HackerRank offers a bunch of exercises that require you to solve without any context. It’s the best way to practice different functions and outputs in Python in isolation (though you’ll still want to do different projects to be able to cement your Python skill.) You’ll earn points and badges as you complete more challenges. This certainly motivates me to learn more. A very useful sandbox for you to learn Python with.

**[47-Project Euler: About](https://projecteuler.net/)**

Project Euler offers a variety of ever-harder programming challenges that aim to test whether you can solve mathematical problems with Python. Use it to practice your mathematical reasoning and your Pythonic abilities.

**[48-Writing your first Django app, part 1 | Django documentation | Django](https://docs.djangoproject.com/en/2.2/intro/tutorial01/)**

This documentation helps you get on the ground with your first Django app, allowing you to use Python to get something up on the web. Once you’ve started with it, you can build anything you want.

**[49-Top 100 Python Interview Questions & Answers For 2019 | Edureka](https://www.edureka.co/blog/interview-questions/python-interview-questions/)**

Should you ever be in an interview where your Python skills are at question, this list of interview questions will help as a useful reminder and refresher and a good way for you to practice and cement different Python concepts.

50-[6 best online courses for ethical hackers](https://www.comparitech.com/blog/information-security/hacking-python-courses-online/)

Ethical hackers play an important role in organizations by finding and fixing vulnerabilities in systems and applications. Python is a high-level programming language that’s ideal for security professionals as it’s easy to learn and lets you create functional programs with a limited amount of code.

# 实例

## 语法

爬虫：requests、scrapy、selenium、beautifulSoup，这些库都是写网络爬虫需要使用到的，好好掌握这些东西，数据就有了。

数据处理：Numpy、scipy、pandas、matplotlib，这些库分别可以进行矩阵计算、科学计算、数据处理、绘图等操作，有了这些库，你就可以一步步开始把数据处理成你需要的格式。

建模：nltk、keras、sklearn，这些库主要是用于自然语言处理、深度学习和机器学习的，把这些用好了，你的模型就构建出来了。

Web开发：django、flask、tornado，这些库搞明白了，你web开发也就搞定了。

### requests

优雅简单的 HTTP 模块。

### BeautifulSoup

很好用的 HTML/XML 解析器。

### json

JSON 编码解码器。

应用举例：

* 格式化 JSON 文件

  ```sh
  python -m json.tool src.json > dst.json
  ```

  在 Vim 里格式化 JSON：

  ```sh
  :%!python -m json.tool
  ```

### CGIHTTPServer

简单实用的 HTTP 服务器。

应用举例：

* 运行一个简易的 HTTP 服务器

  ```sh
  python -m CGIHTTPServer 80
  ```

### base64

方便地进行 base64 编解码的模块。

应用举例：

* 解码 base64

  ```sh
  echo aGVsbG93b3JsZA== | python -m base64 -d
  ```

  则能看到输出

  ```sh
  helloworld
  ```
]]></content>
      <categories>
        <category>Programming</category>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title>青海湖大环线旅游线路</title>
    <url>/qinghaihu/</url>
    <content><![CDATA[
- 第一天：西宁-塔尔寺 --日月山-拉脊山--倒淌河--青海湖-夜宿黑马河

- 第二天：黑马河看日出-翻越橡皮山（海拔3817）-进入柴达木盆地-茶卡盐湖-雅丹地貌，-夜宿大柴旦

- 第三天：大柴旦-当金山-阿克塞-玉门关-汉长城-夜宿敦煌

- 第四天：敦煌莫高窟-鸣沙山月牙泉-沙洲夜市-夜宿敦煌

- 第五天：敦煌--嘉峪关城--张掖七彩丹霞-夜宿张掖

- 第六天：张掖--鸳鸯花海-阿柔大寺-祁连卓尔山-夜宿祁连

- 第七天：祁连-卓尔山-祁连大草原-- 大阪山观景台（远眺岗什卡雪山）-门源-黑泉水库-西宁（结束）

<!--more-->

1. 青海湖最美的时间是7月和8月。为了避免人多可以选7月初或8月底。十月份去的朋友可以去北上看胡杨林，很赞的。出发前记得带上买一箱水、晕车药、感冒药、口罩、眼镜、帽子、四季各一套衣服，提前预定火车票、飞机票还有莫高窟的门票（必须提前买）。

2. 大家可以在武大或华科搞到学生证，能半价买门票哦。

3. 飞机票武汉直飞西宁来回都是1300，飞兰州为1000，回来800.高铁兰州到西宁是61.所以果断选址了飞兰州高铁的组合，节约了大概800，也为路程上大吃大喝做了铺垫。财政预算：人均6000-7000弹性保证。 看你的奢侈程度和节约程度 。

4. 住宿：包车师傅提前帮我们搞定了。

5. 我们是包车出游，包车费6000，4个人分摊1500一个，师傅人很好，我们想在多玩几个地方也很乐意，中途也给我们省了不少钱，有需要的可以联系我，我给你们电话。

6. 出发前查询了2个星期的天气，因为考虑去茶卡（最漂亮）会下雨，我们选择按线路逆向玩耍。

好的，下面就正式出发了。

第一天：武汉--兰州--西宁--到处找吃的，储备体力。

第二天：我们的线路是 西宁出发-黑泉水库-门源-岗什卡雪山-鸳鸯花海（来的不是时候祁连大草原-卓尔山-祁连。第二天的主景点是卓尔山（海拔3800 藏区）

首先看到的第一个主景点是门源，这里的油菜花是7月底至8月初。我们来的时候已经凋谢了，实际应该看到的金黄色的油菜尽染整个山谷。岗什卡雪山远眺尽收眼底。在向西还有一条线路（冰沟）时间原因我们也没去。

一路上我们看到的是祁连山大草原，成片的牛羊。

接着我们翻过N个山头到达第一天的主景点卓尔山（半价门票）住在半山腰藏区旅馆。

第三天：卓尔山出发--马蹄寺--（大佛寺）--七彩丹霞--张掖（住宿）

第三天从卓尔山出发下山，早上起来可以去卓尔山看日出，天气原因没有去，首先达到马蹄寺(半价），毋庸置疑马蹄寺是一个寺庙（悬壁），游玩大概2小时。

接着到达我们的主景点：张掖七彩丹霞（一定要下午来）夕阳西下晒红整个土堆（我取得，哈哈）美吧，七彩离张掖大概70公里，晚上我们就住景区旁边的旅馆。

第四天：张掖--嘉峪关--悬壁长城--嘉峪关关城--敦煌

第四天实际路线是以上的，考虑到长城去过，也就只是在关成溜达，路上进过瓜洲（吃瓜），晚上到达敦煌（住呤沙山旁边），附装B图一张。

第五天：敦煌--呤沙山月牙泉（早上5点起来看日出）--莫高窟（时间固定的10.30，要玩将近4个小时）--回到住宿点

第六天：住处--玉门关-魔鬼城（旁边是新疆，属于罗布泊区了，热成狗）-阿克塞（住）

第七天：阿塞克（6点出发）--当金山--大柴旦--克鲁克湖--德令哈--尕海（还不错，沙漠里的一片绿洲）--茶卡盐湖--黑马河(住)

这里我只想说茶卡，因为茶卡太美了，其他景色都是打酱油。再次装B

第八天：黑马河--早起看星星，接着看日出--151青海湖油菜花--倒淌河--日月山--拉脊山--塔尔寺（藏族第六大寺）--西宁--兰州（住）。

第九天：兰州--88青海回我大武汉。

---
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Travel</tag>
      </tags>
  </entry>
  <entry>
    <title>文献管理</title>
    <url>/reference-manage/</url>
    <content><![CDATA[
文献管理方面主要包括文献收集、整理、分析与追踪，目的是获取当前研究趋势。本文介绍一些文献管理方法，提高科研效率。

<!--more-->

# 领域入门

我们界定的入门标准主要有三条：1）了解该学科历史脉络和近二十年的研究重点难点，且能如数家珍；2）确保与该学科的专业人士交流时不说外行话；3）了解该学科近三年的至少三个国际前沿热点问题，且能适当点评。

刚开展研究工作的第一步就是背景知识的了解，

1. 最好的开端是一本英文教材；
2. 通过 MOOCs 来系统学习；
3. 有了相对前沿的教材或讲义作为知识框架，你的脑子里此时应该比较清楚导师让你做的东西或自己打算做的东西在学科中的定位，解决的是什么科学或工程问题，此时可以进行**基于关键词检索**的[文献检索](#literature-search)收集了。

以下从领域/文献分析挖掘工具、文献检索和学者动态跟踪等方面就行一些有益探讨。

<div id="literature-analysis"></div>

## 文献分析挖掘工具

为了更加高效准确地分析不同网络的各类特征，研究学者们已经开发出了大量的网络分析工具[^blog_48e0ae280100cve4]。

[^blog_48e0ae280100cve4]: [ArnetMiner和D-Dupe--网络科技文献分析工具](http://blog.sina.com.cn/s/blog_48e0ae280100cve4.html)

- [如何对PDF文献做可视化分析](http://blog.sciencenet.cn/home.php?mod=space&uid=377709&do=blog&id=1081637)

<div id="arnetminer"></div>

### ArnetMiner

[ArnetMiner](http://www.arnetminer.org/)（推荐使用）：科研合作网的专家检索系统。 ArnetMiner主要面向研究社会网络的各种特征，提供在线的作者资料检索，是相关领域及合作关系挖掘软件，可以很好地找出领域专家、作者从事的领域、合作团体等。该软件偏重于对单个作者信息的检索和挖掘，只集成了部分挖掘算法。项目在 2007年开发完成，使用的技术和方法都比较新颖，对领域专家和科研评价都有比较好的效果。

<div id="histcite"></div>

### Histcite

[Histcite](https://histcite.software.informer.com/)是一款文献引文分析工具，通过数据分析，可以快速绘制出某个研究领域的发展脉络图，让你找到重要文献和学术大牛。是一款受众非常小的强大工具。[HistCite Pro](https://zhuanlan.zhihu.com/p/20902898)是用 Python 写了一个更好用的增强版本。

参考[Histcite使用教程](https://wenku.baidu.com/view/81bf09dfaeaad1f346933f98.html)列出几个重要的英文缩写：

- GCS（global citation score）， 某一文献在WOS数据库中的总被引用次数。有些引用这篇参考文献的文章可能和你的研究方向毫无关系，但GCS还是会把这个引用数据记录下来。
- LCS（local citation score），某一文献在本地数据集中的被引用次数。因为你导入Histcite的文章都是和你检索词有关系的，可以认为这些文章是你的研究同行，因此如果某一篇文献的LCS值很高，就意味着它是你研究领域内的重要文献，很有可能是你领域内的开创性文章，注意LCS高的文献和GCS高的文献不一定是同一篇！
- LCR（local cited references）， 某一文献引用本地数据集中参考文献的数目。根据LCR值的排序，可以快速定位近期关注该领域的重要文献，因为某一篇文献引用当前数据集中的文献数越多，说明它非常关注你检索的这个研究方向的文献，和你的研究肯定有相似或者可参考之处，可以从该文章中发现新动向。
- CR（cited references）， 某一文献引用WOS数据库中参考文献的数目。这个值越高，说明这篇文献很可能是综述性文献，可根据该值的排序，也可快速定位综述文献。

<div class="note info"><p>HistCite 只支持 WOS 数据库，你也可以尝试利用[Scopus2Histcite](https://github.com/leoatchina/Scopus2Histcite)将 Scopus 导入 Histcite 进行分析。</p></div>

HistCite Pro 的使用方法：

1. 打开[WOS](http://apps.webofknowledge.com/)，注意数据库要<font color=red>选择核心合集（Core Collection）</font>。
2. 输入关键词进行检索。
3. 按照`被引频次降序排列`，点击页面上的`保存至 Endnote Online`按钮右边的下拉按钮，选择`保存为其他文件格式`并出现弹窗，记录数填写`1-500`，记录内容选择`全记录与引用的参考文献`，文件格式选择`纯文本`，然后点击`发送`即可得到导出的 txt 文件。一般导出前 1000-2000 篇就差不多了。因为每次最多只能导出 500 篇文献，所以需要分成多次导出。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g13g642f1cj20k00at3z1.jpg)
5. 下载 [HistCite Pro 的压缩包](https://pan.baidu.com/s/1hsIwJzQ)并解压（<font color=red>解压根目录路径中不含中文</font>），把从 WOS 上导出的全部 txt 数据文件放到 TXT 文件夹里面，然后双击 `main.exe` 并输入数字 `3` 即可一键完成加载。
6. 该模式启动之后会自动打开两个浏览器窗口，先打开默认的 IE 浏览器窗口（记为 A 窗口），然后 5 秒之后会调用系统默认浏览器（推荐安装 Chrome 浏览器并设置为默认）打开另一个窗口（记为 B 窗口），一般在 B 窗口就可以正常进行数据的导入。等导入完成之后，你可以将 A 窗口关闭，在 B 窗口里面分析数据。
7. 点击 `Tools` 菜单下的 `Graph Maker`，在弹出的页面上点击 `Make Graph` 即可得到一张引文关系图，包含了最有价值的前 `30` 篇文章（可以自行修改数字）的完整引文关系。如果这张图看起来不是很清楚，在左边的 `Size` 选项中选择 `Full` 模式，重新绘制一张高清图，然后右击图片`另存为`一张图片即可。
    - 图上有 30 个圆圈，每个圆圈表示一篇文献，中间的数字是这篇文献在数据库中的序号。圆圈越大，表示被引用次数越多。不同圆圈之间有箭头相连，箭头表示文献之间的引用关系。多数情况下，你会看到最上面有一个圆圈较大，并有很多箭头指向这篇文章。那么这篇文章很可能就是这个领域的开山之作。
1. 点击页面上的`Cited References`，然后就可以看到本地库中的文献参考的全部文献信息，后面带有加号的表示本地txt库中没有包含。如果然后按照 Recs 数排序，可以看到有几篇 Recs 数很大的文献并没有在分析范围之内，这些往往就是被遗漏的重要文献。正常情况下点击加号`+`后的 WOS 就可以自动通过 WOS 将文献载入分析。
2. 如果点击之后网页报错，内容是：Routing Error。可以按照以下方法来解决：
    - 首先在任何网页浏览器中打开 [Web of Science](http://apps.webofknowledge.com) 网页，点击`被引参考文献检索`（`Cited Reference Search`）标签。复制当前页面的网址：`http://apps.webofknowledge.com/UA_CitedReferenceSearch_input.do?SID=5EHiltH2Yy&product=UA&search_mode=CitedReferenceSearch`。
    - 然后在 Histcite 工具栏 `tools`下拉菜单中选择 `Settings`。在弹出的对话框中，往下找到 `WoS link` 这一栏，默认选择是 `Universal setup`，改选 `Manual setup version 4`，然后在 `ISI web of knowledge 4 location URL` 下面的框里粘贴刚才复制的网址，再点击`Set`即可。
    - 然后再点击遗漏文献后面加号`+`后的 WOS 就可以打开 WOS 并自动将文献信息填进去，然后点击`检索`。在搜索结果中**勾选**所需要的文献（一般被引次数最多的那个就是），点击`完成检索`即可显示引用了该篇文献的所有文献，同样可以导出 txt 加入 Histcite 进行分析。
1. 同样的，我们点击 Histcite 页面的`Authors`按钮，可以找到本领域的一些大牛。
1. 导出到Endnote或者Noteexpress。
    - 首先点击菜单栏中`Tools`下的 `Mark&Tag` 选项，调出标记选择工具栏。
    - 左边栏用于指定选择范围，可以选择当前列表中的全部文献，也可以按照序号（#）、LCS、LCR等数值的区间来选择文献，还可以手动勾选需要的文献。中间栏表示的是需要导出的信息范围，可以只导出记录本身，也可以选择导出引用的文献或者被引的文献。
        ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g13gtcse72j20k00d4mym.jpg)
    - 选择好了需要导出的文献记录，点击`Mark`按钮。然后，我们就会发现上面出现了一个新的标签`Marks`，后面的数字就是我们选中的记录条数，如果发现这个数字不正确，点击`Mark`按钮旁边的 `Unmark` 来重新选择。确认无误之后，点击图示的`Marks`标签链接，即可显示全部被选的文献记录。
    - 下面依次点击 `File` 、 `Export` 、 `Records...` 来导出选中的文献记录。成功导出后得到一个 `.hci` 格式的文本文件，直接修改后缀为 `txt`。如果导出不成功，一般多尝试几次就可以。
    - 打开`Endnote`，依次点击 `File` 、 `Import`、 `File...` 按钮。在弹出的对话框中通过 `Choose...` 找到刚才的txt文件， `Import Option` 选择 `Multi-Filter (Special)`， `Duplicates` 选择 `Import All`，然后点击 `Import` 按钮即可导入。
    - 打开 Noteexpress 软件里的方法，具体操作是在导入时将过滤器选择为 `web of science`。

<div id="CiteSpace"></div>

### CiteSpace

> [CiteSpace从安装到简单使用](http://blog.sina.com.cn/s/blog_64be4ff90100tps9.html)  
> [如何使用CiteSpace的一组示范及常见问题解答](http://blog.sciencenet.cn/blog-496649-838067.html)  
> [CiteSpace 中文版指南](cluster.ischool.drexel.edu/~cchen/citespace/manual/CiteSpaceChinese.pdf)

[CiteSpace](http://cluster.cis.drexel.edu/~cchen/citespace/)（[下载地址](http://cluster.ischool.drexel.edu/~cchen/citespace/download/)）是一款可视化文献分析软件，能够显示一个学科或知识域在一定时期发展的趋势与动向，形成若干研究前沿领域的演进历程。简单说来，就是找出学术文献中文字（包括：作者，杂志，关键词，被引用词汇等等）的关系！并可视化表示出来！

<div id="PaperLens"></div>

### PaperLens

[PaperLens](http://www.cs.umd.edu/hcil/paperlens/)：用优雅的可视界面来反应某科研领域的发展趋势、活动和关系的软件。如名称所示，它专门针对文献数据的分析和挖掘，包括统计、评价等功能。它将文章、作者和会议间的关系挖掘出来，已经实现了对1995-2002年8年期间的 Infovis会议的论文集数据的分析，并进一步扩展到对（1982-2004）23年间的 ACM SIGCHI会议文献的挖掘。现在由马里兰大学和微软公司共同研制，进行进一步的研发，将来用于科学评价领域。

<div id="literature-search"></div>

## 文献检索

文献检索(document retrieval)是在科学研究，撰写论文时所必需的一种手段。检索数据库可以查阅[文献检索](https://sli1989.github.io/information-search/#literature-search)

一个良好的搜索返回的结果应该在10篇以内：

- 首先要是近5年的综述，每1-2年选一篇综述去看，要求是精读，也就是论文里提到的研究都加到你的文献库里并阅读细节，同时可参考综述章节对文献库进行分组。一定要做笔记，而且要进行结构化的笔记或思维导图，这个阶段时间可能比较长也比较累，成果是当你去听系里的报告时，你大概能将报告定位到你的笔记框架里。到此文献库就从无到有了。
- 然后关键词检索方面，建议学点逻辑运算符来过滤掉不相关信息，

<div id="literature-manage"></div>

# 文献管理软件

文献信息的收集与整理不是为了写笔记，是为了需要用的时候瞬间能够用到，例如写一个技术报告，给别人审稿，还有最重要的：写科技论文。

目前流行的文献管理软件有老牌的 EndNote，本土化的 NoteExpress 和新兴的 Mendeley、Zotero 等。他们各有特色，也有不同的用户群，满足了大多数人对文献管理的需求。这类软件的最主要功能有两个：

* 作为文献数据库，保存并管理文献题录信息；
* 作为样式管理器，根据论文需求，将文献引用样式导入文档编辑器中。

<div id="bibtex"></div>

## 获取引文BIBTEX

为了得到比较规范完整的BIBTEX题录：

- 推荐使用[CROSSREF](https://search.crossref.org/)或者[dblp](https://dblp.uni-trier.de)搜索（自带DOI信息），点击`Actions-Cite`获取。但引文格式包含latex格式，不过可以利用文献管理软件的`自动更新题录`功能进行优化，自己取舍。
- 如果上述数据库无法找到，然后在使用[谷歌学术搜索](https://scholar.google.com/)（[谷歌访问配置](https://sli1989.github.io/windows-use/#google)）或者[百度学术搜索](http://xueshu.baidu.com/)（`批量引用`服务有时候会出现导出的文献数目不一致）导出为BIBTEX。
    - 在使用谷歌学术时，**建议点击页面右上部分的`下三角`中的`设置`，勾选`open each selected ... window`，显示参考书目管理软件选项中设置`显示导入bibtex的链接`**。这样搜索出来的文献下方会出现显示`导入bibtex`，减少点击次数。清理浏览器缓存会消除此设置，可以将此地址设置为白名单。
<div id="doi"></div>
- 如果BIBTEX题录中没有DOI，则需要手动查找，中文DOI：[万方数据库](http://www.wanfangdata.com.cn/)，英文DOI：[CROSSREF](https://search.crossref.org/)。也可以在百度学术、Citeseer、ACM等[数据库](https://sli1989.github.io/information-search/#literature-search)查找来源。

## 导入引文BIBTEX

这里，我是利用Noteexpress阅读整理文献、WORD中文写作，利用[JabRef](#JabRef)更新、插入TEX题录。

### Noteexpress

<div class="note info"><p>Noteexpress[校内下载地址](http://www.lib.hust.edu.cn/DBView.aspx?id=40&Tab=1)，[noteexpress使用教程百度云盘](http://pan.baidu.com/s/1jI3LqFO)（密码：w9m8），[noteexpress官方教程](http://www.inoteexpress.com/wiki/index.php/%E9%A6%96%E9%A1%B5) </p></div>

使用Noteexpress有以下优点：

- <font color=red>题录标签</font>：可以把每个题录进行**标签化管理**，用几个标签来说明某个题录的中心思想。当需要某一类标签内容时，可以直接点击查看相关题录。
- 附件管理：可以直接打开源文件。
- 题录笔记：可以为每个题录进行笔记说明。

<div id="JabRef"></div>

### JabRef

<div class="note info"><p>[JabRef简明教程](http://www.cnblogs.com/tsingke/p/4523908.html)</p></div>

[JabRef](http://jabref.sourceforge.net/) 是一个开源的参考文献管理软件，使用 Java 语言编写，所以天生具有跨平台特性，通用于安装有 Java 支持的 Windows, Linux 和 Mac。它可以很方便地管理下载到本机的文献，生成 BibTeX 文献数据库，供 LaTeX 或其它软件使用，可以与 Kile, Emacs, Vim, WinEdt 等多种软件结合使用。总的来说 **JabRef 最大的特点就是使用 BibTeX 格式的数据库，主要用于LATEX的论文写作**。

> - 不支持粘贴板导入，只能批量导入bib格式文件。
> - 可以直接在 JabRef 中选择 Web search->Search IEEEXplore，然后用标题名搜索，点 Fetch，就可以直接得到 citation 信息  
> - 对某篇文献有深刻印象或者想记一下笔记，可以在 Review 选项卡中记录下自己的想法。  
> - 文献还可以分组。View->Toggle groups interface，可以新建、修改分组，这样有一个好处是可以将该数据库所属大方向的很多小方向分组浏览。  

1. 文献导入：[导入bibtex条目](#bibtex)后，可以在菜单栏左下角 `update bibliographic information from the web`，选择`CROSSREF`（获取DOI信息），在弹窗中<font color=red>确认题目一致</font>，勾选需要保留左右侧内容，选择 `replace original entry` 即可自动更新题目，这点比noteexpress更好。
1. 管理附件
    - 只需要将下载下来论文的文件名保存成特定的格式，一种方法是文件名中包含 BibTeXkey，Bibtexkey就是文献条目的标识，相当于一个人的名字，在一个文献库里面Bibtexkey不会重复。如果是 A. Yao 在 2005 年发表的文章，文件名就起为 xxx-Yao2005-yyy.pdf；一种方法是文件名包含论文名，或[year]-[auth]-p[firstpage]-[lastpage]。
    - 然后修改匹配规则：Options->Preferences->External Programs->Use Regular Expression Search 文本框，如果我们把文献数据库 bib 文件和 pdf 文件放在同一目录下，只需要使用在当前目录下匹配即可。  
        ```
        在当前目录下匹配包含 BibTeXkey 的文件：“./.*[bibtexkey].*\\.[extension]”  
        在当前目录下匹配包含论文名的文件：“./.*[title].*\\.[extension]”  
        在子目录中匹配包含 BibTeXkek 的文件：“**/.*[bibtexkey].*\\.[extension]”。
        ```
    - 文件名和匹配关系修改好了，那么我们就可以将论文记录关联到文件了。
        - 如果是一次导入很多文献，可以使用批量处理：`Tools->Scan database->Sychronize file links`，但是同步的时候不要选择 `Check existing file links`，那样会很慢；
        - 处理单一记录的方法是：双击某论文条目，或者选中后按 `Ctrl-e`，就可以编辑该条目。进入 `General` 选项卡，在 `File` 条目后面点 `Auto`，JabRef 就会按照匹配规则搜索匹配的文件，关联到该条目。如果能搜索到 pdf 文件，关联后该条目的前面会出现一个 pdf 图标，点击该图标，就可以直接打开该论文的 pdf 文件。
        - 除了自动匹配以外，也可以使用 Auto 旁边的 + 号手动添加文件。

### Citavi

[Citavi 官方网站](https://www.citavi.com/en/)来自瑞士 Swiss Academic Software 公司。其定位于“知识管理软件”，在欧洲（特别是德语区）被广泛使用。它不仅仅是一款文献管理软件，而且整合了知识管理、任务计划、PDF原文全文搜索、笔记等科研工作中的亟需功能，可以说是科研工作的瑞士军刀！免费版有每个项目100篇文献条目的限制，完整版则没有条目限制。没有接触文献管理的，可以下载注册机尝试下。不过中文的noteexpress也够用。

点击查看[Citavi 中文教程](http://blog.yuelong.info/post/citavi-get-started-1-settings-up.html)。更多参考[点击](http://blog.sciencenet.cn/blog-742276-584427.html)博文查看。

<div id="abbrev"></div>

## 文献缩写

> 缩写标准[List of Title Word Abbreviations](http://www.issn.org/services/online-services/access-to-the-ltwa/)

期刊缩写一般包括两种格式：JCR缩写和ISO缩写。建议通过 [CAS Source Index (CASSI) Search Tool](https://cassi.cas.org/search.jsp) 校正ISO缩写。

[JabRef](#JabRef) 软件提供了[Journal abbreviations](https://docs.jabref.org/v/v4/fields/journalabbreviations) 的转化功能。此功能可以在“选项->管理期刊缩写”（Options -> Manage journal abbreviations）中配置。A repository of abbreviations for references can be found in [abbrv.jabref.org](http://abbrv.jabref.org/journals/).

但是此方法存在问题：Bibtex中的条目存在 `\&` 和 `{}` 的转义，需要期刊全名才能顺利识别。（待续）

# 项目管理工具

- [sciNote](http://scinote.net/)：这是一款带有工作流程和模块化功能的开源实验室笔记本。sciNote 的一个有趣功能是它允许用户在工作流程中链接项目的不同阶段，从而将项目或实验不同阶段获得的数据连接起来，扩展了数据背景；此功能使实验室笔记本条目的逻辑进程变得清晰。这款软件还有一项有趣功能是每个用户都有自己的角色并享有团队内一系列权限，以保护每位研究人员的个人数据并确保其机密性。

<div id="literature-follow"></div>

# 文献跟踪

有了文献库不代表就不用读了，你要建立一个体系来整理并追踪最新文献。

<div id="literature-rss"></div>

## 文献RSS跟踪

推荐使用RSS跟踪最新文献（[如何使用RSS订阅追踪专业前沿领域文献](http://pan.baidu.com/s/1qYUDz1i)，密码：0mgw），RSS会根据您的订阅情况实时更新最新的文献信息，浏览前沿文献的过程中，遇到比较感兴趣的文章，可以再回头去找全文。。

- 在[常用检索数据库](https://sli1989.github.io/information-search/#literature-search)（推荐使用Scopus数据库，注意查看可能的匹配作者）首次搜索关键词后，就对感兴趣的检索结果建立rss跟踪，避免后期需要重新检索。
- RSS阅读器，推荐使用[inoreader](http://www.inoreader.com/welcome)，使用教程查看参考文献[^ino1] [^ino2]或者自行搜索。
- 建议文献追新频率每周一次，固定时间，看到好的文章就马上消化掉。

[^ino1]: [Inoreader 阅读器使用入门指南](https://zhuanlan.zhihu.com/p/24681668)
[^ino2]: [inoreader 阅读器使用](http://blog.csdn.net/mingyong_blog/article/details/40792687)

<div id="follow-scholar"></div>

## 同行学者跟踪

除了本专业内的目标期刊，科研人员都会有自己的学术圈，或者是研究相同、相关领域的专业同行。他们往往需要跟踪对方的学术成果，尤其是，在某一专业领域的知名学者更是备受瞩目。

关于如何跟踪同行学者的最新研究成果，[笔者](http://blog.sciencenet.cn/home.php?mod=space&uid=267717&do=blog&id=1063595)总结以下几条：


- **挂靠单位的个人主页信息**。尽管这一点从时效性的角度并不推荐，但从相对全面地了解同行学者的整体思路来看是有帮助的。
- **检索基金课题号**。打开谷歌学术，然后搜索学者的基金课题编号，注意，使用双引号进行精确搜索，便可以搜索到该课题所发表的成果。
- **检索数据库**：
    - [Scopus](https://www.scopus.com/home.uri?zone=header&origin=AuthorProfile)是全球最大的文献摘要与科研信息引用数据库。针对每位作者，统计了其文献信息（总发文量，总被引次数）、h指数、引文概览（可选择排自引，或排共同作者引用）、作者的个人文献输出分析图表（一键生成）。
    - [Stork](https://www.storkapp.me/)：科研人员只需要提供邮箱及输入感兴趣的研究主题即可定期收到其推送的文章列表。除了跟踪关键词，Stork也可以跟踪学者，可以输入学者的名字。笔者根据自己的使用经验，给读者提一个小建议。在输入关键词的时候尽可能的缩小范围，具体化，可以使用检索常用的逻辑字符，如“AND”、“OR”、“NOT”等。
- [**Researchgate**](http://www.researchgate.net/)是2008年推出的针对学术圈的网络社交平台。只需点击“Follow”对方，就可以了解对方发表最新研究成果的信息、科研项目等，有时候会通过邮箱的形式告知。这里多说几句， Researchgate除了能够跟踪学术文献外，还能起到与同行交流的作用，如可以发私信，评论等途径。当然，还可以下载许多由作者提供的期刊或者非期刊论文。此外，网站也会根据你的研究主题词来推荐一些工作信息。
- **Google学术推送** 与Google学术检索不同，类似于Researchgate的个人学术主页，但仅有论文或者书籍的信息。很多学者都有自己的Google学术账号。在Google学术检索时，会发现有些论文的作者下面会出现链接的信息，如果对他的研究感兴趣，可以点击，然后你会发现他的期刊信息以及他论文的引用情况。如果你想跟踪他的研究成果，只需要点击“关注”，输入常用的邮箱地址，再点击“创建快讯”即可。一旦对方有新发表的论文，你就会收到邮件通知。
- [**Academia**](https://www.academia.edu/)跟Researchgate的功能类似，作者也需要通过邮箱注册，然后可以访问学者信息，下载论文等。感兴趣的朋友可以尝试使用。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>科研经验</tag>
        <tag>文献管理</tag>
      </tags>
  </entry>
  <entry>
    <title>回归分析与方差分析</title>
    <url>/regression-analysis-ANOVA/</url>
    <content><![CDATA[
回归分析（regression analysis)是确定两种或两种以上变量间相互依赖的定量关系的一种统计分析方法。运用十分广泛，回归分析按照涉及的变量的多少，分为一元回归和多元回归分析；按照因变量的多少，可分为简单回归分析和多重回归分析；按照自变量和因变量之间的关系类型，可分为线性回归分析和非线性回归分析。如果在回归分析中，只包括一个自变量和一个因变量，且二者的关系可用一条直线近似表示，这种回归分析称为一元线性回归分析。如果回归分析中包括两个或两个以上的自变量，且自变量之间存在线性相关，则称为多重线性回归分析。

方差分析(Analysis of Variance，简称ANOVA)，又称“变异数分析”，是R.A.Fisher发明的，用于两个及两个以上样本均数差别的显著性检验。 由于各种因素的影响，研究所得的数据呈现波动状。造成波动的原因可分成两类，一是不可控的随机因素，另一是研究中施加的对结果形成影响的可控因素。方差分析是从观测变量的方差入手，研究诸多控制变量中哪些变量是对观测变量有显著影响的变量。

<!--more-->

这两者都是考察所研究的自变量与因变量之间的关系，而且其实任何的方差分析都可以看成是一种特殊的回归，因为二者都可以统一到一个大的范畴——线性模型(General Linear Model, GLM)。但是这两种分析对应的变量可以是不同的，方差分析的自变量一般都是分类变量（当然也可以是连续变量），因变量都是连续变量；而回归分析的自变量和因变量都是连续变量。这样，从形式上来看方差跟回归的形式差不多，但是线性回归中的自变量和因变量是一一对应的，而方差分析中的自变量和因变量可能是一对多的。

虽然，很多教科书在介绍这两种分析方法时，都由于他们的分析目的不同而把他们界定为两种不同的分析方法，因为方差分析考察的是自变量对因变量的影响是否显著，而回归分析考察的是自变量与因变量之间的可以用数学表达式来表示的线性相关关系。但是分析的目的是基于研究目的，因为方差分析与回归分析对同一组数据得出的结果是一样的，那么在解释分析结果时，就要根据研究结果具体问题具体对待。

因此从这两种分析的本质来讲，方差分析与回归分析总体上属于一个类别，都是线性模型（ linear model, LM）。至于到底选择什么模型，是方差分析还是线性回归，其实不必拘泥，可以根据实际的研究需要，选择相应的分析方法。

> 摘录于[数理统计知识整理——回归分析与方差分析](https://github.com/xiahouzuoxin/notes/blob/master/essays/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86%E2%80%94%E2%80%94%E5%9B%9E%E5%BD%92%E5%88%86%E6%9E%90%E4%B8%8E%E6%96%B9%E5%B7%AE%E5%88%86%E6%9E%90.md)

# 回归分析

回归分析的主要内容是通过试验或观测数据，寻找相关变量之间的统计规律性，再利用自变量的值有效预测因变量的可能取值。

其实际操作的步骤是：

- 设定回归方程
- 根据误差分析，考虑搜集数据对回归方程参数的影响，有目的的搜集数据
- 确定回归系数
- 进行相关性检验
- 预测


# 线性回归

## 原理分析

要研究最大积雪深度x与灌溉面积y之间的关系，测试得到近10年的数据如下表：

![][最大积雪深度-灌溉面积]

使用线性回归的方法可以估计x与y之间的线性关系。

线性回归方程式：

![][回归方程]

对应的估计方程式为

![][线性回归方程]

线性回归完成的任务是，依据观测数据集(x1,y1),(x2,y2),...,(xn,yn)使用线性拟合估计回归方程中的参数a和b。a,b都为估计结果，原方程中的真实值一般用α和β表示。

为什么要做这种拟合呢？

答案是：为了预测。比如根据前期的股票数据拟合得到股票的变化趋势（当然股票的变化可就不是这么简单的线性关系了）。

线性回归的拟合过程使用最小二乘法，

![][最小二乘法]

最小二乘法的原理是：选择a,b的值，使得残差的平方和最小。

为什么是平方和最小，不是绝对值的和？答案是，绝对值也可以，但是，绝对值进行代数运算没有平方那样的方便，4次方又显得太复杂，数学中这种“转化化归”的思路表现得是那么的优美！

残差平方和Q，

![][残差]

求最小，方法有很多。代数方法是求导，还有一些运筹学优化的方法（梯度下降、牛顿法），这里只需要使用求导就OK了，

![][残差和求导]

为表示方便，引入一些符号，

![][线性回归符号]

最终估计参数a与b的结果是：

![][b]

![][a]

自此，针对前面的例子，只要将观测数据带入上面表达式即可计算得到拟合之后的a和b。不妨试一试？


从线性函数的角度，b表示的拟合直线的斜率，不考虑数学的严谨性，从应用的角度，结果的b可以看成是离散点的斜率，表示变化趋势，b的绝对值越大，表示数据的变化越快。

线性回归的估计方法存在误差，误差的大小通过Q衡量。


## 误差分析

考虑获取观测数据的实验中存在其它的影响因素，将这些因素全部考虑到e~N(0,δ^2)中，回归方程重写为

y = a + bx + e

由此计算估计量a与b的方差结果为，

![][Dab]

a与b的方差不仅与δ和x的波动大小有关，而且还与观察数据的个数有关。在设计观测实验时，x的取值越分散，估计ab的误差就越小，数据量越大，估计量b的效果越好。这也许能为设计实验搜集数据提供某些指导。


## 拟合优度检验及统计量

拟合优度检验模型对样本观测值的拟合程度，其方法是构造一个可以表征拟合程度的指标，称为统计量，统计量是样本的函数。从检验对象中计算出该统计量的数值，然后与某一标准进行比较，得出检验结论。

这是又会问了，最小二乘法不是保证了模型最好的拟合样本观测值了吗？为什么还要检验拟合程度？

最小二乘法保证的是同一个样本集使用最小二乘法拟合程度最好，而拟合优度检验结果表示的是多个不同样本集各自进行拟合后对拟合效果的比较。比如，下面的直线方程都是使用最小二乘法拟合的结果，但二者对样本观测值的拟合程度显然不同。

![][拟合优度检验]


为构造统计量，先定义三个表达式：


![][Se]

![][SR]

![][ST]

通过推倒可以发现：![][ST-Se-SR]

![][_ST]表示观测值y1,y2,y3,...yn与它们的平均值的离差平方和，![][_ST]越大，则观测值的波动越大。因此称总离差平方和。

![][_SR]表示回归直线上点的纵坐标^y1,^y2,...,^yn与与观测值均值的离差平方和。所以称为回归平方和。![][_SR]反映出回归直线因素对![][_ST]的影响。

![][_Se]是最小二乘法中残差平方和Q的最小值，它是实际观测值yi与回归直线上的点(xi,^yi)的纵坐标^yi的离差平方和。![][_Se]是扣除线性影响外的剩余平方和，因此称为残差平方和。

显然，一个拟合得比较好的模型，![][_ST]与![][_SR]应该比较接近，而![][_Se]应该尽可能的小。因此，可以通过构造某种![][_ST]与![][_SR]的表达式作为拟合优度检验中的统计量。

- 构造统计量——相关系数

因此，构造相关系数

![][相关系数]

不同的r值有不同的线性相关表示，如下图

![][相关系数图]

结论：

	当|r|->0时，表示x与y之间的线性关系不明显，不适合使用线性回归建模。反之，当|r|越接近1时，表示x与y之间的线性关系越密切。


- 构造统计量——F

![][统计量F]

F值越小表示线性关系越密切，反之线性关系越弱。

- 构造统计量——t

![][统计量t]

|t|越大，x与y之间的线性关系越密切；反之，越小，x与y之间的线性关系越微弱。


不管是相关系数，还是F，或者t，都能用于描述x与y之间的线性相关程度。并且可以通过验证，这三种统计量用于下面的显著性检验是完全一致的。

## 显著性检验

显著性检验，

以开头“最大积雪深度x与灌溉面积y之间的关系”的线性关系是否显著为例，使用上面构造的统计量进行显著性检验的过程如下：

![][显著性检验-1]

![][显著性检验-2]

![][显著性检验-3]

![][显著性检验-4]

![][显著性检验-5]

在当中，计算线性回归及显著性检验使用到如下的公式，下面的公式不用记住，使用时查询即可。


![][线性回归季显著性检验的公式]

相关系数的查表参见[相关系数显著性检验表]


## 置信区间

回归系数α以1-α为置信度的置信区间为

![][alpha置信区间]

回归系数β以1-α为置信度的置信区间为

![][beta置信区间]

其中S都为，

![][S-Equal]

## 使用Matlab做回归分析

使用最小二乘法做多元线性回归分析的函数为：

```
[b,bint,r,rint,stats] = regress(y,X,alpha);

% alpha  为显著性水平
% b bint 为回归系数估计值向量及其置信区间
% r rint 为残差向量及其置信区间，可用rcoplot(r,rint)绘图
```

下面是一个使用Matlab做线性回归分析的实例：

	EG:
	x  0.10 0.11 0.12 0.13  0.14 0.15 0.16 0.17 0.18
	y  42.0 41.5 45.0 45.5 45.0 47.5 49.0 55.0 50.0

Matlab代码如下：

```
clear all
clf
close all

% 绘制(X,Y)散点图
figure,
x=0.1:0.01:0.18;
y=[42,41.5,45.0,45.5,45.0,47.5,49.0,55.0,50.0];
plot(x,y,'+')

% 线性回归分析
x1=x';
y1=y';  
x2=[ones(9,1),x1];
[b,bint,r,rint,stats]=regress(y1,x2);

% 绘制拟合直线
y = b(2)*x + b(1);
hold on,plot(x,y,'r');

% 绘制残差图
figure,rcoplot(r,rint);
```

结果为拟合直线图和残差图如下：

![][回归分析Matlab1]
![][回归分析Matlab2]

在Matlab中还可以使用polyfit函数非常方便的对数据进行拟合，polyfit除了能进行线性拟合，还可以进行非线性的拟合。

使用polyfit拟合方法如下：

```
% 绘制(X,Y)散点图
figure,
x=0.1:0.01:0.18;
y=[42,41.5,45.0,45.5,45.0,47.5,49.0,55.0,50.0];
plot(x,y,'+');

% 绘制拟合直线
hold on,
p = polyfit(x',y',1);
y = p(1).*x + p(2);
plot(x,y2，'r');
```

拟合结果与上面的一样。

## 回归分析的实际操作步骤

回归分析的主要内容是通过试验或观测数据，寻找相关变量之间的统计规律性，再利用自变量的值有效预测因变量的可能取值。

其实际操作的步骤是：

1. 设定回归方程
2. 根据误差分析，考虑搜集数据对回归方程参数的影响，有目的的搜集数据
3. 确定回归系数
4. 进行相关性检验
5. 预测


# 方差分析

方差分析问题：用数理统计分析试验结果、鉴别各因素对结果影响程度的方法称为方差分析（Analysis Of Variance），记作ANOVA。

方差分析主要分为'①单因素一元方差分析'； '②双因素一元方差分析 '； '③多因素一元方差分析 '； '④单因素多元方差分析 '。

## 引入

![][灯泡寿命-灯丝]

如上图，对A1~A4共4种不同灯丝的灯泡进行抽样检测灯泡寿命，根据测试数据，现在要问：灯泡寿命是否与灯丝材料的不同有关。

问题特点有：

- 1项指标（__因变量__）：寿命
- 影响指标的因素（__因子__）：灯丝
- 因素存在多个不同状态（__水平__），要求分析因素的不同状态是否对指标有显著影响

这就是方差分析问题：用数理统计分析试验结果、鉴别各因素对结果影响程度的方法称为方差分析（Analysis Of Variance），记作ANOVA。

## 单因素方差分析

其它因素不变，只考虑一个因素A，因素存在多个水平，在每个水平上做若干次实验，从实验结果推断是否该因素对指标有显著影响？这就是单因素的方差分析，上面的例子就是单因素方差分析的例子。

- 前提假设

设因素A的r个水平为A1,A1,...,Ar，每个水平下的指标服从正态分布N(u1,δ2),N(u2,δ2),...,N(ur,δ2)。

- 模型建立

实验数据的格式：

![][单因素方差分析实验数据表]

因子对指标是否有影响取决于指标的正态分布是否一致，如果有影响，则正态分布应该存在差异，而正态分布由均值和方差决定，假设中方差相同，因此各个水平下的正态分布均值直接决定因素是否对指标有影响。

所以，问题可以转化为假设检验，设

H0: u1=u2=u3=...=ur

检验结果如果拒绝原假设，则认为因素A对指标有显著影响，否则认为无显著影响。

设

u = (1/r)\sum_1^a{ui}

αi = ui - u

则，H0假设改写成

H0: α1=α2=α3=...=αr=0

- 构造统计量（摘自《数学建模Matlab大全》）

![][方差分析1]
![][方差分析2]

- 单因素方差分析表

过对上面模型中相关参数进行计算，为计算分析方便，将结果填入下表中：

![][单因素方差分析表]

表中的Pr反映的就是>F值的概率，F值通过因素A均方除以误差均方获得。

因此，有

1. 如果Pr大于α，则接受H0，因素对指标无显著影响
2. 如果Pr小于α，则拒绝H0，因素对指标有显著影响

Matlab的输出结果即为上面的方差分析表，因此，用matlab很容易进行方差分析。

## 用Matlab进行单因素方差分析

![][单因素方差分析题]

能否认为这三所小学五年级男学生的平均身高相同？取显著水平α=0.05.

假设H0: 这三所小学五年级男学生的平均身高相同。

```Matlab
data = [...
128.1	134.1	131.1	138.9	140.8	127.4; ...
150.3	147.9	136.8	126.0	150.7	155.8; ...
140.6	143.1	144.5	143.7	148.5	146.4...
];
data = data';

P=anova1(data);  % 方差分析函数anova1
```

Matlab程序的运行结果为：

![][单因素方差分析Matlab]

∵ Pr=0.0275 < α
∴ 拒绝H0，即不能认为这三所小学五年级男学生的平均身高相同。

实验数据也可以是非平衡数据，如上，假设小学2的测试数据少一组：

![][单因素方差分析题1]

此时，anova1调用格式有所改变，

```
p=anova1(x,group)

% x 为向量，从第 1 组到第r组数据依次排列；group 为与 x 同长度的向量，标志 x 中数
% 据的组别（在与 x 第i组数据相对应的位置处输入整数 i=1,2,..r）
```

此时的Matlab代码为：

```matlab
x = [...
128.1	134.1	131.1	138.9	140.8	127.4; ...
150.3	147.9	136.8	126.0	150.7	0; ...
140.6	143.1	144.5	143.7	148.5	146.4...
];
x = [x(1,:),x(2,1:5),x(3,:)];
g = [ones(1,6),2*ones(1,5),3*ones(1,6)];

P=anova1(x, g);
```

结果为

![][单因素方差分析Matlab1]

因为仅改变了一个实验数据，其结果和前面的一致。


## 双因素方差分析

关于双因素方差分析的模型请参考[3]，这里从实际角度出发：

- 考虑如何测试实验数据

按下表测试数据，每组t各数据，共r x s组。

![][双因素分析实验数据表]


- 考虑双因素间是否有交互影响

无交互影响时可简化测试的实验数据数，每组测一个数据（令t=1）即可，因为无交互影响双因素方差分析表中各量都与t无关。

![][无交互影响双因素方差分析表]

有交互影响的方差分析表如下：

![][有交互影响方差分析表]

从方差分析表中可以看出：与单因素方差分析相比，双因素方差分析只是多了一个因素，因此方差分析表中多了一行而已，再加上要考虑交互影响，则方差分析表中再增加1行。

- 考虑如何使用Matlab进行分析

Matlab中通过
```
p=anova2(x,reps)
```
进行双因素的方差分析，不妨使用

```
>> help anova2
```

查看anova2函数的使用方法。

	对无交互关系的双因素方差分析，此时每个单元只需要测一个值，reps=1
	对于交互关系的双因素方差分析，此时每个单元需要测多个值（t>1）,reps=2

参数x的格式为：

	% 列因素有3个水平(s=3)，行因素有2个水平(r=2)，每组测试2个数据(t=2)
	x =[x111 x121 x131
	    x112 x122 x132
	    x211 x221 x231
	    x221 x222 x232]

1\. 无交互作用双因素方差分析的例子

>> 一种火箭使用了四种燃料、三种推进器，进行射程试验，对于每种燃料与每种推进器的组合作一次试验，得到如下数据表，问各种燃料之间及各种推进器之间有无显著差异？设显著性水平α=0.05.
![][火箭试验数据]

Matlab解题代码如下：

```matlab
x=[58.2 56.2 65.3
49.1 54.1 51.6
60.1 70.9 39.2
75.8 58.2 48.7];

[p,t,st]=anova2(x,1);
```

分析结果的方差分析表如下：

![][双因素方差分析EG1]

求得p=[0.4491 0.7387]，都大于α，所以各种燃料之间及各种推进器的差异都对火箭射程没影响。

2\. 有交互作用双因素方差分析的例子

> 一种火箭使用了四种燃料、三种推进器，进行射程试验，对于每种燃料与每种推进器的组合作2次试验，得到如下数据表，问各种燃料之间及各种推进器之间有无显著差异？两因素的交互作用是否显著？设显著性水平α=0.05.
![][火箭试验数据2]

Matlab解题代码如下：

```matlab
x0=[58.2,52.6 56.2,41.2  65.3,60.8
49.1,42.8 54.1,50.5 51.6,48.4
60.1,58.3 70.9,73.2 39.2,40.7
75.8,71.5 58.2,51.0 48.7,41.4];

x1=x0(:,1:2:5);x2=x0(:,2:2:6);
for i=1:4
    x(2*i-1,:)=x1(i,:);
    x(2*i,:)=x2(i,:);
end

[p,t,st]=anova2(x,2);
```

分析结果的方差分析表如下：

![][双因素方差分析EG2]

求得p=[ 0.0035 0.0260 0.0001]，都小于α，所以各实验均值相等的概率很小，认为不同燃料、不同推进器下的射程有显著差异，交互作用也是显著的。


# 回归分析与方差分析的比较

回归分析与方差分析之间都是研究相关关系的统计方法，就我理解，两者之间的差异在于：

1. 回归分析在于建立自变量与因变量之间的定量关系（表达式），这种定量的关系可用于将来的预测（如：根据14年以前的房价数据建立回归模型，可用于14年的房价预测）；方差分析在于解释因素的不同水平（状态）是否对指标有显著影响，如有显著影响，其具体影响的定量关系还需要用其它方法做进一步的分析（如：通过测试试验数据，分析货币的价值（因素）是否对房价（指标）有显著影响，方差分析无法提供房价与货币价值间的定量表达式）

2. 应用上：当不确定谋因素是否对指标有影响时，可先测量小部分数据，做方差分析。若确定因素对指标有影响，则增加测量因素在不同状态下的数据，进一步用回归分析确定因素与指标之间的定量关系。否则认为因素与指标之间无关。


# 参考

1. [相关系数显著性检验表]
2. 北京科技大学统计优化研究生课程课件
3. 数学建模Matlab大全（共30章）

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>RegressionAnalysis</tag>
        <tag>VarianceAnalysis</tag>
      </tags>
  </entry>
  <entry>
    <title>正则化</title>
    <url>/regularization/</url>
    <content><![CDATA[
正则化(regularization)，是指在线性代数理论中，不适定问题通常是由一组线性代数方程定义的，而且这组方程组通常来源于有着很大的条件数的不适定反问题。大条件数意味着舍入误差或其它误差会严重地影响问题的结果。

<!--more-->


看预测房价的例子，我们先对该数据做线性回归。线性回归并没有很好拟合训练数据。我们把此类情况称为欠拟合(underfitting)，或者叫作叫做高偏差(bias)。另一个极端情况是，对于该数据集用一个$m$次多项式来拟合。那么这个函数能很好的拟合训练集（能拟合几乎所有的训练数据），但这也就面临函数可能太过庞大的问题，变量太多。所以，我们把这类情况叫做过拟合(overfitting)，也叫高方差(variance)。也就是说，我们的代价函数可能非常接近于 0 或者就为 0。

那么，如果发生了过拟合问题，我们应该如何处理？

- 方法一：尽量减少选取变量的数量。具体而言，我们可以人工检查每一项变量，并以此来确定哪些变量更为重要，然后，保留那些更为重要的特征变量。至于，哪些变量应该舍弃，我们以后在讨论，这会涉及到模型选择算法，这种算法是可以自动选择采用哪些特征变量，自动舍弃不需要的变量。这类做法非常有效，但是其缺点是当你舍弃一部分特征变量时，你也舍弃了问题中的一些信息。例如，也许所有的特征变量对于预测房价都是有用的，我们实际上并不想舍弃一些信息或者说舍弃这些特征变量。
- 方法二：正则化。正则化中我们将保留所有的特征变量，但是会减小特征变量的数量级（参数数值的大小θ(j)）。这个方法非常有效，当我们有很多特征变量时，其中每一个变量都能对预测产生一点影响。正如我们在房价预测的例子中看到的那样，我们可以有很多特征变量，其中每一个变量都是有用的，因此我们不希望把它们删掉，这就导致了正则化概念的发生。

正则化是一种回归的形式，它将系数估计（coefficient estimate）朝零的方向进行约束、调整或缩小。也就是说，正则化可以在学习过程中降低模型复杂度和不稳定程度，从而避免过拟合的危险。[机器学习之正则化（Regularization）](https://www.cnblogs.com/jianxinzhou/p/4083921.html)给出了正规化背后的思路。这种思路就是，如果我们的参数值对应一个较小值的话（参数值比较小），那么往往我们会得到一个形式更简单的假设。

> [Regularization in Machine Learning](https://towardsdatascience.com/regularization-in-machine-learning-76441ddcf99a)  
> [初学者如何学习机器学习中的L1和L2正则化](https://www.jiqizhixin.com/articles/2017-11-23-4)

正则化项即罚函数，该项对模型向量进行“惩罚”，从而避免单纯最小二乘问题的过拟合问题。训练的目的是最小化目标函数，则C越小，意味着惩罚越小，分类间隔也就越小，分类错误也就越少。

正则化项本质上是一种先验信息，整个最优化问题从贝叶斯观点来看是一种贝叶斯最大后验估计，其中正则化项对应后验估计中的先验信息，损失函数对应后验估计中的似然函数，两者的乘积即对应贝叶斯最大后验估计的形式，如果你将这个贝叶斯最大后验估计的形式取对数，即进行极大似然估计，你就会发现问题立马变成了损失函数+正则化项的最优化问题形式。

(1) 避免出现过拟合（over-fitting）。经验风险最小化 + 正则化项 = 结构风险最小化。

(2) 从模型求解上看，正则化提供了一种唯一解的可能。光用最小二乘拟合可能出现无数组解，加个L1或L2正则化项能有唯一解。

# L1 regularization

> [机器学习：L1与L2正则化项](http://blog.csdn.net/xskxushaokai/article/details/78057440)

L1范数是指向量中各个元素绝对值之和，用于特征选择;

# L2 regularization

L2范数是指向量各元素的平方和然后求平方根，用于 防止过拟合，提升模型的泛化能力

L1与L2区别：使用L1可以得到稀疏的权值；用L2可以得到平滑的权值

---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>Regularization</tag>
      </tags>
  </entry>
  <entry>
    <title>强化学习</title>
    <url>/reinforcement-learning/</url>
    <content><![CDATA[
强化学习是机器学习中的一个领域，强调如何基于环境而行动，以取得最大化的预期利益。其灵感来源于心理学中的行为主义理论，即有机体如何在环境给予的奖励或惩罚的刺激下，逐步形成对刺激的预期，产生能获得最大利益的习惯性行为。这个方法具有普适性，因此在其他许多领域都有研究，例如博弈论、控制论、运筹学、信息论、仿真优化、多主体系统学习、群体智能、统计学以及遗传算法。
<!--more-->

人们一般认为机器学习拥有三根重要的柱石：非监督学习、监督学习、强化学习，这三个部分基本上包含了机器学习研究与应用的方方面面。在非监督学习中，算法的目标是对数据进行有效的归纳总结，我们可以把这一过程视为模型将输入的x数据转换为了可以归纳表示输入信息的低维度输出z。而对于监督学习来说、我们需要通过输入数据x预测出输出数据的某一特征y，这是我们最为熟悉的机器学习方法了，主要包括回归和分类两大分支。而对于强化学习来说，对于特定的输入x对应着两个输出分别是action和reward。强化学习的目标就是在给定输入的情况下尽可能地选择出能使r（奖励）最大的a（行为）。有很多问题可以用强化学习来解决，从游戏中的在线决策到网络世界中的最大化收益都可以通过这样的方式来获取较好的解决方案。

在[An Outsider’s Tour of Reinforcement Learning](http://www.argmin.net/2018/01/29/taxonomy/)（[中文](https://36kr.com/p/5119373.html)）里作者[将强化学习归结成了一种预测分析的模式](http://www.argmin.net/2018/02/05/linearization/)，而在随后的文章里则是[以优化控制的形式展开](http://www.argmin.net/2018/02/08/lqr/)的。

描述性分析指的是通过归纳数据使其具有更好的可解释性，非监督学习就是一种很好的描述性分析方法，而预测分析的目标则是基于现在的数据估计未来的结果，而最终的规范性分析(prescriptive analytics)则旨在指导行动以保证结果。强化学习恰恰就属于最后一个范畴。而最大的挑战则来自于规范性分析。这一类模型的目标十分清晰：强化学习和规范性分析需要分析输入并决定要采取的行动和明确对应的奖励。规范性分析所面对的新数据来源于不确定的环境中，随后需要作出决策并利用这些决策影响环境。这样的系统会在好的决策下获得丰厚的奖励，而在糟糕的决策后则面临着灾难性的结果。但由于反馈来源于复杂的相互联系中使其在理论上难以研究。

强化学习令人不解的原因主要在于它需要我们利用一种在通常机器学习中不常用的核心概念去思考。首先你需要考虑时变的统计学模型并理解数据中的依赖只是暂时的相关而已；第二、你应该理解统计学习问题中的反馈效应，每一次行为后对于结果的观测分布，强化学习系统必须适应这些分布。



---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>ReinforcementLearning</tag>
      </tags>
  </entry>
  <entry>
    <title>记住对方的名字</title>
    <url>/remember-name/</url>
    <content><![CDATA[
对很多人来说，要记住认识不久的人简直是生活中最困扰的记忆难题，特别是你刚到陌生的工作环境，同事和领导的名字跟脸都对不上号，尤其尴尬。

我们要记住一个人，关键便是用心观察，先辨识对方的脸孔特征，再透过谈话了解对方信息，以“名字+外貌+特色”三位一体建构完整认知，就能牢牢记住他了。

<!--more-->

# 记住对方的名字

记住人脸与名字的第一法则，就是“立即将对方的名字与脸孔反复输入大脑”。在社交场合中，互换名片后，多半会展开简短交流，这时就是记忆人名的关键时刻。

① 认真倾听对方的自我介绍；

② 别思考接下来要说什么，倾听对方的名字；

假如没听清楚，只要说“对不起，我没听清楚你的名字”：如果对方的名字很特别，可以进一步询问“可否请教你的名字怎么写？”

③ 大声重复对方的名字；

“哦，你叫巴九灵是吧，巴九灵你好！”通过“听到”“反应”“大声念出”这三个步骤，对方的名字已经在你脑海里形成了初步印象。

④ 想想是否有别人叫这个名字；

你是否恰好有跟对方同名的朋友，或者有没有明星跟他的名字比较相似。

⑤ 交谈的过程与结尾，提及这个名字。

“巴九灵，当你说……”“巴九灵，我以后该怎么联络你？”将对方的名字嵌入对话时的常用语中，可帮助自己记忆更深。

此外，将对方姓名作为对话结尾，也可让对方对自己留下好印象，为整场交谈留下完美句点。比如“很高兴认识你，巴九灵。”

# 观察对方脸孔T字部位

很多人都觉得自己脸盲，明明见过对方几次可是仍旧名字跟脸对不上号，有没有什么办法可以让我们快速记住人脸？

小巴告诉你，当然有，你在观察别人脸部的时候，只要着重观察对方眼睛和口鼻的T字部位就行了，因为人脑设定就是以这部分来辨识别人的，不要依靠对方的身材和发型来区别 ，毕竟很多人换了个发型你就认不出的情况是不是也常发生？

人脸依照五官配置，可分为以下6种基本类型，只要学会分辨，就能快速掌握一个人脸上的特征重点：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lodmbgqj20hj07ggqt.jpg)

# 透过问答掌握对方特征

外向的人往往比较容易让人记住，是因为他们会不断对外提供自身资讯，不知不觉就让人对他们的姓名、个性、表情、穿搭和说话方式都有了印象。

如果你遇到的人没有这么外向，你想记住他就必须主动提问，让对方说出自己的职业、喜好、来此目的、最近从事活动等，最后，将所有资讯与对方说话方式和外貌联结起来，甚至私下帮对方取个绰号。

当你掌握这些信息，对方就会从名字变成一个具有特征的完整个体。

# 对着名片回忆对方名字与脸孔

会面结束后，我们还可以将名片拿出来整理，将重要资讯记录在名片上，例如长相特征、说话内容、整体印象等，帮助日后回想。

# 情境重现，找回遗忘信息

除了人名和数字，我们在工作中还要跟很多业务细节打交道。与其白费功夫，不如从周边相关讯息下手，通过追忆当时的环境、琐事、经过或感觉等信息，重现整件事情的经过，这个方法就叫做心理复习法，对于记起你忘记但是确定十万火急的事，不妨一试。

步骤一 详细描述接触资讯时所处的情况

不要只是在心里默想，一定要动笔在纸上写下整个事件或活动的过程始末，或是大声说出来。手写或口说才能帮助自己回想与凸显出整件事情的轮廓，让自己更容易想起细节信息。

步骤二 开始重建现场

写下或说出所有你对当时现场的记忆，包括看到、听到、感觉到、触摸到与内心的感受和反应，不要错过任何一个细节，越仔细越好。

例如“我坐在会议室里，阳光从背后的窗户照进来，让我桌上的电脑屏幕有些反光；当时第一个发言的是销售部经理，她穿着浅绿色衬衫；吴老师对其中某个销售数据提出了疑问……”

步骤三 设想自己此时就处于该场景中

设想自己此时就身处现场，用现在式的语法进行叙述。

例如：“销售经理坐在我对面，正报告这一季的业绩数字……”而不要用“当时我旁边坐着……”自己越投入当时情境，就能想起越多细节。

步骤四 尽力回想模糊的细节

上述3步骤持续3~5分钟，描述出整个情境与当时感受后，试着添加当时不经意看到的细节，例如“听完销售经理的报告，吴老师挽起了袖子”。

步骤五 连结细节，找出新的印象与观感

把回想起的细节与其他事实和观点联系起来，寻找新的观点和疑问，扩大自己的联想和回忆范围，例如“销售经理谈到这季度的主产品销售业绩很好，对周边产品却完全没有提及，其中有什么原因吗？”

步骤六 持续不断联想，直到想起所有重要细节

继续反复进行上述步骤，直至回忆起所有重要事情。或许每一次只能想起一点新的信息，甚至毫无所获，但依然要强迫自己回想，并把可能的蛛丝马迹都写下来，透过反复检视，你可以重新归类某些有印象但不知道归属的数字或名词，找回记忆拼图。

步骤七 回顾检视，记下所需讯息

最后检视目前为止回想起来的部分，里面可能有你想要的讯息，也可能有许多无关的讯息，把它们重新排列，将零散资讯统合成有顺序、有逻辑的架构脉络，挑出原本想要记起的信息。

> 转载自 [文/巴九灵 （微信公众号：吴晓波频道）](https://mp.weixin.qq.com/s?__biz=MzA3OTM5NTkxNA==&mid=2652424442&idx=1&sn=b096de493c53a95f21328215f2437020&scene=0#wechat_redirect)

---
]]></content>
      <categories>
        <category>Life</category>
        <category>Etiquette</category>
      </categories>
      <tags>
        <tag>礼仪</tag>
      </tags>
  </entry>
  <entry>
    <title>魔方入门玩法教程</title>
    <url>/rubik/</url>
    <content><![CDATA[
魔方，英文名为Rubik's Cube，又叫魔术方块或鲁比克方块和幻方，是一种手部极限运动。通常泛指三阶魔方。三阶魔方魔方形状通常是正方体，由有弹性的硬塑料制成。玩法是将魔方打乱，然后在最短的时间内复原。目前三阶魔方官方世界纪录是由来自澳大利亚的Feliks Zemdegs（菲利克斯·曾姆丹格斯）保持的4.73秒。

<!--more-->

三阶魔方有8个角色块，12个棱色块，6个中心块，中心块相对位置永远不变，一定是红橙相对，蓝绿相对，黄白相对，也就是相近的颜色相对。中心块是什么颜色，这一面最后就会是什么颜色。

![](http://www.rubik.com.cn/newimage/structure.gif)

参考资料：
http://www.rubik.com.cn/beginner.htm
http://www.mf100.org/beginner.htm
https://site.douban.com/107925/widget/notes/4567539/note/171635813/
https://wenku.baidu.com/view/5493724fc850ad02de804132.html

---
]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>魔方</tag>
      </tags>
  </entry>
  <entry>
    <title>Spark 安装与使用教程</title>
    <url>/spark/</url>
    <content><![CDATA[
Spark作为一个基于内存的开源计算框架，在这个大数据时代背景下，受到越来越多的开发者的喜爱，相对于Hadoop,Spark拥有对大量数据更快的处理速度，并且易于使用（支持多种开发语言）。

<!--more-->

# 安装

> [大数据时代--windows下spark的安装与配置教程](https://blog.csdn.net/nxw_tsp/article/details/78281533)  
> [spark 2.1.0安装指南完整版](https://blog.csdn.net/Yt7589/article/details/62039555)

1. Spark是用Scala写的，安装[Scala](http://www.scala-lang.org/download/all.html)，注意Scala版本与Spark版本之间的版本要求。
2. 安装[Spark](http://spark.apache.org/downloads.html)。
3. 因为Spark是基于Hadoop的，下载 [Hadoop](https://archive.apache.org/dist/hadoop/common/)。

---
]]></content>
      <categories>
        <category>Programming</category>
        <category>Spark</category>
      </categories>
      <tags>
        <tag>Spark</tag>
      </tags>
  </entry>
  <entry>
    <title>支持向量机</title>
    <url>/svm/</url>
    <content><![CDATA[
支持向量机（Support Vector Machine）是Cortes和Vapnik于1995年首先提出的，它在解决小样本、非线性及高维模式识别中表现出许多特有的优势，并能够推广应用到函数拟合等其他机器学习问题中。

<!--more-->

最简单的SVM从**线性分类器**导出，根据**最大化分类间隔**的目标（Large Margin Classifier），我们可以得到**线性可分**问题的SVM训练时求解的问题（Hard SVM）。但现实应用中很多数据是线性不可分的，通过加入松弛变量和惩罚因子，可以将SVM推广到**线性不可分**的情况（Soft SVM）。这个优化问题是一个凸优化问题，并且满足Slater条件，因此强对偶成立，通过拉格朗日对偶可以将其转化成**对偶问题**求解（Dual Soft SVM）。到这里为止，支持向量机还是一个线性模型，只不过允许有错分的训练样本存在。通过**核函数**（Kernel Trick），可以将它转化成非线性模型，此时的对偶问题也是一个凸优化问题（Soft Kernel SVM）。这个问题的求解普遍使用的是SMO算法，这是一种分治法，它每次选择两个变量进行优化，这两个变量的优化问题是一个带等式和不等式约束条件的二次函数极值问题，可以求出公式解，并且这个问题也是凸优化问题。优化变量的选择通过KKT条件来确定。

# 统计学习理论

支持向量机方法是建立在统计学习理论的VC 维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度，Accuracy）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力（或称泛化能力）。

统计机器学习能够精确的给出学习效果，能够解答需要的样本数等等一系列问题。

- VC维是对函数类的一种度量，可以简单的理解为问题的复杂程度，VC维越高，一个问题就越复杂。正是因为SVM关注的是VC维，SVM解决问题的时候，和样本的维数是无关的（甚至样本是上万维的都可以。当然，有这样的能力也因为引入了核函数）。
- 机器学习本质上就是一种对问题真实模型的逼近（我们选择一个我们认为比较好的近似模型，这个近似模型就叫做一个假设）。既然真实模型不知道，那么我们选择的假设与问题真实解之间究竟有多大差距（称为风险），我们就没法得知。但我们可以用某些可以掌握的量来逼近它。
    - 最直观的想法就是使用分类器在样本数据上的分类的结果与真实结果之间的差值来表示，这个差值叫做经验风险$R_{emp}(w)$。
    - 以前的机器学习方法都把经验风险最小化作为努力的目标，但回头看看经验风险最小化原则我们就会发现，此原则适用的大前提是经验风险要确实能够逼近真实风险才行。因此很多分类函数能够在样本集上轻易达到100%的正确率，在真实分类时却一塌糊涂（即所谓的推广能力差，或泛化能力差）。
    - 统计学习因此而引入了泛化误差界的概念，就是指真实风险应该由两部分内容刻画，一是经验风险，代表了分类器在给定样本上的误差；二是置信风险，代表了我们在多大程度上可以信任分类器在未知文本上分类的结果。很显然，第二部分是没有办法精确计算的，因此只能给出一个估计的区间，也使得整个误差只能计算上界，而无法计算准确的值（所以叫做泛化误差界，而不叫泛化误差）。统计学习的目标从经验风险最小化变为了寻求经验风险与置信风险的和最小，即结构风险最小。SVM正是这样一种努力最小化结构风险的算法。
        - 置信风险与两个量有关，一是样本数量，显然给定的样本数量越大，我们的学习结果越有可能正确，此时置信风险越小；二是分类函数的VC维，显然VC维越大，推广能力越差，置信风险会变大。

> **小样本**，并不是说样本的绝对数量少（实际上，对任何算法来说，更多的样本几乎总是能带来更好的效果），而是说与问题的复杂度比起来，SVM算法要求的样本数是相对比较少的。  
> **非线性**，是指SVM擅长应付样本数据线性不可分的情况，主要通过松弛变量（也有人叫惩罚变量）和核函数技术来实现，这一部分是SVM的精髓。

# SVM

> - [Python · SVM系列](https://zhuanlan.zhihu.com/p/27224109)  
- [SVM入门系列](http://www.blogjava.net/zhenandaci/archive/2008/06/20/209446.html)
- [支持向量机原理系列](http://www.cnblogs.com/pinard/p/6097604.html)  
- [Stanford机器学习---第八讲. 支持向量机SVM](http://blog.csdn.net/sruixue/article/details/42044263)   
- [解密SVM系列](https://so.csdn.net/so/search/s.do?q=%E8%A7%A3%E5%AF%86SVM%E7%B3%BB%E5%88%97&t=blog&u=on2way)  
- [【直观详解】支持向量机SVM](https://charlesliuyx.github.io/2017/09/19/%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BASVM%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/)  
- [支持向量机SVM](http://www.cnblogs.com/jerrylead/archive/2011/03/13/1982639.html)  
- [【机器学习详解】SVM解二分类,多分类,及后验概率输出](https://blog.csdn.net/luoshixian099/article/details/51073885)  
- [用一张图理解SVM的脉络](https://mp.weixin.qq.com/s/qVhRQr92gBkUjXGymkXGZw)  
- [统计学习方法– weng-JJ技术小站](http://120.79.254.53/?s=%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95)
- [支持向量机背后的数学 -对于SVM背后的数学和理论解释的快速概览及如何实现](https://www.jiqizhixin.com/articles/2020-07-28-3)

支持向量机属于一般化线性分类器，这族分类器的特点是他们能够同时最小化经验误差与最大化几何边缘区，因此支持向量机也被称为最大边缘区分类器。除了进行线性分类之外，SVM还可以使用所谓的核技巧有效地进行非线性分类，将其输入隐式映射到高维特征空间中。

SVM本身是从感知机算法演变而来，往简单来说其实就只是改了感知机的损失函数而已，而且改完之后还很像。感知机算法是在一个线性可分的数据集中找到一个分类超平面，尽可能的将数据集划分开。

理论上这样的超平面有无数多个，但是从直觉上，我们知道离两侧数据都比较远的超平面更适合用于分类，于是我们选择了一个比较“胖”的边界的超平面作为分类界，这就是SVM。 SVM 本身“只是”一个线性模型。只有在应用了核方法后，SVM 才会“升级”成为一个非线性模型

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124016.png)

因此，支持向量机-SVM(Support Vector Machine)从本质来说是一种：用一条线（方程）分类两种事物。SVM的任务是找到这条分界线使得它到两边的margin（构成了两条平行于分离超平面的长带，二者之间的距离称之为margin）都最大。注意，这里的横坐标是 $x_1$ 纵坐标为 $x_2$，如下图所示。让我们想象两个类别：红色和蓝色，我们的数据有两个特征：x 和 y。我们想要一个分类器，给定一对（x，y）坐标，输出仅限于红色或蓝色。支持向量机会接受这些数据点，并输出一个超平面（在二维的图中，就是一条线）以将两类分割开来。这条线就是判定边界：将红色和蓝色分割开。但是，最好的超平面是什么样的？对于 SVM 来说，它是**最大化两个类别边距**的那种方式，换句话说：超平面（在本例中是一条线）对每个类别最近的元素**距离最远**。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124035.png)

如上图所示，在Maximum Margin上的这些点就是支持向量（将距离分离超平面最近的两个不同类别的样本点称为支持向量），具体说即最终分类器表达式中只含有这些支持向量的信息，而与其他数据点无关。在下面的公式中，只有支持向量的系数 $\alpha_i$ 不等于0。说人话，上图中两个红色的点，一个蓝色的点，合起来就是支持向量。（margin以外的样本点对于确定分离超平面没有贡献，换句话说，SVM是有很重要的训练样本（支持向量）所确定的。）

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124051.png)

图中带黑圈的样本点即是支持向量，数学上来说的话，就是$\alpha_i>0$对应的样本点即是支持向量。从图中不难看出，支持向量从直观上来说，就是比较难分的样本点。此外，支持向量之所以称之为“支持”向量，是因为在理想情况下，仅利用支持向量训练出来的模型和利用所有样本训练出来的模型是一致的。这从直观上是好理解的，粗略的证明则可以利用其定义来完成：非支持向量的样本对应着$\alpha_i=0$，亦即它对最终模型——$f(x)=\sum_{i=1}^N\alpha_iy_i(x_i\cdot x)+b$没有丝毫贡献，所以可以直接扔掉。

$$
\mathbf w \cdot \varphi (\mathbf x) = \sum_i \lambda_i y_i k(\mathbf x_i,\mathbf x)
$$

这里有一个视频解释可以告诉你最佳的超平面是如何找到的[^1]：[直观可视化解释](https://v.qq.com/x/page/m05175nci67.html)。

[^1]: [详解支持向量机SVM：快速可靠的分类算法](https://monkeylearn.com/blog/introduction-to-support-vector-machines-svm/)

对于我们需要求解的这个超平面（直线）来说，我们知道它离两边一样远（待分类的两个部分的样本点），最近的距离就是到支持向量中的点的距离。根据这两点，抽象SVM的直接表达（Directly Representation）：

$$
arg \operatorname*{max}_{boundary} margin(boundary) \\
\text{所有正确归类的两类到boundary的距离} \ge margin \tag{1}
$$

> 注：$arg \operatorname*{max}_{x} f(x)$ 表示当 $f(x)$ 取最大值时，x的取值。

## 背景知识

假设样本为(x,y)，超平面为$\Pi:w\cdot x+b=0$

- 空间上的点：$\vec{x^{(i)}}\in \mathbb{R}^n, i=1,2...m$，$m$ 指的是点的数量，$\mathbb{R}^n$表示的是 $n$ 维空间
- 分界线：$\vec{w^T} \cdot {\overrightarrow{x}}+b=0$，简化为 $w^T \cdot x+b=0$

$$
\begin{split}
w^T \cdot x+b&=0\\
\begin{bmatrix}w_1 & w_2\end{bmatrix}\cdot
\begin{bmatrix}x_1\\x_2\end{bmatrix}+b&=0\\
w_1x_1+w_2x_2+b&=0\\
x_2=-\frac{w_1}{w_2}x_1&-b\quad\dots \quad (w_2\neq0)
\end{split}
$$

$$
\begin{split}
\vec{w}\cdot\vec{k}&=w^T\cdot k\\
&=\begin{bmatrix}w_1 & w_2\end{bmatrix}\cdot
\begin{bmatrix}1\\-\frac{w_1}{w_2}\end{bmatrix}\\
&=w_1-w_1\\
&=0\\
\end{split}
$$

- 向量的形式更加简洁，特别是在高维空间的情况下，还有一个好处就是，矢量的形式下 $w$ 刚好与分界线垂直，这个性质会在后面用到。$w^T \cdot x+b=0$ 表示的是分界线上所有的点，当 $w^T \cdot x+b>0$时，表示的是分界线上方的区域，反之则是分界线下方的区域。
- 优化问题
$\min_{w,b}\frac {\|w\|^2}2$，使得$y_i(w\cdot x_i+b)\ge1,\forall(x_i,y_i)\in D$
的求解过程常称为硬间隔最大化，求解出来的超平面则常称为最大硬间隔分离超平面
- 优化问题
$\min_{w,b}\left[\frac {\|w\|^2}2+C\sum_{i=1}^N\xi_i\right]$，使得$y_i(w\cdot x_i+b)\ge1-\xi_i,\forall(x_i,y_i)\in D（\xi_i\ge0）$
的求解过程常称为软间隔最大化，求解出来的超平面则常称为最大软间隔分离超平面
- 若数据集线性可分，则最大硬间隔分离超平面存在且唯一
- 若数据集线性不可分，则最大软间隔分离超平面的解存在但不唯一，其中：法向量（w ）唯一,偏置量（b）可能不唯一

### 函数间隔

- 样本到超平面的函数间隔为：$y(w\cdot x+b)$

由二维直线$w^Tx+b=0$扩展到高维被称为超平面$(w,b)$。一个点距离超平面的远近可以表示分类预测的确信程度。在超平面$w^Tx+b=0$确定的情况下，$|w^Tx+b|$能够相对地表示点x距离超平面的远近，而且如果分类正确，则$y^{(i)}$与$w^Tx+b$的符号一致,即$y^{(i)}(w^Tx^{(i)}+b)>0$，同时表示分类的正确性以及确信度。

函数间隔：超平面$(w,b)$关于样本点$(x^{(i)},y^{(i)})$的函数间隔为

$$\hat{\gamma}^{(i)}=y^{(i)}(w^Tx^{(i)}+b)$$

定义超平面关于样本集S的函数间隔为超平面$(w,b)$与S中所有样本点的函数间隔的最小值

$$\hat{\gamma}=min_{i=1,2,...m}\ \hat{\gamma}^{(i)}$$

定义$\hat{\gamma}$是为了最大化间隔，$\hat{\gamma}$表示关于超平面与训练集中样本的函数间隔最小值，下面只要最大化$\hat{\gamma}$即可。
注意到函数间隔实际上并不能表示点到超平面的距离，因为当超平面$(w,b)$参数扩大相同的倍数后，如$(2w,2b)$，超平面的位置并没有改变，但是函数间隔也变大了相同的倍数$2\hat{\gamma}^{(i)}$.

### 几何间隔

> [我所理解的 SVM（支持向量机）](http://fangs.in/tags/svm/)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fpmv2eb7uzj30m80fa751.jpg)

$$
\begin{split}
width &=\overrightarrow{x_-x_+}\cdot \frac{\vec{w}}{||\vec{w}||}\\
&=\frac{1}{||\vec{w}||}[w^T\cdot(x_+-x_-)]\\
&=\frac{1}{||\vec{w}||}[w^T\cdot x_+-w^T\cdot x_-]\\
&=\frac{1}{||\vec{w}||}[1-b-(-1-b)]\\
&=\frac{2}{||\vec{w}||}
\end{split}
$$


- 样本到超平面的几何间隔为：$\frac1{\|w\|}y(w\cdot x+b)$

#### 解释一

设样本点A坐标为$x^{(i)}$,点A到超平面的垂直距离记为$\gamma^{(i)}$,分离超平面$w^Tx^{(i)}+b=0$的单位法向量为$\frac{w}{||w||}$,因此点B的坐标为$x^{(i)}-\gamma^{(i)}\frac{w}{||w||}$，且点B在直线上，带入直线公式有：

$$w^T(x^{(i)}-\gamma^{(i)}\frac{w}{||w||})+b=0$$

$$\gamma^{(i)}=\frac{(w^Tx^{(i)}+b)}{||w||}$$

如果点被正确分类，$y^{(i)}$与$\frac{(w^Tx^{(i)}+b)}{||w||}$的符号一致，由此同理定义几何间隔

$$\gamma^{(i)}=y^{(i)}\left(\frac{w^Tx^{(i)}+b}{||w||}\right)$$

超平面与样本集S的几何间隔为

$$\gamma=min_{i=1,2,...m}\ \gamma^{(i)}$$

#### 解释二

我们在定义点(x,y)到平面（超平面）$\Pi$的间隔时，一般都是这样做的：

- 将$(x,y)$（垂直）投影到$\Pi$上
- 设投影点为$(x^{\ast},y^{\ast})$，则定义
$d((x,y),\Pi)=\left\{ \begin{aligned} \|x-x^{\ast}\|^2,&\ \ y(w\cdot x + b) \ge0 \\ -\|x-x^{\ast}\|^2,&\ \ y(w\cdot x + b) <0 \end{aligned} \right.$.


注意这里我们允许（当样本被错分类时的）间隔为负数，所以间隔其实严格来说并不是一般意义上的距离。

那么为了找到垂直投影，我们得先找到垂直于超平面$\Pi$的方向。不难看出w就是垂直于$\Pi$的，因为对$\forall x_1,x_2\in\Pi$，由$\left\{ \begin{aligned} &w\cdot x_1+b=0 \\ &w\cdot x_2+b=0 \end{aligned} \right.$知$w\cdot(x_1-x_2)=0$（两式相减即可），从而w垂直于向量$x_1-x_2$，从而也就垂直于$\Pi$：


那么结合之前那张图，不难得知我们可以设$x-x^{\ast} =\lambda w$（这里的$\lambda$可正可负），于是就有（注意由$x^{\ast} \in\Pi$知$w\cdot x^{\ast} +b=0$）

$$
\begin{align}
\|x-x^{\ast} \|^2&=(x-x^{\ast} )\cdot(x-x^{\ast} )=\lambda w\cdot(x-x^{\ast} ) \\ &=\lambda \left[w\cdot(x-x^{\ast} )+(b-b)\right]\\
&=\lambda\left[ w\cdot x+b - (w\cdot x^{\ast} + b)\right] \\ &=\lambda(w\cdot x+b) \end{align}
$$

从而

$$
d((x,y),\Pi)=\left\{ \begin{aligned} \lambda(w\cdot x+b),&\ \ y(w\cdot x + b) \ge0 \\ -\lambda(w\cdot x+b),&\ \ y(w\cdot x + b) <0 \end{aligned} \right.
$$

注意这么定义的间隔有一个大问题：当w和b同时增大k倍时，新得到的超平面$\tilde\Pi:(kw)\cdot x+(kb)$其实等价于原超平面$\Pi$：

$$
x\in\tilde\Pi\Leftrightarrow(kw)\cdot x+(kb)=0\Leftrightarrow w\cdot x+b=0\Leftrightarrow x\in\Pi
$$

但此时$d((x,y),\Pi)$却会直接增大k倍。极端的情况就是，当w和b同时增大无穷倍时，超平面没变，间隔却也跟着增大了无穷倍，这当然是不合理的。

所以我们需要把 scale 的影响给抹去，常见的做法就是做某种意义上的归一化：

$$
d((x,y),\Pi)=\left\{ \begin{aligned} \frac1{\|w\|}|w\cdot x+b|,&\ \ y(w\cdot x + b) \ge0 \\ -\frac1{\|w\|}|w\cdot x+b|,&\ \ y(w\cdot x + b) <0 \end{aligned} \right.
$$

（注意：由于 scale 的影响已被抹去，所以$\lambda$也就跟着被抹去了；同时由$0\le\|x-x^{\ast} \|^2=\lambda(w\cdot x+b)$ 知，我们需要在抹去 $\lambda$的同时、给$w\cdot x+b$套一个绝对值)

不难看出上式可改写为：

$$
d((x,y),\Pi)=\frac1{\|w\|}y(w\cdot x+b)
$$

这正是我们想要的结果。

### 间隔最大化

支持向量机的基本想法是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。为了间隔最大化，只需要最大化几何间隔$\gamma$，同时所有样本的几何间隔必须满足$\gamma^{(i)}\geq\gamma,i=1,2,...,m$

$$max_{w,b}\ \gamma$$

$$s.t.\ y^{(i)}\left(\frac{w^Tx^{(i)}+b}{||w||}\right)\geq\gamma$$

上述问题，可以转变为一个凸二次规划问题，这是支持向量机的一个重要属性，局部极值即为全局最值。

考虑函数间隔与几何间隔的关系：

$$max_{\gamma,w,b}\ \frac{\hat{\gamma}}{||w||}$$

$$s.t.\ y^{(i)}\left(w^Tx^{(i)}+b\right)\geq \hat{\gamma}$$

当超平面参数$(w,b)$同时变为$(2w,2b)$，函数间隔也会变为$2\hat{\gamma}$,目标函数的解并不会变化。即$\hat{\gamma}$的取值不影响优化问题的解。因此令$\hat{\gamma}=1$，目标函数变为最大化$\frac{1}{||w||}$，即最小化${\|w\|^2}$，为了后面的求解方便，添加因子1/2也不影响目标函数的解；

<div id="perceptron"></div>

### 感知机模型

感知机模型只有$w$和$b$这两个参数，它们决定了一张超平$\Pi:w\cdot x+b=0$。感知机最终目的是使得$y(w\cdot x+b)>0,\forall(x,y)\in D$，其中D是训练数据集、y只能取正负。

训练方法则是梯度下降，其中梯度公式为：

$$
\frac{\partial L}{\partial w}(x_i,y_i) = -y_ix_i、\frac{\partial L}{\partial b}(x_i,y_i)=-y_i
$$

我们在实际实现时，采用了“极大梯度下降法”（亦即每次只选出使得损失函数最大的样本点来进行梯度下降）。然后有理论证明，只要数据集线性可分，这样下去就一定能收敛。

```
for _ in range(epoch):
    # 计算 w·x+b
    y_pred = x.dot(self._w) + self._b
    # 选出使得损失函数最大的样本
    idx = np.argmax(np.maximum(0, -y_pred * y))
    # 若该样本被正确分类，则结束训练
    if y[idx] * y_pred[idx] > 0:
        break
    # 否则，让参数沿着负梯度方向走一步
    delta = lr * y[idx]
    self._w += delta * x[idx]
    self._b += delta
```

<div id="optimization-equivalence"></div>

### 优化问题的等价性

为方便，称优化问题：

$$
\min_{w,b}\left[\frac {\|w\|^2}2+C\sum_{i=1}^N\xi_i\right]，使得y_i(w\cdot x_i+b)\ge1-\xi_i,\forall(x_i,y_i)\in D（\xi_i\ge0）
$$

为**问题一**；称：

$$
\min_{w,b}{\left[\frac{\|w\|^2}2 + C\sum_{i=1}^N[1-y_i(w\cdot x_i+b)]_ +\right]}
$$

为**问题二**，则我们需要证明问题一与问题二等价

先来看问题一怎么转为问题二。事实上不难得知：

$$
y_i(w\cdot x_i+b)\ge1-\xi_i,\forall(x_i,y_i)\in D\Rightarrow\xi_i\ge1-y_i(w\cdot x_i+b)
$$

注意问题一是针对w和b进行优化的，且当w和b固定时，为使$\frac {\|w\|^2}2+C\sum_{i=1}^N\xi_i$最小，必有：

- $1-y_i(w\cdot x_i+b)\ge0$时，$\xi_i=1-y_i(w\cdot x_i+b)$
- $1-y_i(w\cdot x_i+b)<0$时，$\xi_i=0$（因为我们要求$\xi_i\ge0$）

亦即$\xi_i=[1-y_i(w\cdot x_i+b)]_ +$。此时损失函数即为$\frac{\|w\|^2}2 + C\sum_{i=1}^N[1-y_i(w\cdot x_i+b)]_ +$，换句话说，我们就把问题一转为了问题二。

再来看问题二怎么转为问题一。事实上，直接令$\xi_i=[1-y_i(w\cdot x_i+b)]_ +$，就有：

- 模型的损失为$\frac {\|w\|^2}2+C\sum_{i=1}^N\xi_i$
- 模型的约束为$\xi_i\ge 1-y_i(w\cdot x_i+b)且\xi_i\ge0$

亦即转为了问题一

<div id="quadratic-programming"></div>

### 带约束的二次规划求解

不妨设我们选取出来的两个参数就是$\alpha_1$和$\alpha_2$，那么问题的关键就在于如何把$\alpha_1$和$\alpha_2$相关的东西抽取出来并把其它东西扔掉。

注意到我们的对偶问题为

$$
\max_\alpha L(\alpha)=-\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j) + \sum_{i=1}^N\alpha_i$$

使得对$i=1,...,N$、都有$\sum_{i=1}^N\alpha_iy_i=0、0\le\alpha_i\le C$。

Gram 矩阵： $G=(x_i\cdot x_j)_ {N\times N}$

所以L就可以改写为

$$L(\alpha)=-\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_jG_{ij}+\sum_{i=1}^N\alpha_i$$

把和$\alpha_1$、$\alpha_2$无关的东西扔掉之后，L可以化简为：

$$
L(\alpha)=-\frac12(G_{11}\alpha_1^2+2y_1y_2G_{12}\alpha_1\alpha_2+G_{22}\alpha_2^2)-\left(y_1\alpha_1\sum_{i=3}^Ny_i\alpha_iG_{i1}+y_2\alpha_2\sum_{i=3}^Ny_i\alpha_iG_{i2}\right)+(\alpha_1+\alpha_2)
$$

约束条件则可以化简为对i=1和i=2，都有$y_1\alpha_1+y_2\alpha_2=-\sum_{i=3}^Ny_i\alpha_i=c$、$0\le\alpha_i\le C$，其中$c$是某个常数

而带约束的二次规划求解过程也算简单：只需先求出无约束下的最优解，然后根据约束“裁剪”该最优解即可。

无约束下的求解过程其实就是求偏导并令其为 0。以$\alpha_1$为例，注意到

$$
y_1\alpha_1+y_2\alpha_2=c\Rightarrow\alpha_2=\frac c{y_2}-\frac{y_1}{y_2}\alpha_1
$$

令$c^{\ast}=\frac c{y_2}$,$s=y_1y_2$，则$c^{\ast}$亦是常数，且由于$y_1$、$y_2$都只能取正负 1，故不难发现$\frac{y_2}{y_1}=\frac{y_1}{y_2}=s$，从而$\alpha_2=c^{\ast}-s\alpha_1\Rightarrow\frac{\partial\alpha_2}{\partial\alpha_1}=-s$

于是

$$
\begin{align}
\frac{\partial L}{\partial\alpha_1}=&-G_{11}\alpha_1-y_1y_2G_{12}(\alpha_2+\alpha_1\frac{\partial\alpha_2}{\partial\alpha_1})-G_{22}\alpha_2\frac{\partial\alpha_2}{\partial\alpha_1} \\
&-y_1\sum_{i=3}^Ny_i\alpha_iG_{i1}-y_2\frac{\partial\alpha_2}{\partial\alpha_1}\sum_{i=3}^Ny_i\alpha_iG_{i2}+1 \\
=&-G_{11}\alpha_1-sG_{12}(c^{\ast}-s\alpha_1-\alpha_1\cdot s)-G_{22}(c^{\ast}-s\alpha_1)\cdot(-s) \\
&-y_1\sum_{i=3}^Ny_i\alpha_iG_{i1}+sy_2\sum_{i=3}^Ny_i\alpha_iG_{i2}+\left(\frac{\partial\alpha_2}{\partial\alpha_1}+1\right)
\end{align}
$$

考虑到$s^2=1$、$sy_2=y_1$、Gram 矩阵是对称阵、且模型在第k个样本$x_k$处的输出为$f(x_k)=\sum_{i=1}^N\alpha_iy_i(x_i\cdot x_k)+b=\sum_{i=1}^N\alpha_iy_iG_{ik}+b$，从而可知

$$
\begin{align}
\frac{\partial L}{\partial\alpha_1}=&-G_{11}\alpha_1-sG_{12}c^{\ast}+2G_{12}\alpha_1+sG_{22}c^{\ast}-G_{22}\alpha_1 \\
&-y_1[f(x_1)-y_1\alpha_1G_{11}-y_2\alpha_2G_{21}] \\
&+y_1[f(x_2)-y_1\alpha_1G_{12}-y_2\alpha_2G_{22}] +(1-s)
\end{align}
$$

令$v_i=(f(x_i)-b)-y_1\alpha_1G_{1i}-y_2\alpha_2G_{2i}\ \ (i=1,2)$，则

$$
\frac{\partial L}{\partial\alpha_1}=-(G_{11}-2G_{12}+G_{22})\alpha_1-sc^{\ast}(G_{12}-G_{22})-y_1(v_1-v_2)+(1-s)
$$

于是

$$
\begin{align}
\frac{\partial L}{\partial\alpha_1}=0\Rightarrow\alpha_1&=-\frac{sc^{\ast}(G_{12}-G_{22})+y_1(v_1-v_2)-(1-s)}{G_{11}-2G_{12}+G_{22}} \\
&=-\frac{y_1[y_2c^{\ast}(G_{12}-G_{22})+(v_1-v_2)-(y_1-y_2)]}{G_{11}-2G_{12}+G_{22}}
\end{align}
$$

注意到$c^{\ast}=s\alpha_1+\alpha_2$，从而

$$
y_2c^{\ast}(G_{12}-G_{22})=y_2(s\alpha_1+\alpha_2)(G_{12}-G_{22})=(y_1\alpha_1+y_2\alpha_2)(G_{12}-G_{22})
$$

令$dG=G_{11}-2G_{12}+G_{22}、e_i=f(x_i)-y_i\ \ (i=1,2)$，则

$$
y_2c^{\ast}(G_{12}-G_{22})+(v_1-v_2)-(y_2+y_1)=... =e_1 - e_2 - y_1\alpha_1dG
$$

从而

$$
\alpha_1^{new,raw}=\alpha_1^{old}-\frac{y_1(e_1-e_2)}{dG}
$$

接下来就要对其进行裁剪了。注意到我们的约束为$0\le\alpha_i\le C$、$\alpha_1y_1+\alpha_2y_2$为常数，所以我们需要分情况讨论$\alpha_1$的下、上界。

- 当$y_1$,$y_2$异号（$y_1y_2=-1$）时，可知$\alpha_1-\alpha_2$为常数、亦即
$\alpha_1^{new}-\alpha_2^{new}=\alpha_1^{old}-\alpha_2^{old}\Rightarrow\alpha_2^{new}=\alpha_1^{new}-(\alpha_1^{old}-\alpha_2^{old})$，结合$0\le\alpha_2\le C$，可知：
    - $\alpha_1^{new}$不应小于$\alpha_1^{old}-\alpha_2^{old}$，否则$\alpha_2$将小于 0
    - $\alpha_1^{new}$不应大于$C+\alpha_1^{old}-\alpha_2^{old}$，否则$\alpha_2$将大于 $C$
- 当$y_1$,$y_2$同号（$y_1y_2=1$）时，可知$\alpha_1+\alpha_2$为常数、亦即
$\alpha_1^{new}+\alpha_2^{new}=\alpha_1^{old}+\alpha_2^{old}\Rightarrow\alpha_2^{new}=(\alpha_1^{old}+\alpha_2^{old}) - \alpha_1^{new}$，结合$0\le\alpha_2\le C$，可知：
    - $\alpha_1^{new}$不应小于$\alpha_1^{old}+\alpha_2^{old}-C$，否则$\alpha_2$将大于 $C$
    - $\alpha_1^{new}$不应大于$\alpha_1^{old}+\alpha_2^{old}$，否则$\alpha_2$将小于 0

综上可知

- $\alpha_1^{new}$的下界为$U=\left\{\begin{aligned}
\max\{0,\alpha_1^{old}-\alpha_2^{old}\}\ \ &y_1y_2=-1 \\
\max\{0,\alpha_1^{old}+\alpha_2^{old}-C\}\ \ &y_1y_2=1
\end{aligned}
\right.$
- $\alpha_1^{new}$的上界为$V=\left\{\begin{aligned}
\min\{C,C+\alpha_1^{old}-\alpha_2^{old}\}\ \ &y_1y_2=-1 \\
\max\{C,\alpha_1^{old}+\alpha_2^{old}\}\ \ &y_1y_2=1
\end{aligned}
\right.$

那么直接做一个 clip 即可得到更新后的$\alpha_1$：

```
alpha1_new = np.clip(alpha1_new_raw, u, v)
```

注意由于我们要保持$\alpha_1y_1+\alpha_2y_2$为常数，所以（注意$\frac{y_1}{y_2}=y_1y_2$）

$$
\begin{align}
\alpha_2^{new}&=\frac1{y_2}(\alpha_1^{old}y_1+\alpha_2^{old}y_2-\alpha_1^{new}y_1) \\
&=\alpha_2^{old}+y_1y_2(\alpha_1^{old}-\alpha_1^{new})
\end{align}
$$

综上所述，我们就完成了一次参数的更新，之后就不断地更新直至满足停机条件即可

<div id="hard-linear-svm"></div>

## Hard Linear SVM

注意我们[感知机](#perceptron)的损失函数为 $\sum_{i=1}^N[-y(w\cdot x+b)]_ +$。由感知机损失函数的形式可知，感知机只要求样本被正确分类，而不要求样本被“很好地正确分类”。这就导致感知机弄出来的超平面（通常又称“决策面”）经常会“看上去很不舒服”。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124109.png)

从直观上来说，我们希望得到的是这样的决策面：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124126.png)


那么应该如何将这种理想的决策面的状态翻译成机器能够学习的东西呢？直观来说，就是让决策面离正负样本点的间隔都尽可能大。

首先定义超平面：$\mathbf w^T \vec x_i + b = 0$（w是这个超平面的法向量），接下来为了方便，设  $\vec x = (x_1,x_2)$  即一条直线。任意点 $\vec x_i$ 到该直线的距离为 $d=\frac{1}{\lVert \mathbf w \lVert} |\mathbf w^T \vec x_i + b|$ （解析几何的知识）。对于空间内所有训练点的坐标记为 $(\vec x_i,y_i)$，其中 $y_i$ = 1 or -1， 表示点 $\vec x_i$ 所属的类。绝对值符号会导致函数不平滑，又因为数据集是线性可分的，所以我们可以把距离公式改写为：$d=\frac{1}{\lVert \mathbf w \lVert} y_i (\mathbf w^T \vec x_i + b)$。

因此，这个“间隔”翻译成数学语言，其实就是简单的：

$$
d((x,y),\Pi)=\frac {1}{\|w\|}y(w\cdot x+b)
$$

在有了样本点到决策面的间隔后，数据集到决策面的间隔也就好定义了：

$$
d(D, \Pi)=\min_{(x,y)\in D}d((x,y),\Pi)
$$

如果这些训练数据是线性可分的，也可称为硬间隔（Hard Margin）。选出两条直线（图中的虚线），使得他们的距离尽可能的大，这两条直线的中央就是待求的超平面（直线）。为了表达直观，我们定义这两个超平面（直线）分别为 $\mathbf w^T \vec x_i + b = 1$ 和 $\mathbf w^T \vec x_i + b = -1$，两个超平面（直线）之间的距离为 $\gamma = \frac{2}{\lVert \mathbf w \lVert}$ 。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124149.png)

为了使得所有样本数据都在间隔区（两条虚线）以外，我们需要保证对于所有的 $i$ 满足下列的条件: $\mathbf w^T \vec x_i + b \geqslant 1$ 若 $y_i = 1$，$\mathbf w^T \vec x_i + b \leqslant -1$ 若 $y_i = -1$ 。上述两个条件可以写作  $y_i(\mathbf w^T \vec x_i + b) \geqslant 1, \quad\text{for all}\quad 1\leqslant i \leqslant n$ ，这里的n指样本点的数量。

上面的表达（Directly Representation）可以被写成：让所有样本点都被正确分类：$y(w\cdot x+b)>0,\forall(x,y)\in D$
让决策面离正负样本点的间隔都尽可能大，最终目的是找到具有“最大间隔”（Maximum Margin）的划分超平面（直线），找到参数 $\mathbf w$ 和 $b$ 使得 $d$ 最大。


$$
margin(b,w)=min_{w,b} \quad d \tag{2}$$

$$
arg \operatorname*{max}_{\mathbf w,b} \left\{ {\frac{1}{\lVert \mathbf w \lVert} \operatorname*{min}_{n} [y_i(\mathbf w^T\vec x_i}+b)]\right\} \tag{3}
$$



$$
\max\min_{(x,y)\in D}\frac {1}{\|w\|}y(w\cdot x+b)
$$

注意到$y(w\cdot x+b)>0$的性质和$\frac {1}{\|w\|}y(w\cdot x+b)$的值在w和b同时扩大 k 倍时不会改变。

> 我们知道同时放缩一个超平面的系数并不会改变这个超平面，such as 3wx+3b=0=wx+b，所以我们可以假设离我们超平面最近的那个向量到平面的距离为1。选择1的好处是，w和b进行尺缩变换（kw和kb）不改变距离，方便计算。


所以我们完全可以假设：若 $(x^{\ast},y^{\ast})=\arg\min_{(x,y)\in D}\frac {1}{\|w\|}y(w\cdot x+b)$，则$y^{\ast}(w\cdot x^{\ast}+b)=1$
（否则假设$y^{\ast}(w\cdot x^{\ast}+b)=c$，令$w\leftarrow\frac wc$,$b\leftarrow\frac bc$即可）。

注意由于$(x^{\ast},y^{\ast})=\arg\min_{(x,y)\in D}\frac {1}{\|w\|}y(w\cdot x+b)$这个最小化过程中$w$是固定的，所以我们可以把$\frac1{\|w\|}$这一项拿掉，从而：

$$
(x^{\ast},y^{\ast})=\arg\min_{(x,y)\in D}y(w\cdot x+b)
$$

所以$y^{\ast}(w\cdot x^{\ast}+b)=1\Rightarrow y(w\cdot x+b)\ge1,\forall(x,y)\in D$

则可以对$(3)$式进行形式变换，得到 canonical representation（最大化问题不是很好解决，我们可以转换为我们熟悉最小化问题）：

$$
\max_{w,b}\frac {1}{\|w\|}，使得y_i(w\cdot x_i+b)\ge1,\forall(x_i,y_i)\in D
$$

$$
\min_{w,b}\frac {\|w\|^2}2，使得y_i(w\cdot x_i+b)\ge1,\forall(x_i,y_i)\in D
$$

$$
arg \operatorname*{max}_{\mathbf w,b} \frac{2}{\lVert \mathbf w \lVert} \implies  arg \operatorname*{min}_{\mathbf w,b} \frac{1}{2}\lVert \mathbf w \lVert ^2 \\
s.t.\quad y_i(\mathbf w^T\vec x_i+b) \geqslant1,\quad i = 1,2,\ldots,m  \tag{4}
$$

> 注：s.t.：subject to 表示约束条件，表达的意思等价于：为了使得所有样本数据都在间隔区（两条虚线）以外。

但是这会导致另一个问题：当数据集线性不可分时，上述优化问题是必定无解的，这就会导致模型震荡（换句话说，$y_i(w\cdot x_i+b)\ge1$这个约束太“硬”了）。

<div id="dual-linear-svm"></div>

## Dual Linear SVM

为什么我们还要考虑它的对偶问题？这是因为化作对偶问题后会更容易求解，同样也方便引入Kernel Trick。表现在 SMO 上的话就是，我们可以通过简单粗暴地将核矩阵K代替 Gram 矩阵G来完成核方法的应用。直观地说，我们只需将上面所有出现过的$G$都换成$K$就行了。

为了解$(4)$式，需要用到[拉格朗日乘子法](https://sli1989.github.io/lagrange-multiplier)（Method of lagrange multiplier），它是用来求解在约束条件目标函数的极值的。）

根据约束的形式，我们引入m个拉格朗日乗法子，记为  $\boldsymbol \lambda = (\lambda_1,\ldots,\lambda_m)^T$ ，原因是，有m个约束，所以需要m个拉格朗日乗法子。可以得出拉格朗日方程如下：

$$
\mathcal{L}(\mathbf w,b,\boldsymbol \lambda) = \frac{1}{2}\lVert \mathbf w \lVert ^2  - \sum_{i=1}^m \lambda_i \{  y_i(\mathbf w^T\vec x_i+b) -1 \} \tag{5}
$$


根据拉格朗日对偶性，原始的约束最优化问题可等价于极大极小的对偶问题：

$$ \max_{\alpha} \min_{w,b} \quad \mathcal{L}(w,b,\lambda) $$


解这个拉格朗日方程，对 $\mathbf w$ 和 $b$ 求偏导数并令其等于0，可以得到以下两个条件

$$
\mathbf w = \sum_{i=1}^m \lambda_i y_i \vec x_i \\
0 = \sum_{i=1}^m \lambda_i y_i
$$

将这两个条件带回公式(4)，可以得到对偶形式（dual representaiton），我们的目的也变为最大化 $\mathcal{L}(\boldsymbol \lambda)$，表达式如下:

$$
arg \operatorname*{max}_{\boldsymbol \lambda}\mathcal{L}(\boldsymbol \lambda)  = \sum_{i=1}^m \lambda_i - \frac{1}{2} \sum_{i=1}^m \sum_{j=1}^m \lambda_i \lambda_j \vec x_i \vec x_j \mathbf x_i^T \mathbf x_j \\
s.t. \quad \lambda_i \geqslant 0, \forall i;\quad \sum_{i=1}^m \lambda_i y_i = 0 \tag{6}
$$

等价于最优化问题：

$$
\begin{align}
\min_{\alpha} \quad  \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i \cdot x_j) - \sum_{i=1}^{N}\alpha_i \\
s.t. \quad \sum_{i=1}^{N}\alpha_i y_i = 0 ; \alpha_i \ge 0, \quad i=1,2,\cdots,N
\end{align}
$$

以上表达式可以通过二次规划算法解出 $\boldsymbol \lambda$ 后，带回，求出$\mathbf w$ 和 $b$，即可得到模型：

$$
f(\mathbf x) = \mathbf w^T\mathbf x + b = \sum_{i=1}^m \lambda_i y_i \mathbf x_i^T \mathbf x + b \tag{7}
$$

这显然又是一个二次规划问题！所$(4)$式的约束是一个不等式约束，所以我们可以使用[KKT条件](https://sli1989.github.io/kkt)得到三个条件：

$$
\lambda_i \geqslant0 ;\quad y_i f(\mathbf x_i)-1 \geqslant0; \quad \lambda_i\{ y_i f(\mathbf x_i)-1 \}=0
$$

使用这些条件，可以构建高效算法来解这个方程，比如SMO（Sequential Minimal Optimization）就是其中一个比较著名的，这就是对偶问题的求解方案。至于SMO是如何做的，考虑到现代很多SVM的Pakage都是直接拿来用，秉承着前人付出了努力造了轮子就不重复造的核心精神，直接调用就好 。

<div id="soft-linear-svm"></div>

## Soft Linear SVM

上面的例子很简单，因为那些数据是线性可分的——我们可以通过画一条直线来简单地分割红色和蓝色。然而，大多数情况下事情没有那么简单。如果样本数据你中有我我中有你（线性不可分），应该如何处理呢？你无法找出一个线性决策边界（一条直线分开两个类别）。这里就需要引入软间隔（Soft Margin），意味着，允许支持向量机在一定程度上出错。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124206.png)

由上一节我们得知，约束为： $y_i(\mathbf w^T\vec x_i+b) \geqslant1,\quad i = 1,2,\ldots,m$ ，目标是使目标函数可以在一定程度不满足这个约束条件，我们引入常数 $C$ 和 损失函数 $\ell_{0/1}(z)$ 为0/1损失函数，当z小于0函数值为1，否则函数值为0。

$$
\operatorname*{min}_{\mathbf w,b} \frac{1}{2}\lVert w \lVert^2 + C \sum_{i=1}^m \ell_{0/1}(y_i(\mathbf w^T\vec x_i+b) -1) \tag {8}
$$

对于$(8)$式来说 $C \geqslant 0$ 是个常数，当C无穷大时，迫使所有样本均满足约束；当C取有限值时，允许一些样本不满足约束。但 $\ell_{0/1}(z)$ 损失函数非凸、非连续，数学性质不好，不易直接求解，我们用其他一些函数来代替它，叫做替代损失函数（surrogate loss）。

$$
\begin{align}
& \text{hinge损失:} \ell_{hinge}(z) = max(0,1-z)\\
& \text{指数损失:} \ell_{exp}(z) =  e^{-z}\\
& \text{对数损失:} \ell_{log}(z) = log(1+e^{-z})\\
\end{align}
$$

三种常见损失函数如下图：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124226.png)

我们已知Hard LinearSVM 问题为

$$
\min_{w,b}\frac {\|w\|^2}2，使得y_i(w\cdot x_i+b)\ge1,\forall(x_i,y_i)\in D
$$

且式中的$y_i(w\cdot x_i+b)$其实就是（没有抹去 scale 的影响的）间隔。所以想要放松对模型的限制的话，很自然的想法就是让这个间隔不必一定要不小于 1、而是只要不小于$1-\xi_i$就行，其中$\xi_i$是个不小于 0 的数。

所以为了让模型在线性不可分的数据上仍有不错的表现，从直观来说，我们应该“放松”对我们模型的限制（让我们模型的约束“软”一点），引入**松弛变量（slack variables）** ：

$$
\min_{w,b}\frac {\|w\|^2}2，使得y_i(w\cdot x_i+b)\ge1-\xi_i,\forall(x_i,y_i)\in D, \xi_i \ge 0
$$


正如前文所说，只放松限制的话肯定不行，会使模型变得怠惰，还得给这个放松一些惩罚。若假设数据集为$D=\left\{(x_1,y_1),...,(x_N,y_N)\right\}$的话，那么经过数学变换后，可将$(8)$式重写为：

$$
\min_{w,b}{\left[\frac{\|w\|^2}2 + C\sum_{i=1}^N[1-y_i(w\cdot x_i+b)]_ +\right]}
$$

其中 “$[ \cdot ]_ +$”其实就是 ReLU 函数。于是可以看出，SVM 在形式上和感知机的差别只在于损失函数，且这两个损失函数确实长得很像。

$$
[x]_ +=\left\{ \begin{aligned} 0&\ \ x\le0 \\ x&\ \ x>0 \end{aligned} \right.
$$

综上所述，在目标优化函数中加一个$C\xi_i$，其中$C$是个大于 0 的常数，可以理解为对放松的惩罚力度。优化问题即可合理地转化为：

$$
\min_{w,b}\left[\frac {\|w\|^2}2+C\sum_{i=1}^N\xi_i\right]，使得y_i(w\cdot x_i+b)\ge1-\xi_i,\forall(x_i,y_i)\in D（\xi_i\ge0）
$$

$$
\operatorname*{min}_{\mathbf w,b,\xi_i} \frac{1}{2}\lVert w \lVert^2 + C \sum_{i=1}^m \xi_i
\\ s.t. \quad y_i(\mathbf w^T\vec x_i+b) \geqslant 1 - \xi_i ;\quad \xi_i \geqslant 0,\quad i = 1,2,\ldots,m \tag{9}
$$

$(9)$式就是常见的**软间隔支持向量机**，其中，每一个样本都有一个对应的松弛变量，用以**表征该样本不满足约束的程度**。$C$为惩罚函数，目标函数有两层含义：margin尽量大，误分类的样本点计量少。

不难得知原始问题相应的拉格朗日函数为：

$$
L=\frac{\|w\|^2}2+C\sum_{i=1}^N\xi_i-\sum_{i=1}^N\alpha_i[y_i(w\cdot x_i+b)-1+\xi_i]-\sum_{i=1}^N\beta_i\xi_i
$$

其中$\alpha_i\ge0、\beta_i\ge0$，

于是 KKT 条件的其中四个约束即为（不妨设最优解为$w^{\ast}$、$b^{\ast}$、$\xi^{\ast}$、$\alpha^{\ast}$和$\beta^{\ast}$）：

- $\alpha_i^{\ast}\ge0$,$\beta_i^{\ast}\ge0$（这是拉格朗日乘子法自身的要求）
- $\xi_i^{\ast}\ge0$、$y_i(w^{\ast}\cdot x_i+b^{\ast})-1+\xi_i^{\ast}\ge0$（此即原始约束）
- $\alpha_i^{\ast}[y_i(w^{\ast}\cdot x_i+b^{\ast})-1+\xi_i^{\ast}]=0$（换句话说，$\alpha_i^{\ast}$和$y_i(w^{\ast}\cdot x_i+b)-1+\xi_i^{\ast}$中必有一个为 0）
  - 该等式有着很好的直观：设想它们同时不为 0，则必有$y_i(w^{\ast}\cdot x_i+b)-1+\xi_i^{\ast}>0$（注意原始约束）、从而$\alpha_i^{\ast}[y_i(w^{\ast}\cdot x_i+b^{\ast})-1+\xi_i^{\ast}]\ge0$，等号当且仅当$\alpha_i=0$时取得。然而由于$\alpha_i^{\ast}\ne0$，所以若将$\alpha_i$取为 0、则上述L将会变大。换句话说，将参数$\alpha_i$取为 0 将会使得目标函数比参数取$\alpha_i^{\ast}$时的目标函数要大，这与$\alpha_i^{\ast}$的最优性矛盾
- $\beta_i^{\ast}\xi_i^{\ast}=0（$换句话说，$\beta_i^{\ast}$和$\xi_i^{\ast}$中必有一个为 0，理由同上）

对偶问题的实质，其实就是将原始问题

$$
\min_{w,b,\xi}\max_{\alpha,\beta} L
$$

转化为对偶问题

$$
\max_{\alpha,\beta}\min_{w,b,\xi}L
$$

于是我们需要求偏导并令它们为 0：

- 对$w$求偏导：$\frac{\partial L}{\partial w}=w-\sum_{i=1}^N\alpha_iy_ix_i=0\Rightarrow w=\sum_{i=1}^N\alpha_iy_ix_i$
- 对$b$求偏导：$\frac{\partial L}{\partial b}=-\sum_{i=1}^N\alpha_iy_i=0\Rightarrow\sum_{i=1}^N\alpha_iy_i=0$
- 对$\xi_i$求偏导：$\frac{\partial L}{\partial\xi_i}=C-\alpha_i-\beta_i=0\Rightarrow\alpha_i+\beta_i=C$

后一个 KKT 条件：最优解自然需要满足这么个条件：

$$\nabla_wL(w^{\ast},b^{\ast},\xi^{\ast},\alpha^{\ast},\beta^{\ast})=\nabla_bL(w^{\ast},b^{\ast},\xi^{\ast},\alpha^{\ast},\beta^{\ast})=\\
\nabla_\xi L(w^{\ast},b^{\ast},\xi^{\ast},\alpha^{\ast},\beta^{\ast})=0$$


注意这些约束中$\beta_i$除了$\beta_i\ge0$之外没有其它约束，$\alpha_i+\beta_i=C$的约束可以转为$\alpha_i\le C$。然后把这些东西代入拉格朗日函数L、即可得到：

$$
\begin{align} L&=\frac{\|\sum_{i=1}^N\alpha_iy_ix_i\|^2}2+\sum_{i=1}^N(C-\alpha_i-\beta_i)\xi_i-\sum_{i=1}^N\alpha_iy_i\left(\sum_{j=1}^N\alpha_jy_jx_j\right)\cdot x_i\\
-b\sum_{i=1}^N\alpha_iy_i+\sum_{i=1}^N\alpha_i \\ &=-\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum_{i=1}^N\alpha_i \end{align}
$$

于是对偶问题为

$$
\max_{\alpha}\left[ -\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum_{i=1}^N\alpha_i\right]，使得\sum_{i=1}^N\alpha_iy_i=0、0\le\alpha_i\le C
$$

亦即

$$
\min_{\alpha}\left[ \frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum_{i=1}^N\alpha_i\right]，使得\sum_{i=1}^N\alpha_iy_i=0、0\le\alpha_i\le C
$$

可以看到在对偶形式中，**样本仅以内积的形式$（x_i\cdot x_j）$出现，这就使得核方法的引入变得简单而自然**。

通过构造拉格朗日函数并求解偏导可得到等价的对偶问题：

$$
\begin{align}
\min_{\alpha} \quad \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j (x_i \cdot x_j) - \sum_{i=1}^{N} {\alpha_i}\\
s.t. \quad \sum_{i=1}^{N}\alpha_i y_i = 0 ; \quad 0 \le \alpha_i \le C, \quad i=1,2,\cdots,N
\end{align}
$$

## Soft Linear SVM的训练

虽然比较简单，但是调优 LinearSVM 的训练这个过程是相当有启发性的事情。关于各种梯度下降算法的定义、性质等等可以参见[参数的更新](http://www.carefree0910.com/posts/55a23cf0/)。

### 极大梯度下降法

极大梯度下降法其实就是随机梯度下降SGD 的特殊形式。

我们已知：

$$
L(D)=\frac{\|w\|^2}2 + C\sum_{i=1}^N[1-y_i(w\cdot x_i+b)]_ +
$$

所以我们可以认为：

$$
L(x,y)=\frac{\|w\|^2}2+C[1-y(w\cdot x+b)]_ +
$$

于是：

- 当$y(w\cdot x+b)\ge1$时：$\frac{\partial L(x,y)}{\partial w} = w$、$\frac{\partial L(x,y)}{\partial b}=0$
- 当$y(w\cdot x+b)<1$时：$\frac{\partial L(x,y)}{\partial w} = w-Cyx$、$\frac{\partial L(x,y)}{\partial b}=-Cy$

所以我们可以把极大梯度下降的形式写成（假设学习速率为$\eta$）：

$$w\leftarrow (1-\eta)w$$

若$y(w\cdot x+b)<1$，则选出某个被错分的样本(x,y)，然后：

$$w\leftarrow w+\eta Cyx$$

$$b\leftarrow b+\eta Cy$$

```
import numpy as np

class LinearSVM:
    def __init__(self):
        self._w = self._b = None

    def fit(self, x, y, c=1, lr=0.01, epoch=10000):
        x, y = np.asarray(x, np.float32), np.asarray(y, np.float32)
        self._w = np.zeros(x.shape[1])
        self._b = 0.
        for _ in range(epoch):
            self._w *= 1 - lr
            err = 1 - y * self.predict(x, True)
            idx = np.argmax(err)
            # 注意即使所有 x, y 都满足 w·x + b >= 1
            # 由于损失里面有一个 w 的模长平方
            # 所以仍然不能终止训练，只能截断当前的梯度下降
            if err[idx] <= 0:
                continue
            delta = lr * c * y[idx]
            self._w += delta * x[idx]
            self._b += delta

    def predict(self, x, raw=False):
        x = np.asarray(x, np.float32)
        y_pred = x.dot(self._w) + self._b
        if raw:
            return y_pred
        return np.sign(y_pred).astype(np.float32)
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/2019-7-29.gif)


虽然看上去不错，但仍然存在着问题：

- 训练过程其实非常不稳定
- 从直观上来说，由于 LinearSVM 的损失函数比感知机要更复杂，所以相应的函数形状也会更复杂。这意味着当数据集稍微差一点的时候，直接单纯地应用极大梯度下降法可能会导致一些问题——比如说模型会卡在某个很奇怪的地方无法自拔。解释1：每次只取使得损失函数极大的一个样本进行梯度下降\rightarrow模型在某个地方可能来来回回都只受那么几个样本的影响\rightarrow死循环

通过将正负样本点的“中心”从原点 (0, 0)（默认值）挪到 (5, 5)（亦即破坏了一定的对称性）并将正负样本点之间的距离拉近一点，我们可以复现这个问题：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/2019-7-29-2.gif)


### Mini-Batch 梯度下降法（MBGD）

解决方案的话，主要还是从改进随机梯度下降（SGD）的思路入手（因为极大梯度下降法其实就是 SGD 的特殊形式）。我们知道 SGD 的“升级版”是 MBGD、亦即拿随机 Mini-Batch 代替随机抽样。这样的话，通常而言会比 SGD 要好 。

```
self._w *= 1 - lr
# 随机选取 batch_size 个样本
batch = np.random.choice(len(x), batch_size)
x_batch, y_batch = x[batch], y[batch]
err = 1 - y_batch * self.predict(x_batch, True)
if np.max(err) <= 0:
    continue
# 注意这里我们只能利用误分类的样本做梯度下降
# 因为被正确分类的样本处、这一部分的梯度为 0
mask = err > 0
delta = lr * c * y_batch[mask]
# 取各梯度平均并做一步梯度下降
self._w += np.mean(delta[..., None] * x_batch[mask], axis=0)
self._b += np.mean(delta)
```

但是问题仍然是存在的：那就是它们所运用的梯度下降法都只是朴素的 Vanilla Update，这会导致当数据的 scale 很大时模型对参数极为敏感、从而导致持续的震荡（所谓的 scale 比较大，可以理解为“规模很大”，或者直白一点——以二维数据为例的话——就是横纵坐标的数值很大）。

<div id="kernel-trick"></div>

## Kernel Trick

> 注意，**核函数技巧实际上并不是 SVM 的一部分**。它可以与其他线性分类器共同使用，如逻辑回归等。支持向量机只负责找到决策边界。

以上我们求解的支持向量机都是在线性情况下的，那么非线性情况下如何处理？这里就引入：**核方法**[^CS229]。

[^CS229]: [CS229机器学习笔记(七)-SVM之Kernels](http://daniellaah.github.io/2016/CS229-Machine-Learning-Notes-Lecture-8.html)

核方法是将一个低维的线性不可分的数据映射到一个高维的特征空间、并期望映射后的数据在高维特征空间里是线性可分的。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729124435.png)

至此，似乎问题就转化为了如何寻找合适的映射$\phi$、使得数据集在被它映射到高维空间后变得线性可分。不过可以想象的是，现实任务中的数据集要比上文我们拿来举例的异或数据集要复杂得多、直接构造一个恰当的$\phi$的难度甚至可能高于解决问题本身。另外一个方面，这也会带来维度的急剧上升和很大的计算成本，使得模型求解效率大大下降。

而核方法的巧妙之处就在于，它能将构造映射这个过程再次进行转化、从而使得问题变得简易：它通过核函数来避免显式定义映射$\phi$。往简单里说，核方法会通过用能够表示成$K(x_i,x_j)=\phi(x_i)\cdot\phi(x_j)$的核函数$K(x_i,x_j)$替换各算式中出现的内积$x_i\cdot x_j$来完成将数据从低维映射到高维的过程。

假设$x, z\in \mathbb{R}^n$, $K(x,z)=(x^Tz)^2.$, 展开$K(x,z)$:

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fnf8a3i4nfj30fe04m3yf.jpg)

其中:

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fnf8b5pxffj308i0830t0.jpg)

在这个例子中，映射后特征的内积和原始特征的内积的平方是等价的。 也就是说， 我们只需要计算原始特征的内积再进行平方就可以了，并不需要先得到映射后的特征再计算映射后特征的内积。计算原始特征内积的时间复杂度为$\mathcal{O}(n)$, 而计算映射特征$\phi(x)$的时间复杂度为$\mathcal{O}(x^2)$。

$$
x^{(i)}\cdot x^{(j)}\longrightarrow \phi(x^{(i)})\cdot \phi(x^{(j)}) =K(x^{(i)},x^{(j)})
$$

映射函数 $\phi$ 的作用是将低维空间的数据映射到高维空间中，核函数 $K$ 表示的是映射之后高维空间中两个矢量的点积。

看一下这个列子：

$$
x=[x_1, x_2, x_3]^T,y=[y_1, y_2, y_3]^T
$$

$$
\phi(x)=[x_1x_1,x_1x_2,x_1x_3,x_2x_1,x_2x_2,x_2x_3,x_3x_1,x_3x_2,x_3x_3]
$$

$$
\begin{split}
\phi(1,2,3)&=[1,2,3,2,4,6,3,6,9]^T\\
\phi(4,5,6)&=[16,20,24,20,25,30,24,30,36]^T\\
\phi(1,2,3) \cdot \phi(4,5,6) &=1\times16+2\times 20 + 3\times 24 + 2\times 20 + 4 \times 25 + 6 \times 30 + 3 \times 24 + 6 \times 30 + 9\times 36=1024
\end{split}
$$

$$
\begin{split}
\phi(x)\cdot \phi(y)&=[x_1x_1,x_1x_2,x_1x_3,x_2x_1,x_2x_2,x_2x_3,x_3x_1,x_3x_2,x_3x_3]^T\cdot [y_1y_1,y_1y_2,y_1y_3,y_2y_1,y_2y_2,y_2y_3,y_3y_1,y_3y_2,y_3y_3] \\
&= x_1y_1x_1y_1+x_1y_1x_2y_2+x_1y_1x_3y_3+x_2y_2x_1y_1+x_2y_2x_2y_2+x_2y_2x_3y_3\\&+x_3y_3x_1y_1+x_3y_3x_2y_2+x_3y_3x_3y_3\\
&=(x_1y_1+x_2y_2+x_3y_3)^2\\
&=(x^Ty)^2\\
&=K(x,y)
\end{split}
$$

$$
\begin{split}
K(x,y)=K((1,2,3),(4,5,6))=(1\times 4 + 2\times 5 + 3\times 6)^2=(32)^2=1024
\end{split}
$$

相比于从低维映射到高维空间再进行矢量积运算，核函数大大简化了计算的过程，使得向更高维转化变为了可能，我们不需要知道低维空间的数据是怎样映射到高维空间的，我们只需要知道结果是怎么计算出来的。

我们再来看另一个kernels:

$$
\begin{align} K(x,z) & =(x^Tz+c)^2 \\ & = \sum_{i,j=1}^n(x_ix_j)(z_iz_j) + \sum_{i=1}^n(\sqrt{2c}x_i)(\sqrt{2c}x_j)+c^2. \end{align}
$$

更广泛的来说，我们有：$K(x,z)=(x^Tz+c)^d$，这个kernel将n维的特征映射为${ {n+d} \choose d }$维。

核方法的思想如下：

- 将算法表述成样本点内积的组合（这经常能通过算法的对偶形式实现）
- 设法找到核函数$K(x_i,x_j)$，它能返回样本点$x_i、x_j$被$\phi$作用后的内积
- 用$K(x_i,x_j)$替换$x_i\cdot x_j$、完成低维到高维的映射（同时也完成了从线性算法到非线性算法的转换）

如果我们有一个新的问题我们该如何构造一个kernel？假设我们有映射后的特征向量$\phi(x)$和$\phi(z)$, kernel就是用来计算它们两之间的内积。如果$\phi(x)$和$\phi(z)$相似的话，即这两个向量的夹角很小，那么这个内积就会很大；相反地，如果它们差别很大，那么这个内积就会很小。所以，我们可以这样想kernels，当$x$和$z$相似时，$K(x,z)$很大。反之，当$x$和$z$不同时， $K(x,z)$很小。

我们再来看一个kernel:

$$
K(x,z)=exp\left(-\frac{||x-z||^2}{2\sigma^2}\right).
$$

这个kernel应该挺符合上面的想法吧。这个kernel长得像高斯分布，我们一般叫他高斯kernel，也可以叫Radial basis funtction kernel，简称RBF核。

下面有张图说明在低维线性不可分时，映射到高维后就可分了，使用高斯核函数。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fnf8jmctxgj30fg07umxs.jpg)


### 核函数有效性判定

并不是所有的函数$K$都能够对应一个映射（亦即不是所有的$K(x_i,x_j)$都能拆成$\phi(x_i)\cdot\phi(x_j)$；比如说，显然$K(x_i,x_j)$至少需要是一个对称函数）。

幸运的是，1909 年提出的 Mercer 定理解决了这个问题。Mercer 定理为寻找核函数带来了极大的便利。如果$K$是一个有效的kernel，那么对于在训练集上的核矩阵$K$一定是半正定的。事实上，这不仅仅是个必要条件，它也是充分条件。有效核也叫作Mercer Kernel。

> Mercer 定理: 函数$K$是$\mathbb{R}^n\times\mathbb{R}^n\to\mathbb{R}$上的映射. 如果$K$是一个有效的(Mercer)Kernel, 那么当且仅当对于任意$\lbrace x^{(1)},…,x^{(m)}\rbrace, (m\lt\infty)$, 相应的kernel matrix是半正定的。

$$K_{ij}=K(x^{(i)}, x^{(j)})=\phi(x^{(i)})^T\phi(x^{(j)})=\phi(x^{(j)})^T\phi(x^{(i)})=K(x^{(j)}, x^{(i)})=K_{ji}$$

那么核方法的应用场景有哪些呢？在 2002 年由 Scholkopf 和 Smola 证明的表示定理告诉我们它的应用场景非常广泛。

<div id="kernel-svm"></div>

## Kernel SVM

因此，SVM 其实并不需要真正的向量，它可以用它们的数量积（点积）来进行分类。核函数可以减少大量的计算资源需求。通常，内核是线性的，所以我们得到了一个线性分类器。但如果使用非线性内核，我们可以在完全不改变数据的情况下得到一个非线性分类器：我们只需改变点积为我们想要的空间，SVM 就会对它忠实地进行分类。这意味着我们可以避免耗费计算资源的境地了。（[直观可视化解释](https://v.qq.com/x/page/k05170ntgzc.html)）。


为了完成这个目的，令 $\phi(\mathbf x)$ 表示将 $\mathbf x$ **映射后的特征向量**，于是，在特征空间**划分超平面**所对应的模型可表示为：

$$
\sum_{k=1}^m\alpha_iy^{(i)}=0, w =\sum_{k=1}^m\alpha_iy^{(i)}x^{(i)} \\
y=w^Tx+b
$$

$$
\begin{split}
y&=\sum_{k=1}^m\alpha _ iy^{(i)}x^{(i)}x+b\\
&=\sum_{k=1}^m\alpha _ iy^{(i)}< x^{(i)},x >+b\\
\end{split}
$$

$$
y=\sum_{k=1}^m\alpha_iy^{(i)} < \phi(x^{(i)}),\phi(x) > +b
$$

$$
f(\mathbf x) = \mathbf w^T \phi(\mathbf x) + b
$$

$$
y=\sum_{k=1}^m\alpha _ iy^{(i)}K(x^{(i)},x)+b\\
$$

在SVM的等价对偶问题中的目标函数中有样本点的内积$(x_i \cdot x_j)$，，在空间变换后则是$(\phi(x_i) \cdot \phi(x_j))$ 。由于维数增加导致内积计算成本增加，这时核函数（kernel function）便派上用场了，将映射后的高维空间内积转换成低维空间的函数：$K(x,z)=\phi(x) \cdot \phi(z)$。

同理上文中引入拉格朗日乘子，求解整个方程后可得：

$$
\begin{align}
f(\mathbf x) &=   \mathbf w^T \phi(\mathbf x) + b \\
&= \sum_{i=1}^m \lambda_i y_i \phi(\mathbf x_i)^T \phi(\mathbf x) + b \\
&= \sum_{i=1}^m \lambda_i y_i k(\mathbf x,\mathbf x_i)+ b
\end{align}
$$

注意，使用核函数后，怎么分类新来的样本呢？是否先要找到$\phi(\mathbf x)$，然后再预测？答案肯定不是了。只需要根据上式的值判断即可，如果值大于等于1，那么是正类，小于等于是负类。在两者之间，认为无法确定。

这里的函数 $k(\cdot,\cdot)$ 就是**核函数（kernel function）** ，常见的核函数见下表：

| 名称 | 表达式 | 参数 |
| :-: | :-: | :-: |
| 线性核 | $\boldsymbol x_i^T \boldsymbol x_j$ | 无 |
|多项式核   |  $(\boldsymbol x_i^T \boldsymbol x_j)^d$ |  $d \geqslant 1$ 多项式次数 |
|高斯核   |  $exp(-\frac{\lVert\boldsymbol x_i - \boldsymbol x_j \lVert^2}{2\sigma^2})$ | $\sigma>0$  高斯核带宽  |
| 拉普拉斯核 |  $exp(-\frac{\lVert\boldsymbol x_i - \boldsymbol x_j \lVert^2}{\sigma})$ | $\sigma>0$  |
|Sigmoid核   | $tanh(\beta \boldsymbol x_i^T\boldsymbol x_j + \theta)$  | $\beta>0$ $\theta>0$  |

### 感知器核方法

怎么应用核方法？简单来说，就是把算法中涉及到样本（$x_i$）的地方都通过某种变换、弄成样本的内积形式（$x_i\cdot x_j$）。


感知机的原始损失函数为

$$
L(D) = \sum_{i=1}^N\left[ -y_i(w\cdot x_i+b)\right]_ +
$$

为了让损失函数中的样本都变成内积形式，考虑令$w = \sum_{i=1}^N\alpha_ix_i$（也有令$w = \sum_{i=1}^N\alpha_iy_ix_i$的），则

$$
\begin{align}
L(D) &= \sum_{i=1}^N\left[ -y_i\left[\left(\sum_{j=1}^N\alpha_jx_j\right)\cdot x_i+b\right]\right]_ + \\
&= \sum_{i=1}^N\left[ -y_i\left(\sum_{j=1}^N\alpha_j(x_i\cdot x_j)+b\right)\right]_ +
\end{align}
$$


在此之上应用核方法是平凡的：设核函数为$K$，只需把所有的$x_i\cdot x_j$换成$K(x_i,x_j)$即可：

$$
L(D) = \sum_{i=1}^N\left[ -y_i\left(\sum_{j=1}^N\alpha_jK(x_i,x_j)+b\right)\right]_ +
$$

于是优化问题变为

$$
\min_{\alpha}\sum_{i=1}^N\left[ -y_i\left(\sum_{j=1}^N\alpha_jK(x_i,x_j)+b\right)\right]_ +
$$

预测步骤则变为

$$
y_{\text{pred}}=w\cdot x+b=\sum_{i=1}^N\alpha_iK(x_i, x)+b
$$

当我们对感知机应用核方法后，它就能对非线性数据集（比如螺旋线数据集）进行分类了 。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/2019-7-29-3.gif)


<div id="soft-kernel-svm"></div>

### Soft Kernel SVM

将其代入一般化的SVM学习算法的目标函数中，可得非线性SVM的最优化问题：

$$
L(D)=\frac12\sum_{i=1}^N\sum_{j=1}^N\alpha_i\alpha_jK(x_i,x_j)+C\sum_{i=1}^N\left[ 1-y_i\left(\sum_{j=1}^N\alpha_jK(x_i,x_j)+b\right)\right]_ +
$$


$$
\begin{align}
\min_{\alpha} \quad  \frac{1}{2}\sum_{i=1}^{N}\sum_{j=1}^{N}\alpha_i \alpha_j y_i y_j K(x_i,x_j) - \sum_{i=1}^{N}\alpha_i  \\
s.t. \quad \sum_{i=1}^{N}\alpha_i y_i = 0 ; \quad 0 \le \alpha_i \le C, \quad i=1,2,\cdots,N
\end{align}
$$


预测步骤则仍然是：

$$
y_{\text{pred}}=w\cdot x+b=\sum_{i=1}^N\alpha_iK(x_i, x)+b
$$

## 核方法的训练

[核感知机的梯度下降法](https://zhuanlan.zhihu.com/p/27445103)

[SMO算法](https://zhuanlan.zhihu.com/p/27662928)的效果

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/2019-7-29-4.gif)


# SVR

对SVM解回归问题，进行分析。

- [【机器学习详解】SVM解回归问题](http://blog.csdn.net/luoshixian099/article/details/51121767)

# 扩展应用

当数据未被标记时，不能进行监督式学习，需要用非监督式学习，它会尝试找出数据到簇的自然聚类，并将新数据映射到这些已形成的簇。将支持向量机改进的聚类算法被称为支持向量聚类，当数据未被标记或者仅一些数据被标记时，支持向量聚类经常在工业应用中用作分类步骤的预处理。

# MATLAB实现

- [LIBSVM -- A Library for Support Vector Machines](http://www.csie.ntu.edu.tw/~cjlin/libsvm/index.html)

- [LibSVM 在matlab中的使用以及libsvm-mat在MATLAB平台下的安装](http://blog.sciencenet.cn/blog-111625-837534.html)

- [How to use libsvm for regression in matlab](http://www.it610.com/article/4759080.htm)

得到数值temp1：

```
cmd = ['-v ',num2str(v),' -c ',num2str(ga_bestc),' -g ',num2str(ga_bestg),' -s 3 -p 0.01'];
temp1 = svmtrain(train_label,train_data,cmd);
```

得到训练的模型temp2：

```
cmd = ['-t 2',' -c ',num2str(ga_bestc),' -g ',num2str(ga_bestg),' -s 3 -p 0.01'];
temp2 = svmtrain(train_label,train_data,cmd);
```

livsvm的svr验证：

```
% 训练集输入
[pn_train,inputps] = mapminmax(p_train');
pn_train = pn_train';
% 测试集输入
pn_test = mapminmax('apply',p_test',inputps);
pn_test = pn_test';
% 训练集预测验证
t_svr_train = zeros(len_train,1);
for i = 1:len_train
    x = pn_train(i,:);
    t_svr_train (i,1) = SVRDecisionFunction(x,gs_model);
end
% 反归一化
t_svr_train_1 = mapminmax('reverse',t_svr_train,outputps);
% 测试集预测验证
t_svr_test = zeros(len_test,1);
for i = 1:len_test
    x = pn_test(i,:);
    t_svr_test (i,1) = SVRDecisionFunction(x,gs_model);
end
% 反归一化
t_svr_test_1 = mapminmax('reverse',t_svr_test,outputps);

figure
hold on
h200=plot(1:length(set_num),[t_train;t_test]','r-o');
h202=plot(1:length(set_num),[gs_predict_1;gs_predict_2]','b-+');
h203=plot(1:length(set_num),[t_svr_train_1;t_svr_test_1]','g-+');

```

<div id="parameter-selection"></div>

# SVM 参数优化

[In support vector machines (SVM) how can we adjust the parameter C?](https://www.researchgate.net/post/In_support_vector_machinesSVM_how_we_adjust_the_parameter_C_why_we_use_this_parameter)

C is a trade-off between training error and the flatness of the solution. The larger C is the less the final training error will be. But if you increase C too much you risk losing the generalization properties of the classifier, because it will try to fit as best as possible all the training points (including the possible errors of your dataset). In addition a large C, usually increases the time needed for training.

If C is small, then the classifier is flat (meaning that its derivatives are small - close to zero, at least for the gaussian rbf kernel this is substantiated theoretically). You have to find a C that keeps the training erro small, but also generalizes well (i.e., it doesn't have large fluctuations). There are several methods to find the best possible C automatically, but you must keep in mind that this depends on the application you are interested in.
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>SVM</tag>
      </tags>
  </entry>
  <entry>
    <title>游泳</title>
    <url>/swimming/</url>
    <content><![CDATA[
游泳作为一项可以调动全身的运动，已成为越来越多人的锻炼首选。那么，如何快速有效地学习游泳？怎样游泳最为减肥？长期游泳又有哪些好处？欢迎一起来[解锁游泳技能](https://www.zhihu.com/roundtable/youyong)。

<!--more-->

# 蛙泳

- [蛙泳怎样才能游得快](https://www.zhihu.com/question/21577700/answer/30628257)
- [蛙泳教学完整版](http://v.youku.com/v_show/id_XMjgwOTA4OTI0.html?from=s1.8-1-1.2)

## 动作时序图

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/bef93fb2gy1fe19d2zopxg20c80gqwi2.gif)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/bef93fb2gy1fe19d3w59dg20c80fg416.gif)

## 要领

* 先划手，后收腿，先伸胳膊后蹬腿。
* 腿部动作时一定要勾脚，大腿不要收太多。
* 收腿放松，蹬腿用力，蹬完一定要漂一会，把握好节奏，不要快蹬快收。
* 手部划水动作不要过大，不要超过肩部。
* 两手开始外分时就抬头吸气。

# 自由泳

## 视频

* [值得一看的自由泳教学视频](http://v.youku.com/v_show/id_XNzIxMTkwOTY0.html?beta&from=s1.8-1-2.999&f=18195375&sf=10102&spm=0.0.0.0.lMFhS6)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/bef93fb2gy1fe19d0vdn8g20c80hvwi8.gif)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/bef93fb2gy1fe19d1uxq4g20c80fmq61.gif)

# 仰泳

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/bef93fb2gy1fe19d4s7xgg20c80eitbi.gif)
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/bef93fb2gy1fe19d5yo90g20c80fw41m.gif)

# 蝶泳

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/bef93fb2gy1fe19d71ah1g20c80hkju4.gif)
![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/bef93fb2gy1fe19d80d5kg20c80ihwi8.gif)
]]></content>
      <categories>
        <category>Wiki</category>
      </categories>
      <tags>
        <tag>游泳</tag>
      </tags>
  </entry>
  <entry>
    <title>Tex使用指南</title>
    <url>/tex/</url>
    <content><![CDATA[
TEX（TeX）是由著名的计算机科学家Donald E. Knuth（高德纳）发明的排版系统，利用TeX可以很容易地生成高质量的dvi，pdf，ps文件等。它在学术界十分流行，特别是数学、物理学和计算机科学界。TeX被普遍认为是一个很好的排版工具，特别是在处理复杂的数学公式时。

<!--more-->

因此，tex是排版语言。Latex是在Tex基础上开发的一个扩展，使之更易用，它的底层还是tex。而Texlive和Ctex是两个套版。界面编辑器有winedt（CTEX自带），texworker（TEXLIVE自带），texmaker， texstudio，Sublime Text等。

[CTAN](https://ctan.org/) 以 HTTP 或 FTP 的形式提供大量 TeX 相关资源的下载。在 CTAN 上可以下载到最新版本的主要 TeX 发行版，如 TeX Live、MiKTeX，可以下载免费的 TeX 相关编辑器、支持工具、附件，如 LyX、WinEdt、GhostScript、TpX 等。

参考连接：

- [TeX 教程](http://www.ctex.org/documents/shredder/tex_doc.html)
- [LaTeXFly 用户文档](http://latexfly.com/docs/latex/mathematics.html)
- [在线TEX编辑器](http://jaxedit.com/)
- [分享与学习LaTeX的王国](http://www.latexstudio.net/)
- [elsarticle.cls学习](https://blog.csdn.net/qq_36607894/article/details/100560421)

# TEX排版

编译必备列表：

- test.tex（主文件）
  - 推荐使用[texstudio](#texstudio)编辑
- test.bst（参考文献样式文件）
- test.eps（图片文件）
  - 参考[做图技巧](#eps)
- test.stl（样式文件）
- test.bib（参考文献文件，bibtex格式）
  - 推荐使用[bibfile格式](#bibfile)

前期文档编辑推荐使用**底层Texlive+界面编辑器texstudio**，后期添加参考文献推荐使用**Texlive+Sublime Text**（可以检索参考文献关键词，调用smartPDF预览修改）。

<div id="texlive"></div>

## Texlive

早期软件使用latex命令编译，源文件中包含的图片格式必须为eps，先生成ps文档，在将其转换成pdf文档；使用pdflatex命令编译，源文件中必须包含pdf格式的图片。如果你用pdflatex命令编译含eps的源文件时，就会出现报错信息。使用[Texlive](https://www.tug.org/texlive/)编译含eps图片的源文件时，编译命令会自动将eps图片转换成pdf类型的图片，最后生成pdf文档，整个过程一气呵成。

<div id="texstudio"></div>

### TEXLIVE + Texstudio

1. 先下载安装TEXLIVE[^info-detail-1016619]。下载后右键管理员，`install-tl-advanced.bat`按步骤即可。点击Continue即可，对于某些装了杀毒软件的，最好先关了，以免误报。安装结束后，记住在点“完成”之后要把cmd关掉。在Win7下，TeX Live提供的字体会自动为XeTeX所用。
2. 然后下载安装[Texstudio](http://texstudio.sourceforge.net/) [^61952467] [^4734521]，安装可以选择安装包或者 Portable Edition。默认安装即可，在没有其他TEX工具时程序会自动配置成TEXLIVE。
3. 解压软件到任意文件夹，打开`TeXstudio.exe`，选择 `Options - Configure TeXstudio`，打开选项卡，选择`Command`，编辑右侧的命令，配置`MiKTeX、ghostscript和pdf阅读器`等。

[^info-detail-1016619]: [在Win7上安装TexLive及设置XeLaTeX的整个过程](http://www.mamicode.com/info-detail-1016619.html)
[^61952467]: [如何配置TeXstudio+SumatraPDF+Texlive](http://blog.csdn.net/niruo_chengfeng/article/details/61952467)

[^4734521]: [TeXstudio 编写Latex论文的若干问题解决方案总结](http://www.cnblogs.com/tsingke/p/4734521.html)

### TexStudio语法检查

详情点击查看[对TexStudio配置拼写和语法检查LanguageTool功能](http://blog.csdn.net/yinqingwang/article/details/54583541)：

1. 下载插件[LanguageTool](https://www.languagetool.org/download/)。TexStudio 2.12.2 (+) 版本：  仅支持LanguageTool 3.5之后 版本。TexStudio版本2.12.2及之后的版本，支持JSON格式的调用，这里我们下载`.zip`格式的文件： `LanguageTool-3.6.zip`。将下载的插件解压缩到任意全英文目录。

2. 根据电脑类型[下载java JRE](http://www.oracle.com/technetwork/java/javase/downloads/index.html)，并安装。

3. 右击`我的电脑->属性->高级->环境变量`。然后把`Java.exe/javaw.exe`所在的路径（`C:\Program Files\Java`）加入PATH环境变量。

4. 打开命令行窗口`cmd.exe`, 转到languagetool所在目录，运行如下命令启动`java –jar languagetool.jar`, 会出现languagetool的窗口，如下图。打开languagetool后，在选项上勾选`运行服务器端口: 8081`。之后关闭languagetool窗口。(配置好后，以后就不需要了)
   
   ```
   e:
   cd /tools/tex/LanguageTool-3.6 %LanguageTool-3.6所在路径
   ```
   
     ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqravneeioj30u70iiq5n.jpg)

5. 启用拼写检查。打开TexStudio, `菜单-option-configure Texstudio`，找到`Language Checking`标签项，设置好`Spell check`，`wordlist directory`, default language设置为`en_US`。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqraw08lazj30se0983zy.jpg)

6. 启用LanguageTool。同样的上述选项卡，`LanguageTool`处，填写如下内容：
   `Server URL： http://localhost:8081`，Java: 选择`javaw.exe` (注意不是java.exe。 仅针对windows平台)。LT Path： `<LanguageTool目录>\languagetool.jar`。LT Argements: （可以不填或者默认）。然后**重新启动** TexStudio。
   ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqraw8yor3j30sb0ea0uw.jpg)

> LanguageTool 不起作用
> 解决： 分几步检查问题所在
> i)  是否版本匹配： TexStudio 2.12.0之前只能使用LauguageTool 2.x版本， TexStudio 2.12.2版本使用LanguageTool 3.6 及之上版本
> ii) 打开TexStudio之后， 打开浏览器，输入地址: http://localhost:8081
> 会出现提示：Error: Missing 'text' parameter。如果未出现类似提示，请检查是否javaw.exe路径设置不正确。

### TeXLive + Sublime Text

> Sublime Text：一款具有代码高亮、语法提示、自动完成且反应快速的编辑器软件，不仅具有华丽的界面，还支持插件扩展机制。

在cite的时候可以输入关键词选择。而texstudio只能显示引用关键词。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1ffhc7w3zjdj20go08iacm.jpg)

1. 安装[TEXLIVE](https://www.tug.org/texlive/)

2. 安装SUBLIME TEXT + PACKAGE CONTROL + LATEXTOOLS
   
   - [Sublime Text: The text editor you'll fall in love with](http://www.sublimetext.com/)，推荐用最新的 Sublime Text 3。[如何优雅地使用Sublime Text](http://www.jeffjade.com/2015/12/15/2015-04-17-toss-sublime-text/)。
   
   - 安装插件首先要[安装](https://packagecontrol.io/installation)Package Control 。所有[其他的插件](https://packagecontrol.io/)都可以通过 Package Control 来安装和管理。。插件安装方式分在线和本地安装，[前端学习日志-Sublime Text 2安装插件方法详解](http://www.monring.com/front_end/sublime-text-2-install-package.html)。
   
   - LaTeXTools，在线安装：在 Sublime Text 中，按 Ctrl+Shift+P 呼出 Command Palette 然后找到 Package Control: Install Package ，等待列表加载完毕后输入 LaTeXTools 回车即可安装。本地安装：下载 SublimeText/LaTeXTools · [GitHub](https://github.com/SublimeText/LaTeXTools)。

3. 安装 SUMATRAPDF，[下载地址](http://www.sumatrapdfreader.org/download-free-pdf-viewer.html)。SumatraPDF 是一个轻量级的PDF阅读软件，绿色单文件，此处用于TeX源文件编译后的预览。支持 PDF、ePub、MOBI、CHM、XPS、DjVu、CBZ、CBR 等格式。
   
   - 将 SumatraPDF 的主程序目录(C:\Program Files\SumatraPDF)添加到环境变量PATH，这一步很重要，否则下一步会无法进行。
   
   - 打开命令提示符（cmd.exe），执行以下命令：（将其中的安装路径替换成你实际的安装路径）
     
     ```
     sumatrapdf.exe -inverse-search "\"C:\Program Files\Sublime Text 3\sublime_text.exe\" \"%f:%l\""
     ```

4. 配置 LATEXTOOLS
   
   - 在 Sublime Text 中，打开 Preference 菜单，找到 Package Settings->LaTeXTools->Settings – User ，在Platfrom settings段，根据自己的系统，修改相应的配置。
     
     ```
     "texpath" : "C:\\texlive\\2016\\bin\\win32;$PATH",
     "distro" : "texlive",//miktex
     ```

5. 至此，环境搭建完成。可以利用以下的测试文章来测试环境。编辑完成后 Ctrl+S 保存为 xx.tex（新建的文件一定要先保存，否则 build 是无效的），然后手工在 Tools->Build System 中选择 LaTeX ，最后通过 Ctrl+B 来编译。
   
   ```
   %!TEX program = xelatex
   \documentclass[UTF8]{ctexart}
   \begin{document}
   This is the context of the article.
   这就是文章的所有内容。
   \end{document}
   ```

# Tex语法

## 常见报错解析

- 无特殊要求，不要使用`\usepackage{epstopdf}`。本地编译没问题，但会导致投稿系统路径编译错误。
- `! File ended while scanning use of \@newl@bel.`可以删除编译文件夹内.aux扩展名结尾的文件，重新用Latex命令进行编译即可。

## TEX中文

> [TeX Live 2009 的 LaTeX 中文支持](http://blog.jjgod.org/2009/11/21/chinese-in-tex-live-2009/)  
> [TexLive的中文编辑——xeTex，xeLatex](http://blog.sciencenet.cn/blog-725052-826695.html)  

处理中文时，编辑器保存中文使用的文件编码是重要的，须以**UTF8 编码保存** （或者用记事本打开并另存为，编码选项选择UTF-8）。

- TeX Live 与 CTeX 套装都自带有 TeXworks 编辑器，其默认编码是 UTF-8。可以在选项中修改。

```
\documentclass{ctexart}
\usepackage[UTF8]{ctex}
\begin{document}
中文English
\[E = m c^2\]
\end{document}
```

使用 **xelatex** 编译即可。

<div class="note info"><p>针对TeXLive编译卡顿的问题，清空 TeXLive 的安装路径 `C:\texlive\2016\texmf-var\fonts\cache` 中的文件，然后在命令行运行`fc-cache -r -v`重新生成字体缓存就好了。</p></div>

疑难问题：

- 中文乱码：在文档首行增加一句：`!TEX encoding = System`

- 要用中文只要安装`texlive-lang-cjk`这个包就行了
  
  ```
  sudo aptitude install texlive-lang-cjk
  or
  sudo apt-get install texlive-lang-cjk
  ```

- [国内期刊 CCT 模板编译经验](https://liam0205.me/2013/10/15/LaTeX-CCT-template/)

## 字体大小

<div id="">front-size</div>

Latex设置字体大小，字体大小命令由小到大依次为：

```
\tiny
\scriptsize
\footnotesize
\small
\normalsize
\large
\Large
\LARGE
\huge
\Huge
```

## 作者信息

同一个单位的作者们

```
> \title{A Title\thanksref{label}}
\thanks[label]{Project supported by the Fundamental Research Funds for the Central Universities(2012RC0504).}
\author{Ping Wang\corauthref{cor}},
\ead{wp112@bupt.edu.cn} \corauth[cor]{Corresponding author}
\author{Ping Xue},
\author{Mingtao DU},
\author{Qingxuan JIA},
\author{Qifei ZHAO}
\address{School of Automation, Beijing University of Posts and Telecommunications, Beijing 100876, China}
```

不同单位的作者们

```
> \author[add1]{Aaron\corauthref{cor1}},% Aaron是第1个单位的作者，且是通讯作者
\ead{* @.edu.cn}
\corauth[cor1]{Corresponding author.}
\author[add1]{Bill}           % Bill是第1个单位的作者，且是通讯作者
\author[add2]{Cart}           % Cart是第2个单位的作者，且是通讯作者
\author[add1]{Damon}          % Damon是第2个单位的作者，且是通讯作者
\address[add1]{** University, Shanghai , China}       % 第1个单位的地址
\address[add2]{** University, Beijing, China}         % 第2个单位的地址
```

同一作者属于不同单位

```
> %列出所有作者所属单位
\author[author1,author2]{Qingmao},         %Qingmao属于第1，2个单位
\author[author2]{Xiaosui},                 %Xiaosui属于第2个单位
\author[author3]{Houcheng},                %Houcheng属于第3个单位
\author[author2]{Tonglin\corauthref{cor1}} %Tonglin属于第2个单位，同时还是通讯作者
\corauth[cor1]{Corresponding author.}
\ead{zzz@163.com}
%所有单位地址
\address[author1]{Colle...
\address[author2]{Colle...
\address[author3]{Colle...
```

## 段落设置

### 首行缩进

```
% 如果默认首行不缩进，则使用indentfirst宏包
\usepackage{indentfirst}
% 指定某段首行缩进，在段首加
\indent
% 指定某段首行不缩进，在段首加
\noindent
% 设置缩进量
\setlength\parindent{2em}
```

### 字间距

```
% 只适用于CJK和xeCJK
\renewcommand{\CJKglue}{\hskip 宽度}
比如
\renewcommand{\CJKglue}{\hskip 1pt plus 0.08\baselineskip}
```

### 行间距

```
\linespread{1.5}
% 或者
\renewcommand{\baselinestretch}{1.5}
```

### 段间距

```
% 设置\parskip的值，比如
\setlength{\parskip}{0.5\baselineskip}
```

## 交叉引用

使用`\usepackage{hyperref}`可以生成文中引用点击跳转。
`

```
Fig.~\ref{tab.5}
Eq.~\ref{Fig.5}
```

## 脚注

```
\footnote{footnote text}
```

## 插入网址

在文档头加上宏

```
\usepackage{hyperref}
\usepackage{lineno,hyperref}
% \usepackage[colorlinks,linkcolor=blue]{hyperref}
% 在正文中直接输入如下代码:
\url{https://www.google.com.hk}
```

其中linkcolor=red是指将链接的颜色设置为红色，也可以设置为blue，black，green等颜色。

如果不想在正文中出现链接地址的话，而想用文字或其他字体显示链接，则可以输入如下代码：

```
\href{https://www.google.com.hk}{google}
```

设置邮箱地址超链接也需要在文档开头加上宏包

```
\usepackage[colorlinks,linkcolor=red]{hyperref}
```

含义同上,同时需要在转入的邮箱地址前加上mailto命令，然后在后面大括号里面输入邮箱地址便可。

```
\href{mailto:xx@163.com}{xx@163.com}
```

<div id="eps"></div>

## 做图技巧

一般要求的Width是3.5inchs，分辨率是600dpi。保存原始仿真图像，方便后期修改。

### 图片剪切技巧

- 命令行，不失真。
  
  ```
  sam2p xxx.jpg  xxx.eps
  pdf2ps abc.pdf abc.ps
  ps2epsi.bat abc.ps abc.eps
  ```

- 图片-PS-EPS：选择Photoshop EPS，对话框选项即可「EPS Options --> Encoding: ASCII」。

- PostScript-PS-EPS：安装PostScript虚拟打印机，然后把图片打印成.ps格式，再用GSview转化成eps格式。

- visio图片：[Latex插入Visio绘制的流程图](http://www.magicsite.cn/blog/other/other407945.html)。visio本来就用另存为pdf的功能，但是直接存的话，很难避免页面的空白边缘。
  
  > 点击“打印”，弹出“打印”对话框。在打印机“名称”下拉列表中选择“Adobe PDF”，然后点击“属性”按钮，弹出“**Adobe PDF 文档属性**”对话框。选择“**布局**”选项卡，点击右下角的“**高级**”按钮，弹出“Adobe PDF Converter 高级选项”对话框，在“**文档选项－PostScript选项－PostScript输出选项**”，选择“内嵌的PostScript （EPS）”，点击“确定”，返回到“Adobe PDF 文档属性”对话框，选择“Adobe PDF 设置”选项卡，把“**不要发送字体到Adobe PDF（N)**”复选框前面的对号去掉，点击“确定”，返回到“打印”对话框，点击“确定”（注意，在“打印”对话框中不要选中“打印到文件（L)”复选框），选择文件名，保存成pdf文件。
  
  1. visio转化为pdf。
  2. 先用visio画好图，然后`设计`--`大小`--`适应绘图`。visio就会自动调整画布来去除空白边缘，此时再另存外pdf即可。
  3. visio中的图copy到adobe illustrator中。最后，在adobe illustrator中，直接`另存为eps`即可。

### MATLAB图片

为了在tex中使用且避免失真，一般可直接将图片保存为eps格式。<font color=red>建议画图时均单独plot</font>，不使用subplot，其中的legend大小比例更好设置。

> 对于数据量较大的图，最好的方法在Matlab里直接存成增强型JPG格式，然后用bmeps工具转换成eps格式，效果比较好，也可以克服图转换成JPG后失真的问题。小数据量的图，直接通过Matlab图形界面另存为eps格式即可，但是设置不当生成的eps格式图容易超出边界，这点可以通过GsView先预览一下，如果没有超出边界就可以采用，如果超出边界了可以作如下处理：直接复制到word文档里，转换成PDF格式，再用GSview处理或ImageMagic处理[^blog-533656-428329]。

[^blog-533656-428329]: [解决Matlab画图直接保存.eps格式而导致图不全的问题](http://blog.sciencenet.cn/blog-533656-428329.html)

MATLAB中常用标准命令可以查看[PLOT设置](https://sli1989.github.io/matlab/#matlab-plot)。一般来说，上述方法输出的EPS可以直接使用，无须进行裁剪。但是有时由于原来的图像可能有较大的空白边缘，在文章中显示效果不佳，需要将图片裁剪空白边缘。这样需要进行如下设置：

- EPS-PS-EPS：用Gsview（使用ctex套件中的Gsview版本）裁剪。
  
  1. 菜单栏  `options--show bounding boxs` 选中.
  
  2. 打开eps图，然后`File->PS TO EPS`，不选择`Automatically calculate Bounding Box`，然后点击`yes`，用鼠标单击上下左右，输入要保存的文件名。也可以选择`Automatically calculate Bounding Box`。
     
     > 注意，这样生成的新文件如果用Gsview打开了看，还是会发现空白依然存在，但是插入LaTex中使用，生成PDF后会发现使用的图，空白消失了，完全按照你刚才设定的大小输出。

- EPS-PDF-adobe-PS-EPS：把已有的eps图片转化为pdf，使用adobe acrobat中的裁剪工具，然后另存为ps。再用gsviewer打开ps，另存为eps即可。
  
  > 台湾某牛写的pdf裁剪的一个小工具，pdfcropper。 ctex有eps和pdf裁剪包(pdfcrop)，不过需要Perl支持，可安装草莓Perl，效果不错。

## 图片调用技巧

> [图片位置排版技巧](http://zhanglei.eu/2016/06/29/Latex%E5%9F%BA%E7%A1%80-%E5%9B%BE%E7%89%87%E4%BD%8D%E7%BD%AE%E6%8E%92%E7%89%88%E6%8A%80%E5%B7%A7/)

头文件：

```
\usepackage{graphicx}
```

> eps文件和tex文件放在同一个文件夹，只用文件名就可以调用，不用写路径。编译时不能使用pdflatex，会出错。即使不出错，也看不到图。应使用latex编译生成dvi，然后dvi2ps，ps2pdf就可以看到图了。

### 位置

如果希望避免浮动体跨过`\section`，可以使用 `placeins` 宏包。

```
\usepackage[section]{placeins}
```

如果希望禁止浮动，可以使用 `float` 宏包，结合 `H` 选项。

```
\usepackage{float}
% ...
\begin{figure}[H]
% ...
\begin{table}[H]
% ...
```

当在双栏模式中插入跨栏图表时（`figure*`或`table*`），使用`stfloats`包进行控制：

```
\usepackage{stfloats}

\begin{figure*}[hb]
...
\end{figure*}
```

> h 当前位置。 将图形放置在 正文文本中给出该图形环境的地方。如果本页所剩的页面不够， 这一参数将不起作用。
> t 顶部。 将图形放置在页面的顶部。
> b 底部。 将图形放置在页面的底部 16.1。
> p 浮动页。 将图形放置在一只允许 有浮动对象的页面上。
> 如果在图形环境中没有给出上述任一参数，则缺省为 [tbp]。给出参数的顺序不会影响到最后的结果。给出的参数越多， LATEX 的排版结果就会越好。 在浮动位置选项前加上一个惊叹号会使 LATEX 忽略应用于文本页的审美条件，试图用最严格的标准来 放置浮动图形。

调整图表说明与正文之间的间距：

```
\vspace{-0.8cm}  %调整图片与上下文的垂直距离
%放在 \begin{figure} 之前调整上文距离
%放在 \end{figure} 之后调整下文距离

\begin{figure}[hb]

\setlength{\abovecaptionskip}{-0.2cm}   %调整图片标题与图距离
\setlength{\belowcaptionskip}{-1cm}   %调整图片标题与下文距离
%放在 \begin{document} 之前全局设置
%放在 \begin{figure} 之后单个设置

\end{figure}
```

考虑到长标题的图表并不多，因此尝试对单个图表进行修改。通过`\captionsetup{font={small,bf,stretch=1.25}, justification=raggedright} `来进行重新修改caption格式。

图表说明居中设置：`\usepackage[justification=centering]{caption}`

### 大小

使用[选项]可以指定图片大小：

> `\includegraphics[width=3in]{file.eps}`
> 设定图片宽度为3 inches，图片高度会自动缩放。  
> `\includegraphics[width=\testwidth]{file.eps}`
> 设定图片宽度为文本宽度。  
> `\includegraphics[width=0.8\textwidth]{file.eps}`
> 设定图片宽度为文本宽度的0.8倍  
> ` \includegraphics[width=\testwidth-2.0in]{file.eps}`
> 设定图片宽度比文本宽度少2 inches。  
> 使用[选项]指定图片旋转角度将图片旋转270度。
> `\includegraphics[angle=270]{file.eps}
> `  
> 两个选项同时使用，中间用逗号隔开：
> `\includegraphics[width=\testwidth, angle=270]{file.eps}`

如果不喜欢让Latex自动安排图片位置，可以使用float包，然后用`\begin{figure}[H]`。

```
\usepackage{float}  
\begin{figure}[H]
```

### 插入并列的子图

头文件：`\usepackage{subfigure} `

```
\begin{figure}[H]
\centering
\subfigure[SubfigureCaption]{
\label{Fig.sub.1}
\includegraphics[width=0.4\textwidth]{figurename.eps}}
\subfigure[SubfigureCaption]{
\label{Fig.sub.2}
\includegraphics[width=0.4\textwidth]{figurename.eps}}
\caption{MainfigureCaption}
\label{Fig.lable}
\end{figure}
```

```
\begin{figure}
\centering
\begin{minipage}[c]{0.45\textwidth}
        \includegraphics[width=0.9\textwidth]{result.png}
        \caption{Report after querying}            
\end{minipage}
\begin{minipage}[c]{0.45\textwidth}
        \includegraphics[width=0.9\textwidth]{chart.png}
        \caption{Chart being outputted}        
\end{minipage}
\end{figure}
```

> 改变间距用 \vspace{.3in} 和\hspace{.1in},置于两subfigure间。这里的in表示inch， 另外也可以用cm控制。

使用subfig如何去掉子图上部空白

subfig定义了一个farskip与上边有个10pt的距离，我们可以通过以下两个方式去掉：
1，subfig包加参数去掉：

```
\usepackage[farskip=0pt]{subfig}
```

2，使用caption来进行设置，如下：

```
\usepackage{caption}
\captionsetup[subfloat]{farskip=0pt}
```

### subfigure竖排图形

注意要使用宏包\usepackage{graphicx}和\usepackage{subfigure}
IEEE给的模板是图形横排，subfigure不支持\\换行

```
\begin{figure}
\centering
\subfigure[the first subfigure]{
\begin{minipage}[b]{0.2\textwidth}
\includegraphics[width=1\textwidth]{fig1.eps} \\
\includegraphics[width=1\textwidth]{fig2.eps}
\end{minipage}
}
\subfigure[the second subfigure]{
\begin{minipage}[b]{0.2\textwidth}
\includegraphics[width=1\textwidth]{fig3.eps} \\
\includegraphics[width=1\textwidth]{fig4.eps}
\end{minipage}
}
\end{figure}
```

### 多子图分页

宏包：

```
\usepackage[centerlast]{caption2}
\usepackage{subfigure}
```

使用两个图形环境，欺骗下LaTeX的计数器:

```
 \begin{figure}
  \centering
  \subfigure[First Part]{
    \label{fig:graphics:a}
    \includegraphics[width=\textwidth]{wide.eps}}
  \caption{Large Graphics}
  \label{fig:graphics} % label for figure
\end{figure}
\addtocounter{figure}{-1}       %先欺骗LaTeX图形计数器
\begin{figure}
  \addtocounter{figure}{1}      %再告诉LaTeX图形计数器真相
  \centering
  \subfigure[Second Part]{
    \label{fig:graphics:b}
    \includegraphics[width=\textwidth]{wide.eps}}%
  \caption{Large Graphics (con't)}
\end{figure}
```

```
\documentclass[12pt,onecolumn]{article}
\usepackage{geometry}
\usepackage[]{graphicx}
\geometry{left=1in,right=1in,top=1in,bottom=1in}
\pagestyle{empty}
\begin{document}
{\centering
\footnotesize
\begin{tabular}{@{}c@{}c@{}c@{}}
\includegraphics[width=0.33\textwidth]{Cm-scene-8-prod-max-r1.eps}
&\includegraphics[width=0.33\textwidth]{Cm-scene-13-prod-max-r1.eps}
&\includegraphics[width=0.33\textwidth]{Cm-scene-15-prod-max-r1.eps}\\
(a)&(b)&(c)
\end{tabular}
}
\end{document}
```

需要注意的是，tex文档会自动插入页码，这样生成的eps的boundingbox不正确。应该加一句`\pagestyle{empty}`，这样就没有页码，最终生成完美的eps文件。

### 子图如何添加双语标题

[来源](http://blog.sina.com.cn/s/blog_5e16f1770100n206.html)

```
\begin{figure}[htbp]
\centering
\subfigure{\label{第1个子图标签名}}\addtocounter{subfigure}{-2}
\subfigure[The 1st subfigure caption]{\subfigure[第1个子图标题]
{\includegraphics[width=0.4\textwidth]{文件名}}}
\subfigure{\label{第2个子图标签名}}\addtocounter{subfigure}{-2}
\subfigure[The 2nd subfigure caption]{\subfigure[第2个子图标题]
{\includegraphics[width=0.4\textwidth]{文件名}}}
\bicaption[总标签名]{}{中文总标题}{Fig.$\!$}{The total caption}
\vspace{-1em}
\end{figure}
```

### 动图显示

> [用tikz和animate包制作动画pdf](https://zhuanlan.zhihu.com/p/144472941)

要在pdf中看到动画效果，用的是一种障眼法。也就是动画的帧数，那么animate包就可以将很多页pdf放在一页中，然后以选定的帧数进行播放，进而实现动画效果，内部则是调用了javascript。

1. 首先要包含相应的package：
   
   ```
   \usepackage{graphicx}
   \usepackage{animate}
   ```

2. 使用`ImageMagick`软件包，通过CMD窗口将该gif文件转化成一系列的单帧图片，并新建一个`imgs`文件夹，将这些新生成的eps文件存入。
   
   ```
   convert abc.gif -coalesce animate_abc_%d.eps
   magick abc.gif -coalesce animate_abc_%d.eps
   % 如果你使用的ImageMagick版本超过7.2，那么需要使用“magick”命
   ```

3. 调用（这里的`autoplay`和`loop`分别表示自动播放动画和循环播放，后面4个参数分别表示每秒的播放帧数，需要使用的文件名，文件的起始页码和终止页码，如果页码置空，则表示从首页到尾页）。然后必须用`Adobe Reader`打开就能看到动画的效果了。
   
   ```
   \usepackage{graphicx,animate}
   \begin{document}
       \begin{figure}
       \centering
       \animategraphics[loop,autoplay]{12}{./imgs/animate_abc_}{0}{100}
       \end{figure}
   \end{document}
   ```

### IEEE模板

IEEE模板中图下面的标题应该是左对齐，但只有在标题超过一行的时候才会激活，需要将对齐方式对单行的标题也有效需要对caption宏包进行设置 singlelinecheck=false，否则默认会居中 。还有，Latex模板中默认的Fig. 1后面使用的是冒号分隔符，即“Fig.1 :”，与word模板不一致，可以修改为labelsep=period 。所以，最后在开头的package声明中应该是： `\usepackage[singlelinecheck=false, labelsep=period]{caption}` ，这样就可以与word中一致了 。

latex文档请记得在开头加上

```
\documentclass[conference, a4paper]{IEEEtran}
\captionsetup{font=sc}
```

```
\begin{table}[!htbp]%\renewcommand{\arraystretch}{1.5}
\centering
\caption{XXX~方法和~YYY~方法的对比}\label{tab:5-5}
%\vspace{15pt}
\begin{tabular}{|l|c|c|}
\hline
& XXX & YYY \\
\hline
A1 & 7.4027 & 8.5846  \\
A2 & 4.4622 & 9.2157  \\
A3 & 7.5864 & 13.1597  \\
A4 & 5.5718 & 6.5974  \\
\hline
\end{tabular}
\end{table}
```

## 表格使用技巧

规范参考：

```
\begin{table}[!b]
    \centering
    \caption{xx}
    \scalebox{1}{1}{\begin{tabular}
    ...
    \end{tabular}}
    \label{tab:xx}
    \end{table}
```

### 制作方法

- 推荐[Excel2LaTeX](http://www.ctan.org/tex-archive/support/excel2latex/)宏插件。[LaTeX使用excel2latex插入表格](http://www.cnblogs.com/Hand-Head/articles/5196340.html)
  - 首先要在  `文件-选项-信任中心-信任中心设置-宏设置`  里确认没有选择禁用所有宏，若已禁用的就更改下设置。
  - 然后在 `文件-选项-加载项-管理加载项`  的选项卡里点浏览，载入已下载好的`Excel2LaTeX.xla`文件，并勾选确认。
  - 打开想要转化成latex代码的表格，选择表格内容点"Convert table to Latex"
- 手动输入
- 读取CSV。可以使用一个叫`pgfplotstable`的包，也可以使用[Nicola Talbot](http://www.dickimaw-books.com/)编写的datatool 宏包。[教程](http://www.latexstudio.net/archives/3176)。
- [LaTeX Table Generator](http://www.tablesgenerator.com/)在线表格制作。

### 三线表格横竖线断开

- 不用booktabs宏包，使用makecell宏包
  
  ```
  %模仿booktabs宏包的三线宽度设置
  \newcommand\toprule{\Xhline{.08em}}
  \newcommand\midrule{\Xhline{.05em}}
  \newcommand\bottomrule{\Xhline{.08em}}
  ```

- 用booktabs宏包
  
  ```
  \setlength{\abovetopsep}{0.5ex}
  \setlength{\belowrulesep}{0pt}
  \setlength{\aboverulesep}{0pt}
  ```

### 自动宽度表格

```
usepackage{tabularx}

\begin{tabularx}{0.9\textwidth}{rX}%注意对齐方式用rX,其中X表示自动宽度
    \centering
    \toprule
    Period & Progress \\
    \midrule
    Week 1-2 & Pre-conferences and documentation study \\
    Week 3-4 & Confirming development tool and frame designing \\
    Week 5-6 & Login system designing and debugging \\
    Week 7-8 & Inputing graphical user interface(GUI) designing \\
    Week 9-10 & Development of the query and the report function \\
    Week 11-12 & Overall debugging and testing \\
   \bottomrule
\caption{Progress schedule}
\label{Progress Control}
\end{tabularx}
```

### 表格内文字过长自动换行

- 在一些论文中往往出现表格表头文字过长，使得表格排到页面以外，我们可以把表头文字进行竖排。我们可以使用graphicx提供的`\rotatebox{90}{}`来实现这一操作。

- 设置[字体大小控制符](#front-size)即可。
  
  ```
  \begin{table}[h] \small
  ```

- 利用graphicx宏包提供的\scalebox盒子命令，把表格内容（比如tabular环境中的所有东西）放到这个缩放盒子里。
  
  ```
  \usepackage{booktabs,graphicx}
  
  \scalebox{<h-scale>}[<v-scale>]{<text>}
  这里的h-scale和v-scale分别是水平和竖直的缩放因子，要缩小，那么取值就在0~1之间，后边花括号里就是缩放的内容。
  ```
  
    参考文献[1](http://blog.163.com/heyanqiner@126/blog/static/173423558201152454357190/)：
  
  ```
  \usepackage{array}
  
  % 方法3
  \begin{tabular}{m{5cm}}
  % 方法4
  \begin{tabular}{p{0.9\columnwidth}}
  \begin{tabular}{|l|p{10cm}|}
  % 方法5
  \multirow{nrows}[bigstructs]{width}[fixup]{text}
  nrows 设定所占用的行数。
  bigstructs 此为可选项，主要是在你使用了 bigstruct 宏包时使用。
  width 设定该栏文本的宽度。如果想让 LaTeX 自行决定文本的宽度，则用 * 即可。
  fixup 此为可选项，主要用来调整文本的垂直位置。
  text 所要排版的文本。可用 \\ 来强迫换行。
  % 方法6
  加入宏定义：
  \newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}
  然后使用`\tabincell{c}{ \\ }`，在表格中强制换行
  ```

### 表格并排

```
% 方法1 测试无效
\begin{table}  
\caption{Caption for total table}  
\centering  
\subtable[Caption for table 1]{  
       \begin{tabular}{ccc}  
        1 & 2 & 3  
       \end{tabular}  
       \label{tab:firsttable}  
}  
\qquad  
\subtable[Caption for table 2]{          
       \begin{tabular}{ccc}  
       a & b & c  
       \end{tabular}  
       \label{tab:secondtable}  
}  
\end{table}  
```

```
% 方法2
\usepackage{floatrow}

\begin{table}[htbp]
    \begin{floatrow}
    \subtable[P values]{...}

    \subtable[P values]{...}

    \end{floatrow}  
\label{123}}
\end{table}
```

```
% 方法3 minipage 未测试
\usepackage{ctex}
\usepackage{times}
\usepackage{graphicx,floatrow}
\usepackage[labelfont=bf,labelsep=quad]{caption}
\DeclareCaptionFont{kai}{\kaishu}
\captionsetup{textfont=kai}
\floatsetup[table]{capposition=top}%加上这条命令table环境的caption才会置于表格顶端

\begin{minipage}[c]{0.46\textwidth}
\centering
\subtable[Caption for table 1]{
       \begin{tabular}{ccc}
        1 & 2 & 3
       \end{tabular}
       \label{tab:firsttable}
}
\end{minipage}

%$\rightarrow$

\begin{minipage}[c]{0.46\textwidth}
\centering
\subtable[Caption for table 2]{        
       \begin{tabular}{ccc}
       a & b & c
       \end{tabular}
       \label{tab:secondtable}
}
\end{minipage}
\end{table}
```

```
% 方法4 \ttabbox 统一标题 未测试

\begin{table}[htp]
\ttabbox{\caption{...}}{

\centering
\begin{minipage}{0.45\textwidth}
\begin{tabular}
...
\end{tabular}
\end{minipage}
\hfil
\begin{minipage}{0.45\textwidth}
\begin{tabular}
...
\end{tabular}
\end{minipage}

}
\end{table}
```

```
% 方法5 \ttabbox 子标题 未测试

\begin{table}[htp]
\floatsetup{floatrowsep=qquad,captionskip=5pt}
\tabcolsep=9pt

\begin{floatrow}

\ttabbox{\caption{...}}{
\begin{tabular}
...
\end{tabular}}

\ttabbox{\caption{...}}{
\begin{tabular}
...
\end{tabular}}

\end{floatrow}
\end{table}
```

## 插入项目符号和编号

### 不带序号

关于{itemize}里序号的形式：latex默认生成的简单列表，默认为一个小圆点，而我们在写文章时可能想要一些不一样的列表符号，比如 -， * 之类的. 我们可以这样写

```
\begin{itemize}
\item[-] good morning...
\item[-] good morning....
\end{itemize}
```

### 带序号

关于{enumerate}，这是用于带序号的列表。 默认生成 1，2，3。如果想要其他修饰，如(1) (2)....或step1，step2，需要加载 \usepackage{enumerate}，然后如下使用

```
\begin{enumerate}[step 1]
\item good morning...
\item good morning....
\end{enumerate}
```

<div id="tex-math"></div>

## 公式使用技巧

编辑TEX公式的方法：

- [在线手写公式转Tex公式](https://webdemo.myscript.com/views/math/index.html)
  - [Mathpix](https://www.appinn.com/mathpix/) 是一款跨平台（Windows、macOS、Linux）的 OCR 工具，它能够识别复杂的数学公式，并将其转换为 LaTeX 语法。
- [在线LaTeX公式编辑器](https://www.latexlive.com/home)
  - [在线Latex编辑器](http://latex.codecogs.com/eqneditor/editor.php)
  - [Online Mathematics Editor
    a fast way to write and share mathematics](https://www.mathcha.io/editor)
- MathType转化。MathType可以轻松的将数学公式转换成LaTex代码，但两者进行转换时也会有些[需要注意的问题](http://www.mathtype.cn/wenti/zhuanhuan-latex-daima-wenti.html)。

<div class="note info"><p>当遇到绝对值报错`Missing delimiter (. inserted).`，只需将`\left |`改为`\lvert`；将`\right |`改为`\rvert`。</p></div>

### 常用数学符号

摘自“一份不太简短的 LATEX2e 介绍”
http://mohu.org/info/symbols/symbols.htm

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729125447.png)

```
\begin{tabular}{|lcc|lcc|}
\hline
命令 & 大写 & 小写 & 命令 & 大写 & 小写 \\
\hline
  alpha & $A$ & $\alpha$ &  beta & $B$ &$\beta$  \\
  gamma & $\Gamma$ & $\gamma$  &  delta & $\Delta$ & $\delta$ \\
  epsilon & $E$ & $\epsilon,\varepsilon$ &  zeta & $Z$ & $\zeta$ \\
   eta & $H$ &$\eta$  &  theta & $\Theta$ & $\theta,\vartheta$ \\
  iota & $I$ & $\iota$ &   kappa & $K$ & $\kappa$ \\
  lambda & $\Lambda$ & $\lambda$  & mu & $M$ & $\mu$ \\
  nu & $N$ & $\nu$ & omicron & $O$ & $o$ \\
    xi & $\Xi$ & $\xi$  &   pi & $\Pi$ & $\pi,\varpi$ \\
    rho & $P$ & $\rho,\varrho$  &  sigma & $\Sigma$ & $\sigma,\varsigma$ \\
   tau & $T$ & $\tau$ &   upsilon & $\Upsilon$ & $\upsilon$ \\
  phi & $\Phi$ & $\phi,\varphi$ &  chi & $X$ & $\chi$ \\
  psi & $\Psi$ & $\psi$  &  omega & $\Omega$ &$\omega$ \\
\hline
\end{tabular}
```

```
大于等于号，小于等于号
\geqslant和\leqslant代替\geq和\leq

\lq左引号，\rq右引号；双引号就输入两个
```

### MathType公式转换Tex代码

**方法一、使用剪切和复制预置，在txt文件中显示LaTeX代码**

1. 打开MathType编辑软件，编辑好公式后，点击“预置（P）”菜单，选择“剪切和复制预置（C）”。
2. 弹出剪切和复制预置对话框，点选“MathML或Tex”，并去掉“在转换中包括MathType数据（D）”前面的勾，点击“确定”。
3. 回到MathType，选中公式，按“Ctrl+C”复制，然后粘贴到txt文件中，公式显示为LaTex代码。

> 情况1：文字中插入的公式，和文字内容放在一行
> 上面转换的公式语句的公式环境是`\[\]`，这种环境会使公式独占一行，所以需要将其改为`$ $`环境。通常是把所有的公式都转换完毕后，全文替换修改之，当然也要主意一些问题，例如会把文中的其他部分也替换之，所以应该先注意这些再全文替换。

> 情况2：文中的公式是不用带序列号的
> 考虑到文章排版的美观，最好把`\[    \]`环境换为`\begin{eqnarray*}    \end{eqnarray*}`，个人认为在书写公式时，先写好这样一个`\begin{eqnarray*}    \end{eqnarray*}`公式环境，然后把转换后的公式语句粘贴到此环境里，最后把`\[    \]`删除即可。

> 情况3：文中的而公式是带序列号的
> 我们要把`\[ ,\]`环境换为`\begin{eqnarray}    \end{eqnarray}`或者`\begin{equation}
> \end{equation}`，具体做法和情况2相似，唯一的区别是情况2的环境不会产生序列号，情况3的环境会产生序列号。

```
% 举例
\begin{equation}
\label{labels_name}
...
\end{equation}

% 文中引用
~\ref{label_name}
```

**方法二、使用MathType转换公式（Convert Equations）**

1.在MathType公式编辑器中输入公式，保存后将其选中。
2.设置转换格式。点击 Word文档中的MathType->转换公式（Convert Equations），设置转换格式。点击Convert即可出现相应的Tex代码。

**方法三、使用发布切换（Toggle MathType/TeX）自动转换**

1.使用Mathtype公式编辑器编辑好准备转换的公式，保存后将其选中。
2.切换到Word中的MathType选项卡，单击第六列“发布”中的“切换TeX”按钮（相应的英文是Toggle MathType/TeX），即可自动出现相应的Tex代码。

**方法四**

在Word文档中选中用MathType编辑的公式，按住`Alt+\`键，可以将 MathType 公式快速转换成 Tex 格式。

### 将Tex公式转换为MathType公式

将Tex格式的公式代码复制到 Word 中，前后分别加上`$`符号，按下`Alt+\`键，就将公式切换成MathType 格式。

### 公式中文字

在数学模式中， 空格和分行都将被忽略。所有的空格或是由数学表达式逻辑的衍生，
或是由特殊的命令如 `\,`，`\quad` 或 `\qquad`来得到。。不允许有空行，每个公式中只能有一个段落。

如果你希望在公式中出现普通的文本（使用正体字并可以有空格），那么你必须使用命
令 \textrm{...} 来输入这些文本。

```
\begin{equation}
x^{2} \geq 0\qquad
\textrm{for all }x\in\mathbf{R}
\end{equation}
```

### 公式对齐

[Tex常见公式环境与对齐方式小节](http://blog.csdn.net/yanxiangtianji/article/details/17583723)

### 多个公式，一个编号

问题：如果有两个等式排成一列，如下：
a+b=1
c+d=2   (1)
其右端的编号(1)如何显示在两个等式的中间？

如果用eqnarray环境，只能将编号显示在上面或下面等式的后面，则编号显示在第二个等式的后面。

```
\begin{eqnarray}
a+b &=& 1 \nonumber \\
c+d &=& 2
\end{eqnarray}
```

> 其中两个&号之间的是公式间对齐的位置，用//隔开各行公式。将eqnarray改为eqnarray*输出的公式是没有编号。

可以使用下面的语句，使得编号显示在两个等式的中间：

```
\begin{equation}
\begin{array}{l}
a+b=1 \\
c+d=2
\end{array}
\end{equation}
```

有时上下列等式之间显得拥挤，可在每个等式前加上\displaystyle来避免这种情况，如：

```
\begin{equation}
\begin{array}{l}
\displaystyle a+b=1 \\
\displaystyle c+d=2
\end{array}
\end{equation}
```

> rray环境中用来标示引用的符号不可任意选择！使用split环境不存在这个问题。

此外，利用split环境也可以将编号写在中间，每行只允许出现一个“&”，使用split命令后，编号会 上下居中 显示。如：

```
\begin{equation}
\begin{split}
a+b=1\\
c+d=2
\end{split}
\end{equation}
```

### 公式大小

在公式之前加上[字体大小控制符](#front-size)即可。

```
\small
\begin{equation}
\begin{split}
a+b=1\\
c+d=2
\end{split}
\end{equation}
```

### 公式间距

第一，我们输入代码的问题。即我们输入公式时，自动自己空行了，会导致间距扩大。

```
the  text

\begin{equation}
a+b=c
\end{equation}

% 两者是不一样的

the text
\begin{equation}
a+b=c
\end{equation}
```

第二，的确是系统提供的公式到文本的间距过大。

我以book类为例。公式和文本之间的间距由`\abovedisplayshortskip` 和 `\belowdisplayshortskip` 两个距离来控制的。book类10号字体的定义为：

```
\renewcommand\normalsize{%
   \@setfontsize\normalsize\@xpt\@xiipt
   \abovedisplayskip 10\p@ \@plus2\p@ \@minus5\p@
   \abovedisplayshortskip \z@ \@plus3\p@
   \belowdisplayshortskip 6\p@ \@plus3\p@ \@minus3\p@
   \belowdisplayskip \abovedisplayskip
   \let\@listi\@listI}
\normalsize
```

所以我们可以通过修改这些参数来控制文本和公式的间距，如下：

```
{\setlength\abovedisplayskip{1pt plus 3pt minus 7pt}
\setlength\belowdisplayskip{1pt plus 3pt minus 7pt}
... (Equation(s)) ...
 }
```

也可以使用

```
\begin{equation}
\setlength{\abovedisplayskip}{3pt}
\setlength{\belowdisplayskip}{3pt}
y(t)=a(t)-b(t).
\end{equation}
```

这样修改只能起到局部的作用。

我们可以在导言区重定义normalsize的长度（这个值修改得比较小，为了演示效果，大家可根据自己的需要来调整其大小。），即可修改文本和公式的间距如：

```
\makeatletter
\renewcommand\normalsize{%
   \@setfontsize\normalsize\@xpt\@xiipt
   \abovedisplayskip 1\p@ \@plus2\p@ \@minus5\p@
   \abovedisplayshortskip \z@ \@plus3\p@
   \belowdisplayshortskip 6\p@ \@plus3\p@ \@minus3\p@
   \belowdisplayskip \abovedisplayskip
   \let\@listi\@listI}
\makeatother
```

## pseudo code

> [算法流程图](http://www.voidcn.com/blog/jzwong/article/p-6183679.html)

```
% 直接加框
\usepackage{framed}
...
\begin{framed}
copious text
\end{framed}
```

```
% 首先，需要使用以下宏包
\usepackage{algorithm}
\usepackage{algorithmic}

\begin{algorithm}[H] % 固定位置

\end{algorithm}
```

介绍下algorithmic和algorithmicx，这两个包很像，很多命令都是一样的，只是algorithmic的命令都是大写，algorithmicx的命令都是首字母大写，其他小写(EndFor两个大写)。

```
algorithmic的基本命令

\STATE <text>
\IF{<condition>} \STATE{<text>} \ENDIF
\FOR{<condition>} \STATE{<text>} \ENDFOR
\FOR{<condition> \TO <condition> } \STATE{<text>} \ENDFOR
\FORALL{<condition>} \STATE{<text>} \ENDFOR
\WHILE{<condition>} \STATE{<text>} \ENDWHILE
\REPEAT \STATE{<text>} \UNTIL{<condition>}
\LOOP \STATE{<text>} \ENDLOOP
\REQUIRE <text>
\ENSURE <text>
\RETURN <text>
\PRINT <text>
\COMMENT{<text>}
\AND, \OR, \XOR, \NOT, \TO, \TRUE, \FALSE
```

```
algorithmicx包的基本命令

\State <text>
\If{<condition>} <text> \EndIf
\If{<condition>} <text> \Else <text> \EndIf
\If{<condition>} <text> \ElsIf{<condition>}  <text> \Else <text> \EndIf
\For{<condition>} <text> \EndFor
\ForAll{<condition>} <text> \EndFor
\While{<condition>} <text> \EndWhile
\Repeat <text> \Until{<condition>}
\Loop <text> \EndLoop
\Require <text>
\Ensure <text>
\Function{<name>}{<params>} <body> \EndFunction
\State \Return <text>
\Comment{<text>}
另外，还有3个修改algorithm标签，require标签，ensure标签显示的三个命令：
\floatname{algorithm}{算法}
\renewcommand{\algorithmicrequire}{\textbf{输入:}}
\renewcommand{\algorithmicensure}{\textbf{输出:}}
```

```
%%%宏包\usepackage{algorithmic} 的改法
%%%原宏包只有require和ensure两个\item，要改成三个（加入OUTPUT）的话，
%%%在algorithmic.sty中找到
% ALGORITHMIC
\newcommand{\algorithmicrequire}{\textbf{Require:}}
\newcommand{\algorithmicensure}{\textbf{Ensure:}}
%%%再下面加入一句：\newcommand{\algorithmiclastcon}{\textbf{Lastcon:}}  %%%lastcon是自己定义的
%%%再找到
 \newcommand{\REQUIRE}{\item[\algorithmicrequire]}
 \newcommand{\ENSURE}{\item[\algorithmicensure]}
%%%在后面加入一句
  \newcommand{\lastcon}{\item[\algorithmiclastcon]} %%% lastcon是自己定义的
%%%保存ALGORITHMIC.sty，在正文中就可以加入\LASTCON 了~！
```

```
% 输入、输出、返回值命令
\REQUIRE ~~ \\
\ENSURE ~~ \\
\RETURN
% 如果不喜欢宏包中默认的命令
\renewcommand{\algorithmrequire}{\textbf{Input:}}
\renewcommand{\algorithmensure}{\textbf{Output:}}

算法部分循环使用总结,前面加\STATE
∘ \IF {"condition"}  "text"   \ENDIF
∘ \IF  {"condition"}   "text"   \ELSE   "text"    \ENDIF
∘ \IF  {"condition"}    "text"   \ELSIF   "text"     \ELSIF  "text"    \ELSE  "text"  \ENDIF
∘ \FOR {"condition"}  "text" \ENDFOR
∘ \FORALL {"condition"}  "text"  \ENDFOR
∘ \WHILE {"condition"}  "text"  \ENDWHILE
∘ \REPEAT "text"  \UNTIL {"condition"}
∘ \LOOP "text"  \ENDLOOP
```

例子：

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fesb906r6gj20cy0fz75g.jpg)

```
\usepackage{algorithm}           
\usepackage{algorithmic}        %用到的宏包，要自己改下    
\usepackage{multirow}               
\renewcommand{\algorithmicrequire}{\textbf{Initialization:}}   %改成后面的小标题
\renewcommand{\algorithmicensure}{\textbf{Iteration:}}
\renewcommand{\algorithmiclastcon}{\textbf{Output:}}
%%正文代码
\begin{algorithm}[htb]         %算法的开始
\caption{ ABC }             %算法的标题
\label{alg:SA}                  %给算法一个标签，这样方便在文中对算法的引用
\begin{algorithmic}[1]                %不知[1]是干嘛的？
\REQUIRE ~~\\                          %算法的输入参数：Initialization
    Set $J=0$; $S_0  = \left\{ \phi  \right\}$; $R(S_0 ) = 0$; $\Omega=\{1,2,\ldots,K\}$;
\ENSURE ~~\\                           %算法的迭代：Iteration
    %Ensemble of classifiers on the current batch,  $E_n$;
\WHILE    {$J<M$}
\STATE $J\leftarrow J+1$;
    \FORALL {$k\in \Omega$}
    \STATE  $R_{temp}=0$;  $\Delta R_{J,k} = R(S_{J-1}\cup \{k\})-R(S_{J-1})$;
         \IF  {$\Delta R_{J,k}>0$}
            \IF{$R(S_{J-1}\cup \{k\})\geq R_{temp}$}
            \STATE $R_{temp}\leftarrow R(S_{J-1}\cup \{k\})$; $s_J\leftarrow k$;
            \ENDIF
         \ELSE
            \IF{$1/(1-\Delta R_{J,k}/c_k )<rand(1)$}
            \STATE $\Omega= \Omega-\{k\}$;
            \ENDIF
         \ENDIF
    \ENDFOR
\IF {$R_{temp}>0$}
\STATE $S_J\leftarrow S_{J-1}\cup \{s_J\}$;
\ELSE
\STATE $J\leftarrow J-1$; Break;
\ENDIF
\ENDWHILE              %算法的返回值
\lastcon ~~\\          %OUTPUT
  selected user set $S_J$ and weighted sum rate $R(S_J)$;
\end{algorithmic}
\end{algorithm}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqrawprtpxj30j5062aa5.jpg)

```
\begin{algorithm}  
\caption{A}  
\label{alg:A}  
\begin{algorithmic}  
\STATE {set $r(t)=x(t)$}   
\REPEAT   
\STATE set $h(t)=r(t)$   
\REPEAT  
\STATE set $h(t)=r(t)$   
\UNTIL{B}   
\UNTIL{B}  
\end{algorithmic}  
\end{algorithm}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqrawwlvn8j30jo0dhjs1.jpg)

```
\begin{algorithm}  
\caption{Calculate $y = x^n$}   
\label{alg1}  
\begin{algorithmic}  
\REQUIRE $n \geq 0 \vee x \neq 0$   
\ENSURE $y = x^n$   
\STATE $y \Leftarrow 1$   
\IF{$n < 0$}   
\STATE $X \Leftarrow 1 / x$   
\STATE $N \Leftarrow -n$   
\ELSE   
\STATE $X \Leftarrow x$   
\STATE $N \Leftarrow n$  
\ENDIF   
\WHILE{$N \neq 0$}   
\IF{$N$ is even}   
\STATE $X \Leftarrow X \times X$   
\STATE $N \Leftarrow N / 2$   
\ELSE[$N$ is odd]   
\STATE $y \Leftarrow y \times X$   
\STATE $N \Leftarrow N - 1$   
\ENDIF   
\ENDWHILE  
\end{algorithmic}  
\end{algorithm}  
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqrax4k6ydj30jv0agwg2.jpg)

```
%导言区
\renewcommand{\algorithmicrequire}{ \textbf{Input:}} %Use Input in the format of Algorithm  
\renewcommand{\algorithmicensure}{ \textbf{Output:}} %UseOutput in the format of Algorithm  


\begin{algorithm}[htb]   
\caption{ Framework of ensemble learning for our system.}   
\label{alg:Framwork}   
\begin{algorithmic}[1] %这个1 表示每一行都显示数字  
\REQUIRE ~~\\ %算法的输入参数：Input  
The set of positive samples for current batch, $P_n$;\\  
The set of unlabelled samples for current batch, $U_n$;\\  
Ensemble of classifiers on former batches, $E_{n-1}$;  
\ENSURE ~~\\ %算法的输出：Output  
Ensemble of classifiers on the current batch, $E_n$;  
\STATE Extracting the set of reliable negative and/or positive samples $T_n$ from $U_n$ with help of $P_n$;   
\label{ code:fram:extract }%对此行的标记，方便在文中引用算法的某个步骤  
\STATE Training ensemble of classifiers $E$ on $T_n \cup P_n$, with help of data in former batches;   
\label{code:fram:trainbase}  
\STATE $E_n=E_{n-1}\cup E$;   
\label{code:fram:add}  
\STATE Classifying samples in $U_n-T_n$ by $E_n$;   
\label{code:fram:classify}  
\STATE Deleting some weak classifiers in $E_n$ so as to keep the capacity of $E_n$;   
\label{code:fram:select}  
\RETURN $E_n$; %算法的返回值  
\end{algorithmic}  
\end{algorithm}  
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqraxbnl0sj30kl0dagn6.jpg)

```
\begin{algorithm}[h]  
\caption{An example for format For \& While Loop in Algorithm}  
\begin{algorithmic}[1]  
\FOR{each $i \in [1,9]$}  
\STATE initialize a tree $T_{i}$ with only a leaf (the root);\  
\STATE $T=T \cup T_{i};$\  
\ENDFOR  
\FORALL {$c$ such that $c \in RecentMBatch(E_{n-1})$}   
\label{code:TrainBase:getc}  
\STATE $T=T \cup PosSample(c)$;   
\label{code:TrainBase:pos}  
\ENDFOR  
\FOR{$i=1$; $i<n$; $i++$ }  
\STATE $//$ Your source here;  
\ENDFOR  
\FOR{$i=1$ to $n$}  
\STATE $//$ Your source here;  
\ENDFOR  
\STATE $//$ Reusing recent base classifiers.   
\label{code:recentStart}  
\WHILE {$(|E_n| \leq L_1 )and( D \neq \phi)$}  
\STATE Selecting the most recent classifier $c_i$ from $D$;  
\STATE $D=D-c_i$;  
\STATE $E_n=E_n+c_i$;  
\ENDWHILE   
\label{code:recentEnd}  
\end{algorithmic}  
\end{algorithm}  
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqraz4ir9kj30lx0cwt9a.jpg)

```
\documentclass{article}
\usepackage{amsmath}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}

\makeatletter
\def\BState{\State\hskip-\ALG@thistlm}
\makeatother

\begin{document}
\begin{algorithm}
\caption{My algorithm}\label{euclid}
\begin{algorithmic}[1]
\Procedure{MyProcedure}{}
\State $\textit{stringlen} \gets \text{length of }\textit{string}$
\State $i \gets \textit{patlen}$
\BState \emph{top}:
\If {$i > \textit{stringlen}$} \Return false
\EndIf
\State $j \gets \textit{patlen}$
\BState \emph{loop}:
\If {$\textit{string}(i) = \textit{path}(j)$}
\State $j \gets j-1$.
\State $i \gets i-1$.
\State \textbf{goto} \emph{loop}.
\State \textbf{close};
\EndIf
\State $i \gets i+\max(\textit{delta}_1(\textit{string}(i)),\textit{delta}_2(j))$.
\State \textbf{goto} \emph{top}.
\EndProcedure
\end{algorithmic}
\end{algorithm}
\end{document}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqray9tiruj30dk0lsdhf.jpg)

```
\documentclass[11pt]{article}
\usepackage{CJK}
\usepackage[top=2cm, bottom=2cm, left=2cm, right=2cm]{geometry}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}
\usepackage{amsmath}

\floatname{algorithm}{算法}
\renewcommand{\algorithmicrequire}{\textbf{输入:}}
\renewcommand{\algorithmicensure}{\textbf{输出:}}

\begin{document}
\begin{CJK*}{UTF8}{gkai}
    \begin{algorithm}
        \caption{用归并排序求逆序数}
        \begin{algorithmic}[1] %每行显示行号
            \Require $Array$数组，$n$数组大小
            \Ensure 逆序数
            \Function {MergerSort}{$Array, left, right$}
                \State $result \gets 0$
                \If {$left < right$}
                    \State $middle \gets (left + right) / 2$
                    \State $result \gets result +$ \Call{MergerSort}{$Array, left, middle$}
                    \State $result \gets result +$ \Call{MergerSort}{$Array, middle, right$}
                    \State $result \gets result +$ \Call{Merger}{$Array,left,middle,right$}
                \EndIf
                \State \Return{$result$}
            \EndFunction
            \State
            \Function{Merger}{$Array, left, middle, right$}
                \State $i\gets left$
                \State $j\gets middle$
                \State $k\gets 0$
                \State $result \gets 0$
                \While{$i<middle$ \textbf{and} $j<right$}
                    \If{$Array[i]<Array[j]$}
                        \State $B[k++]\gets Array[i++]$
                    \Else
                        \State $B[k++] \gets Array[j++]$
                        \State $result \gets result + (middle - i)$
                    \EndIf
                \EndWhile
                \While{$i<middle$}
                    \State $B[k++] \gets Array[i++]$
                \EndWhile
                \While{$j<right$}
                    \State $B[k++] \gets Array[j++]$
                \EndWhile
                \For{$i = 0 \to k-1$}
                    \State $Array[left + i] \gets B[i]$
                \EndFor
                \State \Return{$result$}
            \EndFunction
        \end{algorithmic}
    \end{algorithm}
\end{CJK*}
\end{document}
```

<div id="tex-tikz"></div>
## TikZ 宏包

- [PGF/TikZ资源汇总](http://www.hahack.com/tools/pgftikz-resources/)  
- [TikZ and PGF examples](http://www.texample.net/tikz/)
- [LaTeX宏包TikZ-UML使用备忘](https://www.geek-share.com/detail/2755602960.html)
- [线条、树和节点](https://njuwfang.github.io/2018/10/23/Latex-Tikz/)

<div class="note warning"><p>[Springer Nature LaTeX Template 中如需使TikZ 宏包](https://9to5science.com/springer-nature-latex-template-and-tikz-issue)，需要添加在`\documentclass{...}`前面添加`\RequirePackage{tikz}`。</p></div>

### 框架图

- [TikZ diagram, placement of nodes, dotted line](https://tex.stackexchange.com/questions/330286/tikz-diagram-placement-of-nodes-dotted-line)

```
\documentclass[tikz]{standalone}
\begin{document}
    \begin{tikzpicture}[
              inner/.style={draw,
              solid,% <-- added
              fill=blue!5,thick,inner sep=3pt,minimum width=8em},
            outer/.style={draw=gray,dashed,fill=green!1,thick,inner sep=5pt}
                        ]
\node[outer] (A) {
    \begin{tikzpicture}[node distance=1cm,outer sep = 0pt]
      \node [inner,minimum width=18em] (A1) {Mr. A};
      \node [inner,anchor=south west,minimum width=8em] (A2) at ([yshift=1em]A1.north west) {Mr. A1};
      \node [inner,anchor=south east,minimum width=8em] (A3) at ([yshift=1em]A1.north east) {Mr. A2};
      \node (text) [anchor=north] at ([yshift=4em]A1.north) {Hello Tikz};
    \end{tikzpicture}
                };
    \end{tikzpicture}
\end{document}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqusbrfsrnj306n028dfr.jpg)

[how-to-draw-boxes-around-set-of-nodes](https://tex.stackexchange.com/questions/8890/tikz-how-to-draw-boxes-around-set-of-nodes/8896):

```
\documentclass{standalone}
\usepackage{tikz}
\usetikzlibrary{calc}

\begin{document}
  \begin{tikzpicture}[%
    auto,
    block/.style={
      rectangle,
      draw=blue,
      thick,
      fill=blue!20,
      text width=5em,
      align=center,
      rounded corners,
      minimum height=2em
    },
    block1/.style={
      rectangle,
      draw=blue,
      thick,
      fill=blue!20,
      text width=5em,
      align=center,
      rounded corners,
      minimum height=2em
    },
    line/.style={
      draw,thick,
      -latex',
      shorten >=2pt
    },
    cloud/.style={
      draw=red,
      thick,
      ellipse,
      fill=red!20,
      minimum height=1em
    }
  ]
    \draw (2.5,-2) node[block] (C) {Subanta};
    \path (0,-3) node[block] (G) {Pumlinga}
          (0,-4) node[block] (H) {Strilinga}
          (0,-5) node[block] (I) {Napumsaka}
          (5,-3) node[block] (J) {Pumlinga}
          (5,-4) node[block] (K) {Strilinga}
          (5,-5) node[block] (L) {Napumsaka};
    \draw (C.south) -- ++(0,-0.25) coordinate (linga);
    \draw (linga) -- ++(-1,0) coordinate (ling);
    \draw[-latex] (ling) |- (G.east);
    \draw[-latex] (ling) |- (H.east);
    \draw[-latex] (ling) |- (I.east);
    \draw (linga) -- ++(1,0) coordinate (hling);
    \draw[-latex] (hling) |- (J.west);
    \draw[-latex] (hling) |- (K.west);
    \draw[-latex] (hling) |- (L.west);
    \draw[red,thick,dotted] ($(J.north west)+(-0.3,0.6)$)  rectangle ($(L.south east)+(0.3,-0.6)$);
    \draw[thick,dotted]     ($(I.north west)+(-0.5,0.15)$) rectangle ($(L.south east)+(0.5,-0.15)$);
  \end{tikzpicture}
\end{document}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fquscyjiyvj30al05r0sl.jpg)

### 流程图

> [在 Tex 中画流程图（FlowChart）](http://www.latexstudio.net/archives/2095)， [使用 LaTeX 绘制流程图](http://www.itdadao.com/articles/c15a83727p0.html)，[利用 TikZ 宏包在 LaTeX 中绘制流程图](http://yzlnew.github.io/2016/06/22/flowchart/)，[TikZ入门教程](http://fuzihao.org/blog/2015/08/11/TikZ%E5%85%A5%E9%97%A8%E6%95%99%E7%A8%8B/)

先画node，然后从上往下、从左往右等规律画箭头方向。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqraylxdm7j30ha0kt0u0.jpg)

```
导言区

\usepackage{tikz}
\usetikzlibrary{shapes,arrows,chains}
\usepackage{xcolor}
% 设置颜色代号
\colorlet{lcfree}{green}
\colorlet{lcnorm}{blue}
\colorlet{lccong}{red}
% 设置调试标志层
\pgfdeclarelayer{marx}
\pgfsetlayers{main,marx}
% 标记坐标点的宏定义。交换下面两个定义关闭。
\providecommand{\cmark}[2][]{%
  \begin{pgfonlayer}{marx}
    \node [nmark] at (c#2#1) {#2};
  \end{pgfonlayer}{marx}
  }
\providecommand{\cmark}[2][]{\relax}

正文

% 开始绘图
\begin{figure}[H]
    \centering
    \scalebox{.8}{                %设置缩放
\begin{tikzpicture}[
    >=triangle 60,              % 箭头的形状
    start chain=going below,    % 从上往下的流程
    node distance=6mm and 60mm, % 全局间距设置
    every join/.style={norm},   % 连接线的默认设置
    ]
% -------------------------------------------------
% 节点的样式定义
% <on chain> 和 <on grid> 可以减少手动调整节点位置的麻烦
\tikzset{
  base/.style={draw, on chain, on grid, align=center, minimum height=4ex},
  proc/.style={base, rectangle, text width=8em},
  test/.style={base, diamond, aspect=2, text width=5em},
  term/.style={proc, rounded corners},
  % coord 用来表示连接线的转折点
  coord/.style={coordinate, on chain, on grid, node distance=6mm and 25mm},
  % nmark 用来表示调试标志
  nmark/.style={draw, cyan, circle, font={\sffamily\bfseries}},
  % -------------------------------------------------
  % 不同的连接线样式
  norm/.style={->, draw, lcnorm},
  free/.style={->, draw, lcfree},
  cong/.style={->, draw, lccong},
  it/.style={font={\small\itshape}}
}
% -------------------------------------------------
% 先放节点
\node [term, densely dotted,fill=lccong!25, it] (p0) {输入};
% 用 join 表示和上一个节点相连
\node [proc, join]    {使用非线性最小二乘法得到 $X_0$};
\node [proc, join]    {记录 $X=X_0, f=f(X_0)$};
\node [test, join] (t1)    {$T>T_E$?};
\node [proc] (p1)        {$step=0$};
\node [test, join] (t2)    {$step<count$?};
\node [proc] (p2)        {得到新状态$P_N=P+scale\times rand$,计算目标函数差$\Delta f$};
\node [test, join] (t3)    {$F_{Accept}<rand$?};
\node [proc] (p3)        {记录新状态 $X=X_N,f=f(X_N)$};

\node [proc, left=of t1] (p4)    {$T=T\times a,scale=scale\times b$};
\node [term, densely dotted, right=of t1,fill=lcfree!25](p5)    {输出};
\node [proc, right=of t3](p6)    {$step++$};

\node [coord, left=of t2] (c1)  {};
\node [coord, right=of t2] (c2)  {};
\node [coord, right=of p3] (c3)  {};
%先画南北方向的连接线，先画线再画两端的标志和箭头
\path (t1.south) to node [near start, xshift=1em] {$y$} (p1);
  \draw [*->,lcnorm] (t1.south) -- (p1);
\path (t2.south) to node [near start, xshift=1em] {$y$} (p2);
  \draw [*->,lcnorm] (t2.south) -- (p2);
\path (t3.south) to node [near start, xshift=1em] {$y$} (p3);
  \draw [*->,lcnorm] (t3.south) -- (p3);
%接着画东西方向的连接线，方法同上
\path (t1.east) to node [near start, yshift=1em]  {$n$}(p5);
  \draw [o->,lcnorm] (t1.east) -- (p5);
  \draw [->,lcnorm] (p4.east) -- (t1);
\path (t3.east) to node [near start, yshift=1em]  {$n$}(p6);
  \draw [o->,lcnorm] (t3.east) -- (p6);
\path (t2.west) to node [near start, yshift=1em]  {$n$}(c1);
  \draw [o->,lcnorm] (t2.west) -- (c1) -| (p4);
  \draw [->,lcnorm] (p3.east) -- (c3) -| (p6.south);
  \draw [<-,lcnorm] (t2.east) -- (c2) -| (p6.north);

\end{tikzpicture}
}
    \label{fig:algorithm}
\end{figure}
```

案例：`start chain=going below`指明了流程图的默认方向，`node ditance=8mm`则指明了默认的`node`距离。这些可以在定义`node`的时候更改。

```
\documentclass[a4paper,UTF8]{article}  

\usepackage{xcolor}  
\usepackage{tikz}  
\usetikzlibrary{arrows,shapes,chains}  

\begin{document}  
    \centering  
    \begin{figure}  
        \scriptsize  
        \tikzstyle{format}=[rectangle,draw,thin,fill=white]  
        # \tikzstyle{test}=[diamond,aspect=2,draw,thin,text width=2cm]
        \tikzstyle{test}=[diamond,aspect=2,draw,thin]
        \tikzstyle{point}=[coordinate,on grid,]  
        \begin{tikzpicture}[node distance=8mm,  
                auto,>=latex',  
                thin,  
                start chain=going below,  
                every join/.style={norm},]  
            \node[format] (n0){A};  
            \node[format,below of=n0] (n1){B};  
            \node[format,below of=n1] (n2){C};  
            \node[format,below of=n2] (n3){D};  
            \node[point,right of=n3] (p0){};  
            \node[point,left of=n3] (p1){};  
            # \node[point,right of=n3,node distance=10mm] (p0){};
            \node[format,below of=n3] (n4){E};  
            \node[format,below of=n4] (n5){F};  
            \node[format,right of=n5] (n6){G};  
            \node[test,below of=n5] (n7){H};  
            \node[point,right of=n7] (p2){};  
            \node[format,below of=n7] (n8){I};  
            # 直接指定node的位置
            # \node[format] (n0) at(3,0){A};

            \draw[->] (n0.south) -- (n1);  
            # \draw[-] (n0.south) -- (n1);
            # \draw[<->] (n0.south) -- (n1.north);
            # \draw[<-,dashed] (n1.south) -- (n2.north);
            # 文字总是在箭头方向的右边
            # \draw[<-] (n0.south) to node{Yes} (n1.north);  
            # \draw[->] (n1.north) to node{Yes} (n0.south);
            # 曲线
            # \draw[->] (n1.north) to[out=60,in=300] node{Yes} (n0.south);
            # \draw[->,draw=red](n2)--(n1);
            \draw[->] (n1.south) -- (n2);  
            \draw[->] (n2.south) -- (n3);  
            \draw[->] (n3.south) -- (n4);  
            \draw[->] (n4.south) -- (n5);  
            \draw[->] (n5.south) -- (n7);  
            \draw[->] (n7.south) to node {Yes} (n8);  

            \draw[->] (n7.east) to node {No} (p2) |- (n6.south);  
            \draw[->] (n6.north) -- (p0) |- (n3.east);  
        \end{tikzpicture}  
    \end{figure}  
\end{document}  
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqus1h2zkkj304i095q2t.jpg)

弧线连接`\draw [->,red] (A) to [out=180,in=90] (O);`：

```
\begin{tikzpicture}[line width =1.5pt]
%辅助网格
\draw  [dashed,step=1,line width =0.5pt](0,0)grid(2,2);
%标注一个圆点,inner sep表示圆内文字和边界的空白
\node [circle,fill=red,inner sep=2pt,label=above:$(1\text{,}2)$] (A) at
(2,2) {$A$};
%标注一个矩形,inner sep表示矩形内文字和边界的空白
\node [rectangle,fill=blue,inner sep=3pt,label=below:$(0\text{,}0)$] (O) at
(0,0) {$o$};
%连接node的技巧:使用to可以设置不同角度的连接效果
\draw [->,red] (A) to [out=180,in=90] (O);
\draw [->,blue] (A) to [out=-90,in=90] (O);
%使用水平和垂直线连接node
\draw [->,green] (A)|- (O);
\draw [->,yellow] (A)-| (O);
\end{tikzpicture}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20210423094422.png)

案例：

```
% 流程图定义基本形状
\tikzstyle{startstop} = [rectangle, rounded corners, minimum width = 2cm, minimum height=1cm,text centered, draw = black, fill = red!40]
\tikzstyle{io} = [trapezium, trapezium left angle=70, trapezium right angle=110, minimum width=2cm, minimum height=1cm, text centered, draw=black, fill = blue!40]
\tikzstyle{process} = [rectangle, minimum width=3cm, minimum height=1cm, text centered, draw=black, fill = yellow!50]
\tikzstyle{decision} = [diamond, aspect = 3, text centered, draw=black, fill = green!30]
% 箭头形式
\tikzstyle{arrow} = [->,>=stealth]

\begin{figure}[htbp]
\centering
\begin{tikzpicture}[node distance=2cm]
%定义流程图具体形状
\node (start) [startstop] {start};
\node (pro1) [process, below of=start, yshift=-0.2cm, left of=start, xshift=-1cm] {PROCESS 1};
\node (pro2) [process, right of=pro1, xshift= 4cm] {PROCESS 2};
\node (in1) [io, below of=pro1, yshift= -0.2cm, right of=pro1, xshift=1cm] {IO};
\node (pro3) [process, below of=in1, yshift= -0.2cm] {PROCESS 3};
\node (pro4) [process, below of=pro3, yshift= -0.2cm] {PROCESS 4};
\node (in2) [io, below of=pro4, yshift= -0.2cm] {IO 2};
\node (dec1) [decision, below of=in2, yshift= -0.2cm] {DECISION};
\node (stop) [startstop, below of=dec1] {end};

%连接具体形状
\draw [arrow](start) -- (pro1);
\draw [arrow](start) -- (pro2);
\draw [arrow](pro1) -- (in1);
\draw [arrow](pro2) -- (in1);
\draw [arrow](in1) -- (pro3);
\draw [arrow](pro3) -- (pro4);
\draw [arrow](pro4) -- (in2);
\draw [arrow](in2) -- (dec1);
\draw [arrow](dec1) -- ($(dec1.east) + (1.5,0)$) node[anchor=north] {NO} |- (pro3);
\draw [arrow](dec1) -- node[anchor=west] {YES} (stop);
\end{tikzpicture}
\caption{\label{fig: } 示例图}
\end{figure}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqusf97azyj30dm0nwmxm.jpg)

### 故障树

```
\usetikzlibrary{arrows,shapes,chains,shapes.gates.logic.US,trees,positioning}  

\begin{figure}  
    \begin{tikzpicture}[  
        and/.style={and gate US,thick,draw,fill=red!60,rotate=90,  
            anchor=east,xshift=-1mm,scale=0.7},  
            or/.style={or gate US,thick,draw,fill=blue!60,rotate=90,  
                anchor=east,xshift=-1mm,scale=0.7},  
            label distance=1mm,  
            every label/.style={blue},  
            event/.style={rectangle,thick,draw,fill=yellow!20,text width=0.5cm,  
            text centered,font=\sffamily,anchor=north},  
        basicEvent/.style={circle,thick,draw,fill=blue!20,text width=0.5cm,  
            text centered,font=\sffamily,anchor=north},  
            edge from parent/.style={very thick,draw=black!70},  
            edge from parent path={(\tikzparentnode.south) -- ++(0,-0.8cm)  
            -| (\tikzchildnode.north)},  
            level 1/.style={sibling distance=7cm,level distance=0.9cm,  
            growth parent anchor=south,nodes=event},  
            level 2/.style={sibling distance=3cm},  
            level 3/.style={sibling distance=2cm},  
            level 4/.style={sibling distance=1cm}  
            ]  

        \node (g1) [event] {A}  
            child{node (g2) {B}     
                    child {node (g3) {C}  
                        child {node (g4) {D}  
                            child {node (t1)[basicEvent] {e0}}  
                            child {node (b2)[basicEvent] {e1}}  
                }  
                child {node (g5) {G}  
                            child {node (t2)[basicEvent] {e1}}  
                            child {node (b3)[basicEvent] {e2}}  
                }  
            }  
            child {node (b1)[basicEvent] {e3}}  
        };  

        \node [and] at (g1.south) {};  
        \node [or] at (g2.south) {};  
        \node [and] at (g3.south) {};  
        \node [or] at (g4.south) {};  
        \node [or] at (g5.south) {};  

    \end{tikzpicture}  
\end{figure}  
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1fqus97m882j309z0ait8x.jpg)

## beamer

使用XeTeX和beamer包来创建演示文稿，嵌入电影。

```
\usepackage[dvipdfmx]{movie15_dvipdfmx}
```

## 修改批注

<div id="trackchanges"></div>

### TrackChanges

本功能基于 [changes-package](http://mirrors.ctan.org/macros/latex/contrib/changes/changes.english.pdf) 来实现。使用举例[^answer/131498823][^questions/25543]：

[^answer/131498823]: [用 LaTeX 撰写的学术论文怎么方便的供老师评注和修改？](https://www.zhihu.com/question/22316670/answer/131498823)

[^questions/25543]: [changing the default color using the changes package](https://tex.stackexchange.com/questions/25543/changing-the-default-color-using-the-changes-package)

```
\documentclass{article}

%\usepackage[final]{changes}
% 加上[final]选项，编译修订后的文档
% 加上[authormarkup=none]选项，不显示右上角作者代号
\usepackage{changes}

%\definechangesauthor[name={Per cusse}, color=orange]{per}
% 设置不同作者的批注颜色

\begin{document}
This is \added[id=per,remark={we need this}]{new} text.
This is \added[remark={has to be in it}]{new} text.
This is \deleted[id=per,remark=obsolete]{unnecessary}text.
This is \replaced{nice}{bad} text.

% list of changes
\listofchanges

\end{document}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fhxp5si1onj20go06d0tj.jpg)

另外，change tracking commands have issues with citations，要么 putting the citation outside of the `\replaced{bad}{good}` command (like this: `\replaced{This sentence is lame}{This is a better sentence} \added{\citep{somearticle2016}}`) （修改内容过多的话很繁琐），要么按照如下设置：

1. 结合`cite`使用`\mbox`命令： `\deleted{test \mbox{\parencite{foo,bar}}`[^questions/53024]，避免出现无法生成pdf，但存在参考文献引用不换行情况。
2. 然后[使用`\bibliographystyle{elsarticle-num}`等数字类的引文格式](#tex-reference)，避免出现参考文献引用不换行情况。

[^questions/53024]: [Change tracking while using bilatex-apa results in an error](https://tex.stackexchange.com/questions/53024/change-tracking-while-using-bilatex-apa-results-in-an-error)

<font color=red>当稿件进行多轮修改时，建议通过引入`\finalstate`定义修改。</font>

<div class="note warning"><p>但是嵌套使用会造成`1st`的长句无法自动换行，`2nd`修改的时候需要手动接受`1st`的修改，并去掉相关`\added`，`deleted`，`replaced`。</p></div>

1. 宏包设置。
   
   ```
   \usepackage[authormarkup=none]{changes}
   \usepackage{etoolbox,xparse}
   \definechangesauthor[color=blue]{1st}
   \definechangesauthor[color=red]{2nd}
   ```

2. 重定义 `\added`，`deleted`，`replaced`。不同 texlive 版本 `changes.sty`中其定义方式不同。以 texlive 2016 版本中 `\added`的为例，用`\renewcommand`重定义，并加入 IF 语句进行嵌套。
   
   ```
   \newcommand{\added}[2][\@empty]{%
   \setkeys{Changes@added}{#1}%
   \Changes@output%
   {\Changes@Markup@Added{#2}}%
   {#2}%
   {\Changes@added@id}%
   {\Changes@added@remark}%
   {#2}%
   {\changesaddname}%
   {\Changes@added@dec}%
   {\Changes@added@decid}%
   {\Changes@added@decremark}%
   \stepcounter{Changes@AddCount\Changes@added@id}%
   }
   ```

    ```
    \ifallfinal
    #2%
    \else
    \xifinlist{\Changes@added@id}{\finalstateids}{%
      #2%
    }{%
    ...
    }
    
    \ifallfinal\else%
    \xifinlist{\Changes@deleted@id}{\finalstateids}{}{%
      ...
    }%
    
    \ifallfinal
    #2%
    \else
    \xifinlist{\Changes@replaced@id}{\finalstateids}{%
        #2%
    }{%
        ...
    }%
    ```
    
    ```
    \makeatletter
    \renewcommand{\added}[2][\@empty]{%
        \setkeys{Changes@added}{#1}%
        \ifallfinal
        #2%
        \else
        \xifinlist{\Changes@added@id}{\finalstateids}{%
            #2%
        }{%
            \Changes@output%
            {\Changes@Markup@Added{#2}}%
            {#2}%
            {\Changes@added@id}%
            {\Changes@added@remark}%
            {#2}%
            {\changesaddname}%
            {\Changes@added@dec}%
            {\Changes@added@decid}%
            {\Changes@added@decremark}%
            \stepcounter{Changes@AddCount\Changes@added@id}%
        }%
    }%
    \makeatother
    
    \newcommand{\finalstateids}{}
    \newif\ifallfinal
    \NewDocumentCommand{\finalstate}{o}{%
        \IfNoValueTF{#1}
        {\allfinaltrue}% All ids are in final state
        {\renewcommand{\do}[1]{\listgadd\finalstateids{##1}}% Add id to final state list
            \docsvlist{#1}}% Process list
    }
    \newcommand{\clearfinalstateids}{\renewcommand{\finalstateids}{}}
    ```

1. 正文中的使用方式。
   
   ```
   \finalstate[1st] % 只显示作者1st的最终版
   ```

稿件终稿提交时，由于`\finalstate`受到Tex版本影响，请去掉如下宏定义和`\finalstate[1st,2nd]`，同时直接使用`\usepackage[final]{changes}`。

```
\usepackage[final]{changes}
\definechangesauthor[color=blue]{1st}
\definechangesauthor[color=red]{2nd}
```

具体[使用案例](https://tex.stackexchange.com/a/214389)（但是其中的重定义并不通用）：

```
\documentclass{article}

\usepackage{changes,etoolbox,xparse}

\definechangesauthor[name={Reviewer 1. Comment 1}, color=red]{r11}
\definechangesauthor[name={Reviewer 1. Comment 2}, color=red]{r12}
\definechangesauthor[name={Language/Grammar}, color=black!50!green]{lang}

\begin{document}

Bla bla bla \added[id=lang]{blubb} bla bla \replaced[id=r11]{addition}{Bla} bla bla \deleted[id=r12]{Bla}.

\bigskip\verb|\finalstate[lang]|:\finalstate[lang]

Bla bla bla \added[id=lang]{blubb} bla bla \replaced[id=r11]{addition}{Bla} bla bla \deleted[id=r12]{Bla}.

\bigskip\verb|\finalstate[r12]|:\finalstate[r12]

Bla bla bla \added[id=lang]{blubb} bla bla \replaced[id=r11]{addition}{Bla} bla bla \deleted[id=r12]{Bla}.

\bigskip\verb|\clearfinalstateids\finalstate[r11,r12]|:\clearfinalstateids\finalstate[r11,r12]

Bla bla bla \added[id=lang]{blubb} bla bla \replaced[id=r11]{addition}{Bla} bla bla \deleted[id=r12]{Bla}.

\bigskip\verb|\finalstate[lang,r11]|:\finalstate[lang,r11]

Bla bla bla \added[id=lang]{blubb} bla bla \replaced[id=r11]{addition}{Bla} bla bla \deleted[id=r12]{Bla}.

\bigskip\verb|\clearfinalstateids|:\clearfinalstateids

Bla bla bla \added[id=lang]{blubb} bla bla \replaced[id=r11]{addition}{Bla} bla bla \deleted[id=r12]{Bla}.

\bigskip\verb|\finalstate|:\finalstate

Bla bla bla \added[id=lang]{blubb} bla bla \replaced[id=r11]{addition}{Bla} bla bla \deleted[id=r12]{Bla}.

\end{document}
```

![](https://i.stack.imgur.com/d8g3Q.png)

如果使用[texstudio](#texstudio)当作编辑器的话，**可以利用它的宏选项来给这三个命令设置快捷键**（默认Shift+F1, F2 ...）

- replace-1st
  
  ```
  %SCRIPT
  txt = cursor.selectedText()
  editor.write("\\replaced[id=1st]{x}{"+txt+"}")
  cursor.clearSelection()
  ```
- add-1st
  
  ```
  %SCRIPT
  txt = cursor.selectedText()
  editor.write("\\added[id=1st]{"+txt+"}")
  cursor.clearSelection()
  ```
- del-1st
  
  ```
  %SCRIPT
  txt = cursor.selectedText()
  editor.write("\\deleted[id=1st]{"+txt+"}")
  cursor.clearSelection()
  ```
- mbox
  
  ```
  %SCRIPT
  txt = cursor.selectedText()
  editor.write("\\mbox{"+txt+"}")
  cursor.clearSelection()
  ```

### latexdiff

> 未测试成功。

首先不得不说Word中的批注和删改功能做得非常不错，而[latexdiff](https://www.ctan.org/tex-archive/support/latexdiff)插件的出现让LaTex也具有批注和删除功能，并且使用简单「参考说明文档即可」，效果显示也不错。

[Package texlive-latexdiff](https://www.mankier.com/package/texlive-latexdiff)：

Latexdiff is a Perl script for visual mark up and revision of
significant differences between two LaTeX files. Various
options are available for visual markup using standard LaTeX
packages such as color. Changes not directly affecting visible
text, for example in formatting commands, are still marked in
the LaTeX source. A rudimentary revision facilility is provided
by another Perl script, latexrevise, which accepts or rejects
all changes. Manual editing of the difference file can be used
to override this default behaviour and accept or reject
selected changes only.

[latexdiff功能使用教程](http://blog.sina.com.cn/s/blog_3ecd13560102vh95.html)，[如何对LaTeX文档中的所作的修改进行高亮显示](http://www.xuebuyuan.com/2140435.html)：

1. 首先，当然要安装[Ctex](http://www.ctex.org/CTeXDownload/)等其他TEX套件。
2. 其次，确认是否安装了Latexdiff，​运行命令行cmd，输入Latexdiff。
3. 如果没有出现上图所示的提示，就要重新安装Latexdiff咯，安装Perl咯，还要添加环境变量的路径。

## 制作Poster

### 设置posterbox位置

默认的模板为三列，如果想实现横跨行的效果，在每个posterbox的地方需要指明`span=?`。

```
\begin{posterbox}[name=a,column=0,span=2]{Section 1}
\begin{posterbox}[name=b,column=0,below=a]{Section 2}
\begin{posterbox}[name=c,column=1,row=1,below=a]{Section 3}
```

### Poster公式

均使用`align`环境。

```
\begin{align}
X = \left[ {\begin{array}{*{20}{c}}
    {{x_1}}&{{x_2}}& \cdots &{{x_{n - 1 - (m - 1)\tau }}}\\
    {{x_{1 + \tau }}}&{{x_{2 + \tau }}}& \cdots &{{x_{n - 1 - (m - 2)\tau }}}\\
    \cdots & \cdots & \cdots & \cdots \\
    {{x_{1 + (m - 1)\tau }}}&{{x_{2 + (m - 1)\tau }}}& \cdots &{{x_{n - 1}}}
    \end{array}} \right]
\end{align}
```

### Poster图片

均使用`center`环境。

```
\begin{center}
    \includegraphics[width=0.9\linewidth]{svr}
\end{center}
```

### posterbox中分栏

展示了左右摆放两张图片，使用`multicol`命令。

```
\usepackage{multicol}

\begin{multicols}{2}%多栏，2为栏数

   \begin{center}
   \includegraphics[scale =.08]{fig-1} %在scale这里设置图片的缩放，原图的0.08倍
   \captionof{figure}{图片的名称}%图片的名称在这里输入
   \label{fig:figlabel}%这里就是默认的fig排序    
   \end{center}

\columnbreak %第一栏结束

   \begin{center}
   \includegraphics[scale =.08]{fig-2} %在scale这里设置图片的缩放，原图的0.08倍
   \captionof{figure}{图片的名称}%图片的名称在这里输入
   \label{fig:figlabel}%这里就是默认的fig排序    
\end{center}

\end{multicols}
```

如果不想5-5分栏，实现左边一个大图，右边上下排列两个小图，可以使用`minipage`命令。

```
\usepackage{minipage}

\begin{minipage}{0.6\linewidth}
\begin{itemize}
    。。。。。
  \end{itemize}    
%minipage中包含5-5分的minipage，实现左边一个大图，右边上下排列两个小图    
  \begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale =.17]{4-1}
    \captionof{figure}{图片名称}%图片的名称在这里输入
    \label{fig:figlabel}%这里就是默认的fig排序
  \end{center}
  \end{minipage}
  \begin{minipage}{0.5\linewidth}
  \begin{center}
    \includegraphics[scale =.14]{4-2}
    \captionof{figure}{图片名称}%图片的名称在这里输入
    \label{fig:figlabel} %这里就是默认的fig排序            
        \\%用换行符实现两张图片上下排列
    \includegraphics[scale =.14]{4-3} %在scale这里设置图片的缩放，原图的0.3倍
    \captionof{figure}{图片名称}%图片的名称在这里输入
    \label{fig:figlabel}%这里就是默认的fig排序    
  \end{center}    
  \end{minipage}
  \end{minipage}

   \begin{minipage}{0.35\linewidth}% 另一个小的minipage
    \begin{minipage}{1\linewidth}%想要实现上下排列一些item和一个表，设置了一个{1\linewidth}的minipage的嵌套
   \begin{itemize}
    .....
   \end{itemize}
   \\        %用换行实现上下排列
  \begin{center}
   \tiny   %设置表的大小为tiny
    \begin{tabular}{l l l}% 设置表中的字左对齐，三列；若居中用 ccc
     \toprule%画一根线
      。。。\\
      \midrule%画一根线
      aaa   \\
     &bbb\\
     \midrule%画一根线
     ccc &  \\
     & ddd &  \\
    & eee &  \\
    & ff &  \\
    & gg &  \\
    \midrule%画一根线
    hhh \\
    &  & iii\\
    &  & jjj\\
    \bottomrule%画一根线
     \end{tabular}
     \captionof{table}{表名称}
     \label{tab:tablabel}
\end{center}
\end{minipage}
\end{minipage}
```

有什么好的办法实现分栏后对称及左右占相等的高度？但实际使用中失效，待测试。

1. 手动调整：`\vspace*{5cm}`
2. 使用 multicol 宏包的 multicols 环境代替 twocolumn 模式：`\usepackage{multicol}`
3. 使用 flushend 宏包：`\usepackage{flushend}`
4. 使用 balance 宏包：`\usepackage{balance}`

### Poster参考文献

由于Poster位置有限，需要将 reference 和reference 上下的空格去掉，这里用的模板是`unsrt`。

```
文章中用\cite{a2007}

结尾用
\renewcommand{\refname}{\vskip-1cm}% 去掉reference的上下空格以及不显示reference
\tiny
\bibliographystyle{unsrt}
\nocite{*}
\bibliography{mybib}
```

或者，在begin document之前插入

```
\usepackage{etoolbox}
\patchcmd\thebibliography
{\labelsep}
{\labelsep\itemsep=-4pt\relax}% 参考文献之间的默认距离是4pt，-4pt之后就能够去掉参考文献之间的空格了
{}
{\typeout{Couldn't patch the command}}

%%
% Document Start
%%
\begin{document}
```

<div id="tex-reference"></div>

## 参考文献

> [作者姓名的引用方式](http://blog.sciencenet.cn/home.php?mod=space&uid=681387&do=blog&id=1086471)
> [参考文献在线生成器](http://www.citethisforme.com/zh)

<div class="note info"><p>[参考文献的缩写](https://sli1989.github.io/reference-manage/#abbrev)</p></div>

目前国际上最常用的参考文献格式是AMA，APA，EmbellishedVancouver，Harvard，Numbered，和Vancouver等等。在准备原稿阶段就按要求统一格式，这样既可以在排版期间省去很多波折，也可以减少排版错误，省去自己检查校样的时间，一举两得。下面把最常见的几种参考文献的格式简单地抄录如下，如果想知道全面的文献格式，请读者浏览各大出版社的作者须知网页，那里的介绍应该更全面细致。

- AMA style:
  1. Paivio A, Jansen B, Becker LJ. Comparisons through the mind’seye. Cognition. 1975;37(2):635–647.
  2. Glaser R, Bond L, eds. Testing: concepts and research. AmPsychol. 1981;36 [special issue].
  3. Strunk Jr W, White EB. The Elements of Style. 3rd ed.New York: MacMillan; 1979 [chapter 4].
- APA style:  
    Paivio, A., Jansen, B., & Becker, L. J. (1975).Comparisons through the mind’s eye. Cognition, 37(2), 635–647.  
    Yuen, A. W. C. (1994). Lamotrigine: a review ofantiepileptic efficacy. Epilepsia, 35(Suppl. 5), S33–S36.  
    Strunk, W., Jr., & White, E. B. (1979). Theelements of style (3rd ed.). New York: MacMillan.  
- Embellished Vancouver style：
  1. Paivio A, Jansen B, BeckerLJ. Comparisons through the mind’s eye. Cognition 1975;37(2):635–47.
  2. Yuen AWC. Lamotrigine: a review of antiepilepticefficacy. Epilepsia 1994;35(Suppl. 5):S33–6.
  3. Wilson JG, Fraser FC, editors. Handbook ofteratology, vols. 1–4. New York: Plenum Press; 1977–78.
- Harvard (Name-date) style:  
    Paivio, A., Jansen, B., Becker, L.J., 1975. Comparisonsthrough the mind’s eye. Cognition 37 (2), 635–647.  
    Yuen, A.W.C., 1994. Lamotrigine: a review ofantiepileptic efficacy. Epilepsia 35 (Suppl. 5), S33–S36.  
    Strunk Jr., W., White, E.B., 1979. The Elements ofStyle, third ed. MacMillan, New York (Chapter 4).  
- Numbered style:   
    [1] A. Paivio, B. Jansen, L.J. Becker, Comparisonsthrough the mind’s eye, Cognition 37 (2) (1975) 635–647.  
    [2] A.W.C. Yuen, Lamotrigine: areview of antiepileptic efficacy, Epilepsia 35 (Suppl. 5) (1994) S33–S36.  
    [3] J.G. Wilson, F.C. Fraser (Eds.), Handbook ofTeratology, vols. 1–4, Plenum Press, New York, 1977–1978.  
- Vancouver style:   
    [1] Paivio A, Jansen B, Becker LJ. Comparisons throughthe mind’s eye. Cognition 1975;37(2):635–47.  
    [2] Yuen AWC. Lamotrigine: a review of antiepilepticefficacy. Epilepsia 1994;35(Suppl.5):S33–6.  
    [3] Letheridge S, Cannon CR, editors. Bilingualeducation: teaching English as a second language. New York: Praeger; 1980.

参考文献编译原理分为下面四步：

1. 用LaTeX编译你的 `.tex` 文件 , 这是生成一个 `.aux` 的文件, 这告诉 BibTeX 将使用那些应用；
2. 用BibTeX 编译 `.bib` 文件；
3. 再次用LaTeX 编译你的 `.tex` 文件，这个时候在文档中已经包含了参考文献，但此时引用的编号可能不正确；
4. 最后用 LaTeX 编译你的 `.tex` 文件，如果一切顺利的话, 这是所有东西都已正常了。

### 建立文献库

参考文献库的建立<font color=red>推荐使用[bibfile格式](#bibfile)</font>。

<div id="bibfile"></div>

#### bibfile格式

<div class="note info"><p>If there are no special macros that handle the doi numbers, then you can try `\_` instead of `_` in the `.bib` file.</p></div>

1. 建立`.bib`文件
   
   ```
   @article{Thomas_2016,
       doi = {10.1080/19475705.2016.1176604},
       url = {https://doi.org/10.1080%2F19475705.2016.1176604},
       year = 2016,
       month = {apr},
       publisher = {Informa {UK} Limited},
       volume = {8},
       number = {2},
       pages = {177--193},
       author = {Sonia Thomas and G.N. Pillai and Kirat Pal},
       title = {Prediction of peak ground acceleration using ϵ-{SVR}, $\upnu$-{SVR} and Ls-{SVR} algorithm},
       journal = {Geomatics, Natural Hazards and Risk}
   }
   ```
   - 如果你使用的是Noteexpress文献管理软件，选择需要导出的题录，在菜单栏依次选择`文件`-`导出题录`-`BIBTEX格式`-`导出到bib文件`。<font color=red>需要手动将`BIBTEXKEY`移动到`{`后面</font>，如上所示：`@article{Thomas_2016,`，`BIBTEXKEY`=`Thomas_2016`。
   - 你也可以单独[获取引文BIBTEX](https://sli1989.github.io/reference-manage/#bibtex)，在记事本中粘贴，然后另存为`.bib`文件
   - 为了使参考文献标题中某些部分保持不变，可以在bib文件中标题部分添加括号 `{...}`即可。
   - bib文件中将某个参考文献全部去掉，可以去掉前面的`@`。如果将某个参考文献中的某一个项目去掉，可以在这一行前加 `//`。
2. 更新`.bib`文件
   - 安装[JabRef软件](https://sli1989.github.io/reference-manage/#JabRef)，打开`.bib`文件。
   - 双击题录，选择左下角 `update bibliographic information from the web`，选择`CROSSREF`（获取DOI信息），在弹窗中<font color=red>确认题目一致</font>，勾选需要保留左右侧内容，选择 `replace original entry` 即可自动更新题目。<font color=red>无法自动更新的题录需要[手动获取DOI](https://sli1989.github.io/reference-manage/#doi)</font>。

<div id="ccdc"></div>

将CCDC的latex模板的参考文献部分修改为bibfile格式引用，参考[cccconf.cls](https://github.com/lyyyuna/mypaper/blob/master/LPV_Multi/cccconf.cls)：

```
% 编辑ccdconf.cls文件

% 删除以下命令行
% \renewcommand\newblock{\par}
% 添加以下命令行，修改行间距和字体大小
\AtBeginDocument{
    \ifcsname bibsep\endcsname\setlength{\bibsep}{\z@}\fi
    \ifcsname bibfont\endcsname\ifChinese\def\bibfont{\zihao{-5}}\else\def\bibfont{\small}\fi\fi
}
```

### 正文引用

参考文献的引用通常有两种样式：作者-年份和数字。TeX 已自带有 8 种数字样式，分别如下：

1. `plain`，按字母的顺序排列，比较次序为作者、年度和标题  
2. `unsrt`，基本上跟 `plain` 类型一样，除了参考文献的条目的编号是按照引用的顺序，而不是按照作者的字母顺序.    
3. `alpha`，用作者名首字母+年份后两位作标号，以字母顺序排序  
4. `abbrv`，类似`plain`，将月份全拼改为缩写，更显紧凑：  
5. `ieeetr`，国际电气电子工程师协会期刊样式：  
6. `acm`，美国计算机学会期刊样式：  
7. `siam`，美国工业和应用数学学会期刊样式：
8. `apalike`，美国心理学学会期刊样式：

LATEX 本身只支持数字样式，而 natbib 宏包则同时支持这两种样式。

> natbib 提供了三种列表样式：plainnat、abbrvnat、unsrtnat。前两种都是作者-年份样式，文献列表按作者-年份排序，后者会使用一些缩写（比如作者的 first name）；unsrtnat 是数字样式，文献列表按引用顺序排序。
> `\setcitestyle` 命令可以用来改变引用样式的设置，
> 引用模式 authoryear、numbers、super
> 括号 round、square、open=char,close=char
> 引用条目分隔符 分号、逗号、citesep=char
> 作者年份分隔符 aysep=char
> 共同作者年份分隔符 yysep=char

所以，完整的使用模板如下：

```
\usepackage{natbib}
% 使连续引用的参考文献能够中间用破折号连起来
% \usepackage[numbers,sort&compress]{natbib}
% 在elsevier模板中，natbib包已经默认引用了，无需重新引用，改一下natbib的选项即可

% 正文引用
% (author, year)
\citep{Bibtexkey}
% author (year)
\cite{Bibtexkey}
\citet{Bibtexkey}
% 连续引用
\cite{bibtexkey1，bibtexkey2，bibtexkey3}

在图表的标题中引用文献
\caption{这是~\protect\citeA{konishi:1999ab}中的一幅插图}


\section*{References}

%\bibliographystyle{plain}

%% Numbered
%\bibliographystyle{model1-num-names}

%% Numbered without titles
%\bibliographystyle{model1a-num-names}

%% Harvard
%\bibliographystyle{model2-names.bst}\biboptions{authoryear}

%% Vancouver numbered
%\usepackage{numcompress}
%\bibliographystyle{model3-num-names}

%% Vancouver name/year
%\usepackage{numcompress}
%\bibliographystyle{model4-names}\biboptions{authoryear}

%% APA style
\bibliographystyle{model5-names}\biboptions{authoryear}

%% AMA style
%\usepackage{numcompress}\bibliographystyle{model6-num-names}

%% `Elsevier LaTeX' style
%\bibliographystyle{elsarticle-num}
%\biboptions{numbers,sort&compress}

%% natbib style
%\bibliographystyle{plainnat}
%\setcitestyle{square,aysep={},yysep={;}}

\bibliography{mybibfile}
```

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fhxp7qnqdmj20go053dhq.jpg)

- 参考文献引用标号在右上角[^zhangzundong2]
  
  ```
  \usepackage{cite}
  
  \newcommand{\upcite}[1]{\textsuperscript{\textsuperscript{\cite{#1}}}}
  % 引用的时候使用
  \upcite{}
  ```

[^zhangzundong2]: [cite宏包的使用](https://sites.google.com/site/zhangzundong2/cite%E5%AE%8F%E5%8C%85%E7%9A%84%E7%94%A8%E6%B3%95)

### 中文参考文献

```
% 如果文档类是article之类的,
\renewcommand\refname{参考文献}
% 如果文档类是book之类的,
\renewcommand\bibname{参考文献}
```

### 网址的引用

```
\usepackage{url}
% 先在bib文件里编辑url引用，再\cite，
% 网址放在@misc的howpublished域，或者@techreport，@article，@book的note域

% 对于带下划线_的url引用，在下划线_之前加上转义符号\
@misc{bworld,
  author = {Ingo Lutkebohle},
  title = {{BWorld Robot Control Software}},
  howpublished = "\url{http://aiweb.techfak.uni-bielefeld.de/content/bworld-robot-control-software/}",
  year = {2008},
  note = "[Online; accessed 19-July-2008]"
}

% 或者
@misc{bworld,
  author = {Ingo Lütkebohle},
  title = {{BWorld Robot Control Software}},
  howpublished = {http://aiweb.techfak.uni-bielefeld.de/content/bworld-robot-control-software/},
  year = {2008},
  note = "[Online; accessed 19-July-2008]"
}
```

## 博士论文模板

### 修改表格字体大小

```
\documentclass{article}
\usepackage{xeCJK}
\usepackage{xltxtra}
\usepackage{tabu}
\usepackage{lipsum}

\begin{document}
请用 \XeLaTeX{} 编译。

\lipsum[1]

\begin{table}[ht]
  \centering
  \caption{标题}
  \label{tab:Title}
  \scriptsize
  \begin{tabu}to \textwidth{*4{X[l]}}
  \tabucline[1pt]{-}
    这是测试文字 & 这是测试文字 & 这是测试文字 & 这是测试文字\\
  \hline
    这是测试文字 & 这是测试文字 & 这是测试文字 & 这是测试文字\\
    这是测试文字 & 这是测试文字 & 这是测试文字 & 这是测试文字\\
    这是测试文字 & 这是测试文字 & 这是测试文字 & 这是测试文字\\
  \tabucline[1pt]{-}
  \end{tabu}
\end{table}

\lipsum[2]
\end{document}
```
]]></content>
      <categories>
        <category>Software</category>
        <category>Tex</category>
      </categories>
      <tags>
        <tag>Tex</tag>
      </tags>
  </entry>
  <entry>
    <title>华中科技大学学位论文格式要求</title>
    <url>/thesis-format/</url>
    <content><![CDATA[
本文介绍华中科技大学学位论文的格式要求，以及各种模板修改。在[Michael Duan](http://www.52souji.net/about.html) 的个人博客基础上进行更新。

<!--more-->

<div class="note info"><p>华科博士论文的word模板和latex模板的下载：[word模板](https://pan.baidu.com/s/1hVBs_RVHaHjQLvfKriaV0w) （密码：4qa8），[latex模板](http://pan.baidu.com/s/1pJwqPNP)（密码：bx49）。</p></div>

# 基本要求

1. 硕士学位论文应能表明作者确已在本门学科上掌握了坚实的基础理论和系统的专门知识，并对所研究课题有新的见解，有从事科学研究工作或独立担负专门技术工作的能力。
1. 博士学位论文应能表明作者确已在本门学科上掌握了坚实宽广的基础理论和系统深入的专门知识，并具有独立从事科学研究工作的能力，在科学或专门技术上做出了创造性的成果。
1. 学位论文一般应用中文撰写，硕士学位论文正文应不少于2万字，博士学位论文正文要求5－8万字。学位论文内容应立论正确、推理严谨、文字简练、层次分明、说理透彻、数据真实可靠。
1. 论文作者应在选题前后阅读有关文献，硕士学位申请人的文献阅读量不少于40篇，其中外文文献至少应占三分之一；博士学位申请人的文献阅读量不少于60篇，其中外文文献至少应占三分之二。综述部分应对所读文献加以分析和综合。
1. 量和单位及其符号均应符合国家标准的规定，国家标准中未规定的，应执行国际标准或行业标准；不同的量必须用不同的符号表示，不得一符多义，含义相同的量则必须用同一符号表示。学位论文应用最新颁布的汉语简化文字，符合《出版物汉字使用管理规定》；专业术语应统一使用全国自然科学名词审定委员会公布的各学科名词，或本学科权威专著和期刊通用的专业术语，且前后应一致；标点符号的使用应符合国家标准《标点符号用法》的规定；数字的使用应符合国家标准《出版物上数字用法的规定》。
1. 图要精选，切忌与文字或表内容重复，图中文字、数据和符号应准确无误且与文字叙述一致，图应有图号和图名，图名应简洁明确且与图中内容相符。表应有表序和表名，表名应简洁并与内容相符。图、表和公式应分别顺序编号。

# 题名

题名是以最恰当、最简明的词语反映论文中最重要的特定内容的逻辑组合。题名既要准确地描述内容，又要尽可能地精练，一般不宜超过20个字。题名应该避免使用不常见的缩略词、字符、代号和公式等。外文题名一般不宜超过10个实词。

# 序或前言（必要时）

序或前言一般是作者对学位论文基本特征的简介，如说明选题的缘起、背景、主旨、目的、意义，以及资助、支持、协作经过等；也可以评述和对相关问题的研究进行说明。序或前言并非必需。这些内容也可以在正文引言中和致谢中陈述。

# 摘要和关键词

摘要是学位论文极为重要、不可缺少的组成部分，它是论文的窗口，并频繁用于国内外资料交流、情报检索、二次文献编辑等。其性质和要求如下：

1. 摘要即摘录论文要点，是论文要点不加注释和评论的一篇完整的陈述性短文，具有很强的自含性和独立性，能独立使用和被引用。
1. 应含有学位论文全文的主要信息，硕士学位论文摘要应突出新见解与成果，博士学位论文摘要应突出创造性成果。
1. 内容范围应包含以下基本要素：
    - 目的：研究、研制、调查等的前提、目的和任务以及所涉及的主题范围。
    - 方法：所用原理、理论、条件、对象、材料、工艺、手段、装备、程序等。
    - 结果：实验的、研究的、调查的、观察的结果、数据，被确定的关系，得到的效果、性能等。
    - 结论：结果的分析、研究、比较、评价、应用；提出的问题，今后的课题，建议，预测等。
    - 其他：不属于研究、研制、调查的主要目的，但就其见识和情报价值而言也是重要的信息。
1. 摘要的详简度视论文的内容、性质而定，硕士学位论文摘要一般为500－600汉字，博士学位论文摘要一般为800－1000汉字。
1. 摘要中一般不用图、表、化学结构式、计算机程序，不用非公知公用的符号、术语和非法定的计量单位。
1. 关键词应有3至8个，另起一行置于摘要下方。涉及的内容、领域从大到小排列，便于文献编目与查询。
1. 应有与中文摘要和关键词相对应的英文摘要和关键词。英语摘要用词应准确，使用本学科通用的词汇；摘要中主语（作用）常常省略，因而一般使用被动语态；应使用正确的时态，并要注意主、谓语的一致，必要的冠词不能省略。

# 引言或绪论

引言或绪论应简要说明研究工作的目的、范围、相关领域的前人工作和知识空白、理论基础和分析、研究设想、研究方法和实验设计、预期结果和意义等。

# 正文

正文是核心部分，占主要篇幅，可以包括：研究对象、理论模型、实验和观测方法、仪器设备、材料原料、实验和观测结果、计算方法和编程原理、数据资料、经过加工整理的图表、形成的论点和导出的结论等。各章节标题应大致对称，内容之间有严密的逻辑论证关系，各部分篇幅长短不宜悬殊太大，章节标题也不宜太长。

由于研究工作涉及的学科、选题、研究方法、工作进程、结果表达方式等有很大的差异，对正文内容不作统一的规定。但是，必须实事求是，客观真切，准确完备，合乎逻辑，层次分明，简练可读。

# 结论

经过对实验记录和实验结果等的综合分析研究，归纳出若干有机联系的论点，并对本研究成果的意义、推广应用的现实性或可能性和进一步发展的探讨加以论述。结论应该准确、完整、明确、精练。

如果不可能导出应有的结论，也可以没有结论而进行必要的讨论。

# 致谢

对在完成课题研究和论文写作过程中给予指导和帮助的导师、校内外专家、实验技术人员、同学等表示感谢。

# 参考文献

在论文中引用了文献内容的，应将其列入参考文献表。

1. 参考文献标注法，在正文中引用文献内容处注明参考文献编号。参考文献目录按正文中引用先后顺序排列，重复引用的文献，按第一次出现的顺序编号。  
2. 文科论文参考文献标注法，可按国际惯例，英文文献用作者姓氏和发表年份加上圆括号来标注，例如(Farrell，1997)；中文文献用作者姓名和发表年份加上圆括号来标注，例如(张华，2000)。当文献作者有两个时，标注方式如(Sommerset and Lovekin，2000)或（张华，李平，2000）。当文献作者多于两个时，标注方式如(Sommerset et al，2000)或(李平等，2000)。如果同一作者有一个以上同一年份的文献被引用，那么在文献标注和参考文献目录中要增加一个标识符，如(1985a)，(1985b)。如果论文中已经提到了作者姓名，则只需在作者姓名后面用发表年份加圆括号标注，例如“F．Modigliani(1960)指出……”。参考文献目录按姓氏或姓氏汉语拼音的字母顺序排列，汉字姓名以姓氏汉语拼音字母为序，英语姓名以姓氏字母为序。  
3. 可列于参考文献表的文献类型包括图书、期刊、会议论文集、专利和学位论文等。其著录格式分别如下（注意标点符号）：
    - 图书： [顺序编号] 作者（采用姓在前，名在后的形式，作者名之间用逗号分隔；3人以内全部写上，3人以上只写3人再加“等”（英文加“ et al”））.书名.版本（第×版）.译者.出版地：出版者，出版年. 起页～止页
    - 期刊：[顺序编号] 作者（采用姓在前，名在后的形式，作者名之间用逗号分隔；3人以内全部写上，3人以上只写3人再加“等”（英文加“ et al”））.文章名称.期刊名称，年号，卷号（期号）：起页～止页
    - 会议论文集：[顺序编号] 作者（采用姓在前，名在后的形式，作者名之间用逗号分隔；3人以内全部写上，3人以上只写3人再加“等”（英文加“ et al”））.文章名称.见（英文用“in”）:论文集主编.论文集名.出版地：出版者，出版年. 起页～止页
    - 专利：[顺序编号] 专利申请者.专利题名.专利国别，专利文献种类，专利号，出版年. 起页～止页
    - 学位论文：[顺序编号] 作者.题名：[博士（或硕士）学位论文]。保存地点：保存单位（如华中科技大学图书馆），年份.
1. 当论文中有些术语、公式、背景或数据来源需要解释或说明，以及援引他人的原话、数据等资料而必须指明资料来源时，可用脚注。脚注要按顺序编号。脚注按每一页单独编号。脚注的标识可以用数字1，2等，也可以用符号①，②等。脚注的资料来源表示方法同参考文献。

# 附录（必要时）

包括详细的公式推导、实验数据、计算程序、援引他人的原始资料、数据及其设备条件等。

学位申请人攻读学位期间发表的学术论文目录置于附录1，格式同第九条要求，并逐篇注明署名单位是否为华中科技大学。

# 编排格式要求

1. 学位论文封面内容与格式由研究生院统一规定。封面上“分类号”和“密级”一般不填，保密的论文按照校保密办认定的密级填写；学校代码为10487；“指导教师”栏可填正、副导师。
1. 论文外形尺寸以A4本为准。装订顺序为：封面、英文扉页、独创性声明和学位论文版权使用授权书、序或前言（必要时）、中文摘要和关键词、英文摘要和关键词、目次页、引言、正文、结论、致谢、参考文献、附录（必要时）、封三、封四。
1. 学位论文文字排版的字号、行距、字距的大小，以版面清晰、容易辨识和阅读为原则，一般可参照下面要求进行排版：章和节的题名用黑体，字号分别用3号和4号；文章段落内容用小四号宋体字，行间距不小于三分之二字高度；正文中标题一律左顶格。


# Latex模板的修改说明

我从google code里下载的模板，在使用WinEdt里的Latex编译时，会提醒缺少文件hypernat.sty。我后来从网上找到了这个文件，把它添加到了latex模板的压缩包里。

另外，如果您要是使用latex撰写博士论文，强烈推荐您先看看李安安博士写的一篇文章《LaTeX撰写博士学位论文》，会给你省去很多麻烦。我转载到了本博，点击以下链接访问。

## 对cls文件的修改

```
（1）搜索`\@hangfrom{#1~~}#2`，将此句用`%`符号注释，防止出现模板默认的图注悬挂缩进。进行这个设置，是为中英文双语的图注做准备。如果不希望加入英文图注，可以不进行此修改。

（2）搜索`设置标题前后间距`，将接下来的两句都注释掉，即不再设置前后间距。将统一的间距设置取消，同样是为中英文双语图注做准备。否则可不做修改。

（3）搜索`\renewcommand\normalsize{\fontsize{12pt}{18pt}\selectfont}`，将`18pt`改成`21pt`，即增加行间距。我赶紧这样更美观~可不是为了增加页数啊。

（4）搜索`\setlength{\parskip}{0pt plus2pt minus1pt}`，将其改为`\setlength{\parskip}{0.5\baselineskip}`，目的是增加段落间的距离，差不多等同于word中段前空0.5行的设置。

（5）搜索`\parbox[t][5.7cm][t]{\textwidth}`，将其中的`5.7cm`改为`4.5cm`。否则英文封面将会被排成2页。

```

## 对cpx文件的修改

（1）搜索`\newcommand{\abstractname}{摘\hspace{1em}要`，在`要`字后加`\footnote{本课题得***}`，即在摘要标题中加入资助信息。本来想把这个加在acknowledgement里面，但老板非要我加在摘要中，只有出此下策。

（2）搜索`\newcommand{\HUST@denotation@name}{符号对照表}`，将`符号对照表`换成`英文缩写名称一览表`——这又是老板的主意。

（3）搜索`\newcommand{\HUST@publication@title}{攻读学位期间发表的学术论文}`，将`攻读学位期间发表的学术论文`替换成`攻读学位期间的主要成果和奖励`——号称所获奖励、专利和软件著作权都是可以写上去的。

## 对cover.tex文件的修改

（1）搜索`\eassosupervisor`，在该命令之后插入 `\edate{December, 2010}`。如果不加入这个命令，自动生成的命令将是编译成PDF的时间，而不是答辩时间。

## 对main.tex的修改

（1）增加`\usepackage{makecell}`。目的是在表格的单元格中建立cell，方便换行。

（2）增加`\usepackage{afterpage}`。目的是立即处理浮动对象。如果图片太多，有必要使用这个命令，防止图片与引用它的正文距离太远。

（3）增加`\usepackage{multirow}`。目的是进行复杂的表格排版，具体可以在google上检索该宏包的说明。

（4）增加`\usepackage{CJKfntef}`。目的是可以给汉子加下划线。

（5）增加`\usepackage[perpage,symbol_]{footmisc}`。目的是将脚注的正文引用处变成`_`号。这里是出于无奈，因为仅仅摘要的脚注使用*号，在`chap01.tex`的一开始，需要插入`\renewcommand{\thefootnote}{\arabic{footnote}}`，将脚注符号再次换成阿拉伯数字。

（6）`\includeonly{ }`命令的使用。由于整个博士论文很大，为了加快速度，往往只编译当前章，比如`\includeonly{data/chap02}`。

（7）搜索`\frontmatter`，在其后面插入`\pagenumbering{Roman}`，确保正文之前，使用大写罗马数字作为页码。

（8）`\newpage`命令的使用。每一章（包括中英文摘要、目录、致谢、参考文献等）的第一页的页码都应该是奇数。所以在全文撰写后，需要用这个命令增加空白页。

## 图形的插入

图形的插入本来很简单，但由于老板要求加入中英文图注，所以就麻烦了。上网找了不少解决方案都不行，所以就自己摸索了。这个方法需要预先在cls文件中进行两处修改，去除默认的格式设计。

（1）插入简单的图（只有一行图注）

```
\begin{figure}[!htbp]
\centering
\includegraphics[width=10cm]{Fig_ch01_neuron.eps}
\caption{神经元的典型结构（引自维基百科）}
{\dawu Fig.\thefigure~~The typical structure of neurons (from Wikipedia)}
\label{fig:ch1:neuron}
\end{figure}
```

`\caption`命令给出中文图注

`{\dawu Fig.\thefigure~~***}`中给出英文图注。其中，`\dawu`指定英文字号为大五，否则中英文字号会不一致；`Fig.\thefigure`给出当前figure的编号，比如Fig.2.1。

（2）插入复杂的图（有多行图注）

```
\begin{figure}[ht]
\centering
\includegraphics[width=15cm]{Fig_ch03_ccdtditest1.eps}
\caption{TDI-CCD 对消除运动模糊失真的测试。}
{\dawu （A）微电路板的成像结果。（B）灰度分布曲线，其位置已用虚线标注在（A）图
中。}\\
{\dawu Fig.\thefigure~~Performance test of TDI-CCD for eliminating the distort
ion resulting from motion blur.}\\
{\dawu (A) Imaging result of micro circuit board. (B) Profiles of pixel value
along the dashed lines in (A).}
\label{fig:ch3:ccdtditest1}
\end{figure}
```

这幅图的图注过长，很明显会超过一行，所以三次使用了`{\dawu ***}`这个命令。在前两个命令后面，还加上了`\`用于换行。这个方法的缺点是，需要根据实际排版情况来寻找断句的地方，常常需要反复编译，以获得最佳的效果。一种有效降低劳动量的方法是尽量减少图注中的字数，复杂的内容都放在正文中去解释。

（3）图的准备

默认的编译过程可以在`msbuild.bat`文件中找到，编译其实就是去执行这个批处理文件。编译有6步，即`latex ->bibtex->latex->gbk2uni->latex->dvipdfm`。所以，先是生成DVI文件，再转成PDF，需要使用eps格式的图片。

我博士论文中所有的图都是用MS Visio画，或者排版。Visio中并不能直接导出eps图像，有两种方法可以做到这一点：

（a）先打印成pdf，然后在adobe acrobat中进行裁剪，裁剪结果另存为eps；

（b）先另存为常用图像格式（比如JPG），然后用adobe acrobat转成pdf，最后在导出为eps。在打印pdf或保持成JPG时，一定要注意调整分辨率为150~300DPI。主要使用方法a，当图片中出现透明色，就必须使用方法b，因为visio中透明色打印成pdf时显示为网格（丑啊）。

事实上，博士学位论文是可以pdfLaTeX编译的，这样可以直接使用JPG图像，感兴趣的可以去试试。

（4）另外一些经验

对于博士学位论文排版，非常害怕出现很大的图，这样会严重影响自动排版的质量。如果这种图的使用无法避免，就尽量用一些命令去控制，比如`\afterpage`。否则，会出现每一章的末尾堆上很多图，图与引用位置间的距离太远（一般控制在同一页，或相邻页）。

推荐使用微软雅黑作为绘图时的字体，效果最好。

为了保证所有图中的线宽和字号统一，需要特别注意。

对于Visio绘图，将图插入论文中后不断调整直到得到合适宽度。记下这个宽度，然后回到Visio中，将图中元件组合，再缩放该图到此宽度。这样获得的图，不会在PDF发生放大或缩小，字号和线框当然会统一。

Matlab中获得的线图可以保存为图元文件（矢量图），然后再插入Visio中编辑。

对于照片（显微镜图像或系统实物图等），尽量将图像的对比度调高一些，否则打印出来后看不清楚。

普通的图做成灰度图，好的实现结果做成彩图，尽量放在连续的几页中。因为，可以把这些好结果打印成彩色，彩打很贵，而且能省则省。

## 表格插入

举一个例子如下：

```
\begin{table}[!htbp]
  \centering
  \caption{\label{tab:methods}鼠脑成像方法}
  {Tab.\thetable~~Brain imaging methods\vspace{11pt}}
    \begin{tabular}{cccccccc}
      \toprule
      \multirow{2}{*}{数据获取方法} &amp; \multirow{2}{*}{成像对象} &amp; \multicolumn
{2}{c}{分辨率 ($\mu{}m$)} &amp; \multirow{2}{*}{样本尺寸} &amp; \multirow{2}{*}{\makec
ell{数据\\配准}} &amp; \multirow{2}{*}{\makecell{自动化\\程度}} &amp; \multirow{2}{*}{
成像方式}\\ \cline{3-4}
       &amp;  &amp; 横向 &amp; 轴向 &amp;  &amp;  &amp;  &amp;\\
      \midrule
      \makecell*{Allen 脑图谱\\获取方法\cite{Lein2007}} &amp; 切片 &amp; 0.2 &amp; 40 &amp; 全
脑 &amp; 否 &amp; 手动 &amp; 明场/荧光\\
      \makecell*{ATomo\cite{Micheva2007}} &amp; 切片 &amp; 0.2 &amp; 0.05 &amp; 脑块 &amp; 否 &amp; 半
自动 &amp; \makecell*{明场/荧光/\\电镜}\\
      \makecell*{数字鼠数据\\获取方法\cite{Bai2006}} &amp; 切片 &amp; 0.5 &amp; 200 &amp; 全脑
 &amp; 是 &amp; 自动 &amp; 明场/荧光\\
      \makecell*{TPTC\cite{Ragan2007}} &amp; 浅层 &amp; 0.3 &amp; 0.6 &amp; $&gt;$6 $mm$ &amp; 是 &amp; 自
动 &amp; 荧光\\
      \makecell*{AOH\cite{Tsai2003}} &amp; 浅层 &amp; 0.3 &amp; 1 &amp; 脑块 &amp; 是 &amp; 自动 &amp; 荧光
\\
      \makecell*{UM\cite{Dodt2007}} &amp; 浅层 &amp; 10 &amp; $&gt;$10 &amp; 全脑 &amp; 是 &amp; 自动 &amp; 荧
光\\
      \makecell*{OPT\cite{Sharpe2004}} &amp; 透明完整样本 &amp; 5--10 &amp; 5--10 &amp; 1--10
$mm$ &amp; 是 &amp; 自动 &amp; 明场/荧光\\
      \makecell*{MRI\cite{Dorr2008}} &amp; 完整样本 &amp; 32 &amp; 32 &amp; 全脑 &amp; 是 &amp; 自动 &amp;
 --- \\
      \bottomrule
    \end{tabular}
\end{table}
```

其中，`\caption{}`中为中文表注，`{Tab.\thetable~~***\vspace{11pt}}`为英文表注。11pt的纵向距离是必要的，否则英文图注和表格间的距离太近，影响美观。

`\multirow`和`\multicolumn`命令可以合并单元格，google一下就清楚用法了。

`\toprule`和`\bottomrule`画粗线，`\midrule`画细线，即所谓的三线表。

`\makecell*{string1\string}`命令构建一个cell，方便内容在单元格内换行，换行的位置用`\`命令控制。`\makecell`命令对于排版很宽的表格非常有用。

排版的结果如下：

## 参考文献插入

我的做法是Endnote做文献管理。在Endnote中编辑好所有文献，保证文献信息的统一。我的文献风格如下：

[5] Snyder E Y, Yoon C, Flax J D, et al. Multipotent neural precursors can differentiate toward replacement of neurons undergoing targeted apoptotic degeneration in adult mouse neocortex. P Natl Acad Sci USA, 1997, 94(21):11663–11668.

作者名字缩写为Snyder E Y，仅列出3人。期刊名使用ISO标准的缩写，比如P Natl Acad Sci USA。然后，还要给每篇文献加入唯一的Label，比如上面这篇文献的Label为Snyder1997。最后，建议删除endnote中记录的无关内容，比如abstract、note、keywords、address等。

LaTeX使用BibTeX管理文献，endnote提供了可以输出为BibTeX格式的style，称为BibTeX Export。输出结果可以直接粘贴`\ref\refs.bib`文件中，比如：

```
@article{Snyder1997,
author = {Snyder, E. Y. and Yoon, C. and Flax, J. D. and Macklis, J. D.},
title = {Multipotent neural precursors can differentiate toward replacement of neurons undergoing targeted apoptotic degeneration in adult mouse neocortex},
journal = {P Natl Acad Sci USA},
volume = {94},
number = {21},
pages = {11663-11668},
year = {1997}
}
```

如果引用的位置为网页，可以直接在bib文件中插入以下类似内容：

```
@MISC{wwwbrainmap,
note = {http://www.brain-map.org},
}
```

## 攻读学位期间的主要成果和奖励

对于不仅有论文的同志，可以按照下面这个格式来写：

```
\begin{publications}
\item `高分辨数字人体三维结构数据集的构建与可视化`获得~2006 年湖北省科技进步奖一等奖. 主要完成人: 骆清铭, 刘谦, 龚辉, 鲁强, 曾绍群, \CJKunderline{李安安}, 徐国栋, 陈华, 韩道, 张杰, 熊小飞.\\
\item ***
\begin{center}
\textbf{\sihao 发表的学术论文\\}
\end{center}
\setcounter{enumi}{0}
\item \CJKunderline{Li A A}, Gong H, Zhang B, Wang Q D, Yan C, Wu J P, Liu Q, Zeng S Q, Luo Q M. Micro-optical sectioning tomography to obtain a high-resolution atlas of the mouse brain. Science, 2010, 330(6009):1404-1408.（第一单位：华中科技大学）
\item ***
\begin{center}
\textbf{\sihao 申请或授权的专利和软件著作权\\}
\end{center}
\setcounter{enumi}{0}
\item 骆清铭, 张斌, \CJKunderline{李安安}, 龚辉, 王冰然. 一种小动物全脑标本的制备方法, 发明专利申请号~200810306435.3.
\item ***
\end{publications}
```

说明：论文的格式和`参考文献`的格式基本一致，但有必要列出所有作者名单。

## 盲审

盲审很无聊，不仅评审人很容易判断论文的作者是谁，而且评审人的名字需要填在毕业前的一大堆表格中。不管怎样，需要按照形式来。我们最好重新建立 `coverM.tex`和`publicationsM.tex`两个文件，分别临时代替原文件。然后，去除所有出现的作者信息，导师信息。说白了就是一个空白的封面，以及没有作者信息的成果列表。另外，在盲审版本中不需要插入`致谢`。

盲审需要打印3本，交给研究生教务员即可。然后，就祈祷各位评审人动作快一点，快递别出啥差错。

## 其他注意事项

### （1）中英文间的空格

比如这么一段：`由表~\ref{tab:aerotech} 可知，$X$ 轴的运动行程最长，便于执行主切削运动，相比之下，$Y$ 轴和~$Z$ 轴的运动行程只有厘米量级。` 为了排版美观，中英文间应该有空格，英文部分与前面的中文间要加入`~`符号，与后面的中文间要加入一个真的空格。在这里，英文是所有阿拉伯数字、希腊字母、公式、拉丁字母等的统称，即凡是汉字以外的字符。但是，中文标点符号与这些元素间是不需要增加额外空格的。

### （2）单位的特殊格式

对于单位、坐标轴等信息，我习惯用公式环境。比如微米写成`$\mu{}m$`，X轴写成`$X$ 轴`。公式环境能够让这些元素在正文中突出显示，更加美观。

### （3）双引号

我过去喜欢用``’’这四个半角字符实现双引号，但是它的效果没有直接使用``这中文符号漂亮，感兴趣的可以去试一试。

### （4）标题深度

虽然学校允许出现`2.1.3.1`这样的四级标题，但是还是建议标题只使用到三级，即不允许出现`\subsubsection{}`这个命令。如果需要在三级标题下增加分割，建议使用`（1）`罗列，代替四级标题。

## 打印最终版本

结合盲审和答辩时反馈回来的意见，论文一般还需要修改。修改后，就要拿去打印了，这时候还是需要做一些事情。

（1）中文的封面不用担心，因为需要由打印人员临时制作彩色的封面。英文封面只占半页纸，背面应该保持空白。

（2）中文摘要、英文摘要、目录、缩写表、正文的每一章、致谢、参考文献、成果这8个部分的第一页都应该位于奇数页，也就是打开一本书的右侧。如果落在了偶数页码，就在`main.tex`的相应位置加上一个`\newpage{}~`命令，注意`~`符号是必须的，这样可以额外增加一个空白页。

（3）需要准备两个版本的PDF，即页眉版和无页眉版。页眉就是每一页上面那两个横杠，以及`华中科技大学博士学位论文`这几个字。页眉版本打印时用普通的纸张，被作为博士学位论文的复印版本。无页眉版本打印时需要使用特殊的纸张，带所谓的`红头`，作为博士论文的原版，要放在学校图书馆收藏。我们可以很容易的切换两种版本的编译，当`main.tex`中的`\documentclass[] {HUSTPHDthesis}`中包含`finalformat`选项时，获得是无页眉版本，否则为页眉版本。

（4）制作成PDF后，应该仔细检查，确认无误后拿去打印。虽然学校集贸市场旁边的论文打印中心很贵，但质量绝对是最好的。而且，结账的时候签实验室的单即可，不用付现金。一般打印7本，1本原版（红头）和3本交到学院，2本交给实验室（gong），自己再留一本。

## 没有解决的问题

有些问题我一直没有解决，因为不影响大局，也就没有再花时间去折腾。包括：

（1）表格和图片浮动体内无法增加脚注

（2）visio打印成PDF时，透明色无法正确显示

（3）在`攻读学位期间的主要成果和奖励`中，`\begin{publications}`后必须要跟`\item`，否者会出错，这使得`所获奖励`小标题无法加入。

（4）无法计算文章字数。

---
]]></content>
      <categories>
        <category>HUST</category>
      </categories>
      <tags>
        <tag>论文写作</tag>
        <tag>HUST</tag>
      </tags>
  </entry>
  <entry>
    <title>时间序列预测</title>
    <url>/time-series-prediction/</url>
    <content><![CDATA[
时间序列（Time Series）是我们在日常生活和社会工作中十分常见的一种数据，它是通过将一系列时间点上的观测值按等时间间隔测量来获取的数据集合，比如商业活动中，服装公司的年销售量，日股票的收盘价格； 气象学中某城市的年降水量，月平均气温等等，因此对时间序列的研究存在于各行各业。

所谓时间序列分析（Time Series Analysis）是指一种动态数据处理的统计学方法，研究数据序列所遵从的统计规律，以用于解决具体行业的实际问题。时间序列预测法是一种历史资料延伸预测的方法，也称历史引伸预测法。是以时间数列所能反映的社会经济现象的发展过程和规律性，进行引伸外推，预测其发展趋势的方法。

<!--more-->

## Challenging Forecasting Problems

Machine learning methods have a lot to offer for time series forecasting problems. A difficulty is that most methods are demonstrated on simple univariate time series forecasting problems.

We will take a closer look at 10 challenging time series datasets from the competitive data science website [Kaggle.com](https://www.kaggle.com/). Not all datasets are strict time series prediction problems; I have been loose in the definition and also included problems that were a time series before obfuscation or have a clear temporal component[^challenging-machine-learning].

[^challenging-machine-learning]: [10 Challenging Machine Learning Time Series Forecasting Problems](http://machinelearningmastery.com/challenging-machine-learning-time-series-forecasting-problems/)

They are:

* How Much Did It Rain? I and II
* Online Product Sales
* Rossmann Store Sales
* Walmart Recruiting – Store Sales Forecasting
* Acquire Valued Shoppers Challenge
* Melbourne University AES/MathWorks/NIH Seizure Prediction
* AMS 2013-2014 Solar Energy Prediction Contest
* Global Energy Forecasting Competition 2012 – Wind Forecasting
* EMC Data Science Global Hackathon (Air Quality Prediction)
* Grupo Bimbo Inventory Demand


# 数据准备

> Data Preparation

在实际工作中，时间序列分析的目的通常有两个，一是要发现产生观测序列的随机机制，即建立数据生成模型，就是我们通常所说的数据建模；二是基于序列的历史数据，以及可能对结果产生影响的其他相关序列，对序列未来的可能取值做出预测。然而在各行各业中实际采集到的时间序列可能由于设备、人员、时间、机制等各种因素产生各种各样的问题，比如数据缺失、数据不准确、数据冗余等等，这些问题会给时间序列建模带来各种困难，甚至使模型失效，因此在数据建模之前，我们通常需要对原始时间序列模型进行大量的数据准备工作，特别是在大数据环境中，数据的宽度和广度都达到了前所未有的程度，因此需要专门的算法对数据进行分析准备工作，比如对数据进行分组、聚合，对数据的分布进行探究，数据质量得到检验以及对缺失值的处理等等[^ba-cn-bigdata-time-series-analysis1]。

[^ba-cn-bigdata-time-series-analysis1]: [大数据下时间序列数据的数据准备](https://www.ibm.com/developerworks/cn/analytics/library/ba-cn-bigdata-time-series-analysis1/index.html)

# 待分类

[TIME SERIES FORECASTING - TAKING KAGGLE ROSSMANN CHALLENGE AS EXAMPLE](http://www.elasticmining.com/post/2016-01-02/time-series-forecasting-kaggle.html)
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>TimeSeriesPrediction</tag>
      </tags>
  </entry>
  <entry>
    <title>无迹卡尔曼滤波</title>
    <url>/ukf/</url>
    <content><![CDATA[
UKF（Unscented Kalman Filter)，中文释义是无损卡尔曼滤波、无迹卡尔曼滤波或者去芳香卡尔曼滤波。是无损变换(UT) 和标准Kalman滤波体系的结合，通过无损变换使非线性系统方程适用于线性假设下的标准Kalman滤波体系。

<!--more-->

卡尔曼最初提出的滤波理论只适用于线性系统,Bucy，Sunahara等人提出并研究了扩展卡尔曼滤波(Extended Kalman Filter，简称EKF)，将卡尔曼滤波理论进一步应用到非线性领域。EKF的基本思想是将非线性系统线性化，然后进行卡尔曼滤波，因此EKF是一种次优滤波。其后，多种二阶广义卡尔曼滤波方法的提出及应用进一步提高了卡尔曼滤波对非线性系统的估计性能。二阶滤波方法考虑了Taylor级数展开的二次项，因此减少了由于线性化所引起的估计误差，但大大增加了运算量，因此在实际中反而没有一阶EKF应用广泛。

在状态方程或测量方程为非线性时，通常采用扩展卡尔曼滤波(EKF)。EKF对非线性函数的Taylor展开式进行一阶线性化截断，忽略其余高阶项，从而将非线性问题转化为线性，可以将卡尔曼线性滤波算法应用于非线性系统中。这样一来，解决了非线性问题。EKF虽然应用于非线性状态估计系统中已经得到了学术界认可并为人广泛使用，然而该种方法也带来了两个缺点，其一是当强非线性时EKF违背局部线性假设，Taylor展开式中被忽略的高阶项带来大的误差时，EKF算法可能会使滤波发散；另外，由于EKF在线性化处理时需要用雅克比(Jacobian)矩阵，其繁琐的计算过程导致该方法实现相对困难。所以，在满足线性系统、高斯白噪声、所有随机变量服从高斯(Gaussian)分布这3个假设条件时，EKF是最小方差准则下的次优滤波器，其性能依赖于局部非线性度。

无损卡尔曼滤波是一种新型的滤波估计算法。UKF以UT变换为基础，摒弃了对非线性函数进行线性化的传统做法，采用卡尔曼线性滤波框架，对于一步预测方程，**使用无迹(UT)变换来处理均值和协方差的非线性传递**，就成为UKF算法。UKF是对非线性函数的概率密度分布进行近似，用一系列确定样本来逼近状态的后验概率密度，而不是对非线性函数进行近似，**不需要求导计算Jacobian矩阵**。UKF没有线性化忽略高阶项，因此非线性分布统计量的计算精度较高。基于上述优点，UKF被广泛应用于导航、目标跟踪、信号处理和神经网络学习等多个领域。

for nonlinear dynamic system, where w ~ N(0,Q) meaning w is gaussian noise with covariance Q, v ~ N(0,R) meaning v is gaussian noise with covariance R

$$
x_{k+1} = f(x_k) + w_k \\
z_k   = h(x_k) + v_k
$$

```
f=@(x)[x(2);x(3);0.05*x(1)*(x(2)+x(3))];  % nonlinear state equations
h=@(x)x(1);                               % measurement equation
```


---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>StateEstimation</tag>
      </tags>
  </entry>
  <entry>
    <title>不平衡数据</title>
    <url>/unbalanced-data/</url>
    <content><![CDATA[
在机器学习中，常常会遇到样本比例不平衡的问题，如对于一个二分类问题，正负样本的比例是 10:1。这种现象往往是由于本身数据来源决定的，如信用卡的征信问题中往往就是正样本居多。样本比例不平衡往往会带来不少问题，但是实际获取的数据又往往是不平衡的，因此本文主要讨论面对样本不平衡时的解决方法。

<!--more-->

样本不平衡往往会导致模型对样本数较多的分类造成过拟合，即总是将样本分到了样本数较多的分类中；除此之外，一个典型的问题就是 [Accuracy Paradox](https://en.wikipedia.org/wiki/Accuracy_paradox)，这个问题指的是模型的对样本预测的准确率很高，但是模型的泛化能力差。其原因是模型将大多数的样本都归类为样本数较多的那一类。

针对样本的不平衡问题，有以下几种常见的解决思路：

> [8 Tactics to Combat Imbalanced Classes in Your Machine Learning Dataset](http://machinelearningmastery.com/tactics-to-combat-imbalanced-classes-in-your-machine-learning-dataset/)  
> [In classification, how do you handle an unbalanced training set?](https://www.quora.com/In-classification-how-do-you-handle-an-unbalanced-training-set)

# 搜集更多的数据

搜集更多的数据，从而让正负样本的比例平衡，这种方法往往是最被忽视的方法，然而实际上，当搜集数据的代价不大时，这种方法是最有效的。

但是需要注意，当搜集数据的场景本来产生数据的比例就是不平衡时，这种方法并不能解决数据比例不平衡问题。

# 改变评判指标

改变评判指标，也就是不用准确率来评判和选择模型，原因就是我们上面提到的 Accuracy Paradox 问题。实际上有一些评判指标就是专门解决样本不平衡时的评判问题的，如准确率，召回率，F1值，ROC（AUC），Kappa 等。

根据这篇文章，ROC 曲线具有不随样本比例而改变的良好性质，因此能够在样本比例不平衡的情况下较好地反映出分类器的优劣。

关于评判指标更详细的内容可参考文章： [Classification Accuracy is Not Enough: More Performance Measures You Can Use](http://machinelearningmastery.com/classification-accuracy-is-not-enough-more-performance-measures-you-can-use/)

# 对数据进行采样

对数据采样可以有针对性地改变数据中样本的比例，采样一般有两种方式：over-sampling 和 under-sampling，前者是增加样本数较少的样本，其方式是直接复制原来的样本，而后者是减少样本数较多的样本，其方式是丢弃这些多余的样本。

通常来说，当总样本数目较多的时候考虑 under-sampling，而样本数数目较少的时候考虑 over-sampling。

关于数据采样更详细的内容可参考 [Oversampling and undersampling in data analysis](http://www.jair.org/papers/paper953.html)

# 合成样本

合成样本(Synthetic Samples)是为了增加样本数目较少的那一类的样本，合成指的是通过组合已有的样本的各个 feature 从而产生新的样本。

一种最简单的方法就是从各个 feature 中随机选出一个已有值，然后拼接成一个新的样本，这种方法增加了样本数目较少的类别的样本数，作用与上面提到的 Over-sampling 方法一样，不同点在于上面的方法是单纯的复制样本，而这里则是拼接得到新的样本。

这类方法中的具有代表性的方法是 SMOTE（Synthetic Minority Over-sampling Technique），这个方法通过在相似样本中进行 feature 的随机选择并拼接出新的样本。

关于 SMOTE 更详细的信息可参考论文 [SMOTE: Synthetic Minority Over-sampling Technique](http://www.jair.org/papers/paper953.html)

# 改变样本权重

改变样本权重指的是增大样本数较少类别的样本的权重，当这样的样本被误分时，其损失值要乘上相应的权重，从而让分类器更加关注这一类数目较少的样本。



---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>MachineLearning</tag>
        <tag>UnbalancedData</tag>
      </tags>
  </entry>
  <entry>
    <title>C程序设计</title>
    <url>/vc/</url>
    <content><![CDATA[
[C语言](https://zh.wikipedia.org/wiki/C%E8%AF%AD%E8%A8%80)是一种通用的编程语言，广泛用于系统软件与应用软件的开发。于1969年至1973年间，为了移植与开发UNIX操作系统，由丹尼斯·里奇与肯·汤普逊，以B语言为基础，在贝尔实验室设计、开发出来。C语言具有高效、灵活、功能丰富、表达力强和较高的可移植性等特点，在程序员中备受青睐，成为最近25年使用最为广泛的编程语言。

<!--more-->

目前，C语言编译器普遍存在于各种不同的操作系统中，例如Microsoft Windows, Mac OS X, Linux, Unix等。C语言的设计影响了众多后来的编程语言，例如C++、Objective-C、Java、C#等。二十世纪八十年代，为了避免各开发厂商用的C语言语法产生差异，由美国国家标准局为C语言订定了一套完整的国际标准语法，称为ANSI C，作为C语言的标准。二十世纪八十年代至今的有关程序开发工具，一般都支持匹配ANSI C的语法。

# C++静态库与动态库

本质上来说库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。库有两种：静态库（.a、.lib）和动态库（.so、.dll）。所谓静态、动态是指链接。[C++静态库与动态库](http://www.cnblogs.com/skynet/p/3372855.html)

# C语言程序四步开发步骤

1. 编辑。可以用任何一种编辑软件将在纸上编写好的C语言程序输入计算机，并将C语言源程序文件“.c”以纯文本文件形式保存在计算机的磁盘上（不能设置字体、字号等）。
1. 编译。编译过程使用C语言编译程序将编辑好的源程序文件“.c”，翻译成二进制目标代码文件“.obj”。编译程序对源程序逐句检查语法错误发现错误后，不仅会显示错误的位置（行号），还会告知错误类型信息。我们需要再次回到编辑软件修改源程序的错误，然后，再进行编译，直至排除所有语法和语义错误。
1. 连接。程序编译后产生的目标文件是可重定位的程序模块，不能直接运行。连接将编译生成的各个目标程序模块和系统或第三方提供的库函数“.lib”连接在一起，生成可以脱离开发环境、直接在操作系统下运行的可执行文件“.exe”。
1. 运行程序。如果经过测试，运行可执行文件达到预期设计目的，这个C语言程序的开发工作便到此完成了。如果运行出错，这说明程序处理的逻辑存在问题，需要再次回到编辑环境针对程序出现的逻辑错误进一步检查、修改源程序，重复编辑→编译→连接→运行的过程，直到取得预期结果为止。

# Code Blocks


> [C语言从零开始（二）-Code::Blocks使用](http://www.jianshu.com/p/d5fa463df77d)  
> [CodeBlocks的下载安装、配置、简单编程](http://www.cnblogs.com/hslog/p/hslog0003.html)


[Code Blocks](http://www.codeblocks.org/downloads/26/)作为一款轻量级的C/C++ IDE，它除了能够完成最基本的编辑、编译、调试的功能，还具备以下特点：

- 开源：每次看到这个词就莫名的激动，特别是对于学生朋友们，囊中羞涩的你再也不用因为使用盗版软件受到内心的谴责。有免费的我们为什么一定要选择花钱呢。

- 跨平台、跨编译器：Windows、Linux、Mac OS都可以使用，即使将来更换了设备也无需担忧。支持多款编译器，只要简单配置一下就可以轻松切换gcc/g++、Visual C++、Borland C++、Intel C++等20多款编译器。

- 插件式框架：初学者可能无法理解框架的概念，简单说就是方便添加各种有的没的小功能。

- 采用C++写成：运行环境非常简单，不用安装其他庞杂的Framework。

- 升级频繁与维护良好：几乎每个月都有升级包，还有各种热心网友提供功能包。

- 内嵌可视化GUI设计：IDE的图形界面，采用wxWidgets，如果你听不懂的话只要知道很牛X就可以了。


# VC6

## VC6.0显示行号

VC6.0是一款比较稳定的功能强大的IDE，目前也有很多人在使用。但美中不足的是它不能像其他IDE那样显示行号。这里需要用到一个插件VC6LineNumberAddin，[下载地址](http://files.cnblogs.com/emanlee/VC6LineNumberAddin.rar)。

1. 将`VC6LineNumberAddin.dll`文件放在VC6.0安装路径，例如：`D:\Program Files\Microsoft Visual Studio\Common\MSDev98\AddIns`；

1. 下载的压缩文件中有一个注册表，点击`VC6LineNumberAddin.reg`进行注册，点击后会出现一个对话框，选择“是”就OK了；

1. 打开VC6.0，选择【工具】——【定制】，进入“定制”对话框，选择【附加项和宏文件】，勾选`VC6LineNumber`前面的复选框，如果没有该选项，点击【浏览】，选择刚才的`VC6LineNumberAddin.dll`添加就可以了，注意，一定要勾选前面的复选框。

1. 设置好后点击【关闭】，就会在编辑框左侧显示代码的行号了。

## VC6.0创建工程

>
[在VC6.0中创建工程并输入源代码](http://c.biancheng.net/cpp/html/732.html)

选择菜单File下的New项，会出现一个选择界面，在属性页中选择Projects标签后，会看到近20种的工程类型，我们只需选择其中最简单的一种：“Win32 Console Application”，而后往右上处的“Location”文本框和“Project name”文本框中填入工程相关信息所存放的磁盘位置（目录或文件夹位置）以及工程的名字。

选择菜单Project中子菜单Add To Project下的new项，在出现的对话框的Files标签（选项卡）中，选择“C++ Source File”项，在右中处的File文本框中为将要生成的文件取一个名字，我们取名为Hello（其他遵照系统隐含设置，此时系统将使用Hello.cpp的文件来保存所键入的源程序）。


## VC6.0打开多个工程实例

xp下设置：打开我的电脑 → 工具 → 文件夹选项 → 在文件类型中选择DSW → 高级 → 编辑 Open 操作 →  去掉“使用 DDE”钩子 →确定完成；

## VC6.0 Debug

> [VC++6.0 Debug单步调试简单入门 ](http://alorry.blog.163.com/blog/static/647257082011664510817/)

当你按捺不住激动滴心情点击运行后，发现结果并不是你想要的结果……郁闷了。然后你在代码中加了n条printf来查看 变量的结果……n多循环……运行，再加printf，again and again……终于，要抓狂了……好吧，同学，如果你会用Debug，也许你不用这么纠结。


为了方便程序员排除程序中的逻辑错误，VC 提供了强大的调试功能。每当我们创建一个新的 VC 工程项目时，默认状态就是 Debug（调试）版本。调试版本会执行编译命令_D_DEBUG，将头文件的调试语句 ifdef 分支代码添加到可执行文件中；同时加入的调试信息可以让开发人员观察变量，单步执行程序。由于调试版本包含了大量信息，所以生成的 Debug 版本可执行文件容量会远远大于Release（发行）版本。

在调试程序的过程中，程序员应该记住以下几种技巧[^html/1618]：


[^html/1618]: [对C语言进行调试的最好方法是什么?](http://c.biancheng.net/cpp/html/1618.html)

- 先调试程序中较小的组成部分，然后调试较大的组成部分；
- 彻底调试好程序的一个组成部分后，再调试下一个组成部分；
- 连续地观察程序流(flow)和数据的变化；
- 始终打开编译程序警告选项  并试图消除所有警告；
- 准确地缩小存在错误的范围。

需要指出的是，主函数不要再用void main()了，这种只有在你学的环境才不会出错，到别的（linux编译器）地方编译是通过不了的。main函数必须要有返回值，如写成int main（）在函数结尾时加一个return 0;，这样，所有编译器都不会报错了。

### 设置断点

在你感觉可能有问题的地方添加断点（按快捷键F9或者点击图中小手按钮），以便运行到断点处好查看运行状态。

设置断点的方法是：将光标停在要被暂停的那一行，选择“Build MiniBar”工具栏按钮“Insert/Remove Breakpoint (F9)”按钮添加断点。如果该行已经设置了断点，那么再次按“F9”功能键会清除该断点。


设置断点后，可以按“F5”功能键启动 Debug模式，程序会在断点处停止。我们可以接着单步执行程序，观察各变量的值如何变化，确认程序是否按照设想的方式运行。

### 调试命令

我们也可以在 VC“Build”（组建）菜单下的“Start Debug”（开始调试）中点击 Go（F5）命令进入调试状态，Build 菜单自动变成 Debug 菜单，提供以下专用的调试命令：

- Go(F5) 从当前语句开始运行程序，直到程序结束或断点处。
- Step Into(F11) 单步执行下条语句，并跟踪遇到的函数。
- Step Over(F10) 单步执行（跳过所调用的函数）
- Run to Cursor(Ctrl+F10) 运行程序到光标所在的代码行。
- Step out(Shift+F11) 执行函数调用外的语句，并终止在函数调用语句处。
- Stop Debugging(Shift+F5) 停止调试，返回正常的编辑状态

必须在运行程序时用 Go 命令（而不是 Execute）才能启动调试模式。在调试模式下，程序停止在某条语句，该条语句左边就会出现一个黄色的小箭头。我们随时中断程序、单步执行、查看变量、检查调用情况。比如，按“F5”功能键进入调试模式，程序运行到断点处暂停；不断按“F10”功能键，接着一行一行地执行程序，直到程序运行结束。

### 查看变量

单步调试程序的过程中，我们可以在下方的Variables （变量）子窗口和Watch（监视） 子窗口中动态地察看变量的值。Variables 子窗口中自动显示当前运行上下文中的各个变量的值变量，而 Watch 子窗口内只显示在此 Watch 子窗口输入的变量或表达式的值。随着程序的逐步运行，也可以直接用鼠标指向程序中变量查看其值。Variables 子窗口中，我们可以清楚地看到，程序已经为自动型变量 first、second、big 分配了内存，但它们的初始值是随机的。

Variables 子窗口有 3 个选项卡：Auto、Locals 和 This。

- Auto 选项卡： 显示出当前语句和上一条语句使用的变量，它还显示使用 Step over 或 Step out 命
令后函数的返回值。
- Locals 选项卡：显示出当前函数使用的局部变量。
- This 选项卡： 显示出由 This 所指向的对象（C 语言不用 this）。

如果变量较多，自动显示的Variables 窗口难以查看时，还可以在右边的Watch 子窗口中添加想要监控的变量名。例如，在 Watch1 子窗口中添加了变量“first”。我们还可以直接将变量拖动到 Watch 子窗口的空白 Name 框中。 添加结束后，该变量的值会被显示出来。并且随着单步调试的进行，会看到变量 first 的值逐渐变化。如果各变量的值按照设想的方式逐渐变化，程序运行结果无误，本次开发就顺利结束了。如果发现各变量值的变化和设想的不一致，说明程序存在逻辑错误，那就需要停止调试，返回编辑窗口，查错并修改程序。

### 查看内存

数组和指针指向了一段连续的内存中的若干个数据。可以使用 memory 功能显示数组和指针指向的连续内存中的内容。在 Debug 工具条上点 memory 按钮，弹出一个对话框，在其中输入数组或指针的地址，就可以显示该地址指向的内存的内容。

## 常见的错误

### 等于运算符的误用

编译时检查有助于发现等于运算符的误用。请看下述程序段：
```
void foo(int a，int b)
{
  if ( a = b )
  {
      / * some code here * /
  }
}
```

这种类型的错误一般很难发现!程序并没有比较两个变量，而是把b的值赋给了a，并且在b不为零的条件下执行if体。一般来说，这并不是程序员所希望的(尽管有可能)。这样一来，不仅有关的程序段将被执行错误的次数，并且在以后用到变量a时其值也是错误的。

### 未初始化的变量

编译时检查有助于发现未初始化的变量。请看下面的函数：
```
void average ( float ar[], int size )
{
       float total;
       int a;
       for( a = 0;a<size; ++a)
       {
            total+=ar[a];
       }
       printf(" %f\n", total /  (float) size );
}
```
这里的问题是变量total没有被初始化，因此它很可能是一个随机的无用的数。数组所有元素的值的和将与这个随机数的值相加(这部分程序是正确的)，然后输出包括这个随机数在内的一组数的平均值。

### 变量的隐式类型转换

在有些情况下，C语言会自动将一种类型的变量转换为另一种类型。这可能是一件好事(程序员不用再做这项工作)，但是也可能会产生意想不到的效果。把指针类型隐式转换成整型恐怕是最糟糕的隐式类型转换。
```
void sort( int ar[],int size )
{
       /* code to sort goes here * /
}
int main()
{
       int arrgy[10];
       sort(  10, array );
}
```

### 运算结果出现 1.#IND, 1.#INF nan, inf

进行浮点数编程时，如果没有注意，常常会出现输出类似 1.#IND, 1.#INF 或者 nan, inf 之类奇怪的输出。这通常隐含了浮点数操作的异常。

1.#INF / inf：这个值表示“无穷大 (infinity 的缩写)”，即超出了计算机可以表示的浮点数的最大范围（或者说超过了 double 类型的最大值）。例如，当用 0 除一个整数时便会得到一个1.#INF / inf值；相应的，如果用 0 除一个负整数也会得到 -1.#INF / -inf 值。

-1.#IND / nan：这个的情况更复杂，一般来说，它们来自于任何未定义结果（非法）的浮点数运算。"IND"是 indeterminate 的缩写，而"nan"是 not a number 的缩写。产生这个值的常见例子有：对负数开平方，对负数取对数，0.0/0.0，0.0*∞, ∞/∞ 等。举个例子，如果log()内的值是1.#INF,得到的log值就会是，1.#INF。              

所以简而言之，如果遇到 1.#INF / inf，就检查是否发生了运算结果溢出除零，而遇到 1.#IND / nan，就检查是否发生了非法的运算。很多 C 库都提供了一组函数用来判断一个浮点数是否是无穷大或 NaN。`int _isnan(double x)` 函数用来判断一个浮点数是否是 NaN，而 `int _finite(double x)` 用以判断一个浮点数是否是无穷大[^blog_5e9e98210101ndgl]。

[^blog_5e9e98210101ndgl]: [如何实现一个通用的判断版本](http://blog.sina.com.cn/s/blog_5e9e98210101ndgl.html)

### 出现stack overflow问题

一般遇到这个问题，有两个常见的情况，一个是存在函数的递归调用，另一个是函数中定义了一个较大的数组或者别的变量。

1. 在函数的递归调用中，函数中定义的局部变量所占的空间要直到递归结束才能被释放，这样函数不停的递归，堆栈早晚会被用完，解决这一问题的办法是在递归函数中每次[动态分配变量的内存](#c-dynamic-memory)，在使用结束的时候释放内存。遇到这种情况更改堆栈的最大空间大小是没有用的，要从代码的优化入手。

1. 堆栈的大小只有1M，如果在函数中定义了一个占用内存比较大的变量，那么也会导致堆栈溢出。这种情况只需在定义的时候定义为静态变量就行了，因为静态变量是不占用堆栈内存的。

1. 还可以通过修改堆栈的最大空间来解决问题，把project设置里的堆栈加大就可以了,默认是1M,你可以加大到10M试试.   具体如下：project-> setting-> link:   在category里选择output,在stack的Reserve里输入0x10000000试试。对于遇到这样的问题建议从代码方面去解决，不要盲目的依靠修改堆栈空间来解决，毕竟有的问题靠修改空间是解决不了的，如递归中产生的stack overflow。

# VS-XP

VS编译出来的程序如何在XP-SP2以下的系统运行。

```
// Including SDKDDKVer.h defines the highest available Windows platform.

// If you wish to build your application for a previous Windows platform, include WinSDKVer.h and
// set the _WIN32_WINNT macro to the platform you wish to support before including SDKDDKVer.h.

#include <SDKDDKVer.h>
```

安装VS2012 Update1包，更改项目属性：

（1）配置属性--常规--平台工具集：Visual Studio 2012 - Windows XP (v110_xp)。

（2）链接器--系统--子系统：控制台或窗口，所需的最低版本5.01

（3）C/C++--代码生成--运行库：多线程静态链接库（Release（LIBCMT.lib）)：/MT，Debug（LIBCMTD.lib）：/MTD）

也可在stdafx.h文件中添加如下代码：

```
// 包括 SDKDDKVer.h 将定义可用的最高版本的 Windows 平台。  
// 如果要为以前的 Windows 平台生成应用程序，请包括 WinSDKVer.h，并将  
// WIN32_WINNT 宏设置为要支持的平台，然后再包括 SDKDDKVer.h。  
#include <WinSDKVer.h>
#ifndef _WIN32_WINNT
#define _WIN32_WINNT _WIN32_WINNT_WINXP
#endif
#include <SDKDDKVer.h>
```

如若进行上述设置后，没有效果，则检查程序引用的外部库属性，是否也进行了相应设置。

# C语言

一般来说，按结构化程序设计原则编写的程序是易于调试和修改的，下面将介绍其中的一些原则[^html/1618]：


- 程序中应有足够的注释；
- 函数应当简洁；
- 程序流应该清晰，避免使用goto语句和其它跳转语句；
- 函数名和变量名应具有描述性；

## 头文件预编译

所谓头文件预编译，就是把一个工程(Project)中使用的一些MFC标准头文件(如`Windows.H`、`Afxwin.H`)预先编译，以后该工程编译时，不再编译这部分头文件，仅仅使用预编译的结果。这样可以加快编译速度，节省时间。   

预编译头文件通过编译`stdafx.cpp`生成，以工程名命名，由于预编译的头文件的后缀是“pch”，所以编译结果文件是`projectname.pch`。   

编译器通过一个头文件stdafx.h来使用预编译头文件。`stdafx.h`这个头文件名是可以在project的编译设置里指定的。编译器认为，所有在指令`#include "stdafx.h"`前的代码都是预编译的，它跳过`#include "stdafx. h"`指令，使用`projectname.pch`编译这条指令之后的所有代码。   

因此，所有的CPP实现文件第一条语句都是：`#include "stdafx.h"`。

## 主函数

- `main`是C/C++的标准入口函数名。
- `WinMain`是windows API窗体程序的入口函数。(int WINAPI WinMain()) 中 WINAPI是__stdcall宏，在`windef.h`中定义的。
- `_tmain` `_tWinMain` 是Unicode版本函数别名，对应与wmain和wWinMain。工程中最好用这类函数。`_tmain`的定义在`<tchar.h>`可以找到,如`#define _tmain main`，所以要加`#include <tchar.h>`才能用。 `_tmain`是个宏,如果是UNICODE则他是wmain()否则他是main()。

## 函数声明/定义/调用

[函数声明/定义/调用](http://www.cnblogs.com/del/archive/2008/12/02/1345452.html)：

1. 如果函数没有声明，应该在调用前定义；
2. 可以在函数头声明；
3. 一般应在文件头声明，函数原型的声明在实际运用中， 会集中声明在头文件(`*.h`)里面。
4. 函数可互调用, 但不能嵌套；
5. 如果函数没有参数, 最好是 fun(void), 不过 fun() 也行; 如果函数没有返回值, 要注明返回类型是 void; 在 C 语言中调用无参函数也要带括号.
6. 声明函数时可以省略形参；
7. 函数的参数一般不要超过 7 个；

## 类型定义

### void

> [C语言void关键字](http://c.biancheng.net/cpp/html/444.html)

- void 修饰变量

void 几乎只有“注释”和限制程序的作用，因为从来没有人会定义一个void 变量。void 不能代表一个真实的变量。void 体现了一种抽象，这个世界上的变量都是“有类型”的，譬如一个人不是男人就是女人（人妖不算）。

void 真正发挥的作用在于：对函数返回的限定；对函数参数的限定。

任何类型的指针都可以直接赋值给`void *`，无需进行强制类型转换。但这并不意味着，`void *`也可以无需强制类型转换地赋给其它类型的指针。因为“空类型”可以包容“有类型”，而“有类型”则不能包容“空类型”。

- void 修饰函数返回值和参数

如果函数没有返回值，那么应声明为void 类型。在C 语言中，凡不加返回值类型限定的函数，就会被编译器作为返回整型值处理。为了避免混乱，我们在编写C 程序时，对于任何函数都必须一个不漏地指定其类型。如果函数没有返回值，一定要声明为void 类型。

如果函数无参数,那么应声明其参数为void。所以，无论在C 还是C++中，若函数不接受任何参数，一定要指明参数为void。

- void 指针

千万小心又小心使用void 指针类型。按照ANSI(American National Standards Institute)标准，不能对void 指针进行算法操作。

如果函数的参数可以是任意类型指针，那么应声明其参数为`void *`。

### const

const在C语言中算是一个比较新的描述符，我们称之为常量修饰符，即就是说其所修饰的对象为常量[^details/6595197]。当你代码中想要设法阻止一个变量被改变，那么这个时候可以选择使用const关键字。在你给一个变量加上const修饰符的同时，通常需要对它进行初始化，在之后的程序中就不能再去改变它。

[^details/6595197]: [C语言的那些小秘密之const修饰符](http://blog.csdn.net/bigloomy/article/details/6595197)

因为预处理语句虽然可以很方便的进行值得替代，但它有个比较致命的缺点，即预处理语句仅仅只是简单值替代，缺乏类型的检测机制。这样预处理语句就不能享受C编译器严格类型检查的好处，正是由于这样，使得它的使用存在着一系列的隐患和局限性。

## 变量

在[《C语言函数的参数和返回值》](http://c.biancheng.net/view/57.html)中提到，形参变量要等到函数被调用时才分配内存，调用结束后立即释放内存。这说明形参变量的作用域非常有限，只能在函数内部使用，离开该函数就无效了。所谓作用域（Scope），就是变量的有效范围。不仅对于形参变量，C语言中所有的变量都有自己的作用域。决定变量作用域的是变量的定义位置。

定义在函数内部的变量称为局部变量（Local Variable），它的作用域仅限于函数内部， 离开该函数后就是无效的，再使用就会报错。在所有函数外部定义的变量称为全局变量（Global Variable），它的作用域默认是整个程序，也就是所有的源文件，包括 .c 和 .h 文件。变量的使用遵循就近原则，如果在当前作用域中存在同名变量，就不会向更大的作用域中去寻找变量。

[局部变量和全局变量的综合示例](http://c.biancheng.net/cpp/html/62.html)

### C++/作用域

1. C++变量根据定义的位置的不同的生命周期，具有不同的作用域，作用域可分为6种：全局作用域，局部作用域，语句作用域，类作用域，命名空间作用域和文件作用域。

    1>全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包含全局变量定义的源文件需要用extern 关键字再次声明这个全局变量。

    2>静态局部变量具有局部作用域，它只被初始化一次，自从第一次被初始化直到程序运行结束都一直存在，它和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。

    3>局部变量也只有局部作用域，它是自动对象（auto），它在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用执行结束后，变量被撤销，其所占用的内存也被收回。

    4>静态全局变量也具有全局作用域，它与全局变量的区别在于如果程序包含多个文件的话，它作用于定义它的文件里，不能作用到其它文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

2. 从分配内存空间看：

    1>全局变量，静态局部变量，静态全局变量都在静态存储区分配空间，而局部变量在栈里分配空间

    2>全局变量本身就是静态存储方式， 静态全局变量当然也是静态存储方式。这两者在存储方式上并无不同。这两者的区别虽在于非静态全局变量的作用域是整个源程序，当一个源程序由多个源文件组成时，非静态的全局变量在各个源文件中都是有效的。而静态全局变量则限制了其作用域，即只在定义该变量的源文件内有效，在同一源程序的其它源文件中不能使用它。由于静态全局变量的作用域局限于一个源文件内，只能为该源文件内的函数公用，因此可以避免在其它源文件中引起错误。

    1)静态变量会被放在程序的静态数据存储区(全局可见)中，这样可以在下一次调用的时候还可以保持原来的赋值。这一点是它与堆栈变量和堆变量的区别。

    2)变量用static告知编译器，自己仅仅在变量的作用范围内可见。这一点是它与全局变量的区别。


从以上分析可以看出， 把局部变量改变为静态变量后是改变了它的存储方式即改变了它的生存期。把全局变量改变为静态变量后是改变了它的作用域，限制了它的使用范围。因此static 这个说明符在不同的地方所起的作用是不同的。应予以注意。

A.若全局变量仅在单个C文件中访问，则可以将这个变量修改为静态全局变量，以降低模块间的耦合度；

B.若全局变量仅由单个函数访问，则可以将这个变量改为该函数的静态局部变量，以降低模块间的耦合度；

C.设计和使用访问动态全局变量、静态全局变量、静态局部变量的函数时，需要考虑重入问题，因为他们都放在静态数据存储区，全局可见；

D.如果我们需要一个可重入的函数，那么，我们一定要避免函数中使用static变量(这样的函数被称为：带“内部存储器”功能的的函数)

E.函数中必须要使用static变量情况:比如当某函数的返回值为指针类型时，则必须是static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

<div id="c-dynamic-memory"></div>

## 动态内存分配

到目前为止，我们的程序中我们只用了声明变量、数组和其他对象（objects）所必需的内存空间，这些内存空间的大小都在程序执行之前就已经确定了。但如果我们需要内存大小为一个变量，其数值只有在程序运行时 (runtime)才能确定，例如有些情况下我们需要根据用户输入来决定必需的内存空间，那么我们该怎么办呢？答案是动态内存分配（dynamic memory）。

[C++ 集成了操作符new 和delete](http://www.prglab.com/cms/pages/c-tutorial/advanced-data/dynamic-memory.php)：

1. 操作符new的存在是为了要求动态内存。new 后面跟一个数据类型，并跟一对可选的方括号[ ]里面为要求的元素数。它返回一个指向内存块开始位置的指针。我们建议在使用new之后总是检查返回的指针是否为空(null)。
2. 既然动态分配的内存只是在程序运行的某一具体阶段才有用，那么一旦它不再被需要时就应该被释放，以便给后面的内存申请使用。操作符delete 因此而产生。

[c语言集成了malloc和free函数](http://www.cnblogs.com/hanyonglu/archive/2011/04/28/2031271.html)：

1. `void *malloc(long NumBytes)`：该函数分配了NumBytes个字节，并返回了指向这块内存的指针。如果分配失败，则返回一个空指针（NULL）。申请了内存空间后，必须检查是否分配成功。malloc()从堆里面获得空间，也就是说函数返回的指针是指向堆里面的一块内存。

1. `void free(void *FirstByte)`： 该函数是将之前用malloc分配的空间还给程序或者是操作系统，也就是释放了这块内存，让它重新得到自由。free()释放的是指针指向的内存！注意！释放的是内存，不是指针！指针并没有被释放，指针仍然指向原来的存储空间。指针是一个变量，只有程序结束时才被销毁。释放了内存空间后，原来指向这块空间的指针还是存在！只不过现在指针指向的内容的垃圾，是未定义的，所以说是垃圾。因此，释放内存后把指针指向NULL，防止指针在后面不小心又被引用了。

## 运算符

### 除法求余

除法运算符“/”。二元运算符，具有左结合性。参与运算的量均为整型时，结果为整型，舍去小数。如果运算量中有一个为实型，结果为双精度实型。除号的正负取舍和一般的算数一样，符号相同为正，相异为负。

求余运算符“%”，二元运算符，具有左结合性。参与运算的量均为整型。求余运算的结果等于两个数相除后的余数`(a%b=a-(int)(a/b)\*b)`。`5%2.0`和`5.0%2`的结果是语法错误。求余符号的正负取舍和被除数符号相同。

### 次方

pow() 函数用来求 x 的 y 次幂（次方），其原型为：`double pow(double x, double y)`，然后将结果返回。设返回值为 ret，则 ret = $x^y$。

可能导致错误的情况：

- 如果底数 x 为负数并且指数 y 不是整数，将会导致 domain error 错误。
- 如果底数 x 和指数 y 都是 0，可能会导致 domain error 错误，也可能没有；这跟库的实现有关。
- 如果底数 x 是 0，指数 y 是负数，可能会导致 domain error 或 pole error 错误，也可能没有；这跟库的实现有关。如果发生 domain error 错误，那么全局变量 errno 将被设置为  EDOM；如果发生 pole error 或 range error 错误，那么全局变量 errno 将被设置为 ERANGE。
- 如果返回值 ret 太大或者太小，将会导致 range error 错误。


```
#include <stdio.h>
#include <math.h>
int main ()
{
    printf ("7 ^ 3 = %f\n", pow (7.0, 3.0) );
    printf ("4.73 ^ 12 = %f\n", pow (4.73, 12.0) );
    printf ("32.01 ^ 1.54 = %f\n", pow (32.01, 1.54) );
    return 0;
}
```



## 类型转换

[类型转换和类型安全（现代 C++）](https://msdn.microsoft.com/zh-cn/library/hh279667.aspx)

## 指针

> [指针与二维数组](http://c.biancheng.net/cpp/html/2930.html)

```
TYPE *name 定义某个类型的指针，取地址。
TYPE **name 指向指针的指针
```

假设有一个 int 类型的变量 a，p1是指向 a 的指针变量，p2 又是指向 p1 的指针变量，它们的关系如下图所示。  

![](http://c.biancheng.net/cpp/uploads/allimg/160714/1-160G41Q12O23.jpg)

```
int a =100;
int \*p1 = &a;
int \**p2 = &p1;

指针变量也是一种变量，也会占用存储空间，也可以使用`&`获取它的地址。C语言不限制指针的级数，每增加一级指针，在定义指针变量时就得增加一个星号`*`。p1 是一级指针，指向普通类型的数据，定义时有一个`*`；p2 是二级指针，指向一级指针 p1，定义时有两个`*`。
```

## 数组与字符串长度

[数组与字符串长度sizeof()、strlen()、string的length()和size()](http://blog.sina.com.cn/s/blog_67d069a90100ui4p.html)

sizeof()不需要头文件，和int一样编译器会识别。sizeof()返回的是变量声明后所占的内存数，不是实际长度，此外sizeof不是函数，仅仅是一个操作符，strlen是函数，在string.h中。（[VC中的sizeof的用法总结](http://www.cnblogs.com/afarmer/archive/2011/05/01/2033710.html)）

c++中的字符串string的长度，size()和length()没有区别。为了兼容等，这两个函数一样。length是因为沿用C语言的习惯而保留下来的，string类最初只有length，引入STL之后，为了兼容又加入了size，它是作为STL容器的属性存在的，便于符合STL的接口规则，以便用于STL的算法。 string类的size()/length()方法返回的是字节数，不管是否有汉字。

```
string str1=”xxxxx”;
int i=str1.length();
cout<<”i=str1.length()= ”<<i<<endl; //结果为5，因为5个x
i=tr1.size();
cout<<”str1.size()= ”<<i<<endl;
```

### sizeof()

求所占的字节数

- 对于整型字符型数组

```
int A[]={1,4,5,2,8,6,0};
//求整型数组A所占的字节数
int i=sizeof(A); //i表示整型数组A所占的总空间的字节数
cout<<” i=sizeof(A)= ”<<i<<endl;             
i=sizeof(A)/sizeof(int); //此时i表示数字数组的元素个数


char B[]={‘a’,’e’,’s’,’r’,’q’};
//求字符数组的所占的字节数
i=sizeof(B);          
cout<<i<<endl; //结果为5*sizeof(char)=5
//求字符数组的元素个数
i=szieof(B)/sizeof(char);//结果为5

char C[]=”abcde”;
i=sizeof(C);//i为字符数组C所占的字节空间，为6，最后一个为’\0’
cout<<i<<endl;

```

- 对于整型或字符型指针

```
int *p;
int A[]={1,2,3,4,5,6,7,8};
p=A;
int i=sizeof(*p); //此时i就是p所指的整型数组A的第一个元素A[0]的所占字节数
cout<<i<<endl;
i=sizeof(P); //p为整形指针，大小为定值为4     
cout<<*p<<endl;  //输出A[0]即1
cout<<p<<endl;   //输出的结果为整型指针所指向的地址 0x……


char *p;
char B[]={‘a’,’s’,’e’,’r’};              
p=B;  //字符指针赋值，或char *p=B;这样为字符指针初始化赋值
i=sizeof(p);  //p为字符指针，指针的大小为定值，为4
cout<<i<<endl;
i=sizeof(*p);  //这是指B[0]所占空间的大小
cout<<i<<endl;   //结果为1

注意：
cout<<*p<<endl;  //输出结果为字符a
cout<<p<<endl;   
cout<<hex<<(int)&(*p)<<"       "<<&B<<endl;  //输出结果两者相同
cout<<hex<<(int)p<<"      "<<&B<<endl;       //输出结果两者相同

```

### strlen()

字符数组或字符串所占的字节数,就是指实际字符串或字符数组的实际长度（不是所占空间的字节数）。strlen所作的仅仅是一个计数器的工作，它从内存的某个位置（可以是字符串开头，中间某个位置，甚至是某个不确定的内存区域）开始扫描，直到碰到第一个字符串结束符`\0`为止，然后返回计数器值。

- 字符数组

```
char A[6]={'a','b','\0','d','e','r'};
int i=strlen(A);          //i为2，因为到’\0’结束，故实际A[]只有2个元素
cout<<i<<endl;
char *str="abcde";
i=strlen(str);           //i为5
cout<<i<<endl;

//char A[6]={"abcdef"};
//error C2117: 'abcdef' : array bounds overflow
```

- 字符指针

```
char C[]={"abcdef"};
char *p1=C;
i=strlen(p1);   //结果为6
cout<<i<<endl;

char D[]={'a','c','q','f','w'};
i=strlen(D);  
//这样，由于没指定D的内存分配大小，用strlen求其长度会造成错误。
//如果为char D[5]={'a','c','q','f','w'};这样再用strlen求其长度也会造成错误，当D[]之中的数
//大于5才不会造成错误。
cout<<i<<endl;
```

- 其他结构

```
class X
　　{
　　int i;
　　int j;
　　char k;
　　};
　　X x;

cout<<sizeof(X)<<endl; 结果 12 ===》内存补齐
cout<<sizeof(x)<<endl; 结果 12 同上

解释一下，在class X中，成员中最大的所占的空间为int类型所占的空间4个字节，故内存补齐，最后结果为: ((int)(实际成员所占内存空间的和/4)+1)*4

```

- 有关空类

```
#include <iostream>
using namespace std;
class A
{
};
class A2
{
};
class B:public A
{
};
class C:public virture B
{
};
class D:public A,public A2
{
};
int main()
{
cout<<"sizeof(A): "<<sizoef(A)<<endl;
cout<<"sizeof(B): "<<sizeof(B)<<endl;
cout<<"sizeof(C): "<<sizeof(C)<<endl;
cout<<"sizeof(D): "<<sizeof(D)<<endl;
return 0;
}

结果：1 1 4 1
表明空类所占空间为1个字节，单一继承的空类空间也为1，多重继承的空类空间还是1，但虚继承涉及虚表（虚指针），所以sizeof(C)为 4。
```


## memset函数

【函数说明】memset() 会将 ptr 所指的内存区域的前 num 个字节的值都设置为 value，然后**返回指向 ptr 的指针**。其原型为：  

    头文件：#include <string.h>  
    void * memset( void * ptr, int value, size_t num );  

参数说明：

* ptr 为要操作的内存的指针。
* value 为要设置的值。你既可以向 value 传递 int 类型的值，也可以传递 char 类型的值，int 和 char 可以根据 ASCII 码相互转换。注意：参数 value 虽声明为 int，但必须是 unsigned char，所以范围在0 到255 之间。  
* num 为 ptr 的前 num 个字节，size_t 就是unsigned int。  


memset() 可以将一段内存空间全部设置为特定的值，所以经常用来初始化字符数组。例如：

    char str[20];
    memset(str, '\0', sizeof(str)-1);

范例：

```
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
int main()
{
    // 不可以声明为 char *str = "http://c.biancheng.net";
    char str[] = "http://c.biancheng.net";
    memset(str, '-', 7);
    puts(str);
    system("pause");
    return EXIT_SUCCESS;
}
```

执行结果：  -------c.biancheng.net  

> 注意：字符数组是可以被修改的，字符串是只读的，不能被修改，而 memset() 又必须修改 str，所以不能将 `char str[] = "http://c.biancheng.net"`; 声明为 `char *str = "http://c.biancheng.net"`;，否则运行时会报错。


## FOR循环

在VC6中， `for(int j = 0; j < 16; ++j)` 中j的作用域在for所在的域中。
而标准C++中, j的作用域在for语句块内。

## 数组与矩阵

C语言支持一维数组和多维数组。如果一个数组的所有元素都不是数组，那么该数组称为一维数组。[一维数组的定义和引用](http://c.biancheng.net/cpp/html/50.html)

在进行科学计算的时候，矩阵是一种很常见的数据类型。但是作为基本算法实现和工程应用的时候C语言并没有提供该数据类型，而是利用二维数组定义该数据类型。

二维数组在概念上是二维的，有行和列，但在内存中所有的数组元素都是连续排列的，它们之间没有“缝隙”。

以下面的二维数组 a 为例：

```
int a[3][4] = { {0, 1, 2, 3}, {4, 5, 6, 7}, {8, 9, 10, 11} };
```

C语言中的二维数组是按行排列的，也就是先存放 a[0] 行，再存放 a[1] 行，最后存放 a[2] 行；每行中的 4 个元素也是依次存放。数组 a 为 int 类型，每个元素占用 4 个字节，整个数组共占用 4×(3×4) = 48 个字节。

C语言允许把一个二维数组分解成多个一维数组来处理。对于数组 a，它可以分解成三个一维数组，即 a[0]、a[1]、a[2]。每一个一维数组又包含了 4 个元素，例如 a[0] 包含 a[0][0]、a[0][1]、a[0][2]、a[0][3]。


### 矩阵的定义和初始化

但是如果矩阵在程序中作为程序返回值的话就不能简单利用二维数组类实现了。以下分享几种C语言矩阵的定义和初始化。

#### 动态申请矩阵存储空间

1）能够动态申请和释放存储空间；
2）对于将矩阵作为返回值的情况具有独特的优势。

```
//定义结构体类型，这里需要利用指针和结构体，其中m和n分别表示矩阵的行和列
typedef struct
{
	double **mat;
	int m, n;
}matrix;

//矩阵申请储存空间，注意这里使用了malloc()函数
void initial(matrix &T,int m,int n)
{
	int i = 0;
	T.mat = (double **)malloc(m*sizeof(double *));
	for (i = 0; i < m; m++)
	{
		T.mat[i] = (double *)malloc(n*sizeof(double));
	}
	T.m = m;
	T.n = n;
}

//初始化矩阵，这里将矩阵初始化为m*n的数组，且矩阵中的每一个元素的值均为0
void initValue(matrix &T, int m, int n)
{
	int i, j;
	initial(T,m,n);
	for (i = 0; i < m; i++)
	{
		for (j = 0; j < n; j++)
		{
			T.mat[i][j] = 0;
		}
	}
}

//释放存储空间
void destroy(matrix &T)
{
	int i;
	for (i = 0; i < T.m; i++)
	{
		free(T.mat[i]);
	}
	free(T.mat);
}
//至此，动态申请矩阵就完成了

```

#### 静态申请矩阵存储空间

静态存储实现，该方法的好处是简单以实现；相对于第一种方法的缺点是：
1）静态实现，**不能动态的申请和释放空间**，对电脑内存要求高；
2）对于将矩阵作为函数返回值的情况，不能使用该方法。

```
double matrix[10][15];
//静态矩阵的初始化
for (i=0;i<10;i++)
{
	for(j=0;j<15;j++)
	{
		matrix[i][j]=0;
	}
}
```


### 矩阵输入

```
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
int main()
{
    int a[10][10],n;
    int i,j;
    printf("输入数字矩阵的维数(1<n<10) n= ");
    scanf("%d",&n);
    if(n<2||n>9)return 0;
    srand((int)time(0));
    for(i=0;i<n;i++)for(j=0;j<n;j++)a[i][j]=rand()%10;
    printf("\n为你产生的 %d 阶随机矩阵为：\n",n);
    for(i=0;i<n;i++){for(j=0;j<n;j++)printf("%2d",a[i][j]);printf("\n");}
    return 0;
}
```

### 矩阵生成

> [C语言生成随机可逆方阵](http://blog.csdn.net/liu1075538266/article/details/51484985)

```
int a[5][5]={0};//先把5阶矩阵中所有元素值附0
int i=0,k=0;
for( ; i<5;i++)
 for ( ; k<5;k++)
  {
   if(i==k) a[i][k]=1;
   }
```

```
int i,j;
for(i=0;i<5;i++)
for(j=0;j<5;j++)
a[i][j]=0;//全部赋值0
for(i=0;i<5;i++)
a[i][i]=1;//主对角线赋值1
```

```
int i,j,a[5][5]={0};//全赋值为0；
for(i=0;i<5;i++)
a[i][i]=a[i][4-i]=1;//两条主对角线都赋值为1；
for(i=0;i<5;i++)
{
for(j=0;j<5;j++)
printf("%2d",a[i][j]); printf("\n");
}
}
```

- 函数型

```
void getIdentityMatrix(int n, int** array)  
{  
        int r = 0;  
        int c = 0;  

        for(r = 0; r < n; ++r)  
        {  
                for(c = 0; c < n; ++c)  
                {  
                        if(r == c)  
                                array[r][c] = 1;  
                        else  
                                array[r][c] = 0;  
                }  
        }  

}  
```

```
void getIdentityMatrix(int n, double *array)  
{  
	int r = 0;  
	int c = 0;  

	for(r = 0; r < n; ++r)  
	{  
		for(c = 0; c < n; ++c)  
		{  
			if(r == c)  
				array[n*r+c] = 1;  
			else  
				array[n*r+c] = 0;  
		}  
	}  

}  
```

### 矩阵转数组

设新的一维向量为b[]，其长度应该是a的行维的长度（设为N），和列维长度M的乘积，即b共有M*N个元素，对于每一个下标k，有k = i*M + j，

```
for(int i = 0; i<N ;i++)
    for(int j = 0; j < M ; j++)
          b[i*M+j] = a[i][j];
```

### 数组赋值

把一维数组赋给另外一个一维数组：

1. 逐个赋值法。
    ```
    int a[10], b[10];
    int i;
    for(i = 0; i < 10; i ++)
        {
          b[i] = a[i];
    }
    ```
2. 整体复制法。

    ```
    int a[10], b[10];
    % memcpy声明与string.h中
    % 形式为 void * memcpy(void *dst, void *src, int length);
    memcpy(b,a,sizeof(a));
    ```

### 数组与数组指针

区别对待**数组指针**[^html/76]：arr 本身就是一个指针(这种表述并不准确，严格来说应该是“arr 被转换成了一个指针”。)，可以直接赋值给指针变量 p。arr 是数组第 0 个元素的地址，所以`int *p = arr`;也可以写作`int *p = &arr[0]`;。也就是说，arr、p、&arr[0] 这三种写法都是等价的，它们都指向数组第 0 个元素，或者说指向数组的开头。


[^html/76]: [C语言数组指针（指向数组的指针）](http://c.biancheng.net/cpp/html/76.html)


数组名是常量，它的值不能改变，而数组指针是变量（除非特别指明它是常量），它的值可以任意改变。也就是说，数组名只能指向数组的开头，而数组指针可以先指向数组开头，再指向其他元素。

    ```
    int arr[] = { 99, 15, 100, 888, 252 };
    int *p = arr;
    ```

### 数组作为函数参数

数组用作函数参数有两种形式[^html/61]，一种是把数组元素（下标变量）作为实参使用；另一种是把数组名作为函数的形参和实参使用。

[^html/61]: [C语言数组作为函数参数](http://c.biancheng.net/cpp/html/61.html)

用数组名作函数参数时，则要求形参和相对应的实参都必须是类型相同的数组，都必须有明确的数组说明。当形参和实参二者不一致时，即会发生错误。

在数组名作函数参数时所进行的传送只是地址的传送，也就是说把实参数组的首地址赋予形参数组名。形参数组名取得该首地址之后，也就等于有了实在的数组。实际上是形参数组和实参数组为同一数组，共同拥有一段内存空间。

## 类与结构体

类是从C语言中的结构体演变而来，结构体的成员变量也就演化成类的成员变量，这时类只能存放数据。为了在类内部操纵这些数据，增加了成员函数的功能。所谓成员函数就是在类的内部定义，用来操作类的成员变量的函数。随后对成员变量和成员函数附上“私有”、“保护”和“公共”的访问权限，于是“类”便大致成型。事实上，C++中结构体的功能大致和类相当，也有了成员函数。“成员”是成员变量和成员函数的统称[^Cpp/Cpp05]。

[^Cpp/Cpp05]: [《C++语言教程》05章 类](http://www.quanxue.cn/qt_xiaoya/Cpp/Cpp05.html)

## 矩阵求逆

```
#include<stdio.h>
#define N 10
int getA(int arcs[N][N],int n)//按第一行展开计算|A|
{
	if(n==1)
	{
		return arcs[0][0];
	}
	int ans = 0;
	int temp[N][N];
	int i,j,k;
	for(i=0;i<n;i++)
	{
		for(j=0;j<n-1;j++)
		{
			for(k=0;k<n-1;k++)
			{
				temp[j][k] = arcs[j+1][(k>=i)?k+1:k];

			}
		}
		int t = getA(temp,n-1);
		if(i%2==0)
		{
			ans += arcs[0][i]*t;
		}
		else
		{
			ans -=  arcs[0][i]*t;
		}
	}
	return ans;
}
void getAStart(int arcs[N][N],int n,int ans[N][N])//计算每一行每一列的每个元素所对应的余子式，组成A*
{
	if(n==1)
	{
		ans[0][0] = 1;
		return;
	}
	int i,j,k,t;
	int temp[N][N];
	for(i=0;i<n;i++)
	{
		for(j=0;j<n;j++)
		{
			for(k=0;k<n-1;k++)
			{
				for(t=0;t<n-1;t++)
				{
					temp[k][t] = arcs[k>=i?k+1:k][t>=j?t+1:t];
				}
			}


			ans[j][i]  =  getA(temp,n-1);
			if((i+j)%2 == 1)
			{
				ans[j][i] = - ans[j][i];
			}
		}
	}
}

int main()
{
    int arcs[N][N];
	int astar[N][N];
	int i,j;
	int n;
	while(scanf("%d",&n)!=EOF && n)
	{
		for(i=0;i<n;i++)
		{
			for(j=0;j<n;j++)
			{
				scanf("%d",&arcs[i][j]);
			}
		}

		int a = getA(arcs,n);
		if(a==0)
		{
			printf("can not transform!\n");
		}
		else
		{
			getAStart(arcs,n,astar);
			for(i=0;i<n;i++)
			{
				for(j=0;j<n;j++)
				{
					printf("%.3lf ",(double)astar[i][j]/a);
				}
				printf("\n");
			}
		}
		printf("\n");

	}


	return 0;
}

```

## 生成随机数

> [浅谈C语言中如何取随机数](http://blog.sina.com.cn/s/blog_574f9aa00100rkis.html)  
> [用C语言的rand()和srand()产生伪随机数的方法总结](http://blog.csdn.net/ns_code/article/details/26935509)  
> [C语言：随机函数rand()、srand()、random()和randomized()的区别和用法](http://blog.sina.com.cn/s/blog_63c66eb60100sc0x.html)  
> [C语言产生满足正态分布的随机数](http://blog.sina.com.cn/s/blog_70a14458010155b8.html)  
>


[C语言产生标准正态分布或高斯分布随机数](http://www.cnblogs.com/tsingke/p/6194737.html):


```
#include
#include

#define NSUM 25

double gaussrand()
{
     double x = 0;
     int i;
     for(i = 0; i < NSUM; i++)
     {
         x += (double)rand() / RAND_MAX;
     }

     x -= NSUM / 2.0;
     x /= sqrt(NSUM / 12.0);

     return x;
}
```

## JACOBIAN METHOD

> [Code for JACOBIAN METHOD in C Programming](http://www.dailyfreecode.com/code/jacobian-method-2374.aspx)  
> [computes all eigenvalues and eigenvectors](http://jean-pierre.moreau.pagesperso-orange.fr/Cplus/ujacobi_cpp.txt)  
> [parallel implementation of Jacobi's method for solving the linear system](http://heather.cs.ucdavis.edu/~matloff/158/Jacobi.c)  
> [NUMERICAL SOLUTION OF A STIFF (OR DIFFERENTIAL ALGEBRAIC) SYSTEM OF FIRST 0RDER ORDINARY DIFFERENTIAL EQUATIONS](http://www.unige.ch/~hairer/prog/stiff/radau.f)


```
n = no of equations
a[n]n] = coefficient matrix
b[n]= right hand side vector

x[n] - solution vector

bool jacobi (double a[][MAXSIZE], double b[], int n, int maxiter, double tol, double x[])

{
   int numiter = 0;
   bool tolexceeded = true;
   int i, j;
   double xold[MAXSIZE];
   double sum;

   for (i = 0; i < n; i++)
     x[i] = b[i]/a[i][i];

   while(tolexceeded && numiter < maxiter)
   {
     for(i = 0; i <n; ++i)
      xold[i] = x[i];

     for (i = 0; i < n; ++i)
       {
         sum = b[i];
         for(j = 0; j < n; ++j)
            if(i != j)
              sum -= a[i][j] * xold[j];

         x[i]= sum/aa[i][i];
       }
       tolexceeded = false;
       for (i = 0; i < n; i++)
        if (fabs(x[i] -xold[i]) > fabs(xold[i] * tol))
           tolexceeded = true;
       ++numiter;
}
  return tolexceeded;
```

## Cholesky分解

Cholesky分解法又称三角分解法，或称因子化法。

设线性方程组$AX=b$（1），式中A为对称、正定的矩阵。对于对称、正定的矩阵A，可进行分解 $A=LD{L^T}$（2），式中L是下单位三角阵，D是对角线矩阵。 右端项列向量（列阵）也作相应的分解$b=LD{b'}$（3）。将式（2）和式（3）代入方程（1），得到上三角方程组${L^T}x={b'}$。再按诸如高斯消元法的回代过程就可解出$x$。[^73e7413a]

[^73e7413a]: [Cholesky分解法的思想及C语言编程](https://wenku.baidu.com/view/73e7413a0740be1e640e9a1b.html)

```
#include<stdio.h>
#include<math.h>
#include<iostream.h>
#define N 4  
void Cholesky(int n,double A[N][N],double x[N],double b[N])
{  
  int i,j,k;   
  double L[N][N],D[N][N],b2[N];
  i=1;   
  D[i-1][i-1]=A[i-1][i-1];  
  for(i=2;i<=n;i++)  
  {   
    j=1;    
    L[i-1][j-1]=A[i-1][j-1]/D[j-1][j-1];   
    if(j==i-1)    
    {       
      D[i-1][i-1]=0;
      for(k=1;k<=i-1;k++)
      D[i-1][i-1]+=pow(L[i-1][k-1],2)*D[k-1][k-1];
      D[i-1][i-1]=A[i-1][i-1]-D[i-1][i-1];
      continue;   
    }   
      else   
      {       
        for(j=2;j<=i-1;j++)       
        {
          L[i-1][j-1]=0;
          for(k=1;k<=j-1;k++)
          L[i-1][j-1]+=L[i-1][k-1]*L[j-1][k-1]*D[k-1][k-1];
          L[i-1][j-1]=(A[i-1][j-1]-L[i-1][j-1])/D[j-1][j-1];
          if(j==i-1)      
          {         
            D[i-1][i-1]=0;
            for(k=1;k<=i-1;k++)
            D[i-1][i-1]+=pow(L[i-1][k-1],2)*D[k-1][k-1];
            D[i-1][i-1]=A[i-1][i-1]-D[i-1][i-1];
            continue;    
            }    
        }     
      }      
   }  
   i=1;    
   b2[i-1]=b[i-1]/D[i-1][i-1];
   for(i=2;i<=n;i++)
   {    
     b2[i-1]=0;        
     for(k=1;k<=i-1;k++)
     b2[i-1]+=L[i-1][k-1]*D[k-1][k-1]*b2[k-1];
     b2[i-1]=(b[i-1]-b2[i-1])/D[i-1][i-1];    
    }  
    x[n-1]=b2[n-1]   
    for(i=n-1;i>=1;i--)   
    {       
      x[i-1]=0.0;       
      for(k=i+1;k<=n;k++)       
      x[i-1]+=L[k-1][i-1]*x[k-1];       
      x[i-1]=b2[i-1]-x[i-1];    
    }  
    for(i=0;i<=n-1;i++)     
    printf("%f\n",x[i]);  
  }  

  void main()
  {  
    double A[4][4]={{1,2,1,3},{2,3,-5,4},{1,-5,5,-1},{3,4,-1,7}};
    double x[4]={0};  
    double b[4]={12,16,18,20}; Cholesky(4,A,x,b);
  }
```

[Cholesky decomposition](https://rosettacode.org/wiki/Cholesky_decomposition#C):

```
#include <stdio.h>
#include <stdlib.h>
#include <math.h>

double *cholesky(double *A, int n) {
    double *L = (double*)calloc(n * n, sizeof(double));
    if (L == NULL)
        exit(EXIT_FAILURE);

    for (int i = 0; i < n; i++)
        for (int j = 0; j < (i+1); j++) {
            double s = 0;
            for (int k = 0; k < j; k++)
                s += L[i * n + k] * L[j * n + k];
            L[i * n + j] = (i == j) ?
                           sqrt(A[i * n + i] - s) :
                           (1.0 / L[j * n + j] * (A[i * n + j] - s));
        }

    return L;
}

void show_matrix(double *A, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            printf("%2.5f ", A[i * n + j]);
        printf("\n");
    }
}

int main() {
    int n = 3;
    double m1[] = {25, 15, -5,
                   15, 18,  0,
                   -5,  0, 11};
    double *c1 = cholesky(m1, n);
    show_matrix(c1, n);
    printf("\n");
    free(c1);

    n = 4;
    double m2[] = {18, 22,  54,  42,
                   22, 70,  86,  62,
                   54, 86, 174, 134,
                   42, 62, 134, 106};
    double *c2 = cholesky(m2, n);
    show_matrix(c2, n);
    free(c2);

    return 0;
}
```

[cholesky.c](https://www.stat.uchicago.edu/~mcpeek/software/MQLS/cholesky.c)：

```
/* file: choesky.c */

/* Take the cholesky decomposition in the manner described in FA Graybill
   (1976).
*/

#include <math.h>
#include <stdio.h>
#include <stdlib.h>


int cholesky(double **orig, int n, double **aug, int mcol,double **chol, double **cholaug, int ofs)
     /*
	Do the augmented cholesky decomposition as described in FA Graybill
	(1976) Theory and Application of the Linear Model. The original matrix
	must be symmetric positive definite. The augmentation matrix, or
	series of column vectors, are multiplied by C^-t, where C is the
	upper triangular cholesky matrix, ie C^t * C = M and M is the original
	matrix. Returns with a value of 0 if M is a non-positive definite
	matrix. Returns with a value of 1 with succesful completion.

	Arguments:

	orig (input) double n x n array. The matrix to take the Cholesky
	      decomposition of.
	n    (input) integer. Number of rows and columns in orig.
	aug  (input) double n x mcol array. The matrix for the augmented
	      part of the decomposition.
	mcol (input) integer. Number of columns in aug.
	chol (output) double n x n array. Holds the upper triangular matrix
	      C on output. The lower triangular portion remains unchanged.
	      This maybe the same as orig, in which case the upper triangular
	      portion of orig is overwritten.
	cholaug (output) double n x mcol array. Holds the product C^-t * aug.
	         May be the same as aug, in which case aug is over written.
	ofs (input) integer. The index of the first element in the matrices.
	     Normally this is 0, but commonly is 1 (but may be any integer).
     */
{
   int i, j, k, l;
   int retval = 1;

   for (i=ofs; i<n+ofs; i++) {
      chol[i][i] = orig[i][i];
      for (k=ofs; k<i; k++)
	 chol[i][i] -= chol[k][i]*chol[k][i];
      if (chol[i][i] <= 0) {
	 fprintf(stderr,"\nERROR: non-positive definite matrix!\n");
	 printf("\nproblem from %d %f\n",i,chol[i][i]);
	 retval = 0;
	 return retval;
      }
      chol[i][i] = sqrt(chol[i][i]);

      /*This portion multiplies the extra matrix by C^-t */
      for (l=ofs; l<mcol+ofs; l++) {
	 cholaug[i][l] = aug[i][l];
	 for (k=ofs; k<i; k++) {
	    cholaug[i][l] -= cholaug[k][l]*chol[k][i];
	 }
	 cholaug[i][l] /= chol[i][i];
      }

      for (j=i+1; j<n+ofs; j++) {
	 chol[i][j] = orig[i][j];
	 for (k=ofs; k<i; k++)
	    chol[i][j] -= chol[k][i]*chol[k][j];
	 chol[i][j] /= chol[i][i];
      }
   }

   return retval;
}
```

## 矩阵的逆

> [（数学概念）矩阵的逆、伪逆、左右逆，最小二乘，投影矩阵](http://www.mm18.net/knowledge/matrix/10945435174894770661.html)

A是可逆矩阵的充分必要条件是，即可逆矩阵就是非奇异矩阵。

伪逆矩阵是逆矩阵的广义形式。由于奇异矩阵或非方阵的矩阵不存在逆矩阵，但在matlab里可以用函数pinv(A)求其伪逆矩阵。基本语法为X=pinv(A),X=pinv(A,tol),其中tol为误差,pinv为pseudo-inverse的缩写：`max(size(A))*norm(A)*eps`。函数返回一个与A的转置矩阵A' 同型的矩阵X，并且满足：AXA=A,XAX=X.此时，称矩阵X为矩阵A的伪逆，也称为广义逆矩阵。pinv(A)具有inv(A)的部分特性，但不与inv(A)完全等同。 　如果A为非奇异方阵，pinv(A)=inv(A)，但却会耗费大量的计算时间，相比较而言，inv(A)花费更少的时间。

广义逆阵(generalized inverse)也称为伪逆矩阵(pseudoinverse)，是在数学矩阵领域内的名词，一矩阵A的广义逆阵是指另一矩阵具有部分逆矩阵的特性，但是不一定具有逆矩阵的所有特性。假设一矩阵A∈Rn*m及另一矩阵Ag∈m*n，若Ag满足此条件，AAgA=A，则Ag即为A的逆矩阵。构建广义逆阵的目的是针对可逆矩阵以外的矩阵(例如非方阵的矩阵)可以找到一矩阵有一些类似逆矩阵的特性。任意的矩阵都存在广义逆阵，若一矩阵存在逆矩阵，逆矩阵即为其唯一的广义逆阵。有些广义逆阵可以定义在和结合律乘法有关的数学结构中。可以借助SVD(奇异值分解)来求解伪逆。

假定拟计算一般矩阵A的Moore-Penrose广义逆A+, 1)对A做SVD: A = U S V, 其中 U, V为酉方阵, S为一般对角阵; 2)将S非零元取逆, 零元不变, 然后专置得到一个一般对角阵T; 3)则广义逆为A+ = V* T U*, 其中 * 表示取矩阵的复共轭.

1. [采用C++和OpenCV实现的求矩阵伪逆](http://www.php361.com/index.php?c=index&a=view&id=3137)

1. [矩阵求逆的几种方法总结（C++）](http://www.aichengxu.com/cyvyan/24640054.htm)

## 读取数据

> [C语言操作Excel表格](http://blog.csdn.net/u011944141/article/details/38043155)

- 从TXT文件中读写数据

```
#include <stdio.h>  

int main()  
{  
    //下面是写数据，将数字0~9写入到data.txt文件中  
    FILE *fpWrite=fopen("data.txt","w");  
    if(fpWrite==NULL)  
    {  
        return 0;  
    }  
    for(int i=0;i<10;i++)  
        fprintf(fpWrite,"%d ",i);  
    fclose(fpWrite);  
    //下面是读数据，将读到的数据存到数组a[10]中，并且打印到控制台上  
    int a[10]={0};  
    FILE *fpRead=fopen("data.txt","r");  
    if(fpRead==NULL)  
    {  
        return 0;  
    }  
    for(int i=0;i<10;i++)  
    {  
        fscanf(fpRead,"%d ",&a[i]);  
        printf("%d ",a[i]);  
    }  
    getchar();//等待  

    return 1;  
}
```

```
#include "stdio.h"
#define M 300
#define N 50

void main()
{
 int i,j;
 float a[M][N]={0};
 FILE *fp;
 if((fp=fopen("test.txt","rt"))==NULL)
 {
  printf("cannot open file\n");
  return;
 }
 for(i=0;i<M;i++)
 {
 for(j=0;j<N;j++)
  fscanf(fp,"%f",&a[i][j]);
 fscanf(fp,"\n");
}
 fclose(fp);
 for(i=0;i<M;i++)
 {
 for(j=0;j<N;j++)
     printf("%g ",a[i][j]);
   printf("\n");
}
}
```

## 输出显示

### printf函数

printf函数[^html/33]是一个标准库函数，它的函数原型在头文件“stdio.h”中。但作为一个特例，不要求在使用 printf 函数之前必须包含stdio.h文件。

[^html/33]: [C语言格式输出函数printf()详解](http://c.biancheng.net/cpp/html/33.html)

`printf(“格式控制字符串”, 输出表列)`：其中格式控制字符串用于指定输出格式。格式控制串可由格式字符串和非格式字符串两种组成。格式字符串是以%开头的字符串，在%后面跟有各种格式字符，以说明输出数据的类型、形式、长度、小数位数等。如：  

- “%d”表示按十进制整型输出；  
- “%ld”表示按十进制长整型输出；  
- “%c”表示按字符型输出等。  

### 输出数组

先定义这个数组有几个元素，否则会不能现返回值！

- 下标法

    ```
    #include<stdio.h>
    void main()
    {
      int a[5] ;
      int n;
      printf("Please input words:");
      for(n=0;n<5;n++)
      scanf("%d",&a[n]);
      printf("\n");
      for(n=0;n<5;n++)
      printf("%d",a[n]);
      printf("\n");
    }
    ```

- 通过数组名计算数组元素地址，找出元素的值

    ```
    #include<stdio.h>
    void main()
    {
            int a[5] ;
            int n;
            printf("Please input words:");
            for(n=0;n<5;n++)
            scanf("%d",&a[n]);
            printf("\n");
            for(n=0;n<5;n++)
            printf("%d",*(a+i));
            printf("\n");
    }
    ```

- 用指针变量指向数组元素

    ```
    #include<stdio.h>
    void main()
    {
            int a[5] ;
            int *p,n;
            printf("Please input words:");
            for(n=0;n<5;n++)
            scanf("%d",&a[n]);
            printf("\n");
            for(p=a;p<(a+10);p++)
            printf("%d",*p);
            printf("\n");
    }
    ```

### 输出矩阵


```
#include <stdio.h>
int main()
{
    int i,j,k=1;
    for(i=0;i<10;i++)
    {
        for(j=0;j<10;j++,k++)
        if(i>j)printf("   ");
        else printf("%3d",k);
        printf("\n");
    }
    return 0;搜索
}
```

```
#include <stdio.h>
int main()
{
int a[10][10],i,j,k=0;
for(i=0;i<10;i++)
for(j=0;j<10;j++)
a[i][j]=++k;
for(i=0;i<10;i++)
{
for(j=0;j<10;j++)
if(j<i) printf(" ");
else printf("%3d ",a[i][j]);
printf("\n");
}
return 0;
}
```

```
#include <stdio.h>
int main()
{
int i,j,k=0;
for(i=0;i<10;i++)
{
for(j=0;j<10;j++)
if(j<i) {printf(" ");++k;}
else printf("%3d ",++k);
printf("\n");
}
return 0;
}
```


```
#include<stdio.h>
void main()
{
int a[10][10],i,j,k;
for(i=0;i<10;i++)
for(j=i;j<10;j++)
a[i][j]=i*10+j+1;
for(i=0;i<10;i++)
{	for(k=0;k<i;k++)
printf(" ");//中间四个空格，因为下面的输出控制了格式的%4d
for(j=i;j<10;j++)
printf("%4d",a[i][j]);
printf("\n");
}
}
```

# 结构图

> [程序流程图&盒图（N-S图）&PAD图](http://www.jianshu.com/p/4a339e558b5f)
]]></content>
      <categories>
        <category>Programming</category>
        <category>C/C++</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title>科技论文词汇与语法</title>
    <url>/vocabulary/</url>
    <content><![CDATA[
虽然大家的学科领域不同，但起承转合的论文写作逻辑套路是共通的，掌握了这些高频词汇和短语，了解了提示文章逻辑的连接词，又掌握了文章论述中惯用的表达方式，一定能帮您在SCI论文写作过程中更轻松容易，提高写作效率。

<!--more-->

# i.e.等

> [论文常用词汇i.e.，e.g.，etc.，viz.，et al.的前世今生](https://zhuanlan.zhihu.com/p/63640148)

i.e.是id est（“that is” , "in other words"。进一步解释用，意为：也就是）的缩写。目的是用来进一步解释前面所说的观点（不像后文的e.g.那样引入实例来形象化），意思是“那就是说，换句话说”。它后面最好紧跟着一个逗号，再跟一个解释。(看大量例句，发现有些句子的确省略了逗号，见例句1和例句2）

> 例句1：Each of these items are actionable, i. e. you can actually do them.  
例句2：The film is only open to adults, i.e. people over 18.  
例句3：And you have to cross reference this time/effort analysis to the results (i.e., the bugs) that the effort yielded.  

e.g.是exempli gratia（"for example; for instance;such as"。举例用，意为：例如）的缩写，其目的用若干例子来让前面说法更具体，更易感知。在使用中，最好把e.g.连同它的例子放在括号中，如例句2。

> 例句1: I like sports, e.g., football.  
例句2：I like most of sports activities (e.g., football).

i.e.和e.g.的区别：

> 例句1：I like to eat boardwalk food, i.e., funnel cake and french fries.  
例句2：I like to eat boardwalk food, e.g., funnel cake and french fries.

例句1表示只有 funnel cake and french fries这两种boardwalk食物，而且这两种我都喜欢。例句2表示我喜欢boardwalk食物，比如 funnel cake and french fries；但是诸如snow cones and corn dogs等其他类型，我也可能喜欢。

etc.是et cetera(“and so forth; and the others; and other things; and the rest; and so on"。举例用，意为：等等)的缩写。它放在列表的最后，表示前面的例子还没列举完，最后加个词“等等”。

etc.前面要有逗号。一般不要在e.g.的列表最后用etc( 在including后的列表后也不宜使用etc)。这是因为 e.g. 表示泛泛的举几个例子，并没有囊括所有的实例，其中就已经包含“等等”，如果再加一个 etc. 就多余了。

> 例句1: I need to go to the store and buy some pie, milk, cheese, etc.

viz.是videlicet（ "namely", "towit", "precisely", "that is to say"。进一步解释用，意为：即）的缩写，与e.g.不同，viz位于同位列表之前，要把它前面单词所包含的项目全部列出。

> 例句1：The school offers two modules in Teaching English as a Foreign Language, viz. Principles and Methods of Language Teaching and Applied Linguistics.（该校提供两个模块用于英语作为外语的教学，即语言教学的原理方法和应用语言学。）  
例句2: In this paper, a new TDNN architecture with two input variable, viz. wave form and its phase difference, is developed to reduce the grain noise.（本文提出了一种新的TDNN结构用于降低粗晶材料结构噪声，该结构具有波形及其相位差组成的双变量输入。）

et al.是et alia（"and others; and co-workers"。在引用文献作者时用，意为:等其他人）的缩写。它几乎都是在列文献作者时使用，即把主要作者列出后，其它作者全放在et al. 里面。

et al.的前面不要逗号。人的场合用et al，而无生命的场合用etc.(et cetera)。

> 例句1: These results agree with the ones published by Pelon et al. (2002).  
例句2: Clegg et al. (1995) explain that in the electronics industry linear-programming models can be used to analyse the viability of the recovered parts in remanufacturing.（克莱格等人（1995）解释说，电子行业的线性规划模型可以用来分析在再制造过程中回收零部件的可行性。）




---
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>论文写作</tag>
      </tags>
  </entry>
  <entry>
    <title>电脑装机说明</title>
    <url>/windows-install-list/</url>
    <content><![CDATA[
{% centerquote %}电脑装机推荐流程{% endcenterquote %}

<!--more-->


电脑使用建议：

- [国产装机神器Ventoy](https://github.com/ventoy/Ventoy)
- 桌面尽量不要保存文件，下载内容可以临时放桌面。当天结束后清理桌面文件，顺便文件归档、整理工作。
- 常用程序固定到开始菜单。
- 常用的文件夹、应用软件拖到任务栏，在资源管理器的跳转列表里固定，或者在常用的工作文件夹右键选择‘固定到快速访问’，以后在任务栏直接右键就可以找到。
- 常用的文件夹可以建立库文件，方便快速访问。
- WIN10多出了快捷键和分屏功能，键盘操作比鼠标方便很多，建议[学习使用快捷键](https://sli1989.github.io/windows-use/#shortcut-key)。
- 简化你的重复性工作，一键自动化启动或运行程序等等，以此提高我们的**工作效率**，推荐[使用AutoHotkey脚本](https://sli1989.github.io/windows-use/#autohotkey)。

系统优化操作（更多工具点击查看[优雅高效地使用WINDOWS](https://sli1989.github.io/windows-use/)）：

1. 所有安装程序放置在`/安装程序`文件夹。
4. 使用`pcmaster`替换系统管理功能，具有垃圾清理、软件管家等功能。优化系统设置。关闭系统休眠功能。优化开机启动项。关闭系统记录隐私，禁止系统记录最近浏览文件， 禁止系统记录最近运行程序。
5. 安装`cclearner`垃圾清理，每天开机后手动右键垃圾箱选择运行cclearner即可，运行完后会自动关闭。卸载系统无用应用程序。<font color=blue>不用升级</font>。
4. 已使用解压工具`7z`，<font color=red>不要升级</font>，在软件管家中忽略。
4. <font color=blue>常用程序尽量不要使用自带应用商店程序，独立安装</font> 。
5. 安装护眼宝过滤蓝光，设置自启动，其他不用设置。
5. 安装`everything`软件（绿色版），快速查找电脑文件，已固定到任务栏，<font color=blue>不用升级</font>。推荐[结合listary使用](https://sli1989.github.io/windows-use/#search)。
6. 配置PDF阅读器：
    - 安装`pdfxchang`软件并设置为默认程序，可以用于页面旋转/提取/删除，<font color=red>不要升级</font>。
    - 安装破解`Adobe Acrobat XI`，可以用于将pdf另存为word等。如需使用此程序打开pdf，选择打开方式为`Adobe Acrobat XI`，<font color=red>不要升级</font>。
    - `/安装程序/PDFPasswordRemover3.0`可以用于解除pdf编辑限制。
7. 安装设置chrome浏览器，并设置为默认浏览器，直接在搜索栏输入即可实现谷歌搜索（[谷歌访问配置](https://sli1989.github.io/windows-use/#google)），所有网站尽量使用`https://`开头。下载文件默认存放在桌面，然后手动移动。保留了edge浏览器和id浏览器快捷方式在开始桌面。
    - [Proxy SwitchyOmega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif) Chrome 插件
    - [二管家](https://chrome.google.com/webstore/detail/nooboss/aajodjghehmlpahhboidcpfjcncmcklf) Chrome 插件
8. 安装[广告终结者](https://chrome.google.com/webstore/detail/%E5%B9%BF%E5%91%8A%E7%BB%88%E7%BB%93%E8%80%85/fpdnjdlbdmifoocedhkighhlbchbiikl)Chrome插件。
1. 配置[百度网盘快速下载](https://sli1989.github.io/bdy/#IDM)，下载工具使用`Internet Download Manager`，并设置自启动，可以快速下载。正常情况下，点击选择下载或者右键选择使用IDM下载，会跳转到IDM下载页面。如果失效，需要手动查看下载链接（在chrome中`ctrl+j`查看），并复制下载链接到IDM或者迅雷，建立下载任务。放置了IDM和迅雷绿色版快捷方式在开始桌面，<font color=red>不要升级IDM和迅雷</font>。
    - [IDM Integration Module](https://chrome.google.com/webstore/detail/idm-integration-module/ngpampappnmepgilojfohadhhmbhlaek) Chrome 插件
    - [Tampermonkey](https://chrome.google.com/webstore/detail/tampermonkey/dhdgffkkebhmkfjojejmpbldmpobfkfo) Chrome 插件
11. 视频播放器使用PotPlayer（绿色版），把视频文件直接拖入即可播放，<font color=blue>不用升级</font>。

---

Office2016安装步骤：

1. 解压或直接打开`SW_DVD5_Office_Professional_Plus_2016_64Bit_ChnSimp_MLF_X20-42426.ISO`；
2. 双击`setup.exe`安装，可以自定义安装位置，其他均可默认安装；
3. 如果需要`Visio`，可以同时安装，解压或直接打开`SW_DVD5_Visio_Pro_2016_64Bit_ChnSimp_MLF_X20-42759.ISO`，双击`setup.exe`安装。

Office/Win激活步骤：

1. 解压`KMSpico Portable.rar`，并**保留压缩包**。
1. 进入`KMSpico Portable`找到`Auto (Run as Admin).cmd`，单击右键选择`管理员运行`（如果安全软件报毒请添加`该程序的全部信任`），等待`激活完成`语音提示后删除解压后的文件即可。如果后期激活失效，<font color=blue>重新运行第四步</font>重新运行第四步即可。

---

WinPE安装xp教程：

1. 首先需要制作自己的WINPE U盘或WINPE光盘
1. 根据启动媒质类型，把BIOS启动项修改为U盘或光驱优先加载项，比如制作的是WINPE U盘则要把BIOS启动项修改为从USB设置启动，如果是WINPE 光盘，则需要把BIOS设置从光盘启动。
1. 选择第一项进入WinPE迷你维护系统。等待启动完成
1. 用`虚拟光驱工具`加载系统镜像文件，光驱盘符我这里假设为A.
1. 请检查将要安装的系统盘（假设是C盘）是否还有数据需要备份，否则可以把该分区先快速格式化一下。如果是使用U盘版的WINPE引导的，这时候把U盘强制拔下来，防止操作系统认错盘符把启动文件拷贝到U盘中，这一步很重要，然后再双击上图中的`SETUP.EXE`
1. 选择“安装Microsoft Windows XP”一项，开始安装XP，默认安装类型是升级安装，请改为全新安装（高级）类型，点击下一步。
1. 如下图，接受许可协议，点击下一步：
1. 如下图，输入密钥`MRX3F-47B9T-2487J-KWKMF-RPWBY`后，并点击下一步：
1. 这一步是安装语言和区域选择，默认即可，我们点击“高级选项...”：
1. 高级选项设置图如下，选中我想在安装过程中选择安装驱动器号和磁盘分区一项，点击确定，并点击上图的下一步（特别注意下图中变灰一项，如果是用虚拟光驱安装到这里，一定要选择<font color=red>从安装CD复制所有安装文件</font>，否则再次重启就找不到源安装文件了。）。
1. 这一步选择是否升级到NTFS系统，如果系统盘已经是NTFS选择否即可，如果是FAT也可以选择是、否都可以，不确定就点否，跳过。下一步：
1. 这是选择是否获取更新，选择“否”，跳过这一步继续安装，点击下一步。

---
]]></content>
      <categories>
        <category>Software</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>优雅高效地使用Windows</title>
    <url>/windows-use/</url>
    <content><![CDATA[
{% centerquote %}电脑实用技巧与软件，优化电脑环境，提高工作效率。{% endcenterquote %}

<!--more-->

> [我最喜爱的软件windows版](http://love.appinn.com/)  
> [Windows下效率必备软件](http://www.jeffjade.com/2015/10/19/2015-10-18-Efficacious-win-software/)

# WIN10

WIN10系统多出了许多快捷键和分屏功能，推荐使用。

## 开启管理员账户

为了防止高权限账户被滥用影响系统安全，Administrator账户被默认关闭和隐藏。开启方式如下：

方法一

- 按住键盘`Windows+R`
- 输入：`secpol.msc`，回车(确认)，来到`本地安全策略编辑器`
- 依次打开：`安全设置>本地策略>安全选项>用户帐户控制：用于内置管理员帐户的管理审批模式`，然后，双击或者右键属性，选择`已启用`，点击`应用`，再点`确定`
- 重启电脑

方法二

- 打开控制面板
- 依次打开：`管理工具–本地安全策略–本地策略–安全选项`，找到`用户帐户控制:用于内置管理员帐户的管理审批模式式`，双击或者右键`属性`，选择`已启用`，点击`应用`，再点`确定`
- 重启电脑

方法三

- 如果上述方法不成功，按住键盘，`Windows+R`，按下之后，在里头输入：`regedit`，回车，打开注册表编辑器。 在注册表编辑器中定位到以下位置（依次打开）`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System`。
- 在右边找到`FilterAdministratorToken`，双击后将数值数据改为`1`后点击`确定`。注意：如果右边没有这个`FilterAdministratorToken`，则需要手动在右边空白处点击鼠标右键，新建DWORD（32位）值，并更名为`FilterAdministratorToken`，将其数值数据改为1。
- 依次找到`HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System \UIPI`，右边有个默认的项，将它的值改成1。
- 重启电脑

<div id="shortcut-key"></div>

## 快捷键技巧

> [Win10方便快捷的操作小技巧](http://iknow.lenovo.com/detail/dc_KB022222.html)

- Win+E：调出资源管理器。
- Win+D：显示桌面
- Win+X：打开简易版开始菜单，这个用来启动一些系统级程序还是很方便的。
- Win+A：激活操作中心
- Win+Tab：Win7时代的Flip3D（3D窗口切换器），到了Win10中变成了虚拟桌面切换器。
- 多桌面，提高效率：`WIN+TAB`新建多桌面。
    - Win+Ctrl+D：创建新的虚拟桌面
    - Win+Ctrl+F4：关闭当前虚拟桌面
    - Win+Ctrl+左/右方向键：切换虚拟桌面
- Win+左/右/上/左上/左下/右上/右下：将窗口快速缩放至1/2分屏、1/4分屏，其中1/4分屏为Win10新增功能，对应快捷键为Win+左上/左下/右上/右下。更多功能介绍[点击](http://www.pconline.com.cn/win10/674/6748976.html)查看。
- Win+M：最小化所有窗口
- Win+L：锁定系统
- Win+P：投影到投影仪或第二个显示器
- Win + R ：Run，打开运行窗口
- Alt + 双击 ：查看文件属性

## 开始菜单布局备份还原

在WIn10系统中，我们可以在开始菜单上添加常用软件的磁贴，并可以随心摆放磁贴位置。

win10开始菜单布局备份还原的操作方法：

1. 在Win10系统下，打开此电脑中的一个盘符，然后在空白处点击右键，在弹出菜单中选择`新建/文件夹`菜单项，建立一个新的文件夹；
2. 把新建文件夹重命名为start（或其他）；
3. 按下Win+R打开运行窗口，输入命令powershell，然后点击确定按钮；
4. 这时就会打开Windows Powershell窗口，在这里输入命令`Export-startlayout –path c:\start\start.xml`，其中`c：\start`就是我们刚刚在上面建立的文件夹，你可以根据自己实际情况来设置相应的路径；
5. 按下回车键后，就会在新文件夹中备份好开始菜单的布局文件；
6. 如果需要恢复开始菜单布局的话，只需要再次打开Windows Powershell命令行窗口，然后输入命令`import-startlayout -layoutpath c:\start\start.xml -mountpath c:`，按下回车键后，即可恢复布局！

## 在线账户改用本地账户

本地启用Administrator，然后登陆Microsoft账户，结果就导致本地Administrator和Mircrosoft合二为一，且没有断开连接和改用本地账户选项。

具体操作如下：

1. 按下WIN+R打开运行，输入regedit 回车，打开注册表编辑器；
2. 定位于`HKEY_LOCAL_MACHINE\SAM\SAM`，这时我们无法看到SAM下的任何东西，其实是有的！右键点击 **选择权限**；选中Administrator 然后设置为完全控制。
3. 回到注册表，F5 刷新一下，这时我们就可以看到`HKEY_LOCAL_MACHINE\SAM\SAM `下还有东西了，再定位到`\Domains\Account\Users\Names\`；
4. 记下`Names\Administrator`项默认值 `0x{ID}`，并记下ID（每个电脑不同），然后我们就可以到User下选中`0x{ID}`；存在如下几个键值数据项，对其删除。
    ```
    Surname
    InternetUserName
    InternetUID
    InternetSID
    InternetProviderGUID
    ```
1. 删除之后，重启电脑，这时你会发现登录界面还是需要密码的【登录名也还是微软帐户的名字】，你还是用你之前的密码登录；
2. 回到桌面，右键点击【此电脑】管理，然后找到【用户和组】-【用户】，找到Administrator，把全名去掉，应用；
3. 右键点击更改密码，清除密码，如果你还不需要的话，注销一下试试，是不是变回到Administrator了呢。

## 右键卡顿BUG修复

2017年10月17下午4点微软推送了win10秋季创意者更新版1709的更新补丁，不少用户在更新完成后反应在桌面上右键会有卡顿1秒的现象。右键空白处时，会出现小阵的卡顿才弹出右键菜单，重启电脑依然存在这个卡顿问题出现这样的情况似乎因为显卡驱动的菜单也导致的。

步骤：

1. 在小娜框中搜索 `regedit`  按下回车键打开 注册表编辑器；
1. 在注册表中依次展开：计算机`\HKEY_CLASSES_ROOT\Directory\Background\shellex\ContextMenuHandlers ` 也可以在注册表的顶部地址栏中直接粘贴该段地址；
1. 展开`ContextMenuHandlers` ，我们可以看到下面有3-5个项，我们只保留 `new` 和 `workFolders` 两个项，将其他的项删除即可。
1. 删除后关闭注册表，在桌面单击右键，发现问题解决，不会有卡顿的现象，点击右键会马上弹出菜单！

## 双硬盘卡顿

莫名其妙出现SSD+机械双硬盘假死的问题，暂时无法解决，可以参考如下链接尝试：[安装Windows 10周年更新后出现冻屏](https://answers.microsoft.com/zh-hans/windows/forum/windows_10-performance/%E5%AE%89%E8%A3%85windows/b3f3a31d-a118-4c65-8b2a-7896c37bfb4e?rtAction=1475154264985&auth=1)，[Win10周年版系统冻结修复方案](http://www.pconline.com.cn/win10/830/8307500.html)，[方法1](https://www.zhihu.com/question/50821797)，[方法2](http://www.pconline.com.cn/win10/739/7395324.html)，[方法3](https://jingyan.baidu.com/article/3f16e003f73b7b2591c10383.html)。

## 远程桌面身份验证错误

升级至win10 最新版本10.0.17134，远程桌面连接Window Server时报错信息如下：`出现身份验证错误，要求的函数不正确，这可能是由于CredSSP加密Oracle修正。`

解决方法：

1. 运行 `gpedit.msc`
1. 本地组策略：`计算机配置>管理模板>系统>凭据分配>加密Oracle修正`，选择启用并选择易受攻击。

## 开机自动拨号上网

方法一：

1. 在计算机中找到`C:\Windows\System32\rasphone.exe`（创建快捷方式放在桌面上方便）双击运行，也可以用`win+R`打开`运行`输入`rasphone.exe`
2. 把这个快捷方式放到系统开机启动文件夹`C:\ProgramData\Microsoft\Windows\Start Menu\Programs`下的`启动`里就可以开机启动了

方法二：

1. 打开记事本输入 ：`CreateObject("WScript.Shell").run"Rasdial 宽带连接 帐号 密码",0`
2. 将句中帐号密码改为你的宽带连接帐户和密码，将记事本另存为:`自动拨号.vbs`
1. 把`自动拨号.vbs`文件拖到启动文件夹`C:\Users\你的用户名\\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup`里去就可以开机自动连接了。

方法三：

1. 打开记事本输入（第一行空行），并另存为`自动拨号.bat`文件。右键此文件，可以直接跳转所在目录。**更多设置在菜单栏`工具`-`选项`中**。
    ```
    Rasdial ADSL 你的帐号 你的密码
    ```
1. 把`自动拨号.bat`文件拖到启动文件夹`C:\Users\你的用户名\\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup`里去就可以开机自动连接了。

方法四：第三方使用软件。

<div id="win-wifi"></div>

## 开启WIFI热点

对于有无线网卡的电脑，宽带拨号连接无法创建WIFI热点。[可以尝试如下方法](https://jingyan.baidu.com/article/6d704a1341e34228db51cab6.html)：

1. 下载 `destop-wifi.bat` [文件](https://pan.baidu.com/s/1RbfakIl_wMAPXUW3byarTw)（提取码：ywcd），找到行 `netsh wlan set hostednetwork mode=allow ssid=xx key=xx` 编辑WIFI名称字段`ssid`、WIFI密码字段`key`，并保持。
1. 右键`以管理员方式运行`，依次输入序号`1`和序号`3`，可以看到这里多了一个`本地连接xx`。
2. 建立电脑正在使用的网络，也可以是宽带连接。
3. 右键`属性`，切换到`共享`的选项卡，勾选`允许其他……连接(N)`，并将`家庭网络连接`切换到我们刚才设置的`本地连接xx`，最后点击`确定`即可。
4. 如果需要关闭WIFI，管理员方式运行 `destop-wifi.bat` 文件，选择序号`4`。每次重启认证网络后，需要管理员方式运行 `destop-wifi.bat` 文件，选择序号`3`。

# 系统设置

## 桌面

可以只留一个回收站在桌面，每天关机前可以清理已完成工作，也可以很好的区分待完成工作。一些常用软件可以直接锁定在任务栏，直接点击就可以打开。同时也可以将常用软件固定在开始菜单，点击`WIN`就可以快速进入。

对于技术控，可以结合AutoHotkey设置系统的快捷键，快速启动程序。

可以把常用的文件夹、应用软件拖到任务栏，这样就会在资源管理器的跳转列表里固定，以后在任务栏直接右键就可以找到。习惯使用资源管理器导航栏。把常用的工作文件夹`固定到快速访问`，或者建立库文件快速访问。

<div id="autohotkey"></div>

## AutoHotkey

**[AutoHotkey](https://autohotkey.com/)** 是一个windows下的开源、免费、自动化软件工具。它由最初旨在提供键盘快捷键的脚本语言驱动(称为：**热键**)，随着时间的推移演变成一个完整的脚本语言。但你不需要把它想得太深，你只需要知道它可以简化你的重复性工作，一键自动化启动或运行程序等等；以此提高我们的**工作效率**，改善**生活品质**；通过按键映射，鼠标模拟，定义宏等。详细教程点击[轻松学会弹指神功](https://autohotkey.com/boards/viewtopic.php?t=4278)，[AutoHotkey 初学者向导](https://fjxhkj.github.io/ahk_doc/zh-cn/docs/Tutorial.htm)查看。

打开你的文本编辑器（notepad、或gVIM），新建一个文件为`myhotkey.ahk`。双击以后我们会看到任务栏右下角有个`H`图标，就表示它在运行了。我们在里面写入相应的映射代码然后右击`H`选择"reload this script"执行它就可以开始使用AutoHotkey里面设置好的功能了。

为了方便修改该脚本，你可以将其放置于你觉得方便的位置，丝毫不影响，双击可运行之。我们还可以为该脚本设置开机自启动，只需要将该脚本生成一个`快捷方式`，然后将此快捷方式放置到程序自启动文件夹`C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp`之下即可。

>**\#** 号代表 **_Win_** 键；  
**!** 号代表 **_Alt_** 键；  
**^** 号代表 **_Ctrl_** 键；  
**+** 号代表 **_shift_** 键；  
**::** 号(两个英文冒号)起分隔作用；  
**run**，程序完整路径，非常常用 的 AHK 命令之一;  
**;** 号代表 注释后面一行内容；

热键是通过一对::创建的. 按键名或组合按键名必须在`::`**左边**. 代码则跟在后面, 以`Return`结束.热字串在要触发的文本两边各有一对::. 替换后的文本在第二对::的**右边**.

```
; 运行程序，选择Alt键组合来打开本地应用程序。

!n::
Run Notepad ; “notepad”是“运行”对话框中的命令之一
Return  ; 热键内容结束,这之后的内容将不会触发.

!n::
Run D:\Program Files (x86)\Sublime Text 3\sublime_text.exe
Return  ; 热键内容结束,这之后的内容将不会触发.

!b::
Run https://www.baidu.com/ ; 极速打开网页，Win键来呼出网页
Return  ; 热键内容结束,这之后的内容将不会触发.

; 现在你决定发送一些按键到一个程序中. 你可以使用 Send 命令. Send 表示发送按键,模拟打字或按键操作.

^!c:: ; 当我们按下CTRL+ALT+C时将会在文档中输入以下格式的文字
Send Sincerely,{Enter}Poison_Kissreturn
Return  ; 热键内容结束,这之后的内容将不会触发.

^b:: ; Ctrl & b 热键
   send, {ctrl down}c{ctrl up}  ; 复制选定的文本. 也可以使用^c, 但这种方法更加可靠.
   SendInput, [b]{ctrl down}v{ctrl up}[/b] ; 粘贴所复制的文本,并在文本前后加上加粗标签.
Return  ; 热键内容结束,这之后的内容将不会触发.

; 缩写快速打出常用语。再加空格、或 tab、或回车，就可以触发缩写，根据输入不同方式（-()[]{}':;"/\,.?!`n `t（注意 `n 是回车，`t 是 Tab）输出的内容后也相应附加了触发方式。

::/mail::gmail@gmail.com
::/jeff::http://www.jeffjade.com/
::btw::By the way   ; 替换"btw"为"By the way", 当你按下结束符的时候.
:*:btw::By the way  ; 替换"btw"为"By the way"而不需要按下结束符.

; 几乎所有AHK内置的特殊按键，**花括号是必须的**. 它将告诉AutoHotkey `{!}` 表示 "感叹号" ,而不是要 "发送 Alt 键击"。

; 复制，粘贴工作，定制宏：选中你要复制的文本，按住windows微标键+q就可以做这一样一个过程：Ctrl+C、Alt+tab、Ctrl+V。
#c::
Send ^c!{tab} ^v
Return

; 一键拷贝文件路径，只需要Ctrl+shift+c即可拷贝文件路径
^+c::
; null=
send ^c
sleep,200
clipboard=%clipboard% ;%null%
tooltip,%clipboard%
sleep,500
tooltip,
return
```

## 鼠标手势

[WGestures](http://www.iplaysoft.com/wgestures.html)，优秀实用的全局鼠标手势工具软件，高手必备效率神器！

## 杀毒防御

微软自己的杀毒防御武器Windows Defender，日常使用完全够了。也推荐使用[火绒安全](https://www.huorong.cn/)软件，还可以拦截弹窗。

- 平时下载软件尽可能到**官网下载软件**，对于软件内的捆绑安装，除非你需要，否则一律**取消那些捆绑安装的选择框**。
- **建议远离各种第三方杀毒软件**，可能会出现各种捆绑的软件、弹广告。

## 清理工具

<div class="note info"><p>ccleaner[官方下载](http://www.piriform.com/download)。使用教程点击[教程1](http://jingyan.baidu.com/album/b87fe19ed739d4521835681f.html)和[教程2](http://bbs.leishen.cn/thread-18903-1-1.html)查看</p></div>

<div id="ccleaner"></div>
- 使用CCleaner免费版即可替代第三方杀毒软件进行系统清理，可以集成在回收站右键、设置开机自动运行等。建议每天或者每周进行清理。
    - 先把语言设置为简体中文，方法为：在左侧选择`Options`标签，在右侧点击最上面的`Settings`，然后在`Language`下拉列表中选择`Chinese（Simplifide）`即可把软件界面切换为简体中文。
- [SDelete](http://www.appinn.com/sdelete-for-windows/) 是著名的微软 Sysinternals 免费工具集软件之一，用来安全的、不可恢复的删除文件，以及多次擦除剩余空间
- 针对`找不到该项目无法删除`的问题，首先新建一个txt文件，把下面的代码复制到里面，然后另保存`aaa.bat`，这个文件名`aaa`要和你想要删除的那个文件或文件夹的名字一样。接下来把想要删除的那个文件拖动到刚才的bat文件上,并刷新即可。
    ```
    DEL /F /A /Q \\?\%1
    RD /S /Q \\?\%1
    ```

## 软媒魔方

功能非常多，同时各个功能的程序又是独立分开的，常用的有设置大师、优化大师以及清理大师。建议下载绿色版，并禁止自启动。点击[官方下载](http://mofang.ruanmei.com/)，推荐下载完整绿色版。

## Windows更新

对于无法安装某些更新，可以使用[脚本](https://gallery.technet.microsoft.com/scriptcenter/reset-windows-update-agent-d824badc)，对Windows Agent进行一次恢复，看下效果。如果不行，试试[关于Windows Update组件重置的方法](https://support.microsoft.com/zh-cn/help/971058/how-do-i-reset-windows-update-components)，看下重置组件后是否能正常进行安装。系统下可能存在的所有三方安全程序和优化软件建议您全部移除掉。

也可以尝试如下步骤：

1. `Win+r`，输入：`msconfig`
2. 点击`服务`标签卡，选择`隐藏所有的微软服务`，然后点击全部禁用（若您启用了指纹识别功能，请不要关闭相关服务）
3. 点击`启动`标签卡, 点击`打开任务管理器`，然后禁用全部启动项并确定
4.  重启设备。当弹出`系统配置实用程序`的时候，选中此对话框中的`不再显示这条信息`并点击确定
5. 按`Win+R`输入`services.msc`打开  找到`Windows Update`停止
6. 打开此电脑C盘：`\Windows\SoftwareDistribution`当中`Download`
和`DataStore`进行删除
7. 按照1的步骤启动`Windows Update`
8. 然后重启电脑

[Dism++](http://www.chuyu.me/zh-Hans/index.html)是由初雨团队采用微软内部API编写的一款开源免费的实用工具。Dism++作为第三版清理工具更加深入系统底层，功能和清理效果都非常不错。它具有功能如：空间回收、更新清理、系统优化、CompactOS、Windows Update、完整ESD支持、ESD转ISO、WIM/ESD互转，Imagex、ISO生成器、引导修复、系统备份、系统还原、春哥附体、驱动管理等，兼容Windows Vista/7/8/8.1/10平台。

<div class="note warning"><p>不要用清理垃圾功能乱精简，会导致系统无法封装。</p></div>


## 卸载Win10内置应用

自从微软开始大力推广Windows应用商店和Win10通用应用，干干净净全新安装的Windows10系统也预装了大批的应用。如果说其中的Xbox游戏、Microsoft Edge浏览器、Cortana微软小娜、应用商店是体验Windows10的新特性必不可少的应用，那么其它的日历、邮件、Groove音乐、电影和电视、照片、天气、OneNote好像没有不让卸载的必要。并且这些预装应用很多都未提供卸载选项。

下面就来分享一下如何卸载这些Win10自带的应用：

- 推荐使用[CCleaner工具](#ccleaner)卸载Win10内置应用，在左侧选择`Options`标签，在右侧点击最上面的`Settings`，然后在`Language`下拉列表中选择`Chinese（Simplifide）`即可把软件界面切换为简体中文。然后点击左侧的`工具`标签，右侧默认显示的就是`卸载`标签，在软件列表中你即可看到Win10系统的内置应用。选中想要卸载的应用，再点击右侧的卸载按钮即可完成卸载。
- 第二种方法就是利用PowerShell命令：
    1. 在系统搜索框中输入`Powershell`，然后在顶部显示的搜索结果`Windows Powershell`上点击右键，选择`以管理员身份运行`。
    2. 然后在打开的窗口中输入以下代码：`Get-AppxPackage *应用名称* | Remove-AppxPackage`，回车运行，就会卸载Win10系统中对应的应用。卸载Win10常用内置应用的具体命令可以[点击](http://www.windows10.pro/windows-powershell-uninstall-win10-built-in-application/)查看。**当执行Xbox删除命令后，会跳出一大段错误提示，我们不必理会，实际上Xbox应用已经成功删除了**。
    1. 如果想要卸载Win10系统安装的所有应用，那么只需运行 `Get-AppxPackage -AllUsers | Remove-AppxPackage` 即可。当我们新建一个账户后，预装的应用就会被重新安装，不过我们可以通过命令 `Get-AppXProvisionedPackage -online | Remove-AppxProvisionedPackage –online` 来避免这一情况的发生。

<div class="note warning"><p>谨慎全部卸载，自从win10年度更新到1607 RS1版本后，无法对应用商店进行恢复，恢复到初始设置也没有用，只能重装。如果没有更新到1607 RS1版本，想恢复应用商店，[点击](http://www.thewindowsclub.com/windows-store-app-missing-windows-10)可以参考文档。输入命令`Get-AppXPackage *WindowsStore* -AllUsers | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register "$($_.InstallLocation)\AppXManifest.xml"}`，并重启。</p></div>

## 禁止开机启动浏览器

> **不要使用如下方法**：~~打开`关闭Windows网络链接状态指示器的活动测试`，然后点击`已启用`~~。会导致网络链接指示失效。虽然可以链接网络，但网络中心链接显示失效，会出现未知问题。

1. 在开始菜单按钮上单击右键，点击`运行`；
2. 在框中输入：`regedit` 点击确定打开注册表编辑器；
 3. 在注册表左侧依次展开：`HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\NlaSvc\Parameters\Internet`；　
4. 在右侧双击打开【EnableActiveProbing】，将默认的`1`改为`0` 然后点击确定即可。

<div class="note warning"><p>可能存在网络中心链接延迟显示链接，存在IPV4链接失效问题</p></div>

## 自定义电池阈值

在经过设置电池阈之后：只要连接电源，若电池的电量在阈值范围内，电池才会进入充电状态。若电量在阈值之外，电源与电池为断开状态，整机纯粹依靠电源供电。所以自定义电池阈值就是为了让每个人都能根据自己 插电/外出 的比例，自己选择一个合适的百分比，避免电池电量过低，续航不够的情况出现。所以，自定义电源阈值的最佳使用情况就是：长时间不外出，大部分情况下都有连接电源，那么你可以将电池阈值设置为 55%~65% 左右，让电池始终处于这一区间内，那么电池也就达到了最佳保存状态，从而保护了电池的寿命。

在默认情况下，ThinkPad 电池阈值的范围是 55%~60%, 其他商务品牌若有类似设置开关，有的虽然不支持自定义，但是也会直接将电量限制在 50%~65% 之间。

最后，避免在长期高温中使用电池，是影响电池效率的重要因素。平时使用时也尽量不要完全耗尽电池，那样并没有什么好处。

# 实用软件

## 邮件客户端

Windows 推荐 [Mozilla Thunderbird](https://www.thunderbird.net/zh-CN/)。使用技巧：[迄今最优秀的邮件平台：Thunderbird](http://meons.lofter.com/post/257de9_874778)，[管理配置文件迁移](http://blog.sina.com.cn/s/blog_5752764e0100d18s.html)

## 护眼宝

电脑工作者必备，为你的手机、电脑开启护眼模式。过滤屏幕有害蓝光，让你夜间阅读更舒适，并有疲劳提醒、健康分析等功能，是保护眼睛、改善睡眠的小助手。

推荐使用[护眼宝](http://huyanbao.com/)和[f.lux](https://justgetflux.com/)两款软件。个人使用的是护眼宝，没有弹窗干扰，没有使用f.lux过，更多f.lux介绍[点击](http://www.iplaysoft.com/flux.html)查看。

<div id="adblock"></div>

## 广告屏蔽

- 同时拦截网络广告和视频广告：推荐使用[uBlock Origin](https://chrome.google.com/webstore/detail/ublock-origin/cjpalhdlnbpafiamejdnhcphjbkeiagm)
	- 或者使用[广告终结者](http://www.adtchrome.com/)（[广告终结者CHROME插件](https://chrome.google.com/webstore/detail/%E5%B9%BF%E5%91%8A%E7%BB%88%E7%BB%93%E8%80%85/fpdnjdlbdmifoocedhkighhlbchbiikl)）
	- 或者[阿呆喵](http://www.admflt.com/)（开源，无广告，静默，还能自定义拦截弹窗广告并导出拦截规则）软件，配置文件[下载](https://pan.baidu.com/s/17wfU2jKmnYkum-CQiiXEkw)（密码：ls2i）。
    - 或者~~[广告净化器](https://www.yiclear.com/download/)（[广告净化器CHROME插件](https://chrome.google.com/webstore/detail/%E5%B9%BF%E5%91%8A%E5%87%80%E5%8C%96%E5%99%A8/cbiaicifbmeokbhollcjfeaoakmppfeh)）~~。2018年6月22日更新，视频拦截规则有点问题，暂时不推荐。
	- 或者~~[ADSafe净网大师](http://www.ad-safe.com/)（[净网大师CHROME插件](http://dl.ad-safe.com/pc_v4/plugin/update/index.html)）~~。
- 拦截弹窗。[阿呆喵](http://www.admflt.com/)或者使用[火绒安全](https://www.huorong.cn/)软件里面的拦截弹窗插件。
- 支持全平台广告屏蔽工具：付费的[Adguard](http://www.appinn.com/adguard-lizhi/) （[Adguard 广告拦截器CHROME插件](https://chrome.google.com/webstore/detail/adguard-adblocker/bgnkhhnnamicmpeenaelnjfhikgbkllg?hl=zh-CN)）（[Adguard v6.1中文纯净破解版](https://www.chunjingku.com/soft/240.html)）

自定义拦截规则：

- [Fanboy Ultimate List](https://www.fanboy.co.nz/filters.html)
- Fanboy's Ultimate List: `https://fanboy.co.nz/r/fanboy-ultimate.txt`
- easylistchina国内网站规则: `https://easylist-downloads.adblockplus.org/easylistchina.txt`
- easylist国外网站规则: `https://easylist.to/easylist/easylist.txt`

## 局域网鼠键控制

我们之前介绍过一款相当神奇的软件 [Synergy](http://www.iplaysoft.com/synergy.html)，它可以让你实现使用一套键盘与鼠标同时控制多台不同的电脑，让你的鼠标指针可以在它们不同的屏幕之间穿梭，非常的方便实用！然而，我们也提到它的一个小缺点，虽然它能在不同电脑间拷贝粘贴文本，但不能拷贝文件。

而微软推出的 Mouse without Borders (无界鼠标) 免费工具就解决了这个问题！它是 Microsoft Garage“车库”团队的一个创新软件项目，和 Synergy 一样，在配置好之后，你的鼠标指针就可以在屏幕的边缘移动到另一台电脑去，进而方便地操作它们。不仅如此，无界鼠标还实现了不同电脑间的文件拷贝与文件拖放，灰常的好玩且实用。更多设置[点击](http://www.iplaysoft.com/mouse-without-borders.html)查看。

无界鼠标各机平等，Synergy分服务端与客户端。无界鼠标仅针对Windows电脑，Synergy具备超强跨系统能力。无界鼠标可跨电脑传文件并共享剪贴板，Synergy只能复制/粘贴文字。无界鼠标有同步控制功能，Synergy支持“死角”大小调节。无界鼠标支持4台电脑，Synergy理论上支持15台电脑。

[Input Director](http://www.inputdirector.com/downloads.html) 是款 Windows 下的一套鼠标键盘控制多台电脑工具。Input Director 有许多小特性，比方说支持多台电脑之间共享剪贴板，非常方便。但很可惜，它并不像无界鼠标那样完美地支持文件拖放的传输，只能复制/粘贴那些已经在局域网共享中的文件。除此之外，还有就是VPN支持/多显示器支持/数据传输加密/Win+L锁定屏幕/Ctrl+Alt+Del热键支持/在其他电脑上打开本机文件/同时向多台电脑传输键鼠动作等等一些小特性，在[官方网站](http://www.inputdirector.com/quickstart-usage.html)上有详细的说明。更多设置[点击](http://www.appinn.com/input-director/)查看。

## 局域网文件访问监视软件

互相分享文件是常事，虽然用飞鸽传输可以点对点分享文件，但 Windows 的文件分享功能还是无法替代的，这个时候怎么知道谁在浏览我的数据呢？当你的共享文件夹被访问时，ShareWatcher 会通知并且显示细节，如文件的浏览、操作等。你也可以设置让 ShareWatcher 在系统托盘显示信息。

<div class="note info"><p>[百度网盘下载链接](http://pan.baidu.com/s/1c2Mm9GG)，密码：2s5z</p></div>

1. 点击`ShareWatcher`中的`setup`安装，退出软件。
2. 点击`Patch-URET`中的`All.Codeline.Software-patch`，找到安装目录`C:\Program Files (x86)\CodeLine\ShareWatcher`中`CodeLineKey.External.dll`文件，进行破解补丁。


## 局域网组建

[百灵快传](https://www.appinn.com/b0pass-lan-large-file-transfer-tool/)是一款基于 Go 语言的高性能 “手机电脑超大文件传输神器”、”局域网共享文件服务器”，只需要在电脑端打开百灵快传，就可以在其他设备上打开浏览器进行文件传输。

[CuteHttpFileServer](https://www.appinn.com/CuteHttpFileServer/)（简称 chfs）是一个免费的文件共享工具，它可以让运行 Windows、Linux、macOS 的设备变成文件服务器，通过 HTTP 网页，或者使用 WebDAV 协议访问共享文件。

[ZeroTier ](http://www.appinn.com/zerotier-one/)是一款非常简单易用的内网穿透工具，不需要配置，就能实现虚拟局域网的组建，让你可以在外也能连回家中、学校、办公室的电脑获取资料，数据。

[Web Server for Chrome](https://www.appinn.com/web-server-for-chrome/) 是一款 Chrome 应用程序，它能够在本地电脑上快速启动一个 HTTP 服务器，用于开发测试，也支持文件上传、下载，方便的做一个文件服务器，除了 Chrome 浏览器，也适用于 ARM 的 Chromebook。

## 局域网投影

[将电脑屏幕拓展到安卓平板](https://jingyan.baidu.com/article/63acb44a2e307661fcc17e11.html)。

<div id="search"></div>

## 文件查找工具

### Everything

[官方下载地址](https://www.voidtools.com/downloads/)。打开压缩包后，直接运行`Everything.exe`，查找你需要的文件。相比系统搜索工具，速度很快。**建议解压后将`Everything.exe`固定在任务栏经常使用**。

[使用指南](https://wenku.baidu.com/view/793afe29ccbff121dd3683ac.html)：搜索`hosts`，默认非全字匹配，在菜单栏`搜索`项中可缩小搜索范围，若选择`全字匹配`，可以看到`hosts`文件。右键此文件，可以直接跳转所在目录。更多设置在菜单栏`工具`-`选项`中。

### Listary

Listary，作为一款Windows文件浏览增强工具，可以为你 Windows 的「文件浏览对话框」、「资源管理器」等增加非常方便的文件快速定位、实时全盘搜索、常用文件夹收藏、打开历史、快速切换到已打开的路径、快捷右键菜单等一系列非常非常实用和高效的功能。与此同时，它还能与很多第三方应用集成，包括鼎鼎大名的Total Commander，还有WinRAR，7zip，FileZilla等等。Listary 体积小巧，而且运行快速，即便在低配置的电脑上常驻系统使用也不会察觉有丝毫拖慢速度的现象。

[破解版下载地址](http://www.ddooo.com/softdown/39673.htm)，点击`Listary.Pro.5.00.Build.2410.exe`安装即可。然后在右下角图标右键选项设置工具条快捷键。只要不跟系统或者别的软件热键相冲突即可。

- 使用 Listary 之后，你完全不需像一般的搜索软件那样去找搜索框或启动窗口来进行输入，**在资源管理器或对话框的界面下，只需直接按键盘，输入字母就能轻松定位和操作文件了**（非常赞的一点是它竟然能支持用拼音缩写来匹配中文文件名），善加使用可以节省大量的鼠标移动和点击，极大的提升文件操作效率。
- 在任一窗体下使用快捷键即可激活Listary，同时光标会自动定位在Listary的输入窗口 ，只要直接开始输入，Listary就自动进行匹配了。使用快捷键可以在启动程序模式与常规模式间进行切换。 Listary的匹配总共有三种，分别为命令，路径，启动程序。
- 激活Listary之后点击有爱心标识的收藏按钮，就可以打开自己的收藏列表，能够更快捷的打开自己常用的软件或者文件。
- 激活Listary之后点击历史记录，就可以打开自己最近打开的文件或者文件夹。
- 激活Listary之后点击快捷功能，就可以弹出一些常用的功能，个人最喜欢的是显示隐藏文件和显示文件扩展名。
- 只要输入文件名的一部分就可以找到这个文件，支持中文与英文。比如，我输入`测试 md`就可以搜索到`测XX试OO.md`这个文件。自然，输入的越多，返回的结果越精确。随着使用记录的积累，常用的文件或程序会获得更高的优先级。

## 文件复制软件

文件复制软件仍是人们日常生活中最常用的软件之一，续而感叹Windows自带复制工具先天不足，比如：不支持断点续传；传输速度较慢；替换/重命名操作设计不合理。幸好，第三方替代品百花齐放。

[文件复制软件评测：FastCopy、TeraCopy、ExtremeCopy、Supercopier](https://xbeta.info/fastcopy-teracopy-extremecopy-supercopier.htm)本着公平公正客观的原则去测试对比、评析4位参赛选手。

如果在节约开支的基础上选择一款复制软件，FastCopy绝对是你最好的选择。轻量级、免安装、传输效率高，支持32/64位系统。ExtremeCopy在简约的界面中添加了许多细节功能，这一点值得称赞。同时，软件的传输表现也是本次评测中最好的。可惜免费版阉割了太多核心功能且不支持Win 8。觉得软件不错的朋友大可购买专业版，顺便支持一下开发者。Teracopy界面最为美观，但是效率低下的事实不可无视。如果你更在意的是传输效率而非表象，或许FastCopy和ExtremeCopy更适合你。

<div class="note info"><p>[Fastcopy第三方汉化版](http://vdisk.weibo.com/s/Ac9sE2hU6W5Y)，[官网下载地址](https://ipmsg.org/tools/fastcopy.html)
</p></div>

<div id="google"></div>

## 谷歌服务

- 最最简单的方法是访问[谷歌镜像地址](http://dir.scmor.com/google/)，不过可能存在不安全因素，<font color=red>不建议登陆账号使用</font>。
- 如果使用校园网环境，则可以使用[IPv6服务](#ipv6)。
- 对于更加一般的网络环境，则推荐使用[科学上网](#goagent)方式。
- 更换HOSTS方式不在实用。~~首先下载最新`hosts`文件，然后覆盖替换文件夹`C:\Windows\System32\drivers\etc`中的原文件（直接复制此路径到文件夹上面的地址栏或者使用[everything](#search)找到此文件夹）。如果无法替换请先退出360等安全软件~~首。

<div id="chrome"></div>

### 谷歌浏览器

<div class="note info"><p>推荐使用[谷歌浏览器](https://www.google.com/intl/zh-CN_ALL/chrome/)：[谷歌搜索引擎主页](https://www.google.com.hk/)，[谷歌学术主页](https://scholar.google.com/)。</p></div>

如果想设置默认引擎（在新标签页直接搜索）为[谷歌搜索引擎](https://www.google.com.hk/)，则需要在浏览器引擎设置里面**添加**google项：`https://www.google.com.hk/search?q=%s`，并设置为默认。

插件推荐：

- [Vimium插件](https://chrome.google.com/webstore/detail/vimium/dbepggeogbaibhgnhhndojpepiihcmeb/related?hl=en)让Chrome起飞。所有的操作都是通过键盘的快捷键来操作。查看[常用快捷键说明](http://www.jeffjade.com/2015/10/19/2015-10-18-chrome-vimium/)。
- [二管家插件](https://chrome.google.com/webstore/detail/nooboss-extensions-manage/aajodjghehmlpahhboidcpfjcncmcklf)用来管理 Chrome 扩展的扩展，它能够在不打开扩展程序界面的情况下开启或者关闭扩展，还能根据规则在需要的时候打开扩展，以减少内存占用。详细规则匹配设置可以查看[Github源代码库说明](https://github.com/AInoob/NooBoss)。

使用技巧：

- 新版本[chrome浏览器](https://www.google.cn/chrome/browser/desktop/index.html)默认会自动舍弃标签页，用于节省系统内存。在地址栏输入`chrome://flags/#automatic-tab-discarding`，设置为停用即可。
- Chrome浏览器中，需要手动点击才能查看flash控件。在Chrome高版本中，plugins 页面被移除后，可以访问: `chrome://settings/content` 调整 Flash、PDF 的设置。如果你想让所有网站都默认启用 flash 不用一个个的添加，可以访问：`chrome://flags/#run-all-flash-in-allow-mode` 选择允许。
- 强制域名使用 HTTPS（SSL）访问设置：在 Chrome 浏览器上输入链接 `chrome://net-internals/#hsts` （可复制此地址粘贴到地址栏），回车。在 Domain 栏里，输入需要访问的域名如 `google.com` ，并勾选下面的两个复选框，点击 `Add` 按钮即可。此时，您无需每次在因为跳回非加密连接中断后手动添加 HTTPS 前缀。对于其他的浏览器，请在对应浏览器的插件目录中查找类似 `HTTPS Everywhere` 的插件，它将自动帮助您强制所有可能的 HTTPS 连接。倘若您想要撤销上述变更，在下方的 `Delete Domain` 区域里，在 Domain 栏里输入您想要撤销规则的域名（例如 `google.com`），并点击 `Delete` 按钮即可。
- [禁用`请停用以开发者模式运行的扩展程序`提示](https://blog.csdn.net/ldu_liuyang/article/details/106333321)：关闭Chrome浏览器，在`chrome.exe`所在的目录以管理员身份运行[补丁文件](https://pan.baidu.com/s/1TQ-u-kgL09mnrRz1vj5kUA)（提取码：wkr3）。

<div id="ipv6"></div>

### 使用IPv6服务

使用IPv6服务是靠访问网站的IPv6地址。如果要去的网站没有IPv6地址，那就没辙。

<font color=red>请确保</font>：自己的机器支持IPv6，自己的网络支持IPv6。打开浏览器，访问[IPv6test.com](http://ipv6-test.com/)，页面上`IPv6 connectivity`一项如果显示`Supported`，或者能够访问[BYR BT](http://bt.byr.cn/)，说明前提条件满足。

[^config-ipv6-to-bypass-gfw-in-bupt]: [北邮校园网通过配置IPv6使用Google服务](http://blog.yuantops.com/tech/config-ipv6-to-bypass-gfw-in-bupt/)

1. 如果之前使用过谷歌插件[Proxy SwitchyOmega](#switchyomega)，需要将情景模式从`自动切换`切换为`直接连接`，不再使用代理软件。
1. 修改hosts文件[^config-ipv6-to-bypass-gfw-in-bupt]（`%SystemRoot%\system32\drivers\etc\hosts`）：
    - 如果可以通过IPv6访问Google搜索、YouTube、六维空间等网站，却打不开谷歌学术。在系统的hosts文件末尾插入入以下内容:
      ```
      ## Scholar 学术搜索 ipv6 HOSTS
      240c:f:1:4000::9999 scholar.google.com
      240c:f:1:4000::9999 scholar.google.com.hk
      240c:f:1:4000::9999 scholar.google.com.tw
      240c:f:1:4000::9999 scholar.google.cn
      2404:6800:4004:81a::2003 scholar.google.com
      2404:6800:4004:81a::2003 scholar.google.com.hk
      2404:6800:4004:81a::2003 scholar.google.com.tw
      2404:6800:4004:81a::2003 scholar.google.cn
      ```
    - 也可以参考托管在[ipv6-hosts](https://github.com/lennylxx/ipv6-hosts/)中的[Hosts](https://ghfast.top/https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts)文件。
1. 设置网络链接的IPv6 DNS服务器为：`2001:4860:4860::8888`，`2001:4860:4860::8844`。（[Google解析服务](https://developers.google.com/speed/public-dns/docs/using)）

<div class="note info"><p>也可以使用内置版浏览器（[GoAgent ipv6版](https://github.com/Alvin9999/new-pac/wiki/GoAgent-ipv6%E7%89%88)，[GoProxy ipv6版](https://github.com/Alvin9999/new-pac/wiki/GoProxy-ipv6%E7%89%88)）的[ipv6开启方法](https://github.com/Alvin9999/new-pac/wiki/ipv6%E5%BC%80%E5%90%AF%E6%96%B9%E6%B3%95)，不过未测试成功，看起来比较麻烦。</p></div>

<div id="goagent"></div>

## 科学上网

[自由上网方法](https://github.com/Alvin9999/new-pac/wiki)介绍了多种不同的方法，可以根据自己的喜好进行使用。以下介绍[代理软件](#agent)或[自建服务器](#shadowsocks)两种方式。

<div id="agent"></div>

### 代理软件

为了避免国内网址无法访问的问题，推荐结合[Proxy SwitchyOmega谷歌插件](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-app-launcher-info-dialog)使用[^wiki/GFWList]。代理软件的详细介绍[点击查看](https://github.com/Alvin9999/new-pac/wiki/%E6%8A%97%E5%B0%81%E9%94%81%E5%BC%BA%E5%B0%8F%E8%BD%AF%E4%BB%B6)。

<div id="switchyomega"></div>

以下举例说明代理软件的快速配置：

[^wiki/GFWList]:  [SwitchyOmega 配合 GFWList 项目使用的场合](https://github.com/FelisCatus/SwitchyOmega/wiki/GFWList)

<div class="note warning"><p>对于部分宽带连接无法访问的情况，需要[修改连接名称为英文名称](https://github.com/shadowsocks/shadowsocks-windows/issues/1502)，然后断开链接重连即可。</p></div>

<div class="note info"><p>固定IP网络环境建议使用Ultrasurf，youtube速度不错。动态IP网络环境建议使用Psiphon（Ultrasurf[需要每次连接更改IP](#Ultrasurf-setting)），但youtube速度较慢。</p></div>

1. 下载[科学上网快速配置](https://pan.baidu.com/s/1Q0LtIx9LaXj-zES6tnvBZw)（提取码: bhx7）文件。
1. 解压并保留压缩包，进行网络链接。
    - 删除`u.ini`文件（保留压缩包），运行`U****.exe`程序（勾选`无界分享`），等待网络链接，成功后会弹出广告页面，关闭该页面即可。如果`U****.exe`链接失效，则运行`psiphon3.exe`。
    - 安装[谷歌浏览器](#chrome)和[谷歌浏览器插件Proxy SwitchyOmega](https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif?utm_source=chrome-app-launcher-info-dialog)。
3. 进入 Proxy SwitchyOmega 的设置界面，点击`导出导入-从备份文件恢复`，导入设置备份文件`OmegaOptions.bak`。

    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fxdeyjzvdqj208g08xdfw.jpg)
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/step2.png)
1. 设置代理软件，确认端口。
    - 使用`U****.exe`：退出`U****.exe`程序，重新**解压覆盖**，运行`U****.exe`程序。由于网络变动，一般情况下你需要按照下面步骤修改对应端口。
    <div id="Ultrasurf-setting"></div>
        - 查看`1`处是否连接成功，并记住`2`处的IP地址。
        ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fxdewazrrij20a5089mx5.jpg)
        - 进入插件的设置界面，点击`Ultrasurf`情景模式，将代理服务器的值改为`2`处的IP地址。
        ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dly1fxdf0uc28sj218g0o4gmd.jpg)
        - 点击`3`处`应用选项`，并关闭设置标签页。
    - 使用`psiphon3.exe`：进入`设置`→`本地代理端口`→`HTTP/HTTPS`设置端口为`8580`。进入`设置`→`拆分隧道`，选择`不要代理国内网站`选项，来启用拆分代理。但是还是存在国内网址访问速度慢的问题。
1. 点击 Proxy SwitchyOmega 插件栏，选择`自动切换`模式。
1. 根据代理服务器的网络情况，点击`插件栏`，点击`虚情景模式GoAgent`<font color=red>右边下拉框</font>选择对应的情景模式，实现一键批量设置代理服务器。如果访问网页中有资源未加载成功，则插件图标上会有提示。**不影响页面浏览就不必修改**。点`插件菜单里未加载的资源`，根据网页需求选择`虚情景模式GoAgent`或`直接连接`就可以了。

**其他补充说明**：

1. 代理软件下载地址
<div id="Ultrasurf"></div>
    - Ultrasurf（[下载地址](https://nofile.io/f/JrQZSVgTr5A#963314168deb8c74)，[备用下载地址](http://www.babel.cc/share.do?s=2973065029822749)）
<div id="freegate"></div>
    - Freegate（[下载地址](https://nofile.io/f/kJGDhxY8vdN#963314168deb8c74) ，[备用下载地址](http://www.babel.cc/share.do?s=1571455430407789)），[如何使用自由门](http://jingpin.org/unblock-blocked-sites-by-freegate/)
<div id="psiphon"></div>
    - Psiphon（[下载地址](https://nofile.io/f/yn7SbPyWXXM#8f632a37f431b327)，[备用下载地址](http://www.babel.cc/share.do?s=6166540161520013)）
1. 备份文件`OmegaOptions.bak`已经新建`虚情景模式GoAgent`（配合`自动切换模式`使用）并修改对应代理端口，如果无法访问，按照如下具体方式进行配置。
    - 请确认代理协议与端口号。
    ![](https://github.com/FelisCatus/SwitchyOmega/wiki/images/t1/step3.png)
    - 点击SwitchyOmega插件栏，进入情景模式`自动切换-切换规则`，如果需要添加规则，模仿已有的规则模式输入即可。
1. 取消代理软件的全局设置：
    - Ultrasurf：打开`Ultrasurf`，点击`高级设置`，勾选`不自动设定系统代理`。
    - Freegate：在`Freegate`的设置选项卡里勾选`不设置IE代理`，选择CHROME浏览器的文件夹位置。至于其他设置根据喜好自己设置，推荐不开机启动，不自动启动浏览器。

<div id="shadowsocks"></div>

### 自建服务器

为保证每位用户都能够分配到一定的带宽资源，[SSR免费账号](https://github.com/Alvin9999/new-pac/wiki/ss%E5%85%8D%E8%B4%B9%E8%B4%A6%E5%8F%B7)进行了单线程限速处理。如果自己搭建服务器就没有这个限制。

[搭建SS或SSR教程](https://github.com/Alvin9999/new-pac/wiki/%E8%87%AA%E5%BB%BAss%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%95%99%E7%A8%8B)的教程分三步：

1. 购买VPS服务器；
1. 一键部署VPS服务器；
1. 一键加速VPS服务器 （谷歌BBR加速，推荐）。

<div class="note info"><p>Windows SSR客户端 [下载地址](https://github.com/shadowsocksr-backup/shadowsocksr-csharp/releases) [备用下载地址](https://nofile.io/f/6Jm7WJCyOVv/ShadowsocksR-4.7.0-win.7z)，MAC SSR客户端 [下载地址](https://github.com/shadowsocksr-backup/ShadowsocksX-NG/releases) [备用下载地址](https://nofile.io/f/jgMWFwCBonU#ab0d3c3b6ac54482)，[Linux客户端一键安装配置使用脚本(使用方法见注释)](https://github.com/the0demiurge/CharlesScripts/blob/master/charles/bin/ssr)，安卓 SSR客户端 [下载地址](https://github.com/shadowsocksr-backup/shadowsocksr-android/releases) [备用下载地址](https://nofile.io/f/GRWw7PbADrc#1c6c32f969e7f5d9)</p></div>

## 下载工具

<div id="idm"></div>

### IDM

IDM 在下载 http和 ftp 方面的能力是毋庸置疑的，只要资源没问题，基本都可以跑满速。还可以[嗅探网页音视频并下载](https://zhuanlan.zhihu.com/p/34135244)。但不能直接下载种子文件，不过可以先利用网盘离线然后用IDM下载（更多内容可以点击查看[百度云盘下载工具](https://sli1989.github.io/bdy/)）。更多设置问题查看[IDM下载器使用技巧](https://www.internetdownloadmanager.cn/idm/24771)。

1. 下载安装[IDM](https://pan.baidu.com/s/1bbK3SGw2keLASVyXU-uBUg)（提取码: ahdb）。当系统报毒时，<font color=blue>请添加`riched32.dll`文件信任</font> 。
1. 安装完成后，**重启浏览器**。

<div class="note info"><p>正常情况下，点击选择下载或者右键选择使用IDM下载，会跳转到IDM下载页面。如果失效，需要手动查看下载链接（在chrome中`ctrl+j`查看），并复制下载链接到IDM或者迅雷，建立下载任务。</p></div>

<div class="note warning"><p>安装破解版IDM软件后，不要升级。如果有弹窗提示升级，请点击取消或者关闭。</p></div>

<div id="sync"></div>

## 同步软件

<div class="note info"><p>[GoodSync破解版下载](http://pan.baidu.com/s/1bo2PXhl)（密码：ms4j）</p></div>

安装方法：

1. 首先运行压缩包中的`GoodSync-Setup.exe`安装程序进行安装原版程序!
1. 运行压缩包中的`KG_ttrar.exe`！
1. 启动GoodSync程序,选择激活!激活方式选择通过浏览器激活!随便输入你的用户名，序列号按照XXX-XXX-XXX-XXX的样式输入！比如输入111-111-111-111等！点击下一步，随便输入你的个人信息，输入什么都行，重点是能继续点击下一步就可以！
1. 在这一步程序会给出一长串的注册代码,复制这段注册代码到`KG_ttrar.exe`,然后点击`generate`按钮生成激活代码!用刚刚获得的激活号注册程序！

使用方法：<font color=red>请注意同步方向，防止被旧文件覆盖</font>。

1. 初次使用会提示新建任务，任意命名即可。
2. 选择任务类型，后期可以自行设置同步类型，点击下图所示即可进入选项。

    > `常规`--`同步方向`中可以设置`双向（同时同步两侧变化的文件）`、`单向左往右`（从左侧完全复制到右侧）、`单向右往左（从右侧完全复制到左侧）`。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g26lpfe10wj20m80c2gmx.jpg)

1. 本地硬盘间同步：选择好`同步类型`，`左右侧文件夹位置`后，点击下面的`分析`，会出现左右侧不同文件的对比，仔细核对是否符合你要同步的方向（一般`同步方向`设置好后不会有问题），点击`同步`等待同步完成即可。
1. 网络硬盘间同步设置方法：账户设置：`菜单栏`--`工具`--`goodsync connect设置`--勾选`使用goodsync connect链接我的计算机`--`next`--`新建goodsync connect账户`--`输入对应信息`--`next`--`设置windows用户`--`next`--`apply`。完成账户设置。

    > 网络硬盘间同步使用方法：在不同计算机之间同步时，需要两台电脑同时进行上述设置并登录上面设置的goodsync connect账户。在文件夹地址`浏览`点击`goodsync connect`即可看到登录中的硬盘地址。按照`本地硬盘间同步`步骤继续进行即可。

1. 该同步软件还支持部分网盘同步，不过网速、网盘空间限制，用处不大，按照相应提示进行即可。

## 分享设备间内容

> [手机电脑互传文件的 10 个免费工具](http://www.ifanr.com/app/668324)

[Pasteasy](http://www.appinn.com/pasteasy/) 是一款利用局域网传输，瞬间自动复制粘贴电脑内容到手机，手机内容到电脑的工具，支持文本、照片、链接、截图等。支持 Mac、Windows、iOS、Android。由于没有通过互联网传输数据，所以你的图片、文本内容是安全的，也不会受墙的影响。

<div class="note info"><p>下载地址：[官方主页](http://www.pasteasy.com/) | [App Store](https://itunes.apple.com/cn/app/pasteasy/id906277880?mt=12) | [Google Play](https://play.google.com/store/apps/details?id=com.tinkerstuff.pasteasy.v2) : [百度盘](http://pan.baidu.com/s/1hqq1qJU)</p></div>


## 文本编辑器

<div id="notepad"></div>

### Notepad++

Notepad++，是在微软视窗环境之下的一个免费的代码编辑器。它使用较少的CPU功率，降低电脑系统能源消耗，但轻巧且执行效率高，使得Notepad++可完美地取代微软视窗的记事本。内置支持多达27种语法高亮度显示(包括各种常见的源代码、脚本，能够很好地支持.nfo文件查看)，还支持自定义语言；可自动检测文件类型，根据关键字显示节点，节点可自由折叠/打开，还可显示缩进引导线，代码显示得很有层次感；可打开双窗口，在分窗口中又可打开多个子窗口，允许快捷切换全屏显示模式(F11)，支持鼠标滚轮改变文档显示比例；提供了一些有用工具，如邻行互换位置、宏功能等；可显示选中文本的字节数 (而不是一般编辑器所显示的字数，这在某些情况下，比如 软件本地化 很方便)。[Notepad++使用教程](http://shandian.biz/395.html)

[【crifan推荐】轻量级文本编辑器，Notepad最佳替代品：Notepad++](https://www.crifan.com/files/doc/docbook/rec_soft_npp/release/htmls/index.html)主要介绍了笔者crifan推荐的轻量级文本编辑器，Notepad最佳替代品：Notepad++，内容主要包含notepad，notepad2，notepad++，ultraEdit的比较，使用Notepad++前要了解的知识，Notepad++的插件，Notepad++的安装过程，Notepad++的各种常见和不常见的功能的详解。


## 在线协作

- [石墨文档](https://shimo.im)，重新支持分享给匿名用户看，可以共享编辑，其微信公众号能够快速访问编辑。推荐使用，体验不错。
- [一起写](https://yiqixie.com)，支持分享给匿名用户看，可以共享编辑。请先使用微信登陆。如果先使用邮箱账号无法绑定微信账户。目前体验不好，非常慢。
- [有道云笔记](https://note.youdao.com)，支持分享给匿名用户看，文档分享出来的链接广告多。更新支持分享权限设置，编辑和评论。
- [小画桌](https://xiaohuazhuo.com/)是一款轻量级的在线实时多人协作白板工具，支持语言通话、演讲模式，适合于在线培训、授课，以及企业进行团队分享、头脑风暴、远程会议等场景。可在电脑与移动设备上使用。著名免费在线思维导图工具 [ProcessOn](https://www.appinn.com/processon-web/) 旗下产品。

<div id="feed"></div>

## Feed制作

对于很多上班族来说，关注重要网站的通知公告信息是每天上班的必修课，然而很多官方网站并不提供 Feed 源，利用[Feed43](http://www.feed43.com/) 可以为没有 Feed 的网页生成 rss 格式的 Feed 地址，即可解决烦恼。

使用教程：

- [为没有 Feed 的网页生成 RSS 格式订阅源](http://www.appinn.com/feed43/)
- [利用 Feed43，将任意网页制作成 RSS 订阅源](https://sspai.com/post/34320)
- [Step-by-step example of feed setup](http://feed43.com/step-by-step.html)
- [Full-Text RSS Feeds](http://fivefilters.org/content-only/)

在线rss阅读器则推荐使用[inoreader](https://www.inoreader.com/welcome)和[Feedly](https://feedly.com)。Feedly网站的交互体验好，第三方客户端没广告，不用科学上网也可以同步数据。但国内需要科学上网，免费用户只有100个订阅额度，搜索功能和整合服务是需要付费，而且费用高。原本feedly pro才有的功能，inoreader免费用户都有，比如搜索订阅源和整合第三方服务evernote、onenote之类的。但广告比较多，不过使用屏蔽软件即可。第三方测评可以查看[RSS订阅服务Feedly转到InoReader](http://louishan.com/articles/feedly-to-inoreader.html)。

<div id="pdf"></div>

## PDF工具

<div class="note info"><p>[PDF工具合辑](https://pan.baidu.com/s/1pNkh3S3)，密码:h936 </p></div>

- PDFXCHANGE：PDF查看、组合、提取等，提供了虚拟打印，提供了word里面转PDF插件，可以模拟打印生成PDF。
- Adobe Acrobat XI Pro：PDF查看、编辑等，用于pdf另存为其他格式很有帮助，可以模拟打印生成PDF。
- Adobe Illustrator CS6：PDF编辑工具，海报等制作.

<div id="pics"></div>

## 图片视频

- [FSCapture](http://pan.baidu.com/s/1slhEZdN)（密码：djyk）支持滚屏截图、录屏，更多查看设置。FSCapture[使用教程](http://www.metsky.com/archives/415.html )。
- [ScreenToGif](https://www.screentogif.com/downloads.html?l=zh_cn) 是一款开源的录屏、摄像头录像、画板录制工具，还带有一个视频编辑器，并能最终导出视频文件，或者 GIF 动画的 Windows 软件，身材小巧，便携版压缩包仅仅 900Kb，单可执行文件。
- [Screen Recorder](https://www.appinn.com/kimcy929-screenrecorder-for-android/) 是一款屏幕录制应用，免费、无广告，支持录制时绘屏，简单的视频剪辑、游戏启动器、截屏等功能。
- [Brush Ninja](https://www.appinn.com/brush-ninja/) 是一款简单易用的免费动画制作工具，拥有在线版本与 macOS 客户端，可以非常方便的创作出 gif 动画，就算是青小蛙这样的新手，也能画出几笔。
- [Remove Image Background](https://www.appinn.com/remove-image-background-online/) 是最近非常火爆的人像照片背景去除工具，只需要上传一张带有人像的照片，它就会帮你自动扣掉背景，全自动、5秒完成，免费。
- 我们的老朋友 #[Aipix](https://www.appinn.com/tag/aipix)，对，就是那个开始自己训练 AI 抠图，后来又做了在线图片编辑器的 [Aipix](https://aipix.net/?from=appinn)。现在他又新推出 [**Aipix 在线图片批量处理**](https://aipix.net/batch/?from=appinn)。
- [Squoosh!](https://www.appinn.com/squoosh/) 是前几日 Google 开源发布的一款专门用来压缩图片的在线服务，支持 JPG、PNG、WebP 等格式的极限压缩，从青小蛙试用这几天的效果来看，比 TinyPNG 要强悍一点点。
- [Picviewer CE+](https://www.appinn.com/picviewer-ce/) 是一款浏览器油猴脚本，可以将包含很多图片的网页变成图片浏览器，还能对图片进行翻转、旋转、放大，显示原始大图、收藏、批量保存，聚合所有分页大图，图片在线编辑等操作，功能丰富的不像是一款浏览器脚本，而更像是浏览器里的看图工具。
- 这是一款叫做 **[HTML5视频播放器增强脚本](https://www.appinn.com/h5player-video-control-greasemonkey/)** 的油猴脚本，可以为在线视频播放添加多达 18 项辅助功能，包括倍速、画中画、截图、亮度调节、逐帧播放、画面移动、播放进度保存等功能，全程快捷键操作，非常高能。

## QQ/微信语音播放器

[楼月微信语音播放器](http://www.louyue.com/weixinplayer.htm) 是一款用来播放微信语音聊天文件 amr、aud 专属格式的播放器，并且可以保存为 WAV 格式。

要播放语音文件，首先要导出。Android 设备位于 `Tencent\Micromsg`路径下，iOS 设备比较麻烦，位于备份文件的 `AppDomain-com.tencent.xin` 路径下。当然最简单的是选择收藏，在收藏文件夹中寻找（选择：`文件\内置SD卡\Tencent\MicroMsg`，然后把`MicroMsg`这个文件夹导出到电脑桌面，然后在文件夹里面搜索`.silk`文件 ，这些`silk`文件就是收藏的声音文件）。然后就可以将 `amr`、`aud` 文件拖到[楼月微信语音播放器](http://www.louyue.com/weixinplayer.htm)界面中，可以直接播放，也可以保持为 `WAV` 格式。

> 本软件支持播放以下语音文件：  
1，安卓手机微信语音文件（`.amr`格式），保存位置：`手机盘符/tencent/MicroMsg/32位字符组成的文件夹/voice2/`，点击此处了解导出方法  
2，苹果手机微信语音文件（`.aud`格式），保存位置：`Documents/32位字符组成的文件夹/Audio/…`，点击此处了解导出方法。  
3， 安卓手机QQ语音文件（`.slk`格式），保存位置：`tencent/MobileQQ/QQ号码/ppt/`  
4，苹果手机QQ语音文件（`.amr`格式），保存位置：`Documents/QQ号码/Audio/`，点击此处了解导出方法。  
5，电脑版QQ语音文件（`.amr`格式），保存位置：`C:/Users/电脑用户名/我的文档/Tencent Files/QQ号/Audio/` 。  

<div id="greasyfork"></div>

## 用户脚本

用户脚本为您增强对浏览体验的控制权。在安装之后，它们可自动为您访问的网站添加功能，或使其更加易用、更加清新。

1. 安装用户脚本管理器。要使用用户脚本，[您首先需要安装一个用户脚本管理器](https://greasyfork.org/zh-CN)。根据您使用的浏览器不同，可用的用户脚本管理器也有所不同。
1. 安装用户脚本。在 [Greasy Fork](https://greasyfork.org/zh-CN) 上的用户脚本是由其他用户编写并向全世界发表的，您可以免费和轻松地安装。查找您想尝试的用户脚本。在您找到想要的用户脚本后，点击用户脚本页面上绿色的安装按钮，您的用户脚本管理器将询问您是否安装。

<div id="tools"></div>

## 小工具

- [频率发生器](http://www.appinn.com/frequency-generator/) 是一款能够让你的 Android 设备播放不同频率的声音的应用，支持 1Hz ~ 22000Hz 范围，而人类的正常听觉范围是 20Hz ~ 20000Hz 之间。
- [晓日程](https://www.appinn.com/xricheng-calendar-wechat/) 是一款可以在微信里与朋友一起使用的日历工具，与朋友一起确定社交聚会、团队行动的时间，还能确认参与人员。也可以用来订阅常用的日历，比如比赛、电影、新闻等等。
- [ieaseMusic](https://www.appinn.com/ieasemusic/) 是一款非常漂亮的网易云音乐播放器，为了解决死链的问题，ieaseMusic 还聚合了 QQ 音乐，酷狗音乐、百度音乐的高品质音乐。
- [SingPlay](https://www.appinn.com/singplay/) 是一款全能消音 K 歌 App，可以帮用户实现音乐的一键消音，同时不需要任何的复杂的参数调整。
- [SpeedTest](https://www.appinn.com/speedtest-isp-maps/) 是一款流行的网络速度测试工具，线路遍布全球，包括非常多的中国线路，最近更新了多线程测速，以及在 Android 版本上添加了运营商信号地图覆盖功能，能够直接在地图上看到网络信号覆盖情况。
- [BigType](https://www.appinn.com/bigtype-for-windows/) 是一款可以解放双眼的 Windows 工具，它能够在键盘光标周围短暂的显示放大镜，并在几秒钟后消失，便于用户看清楚输入的内容。
- 太鼓达人（日语：太鼓の達人）是一款历史悠久的敲鼓游戏，玩具需要配合音乐敲打乐器或者屏幕来完成正确的节奏。这个名为 [taiko-web](https://www.appinn.com/taiko-web/) 的开源项目是一个 太鼓达人 模拟器，它可以让你在电脑浏览器或者手机浏览器上直接敲鼓，推荐使用 Chrome 浏览器。
- [Berkanan](https://www.appinn.com/berkanan-for-ios/) 是一款不需要移动数据网络，也不需要无线网络，有蓝牙就能连、无需注册、P2P 连接、点到点加密，适合于人员密集到 Wi-Fi 与移动网络都不可用的时候使用。
- [Simple.Savr](https://www.appinn.com/simple-savr/) 真是一个神奇的网站，它能够帮你在同一个局域网的不同电脑、设备的浏览器中自动同步文本以及文件，只需要打开一个网站就能实现，非常的简单非常的酷
- [CC助手](https://www.appinn.com/ccyixia/) 是一款 Windows 与 macOS 平台的剪贴板管理工具，只需要复制两次（ctrl/⌘ + C + C），就能将剪贴板内容收藏进 CC助手中，支持文件，进而二次处理，包括 todo、Pin、分类整理、生成二维码等操作，使用体验非常流畅。
- [PasteEx](https://www.appinn.com/pasteex-for-windows/) 是一款能够在粘贴时自动生成文件的 Windows 工具，比如将剪贴板内的文本内容，粘贴为 txt 文件；将剪贴板内的图像，粘贴为 png/jpg 格式。
- [Location SMS](https://www.appinn.com/location-sms/) 是一款没有 4G 信号时也能让紧急联系人获取你地理位置的 Android 应用，只需要发送一条短信即可。另外还能当作寻找手机时使用，支持电子围栏。
- [QQ空间导出助手](https://www.appinn.com/qzoneexport-for-chrome/) 是一款用来导出 QQ 空间的日志、私密日志、说说、相册、留言板、QQ好友、视频为文件的 Chrome 扩展，供永久保存。
]]></content>
      <categories>
        <category>Software</category>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
      </tags>
  </entry>
  <entry>
    <title>Office 使用技巧</title>
    <url>/word-typesetting/</url>
    <content><![CDATA[
各种论文、提案等文档，除了需要良好的文字水平以外，排版也非常重要。这篇文章分享一些常用技巧，包括了图片、表格、公式的编号与交叉引用，公式居中、编号右对齐等，使得我们可以快速规范化文档样式。

<!--more-->

- [latex与word之间的各种转化方法](http://bbs.keinsci.com/thread-2208-1-1.html)

# 样式

[发愤的草莓](https://www.zhihu.com/question/26898769)给出的方法是：给Word写长文（特别是结构化长文）前“打个底妆”——做好段落样式的规划。这种内在美体现在批量式操作、灵活式跳转、快捷式移动、永久式克隆。

因此，推荐使用 Word 中的样式（自己制作或者网络下载）来加速论文排版格式设置。

<div class="note info"><p>华中科技大学毕业论文的WORD模板在标题样式、自动编号和交叉引用等方面提供了参考，有兴趣可以参考[下载](https://pan.baidu.com/s/1hVBs_RVHaHjQLvfKriaV0w)（密码：4qa8），最好保存链接，后期会不定期更新细节。</p></div>

1. 下载`样式模板.dot`。
2. 直接用 Word 打开样式模板文件（实际上就是使用该模板新建了一个 Word 文档）。将自己的论文复制粘贴进去，就可以使用样式来设置论文格式了，然后需要保存为一个新的 Word 文件。也可以应用样式到文档中。

更多内容可以参考：

- [使用 Word 中的样式来加速论文排版格式设置](https://cnzhx.net/blog/word-styles-for-zzti-thesis/)
- [如何将一个word文档的样式应用到另一个word文档](http://www.360doc.com/content/14/0306/11/691214_358174386.shtml)

# 目录

自动生成目录后在对应的页码加上括号的方法：

1. 自动生成目录
2. 按住Alt键移动鼠标选择要加括号的页码这一列，然后按`Ctrl+H`，弹出替换的窗口，在查找内容栏输入`([0-9]{1,})`，在替换栏里输入`(\1)`，点击下面的更多按钮。
3. 勾选使用通配符，点击`全部替换`，此时会给你所选定的这一列页码全部加上括号。也可以选择查找下一处依次选择需要替换的地方，这样可以避免把目录文字里面的数字也加上了括号。
4. 替换完后会显示已替换所选择目录内页码已加括号的数量，点击否。

<div id="multilevel-list "></div>

# 多级标题编号


[定义新的项目符号、编号和多级列表](https://support.office.com/zh-cn/article/%E5%AE%9A%E4%B9%89%E6%96%B0%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%AC%A6%E5%8F%B7%E3%80%81%E7%BC%96%E5%8F%B7%E5%92%8C%E5%A4%9A%E7%BA%A7%E5%88%97%E8%A1%A8-6c06ef65-27ad-4893-80c9-0b944cb81f5f)。<font color=blue>请在`定义新的多级列表`中一次性设置多级标题属性</font>，不然可能会造成编码错误。

<div id="word-figure"></div>

# 图片和表格的插入

按照一般的习惯，以及科技文档的要求，图题应该放在图片的下方，而表题应该放在表格的上方。

## 插入三线表

三线表，通常包括表头、表身与表注等，第二条线最细（通常为 0.75 磅）。用来作为区分的界限，上下的线较粗（通常为 1.5 磅）。参考[快速搞定学术论文中的三线表](https://zhuanlan.zhihu.com/p/33000931)。

感谢博文[一键制作三线表](http://blog.sciencenet.cn/home.php?mod=space&uid=528739&do=blog&id=1185831)：

1) 打开任意Word文档。
2) 按`Alt+F11`，出现VBA程序界面，鼠标点选Normal。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190628150055.png)
3) 选择菜单栏“文件-导入文件”，选择相应的`.bas`文件导入。
4) 关闭VBA界面，回到Word视图，在工具条选择“自定义快速访问工具栏”。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190628150204.png)
5) 在打开的界面选择“宏”，然后在下拉菜单中会出现之前导入的`bas`文件，点选后添加。添加后，可以在右边栏选择对应的VBA宏名，点击下面的“修改”按钮，可以更改名称和图标，安装完毕。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190628150227.png)
6) 打开您需要处理的Word文档。点击之前添加的图标，程序即可对文档中所有表格执行三线表操作，您也可以选择若干表格，那么程序只对您选择的内容进行操作。

<div class="note info"><p>推荐使用一键制作三线表方法</p></div>

word 2016中的手动设置步骤：

1. 【插入】----【表格】；直接用鼠标绘制出三列的表格即可；
2. 选中表格，选择【表格工具】中的【设计】；最右侧的表格下，选择下拉菜单--【创建表格样式】；更改表格属性名称为【三线表】；
3. 点击左下角【格式】---【边框和底纹】；【自定义】设置【预览】中选中上边框与下边框，其他的都不选中～将宽度设置为 1.5 磅；
4. 【将表格应用于】修改成【标题栏】；按照刚才方式，点击【格式】---【边框与底纹】---【自定义】---上边框选中 1.5 磅，下边框选择 0.75 磅。
6. 最后将【仅限此文档】切换到【基于该模板的新文档】即可；
7. 最后可以任意绘制一个表格选中刚刚创建的新样式，即可套用


## 图片并排

1. 先将两张图片均导入word中，位置设置为“嵌入文本行中”，调整图片大小使得两图片刚好可以呈现在同一行。
2. 如果两图片各自要有题注，分别选中两张图片（即该操作对两张图片都要各做一次）：页面布局->分栏->两栏。设置好后，将后面一张图片拖至前一张照片紧随其后，即可看到两张照片并列呈现的样子，然后分别对两张图片添加题注即可。

## 插入EPS

由于安全问题，office 2017年4月份更新后，不再支持直接插入eps。目前的解决方法是修改注册表。

方法1：（失效）打开注册表，对64位系统而言，找到`HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Office\Common\Security\AllowLists\GraphicsFilterImport`。如果没有，自己创建，然后在里面以`REG_DWORD`格式写入`AllowListEnabled`，值设为`1`，然后添加`EPSIMP32.FLT`，后面写上office版本号，就大功告成了[^27157718]。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1frdgvqsq7kj30k009ujs3.jpg)

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/006V2m65ly1frdgvyyko8j30k00cx74l.jpg)

[^27157718]: [word 、ppt 无法插入eps图片，解决方法](https://zhuanlan.zhihu.com/p/27157718)

<div id="figure-autonumbers"></div>

# 图片和表格的自动编号

Word 有内置的题注格式，如果不想用，还可以新建新的格式。

1. 插入需要的图片，在图片上单击鼠标右键，选择“插入题注”（Insert Caption）。
2. 调整配置。在弹出的题注设置对话框中输入/设置题注的标题（输入标题时最好在前面自动生成的题注标签和编号后面输入一个空格），选项中的标签、（题注）位置，还可以勾选下面的排除标签选项。
  ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729121558.png)
1. 新建标签。如果默认的题注形式不符合要求，还可以自己创建一个“新标签”（New Label），也可以只更改“编号”。比如上面默认的标签是 Figure，我想改成“图”。于是单击“新建标签”，在弹出的对话框中输入“图”（不要引号，注意不要输入任何数字，实际编号的数字Word会自动处理的），此时题注对话框的第一行的自动生成部分就符合要求了。
2. 修改编号格式。一般毕业论文中的图和表，其题注的编号需要带上章节号，例如，图1-1 xxx。此时，我们单击“编号”（Numbering），打开“题注编号”（Caption Numbering）对话框，如下图所示。选中“包含章节号”（Include chapter number），上面可以选择数字格式，然后就可以在下面选择 Heading 1，下面还有连接符。这个 Heading 1 就是一级标题的意思（一般章标题都用一级标题）。这些修改完成后，在同一个文档中都是一直有效的。
  ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729121629.png)
1. 自动插入题注。由于我们希望每次插入图片后Word能够自动为插图编号，所以单击“自动插入题注”按钮，在打开的对话框中进行设置。在插入时添加题注列表框中勾选**插入时添加题注的名字**，然后设置**使用标签、位置**，可以单击“编号”按钮，在弹出的对话框中进行设置。设置完成，单击“确定”后返回Word编辑窗口。以后插入相应设置的题注时，Word就会自动为它们添加编号了。
1. 更新题注。每次调整了图片/表格在文档中的顺序，或者是在中间删除/增加了某些图片/表格，整个文档的图片/表格的编号都需要重新编排。一般 Word 会自动完成，如果发现它没有自动完成，可以选中文档全部内容，按下键盘“F9”（或者鼠标右键单击，选择菜单中的“更新域”）即可。


<div id="figure-cross-reference"></div>

# 图片和表格的交叉引用

引用很简单，只要将鼠标光标定位到需要插入引用的位置，然后（步骤编号如上图所示）：

1. 单击 Word 工具栏中的“引用”（References）选项卡；
1. 单击“交叉引用”（Cross-reference）即可打开对话框；
1. 选择要引用的“类型”（Reference type）；
1. 选择引用格式（Insert reference to），一般是“只有标签和编号”（Only label and number）；
1. 挑选要引用的那幅图；
1. 单击“插入”（Insert）；
1. 已完成。

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729121656.png)

<div id="word-math"></div>

# 公式的插入

- [Word插入Latex公式的几种方式](http://blog.csdn.net/lzuacm/article/details/17287385)
- [如何在 Word 和 PowerPoint 中优雅地插入 Latex 公式](https://www.zhihu.com/question/40763253)

<div id="word-mathtype"></div>

MathType是MS Word中最常用的一种数学公式编辑器插件。在默认情况下，MathType公式都将以OLE对象（Object Linking and Embedding object）插入在MS Word文档中。

<div id="word-mathml"></div>

最新Office版本中MathML的体验更加完善。在Word中任意位置按下`Alt+=`可以切换公式编辑（或者点击插入选项卡-插入公式），或者选中文字按下`Alt+=`把它变成公式。在公式编辑中，快捷命令通过空格可以立即转换成格式化后的公式形式。网页渲染的公式可以在公式区域右键点击，选择 `Show Math As` $\to$ `MathML Code`。拷贝一下弹出来的 MathML 代码，再到 Word 里面**以文本格式粘贴**（不是直接`Ctrl-V`）。

> - [Word 2016自带公式编辑器如何做到等号对齐](https://www.zhihu.com/question/42837433)  
> - [Equation Arrays](https://blogs.msdn.microsoft.com/murrays/2011/03/30/equation-arrays/)

MathML只需在公式编辑器中，每行的等号的左边输入一个`&`字符即可，在专业型模式下该字符不可见，切换到线性模式下就能见到了，如果一行里有多个位置需要对齐，只需在多个位置输入`&`即可。对于长公式的等号对齐，先把公式写在一行里，在等号处按`Shift+Enter`插入软回车（注意第一行公式最右边软回车标记），在每个等号左边右键点击`在此字符处对齐`。

```
\eqarray(10&x+&3&y=2@3&x+&13&y=4)#(1)
```


详细使用方法查看：

- [Linear format equations and Math AutoCorrect in Word](https://support.office.com/en-us/article/Linear-format-equations-using-UnicodeMath-and-LaTeX-in-Word-2e00618d-b1fd-49d8-8cb4-8d17f25754f8?ui=en-US&rs=en-US&ad=US)
- [Word - 快速输入数学公式](http://jacobz.top/2017-08/WordMath/)
- [Word2016 中插入数学公式和代码高亮](http://blog.csdn.net/u012705410/article/details/51210331)

如果更换内置公式的数学字体，字体必须支持Opentype Math。下载[数学字体](http://pan.baidu.com/s/1dFBac1r)（密码：swgr）后，打开`C:\Windows\Fonts`将字体拖入安装。在公式设计栏目的工具里点击右下角的快捷键，选择你需要的字体，然后点击左下角默认值设为新建公式的默认字体，点击确定。

尽管Word中支持更改这些字体，但是Office本身局限性，自带pdf输出只支持Cambria Math转换为矢量文本，并不支持其他数学字体转换公式为矢量文本，而是强制转换为位图导致模糊。从Word文档中转换pdf**必须要到**Acrobat DC Pro的Word插件PDFMaker，可以输出高质量的pdf文档。此外，最好设置为高质量印刷来输出 pdf，点击`首选项>转换设置>高质量打印`。

- Latin Modern Math，TeX Live自带默认的数学字体
- STIX， TeX Live中自带，全称是Scientific and Technical Information Exchange font，这个字体是一套比较大的也是历史比较长的字体，这个字体包含正文字体和数学字体。这个字体风格类似Times，所以很多刊物会用到的。
- XITS Math（推荐使用），基于STIX的一套数学字体，TeX Live中自带，比STIX多了一些数学扩展。类似于Times New Roman.
- Bonum Math、Pagella Math、Schola Math、Termes Math一系列字体
- Neo Euler，这个字体需要单独安装6.Cambria Math， 默认字体
- Asana Math， TeX Live自带数学字体

**MathType公式与MathML公式可以相互转化**。


- 将MathType公式转化为MathML公式：
    - 打开MathType公式编辑窗口，在菜单栏中点击选项下的剪切和复制选项，打开转换对话框。
	- 在转换对话框中，将剪切和复制数据类型更改为：转换其他文字，并在下拉选项中选择MathML 2.0 (namespace attr)。点击确定保存更改的设置。
	- 打开目标Word文档，使用MathType打开需要转换的OLE对象公式。在MathTpye对话框中复制需要转换的公式。
	- 在Word文档中**以文本格式粘贴**（不是直接`Ctrl-V`）。
- 将MathML公式转化为MathType公式：
    - MathType插件栏提供了MathML公式转化为MathType的入口，但转化速度较慢。
	- 如何遇到[Problem Converting OMML to MathML](https://docs.wiris.com/en/mathtype/office_tools/support_notices/tn166)的问题，将`Microsoft Office\Office16\OMML2MML.XSL`复制到`Microsoft Office\root\Office16\OMML2MML.XSL`即可。
	- MathType插件栏中格式化公式样式比较好用。

<div id="word-aurora"></div>

## Aurora插件

Aurora 可以在 Word 中插入 LaTex 公式，排版和 LaTex 一样，非常漂亮。当然你可以利用MathType转化为LaTex，在用Aurora渲染，不失为一种好方法。

但是 MathType 是选择然后复制进去的，Aurora 是直接输入 LaTex 源码，然后直接插入（可以不用鼠标，个人觉得更加方便了。）安装后在 Word 插入对象里多一个 Aurora 标签。（因为插件兼容性问题，微软建议使用 32 位的 Office，即使是在 64 位系统上也是如此。）

> [Aurora 百度网盘下载地址1](http://pan.baidu.com/s/1nvfCtp3)（密码：3o05），[Aurora 百度网盘下载地址2](http://pan.baidu.com/s/1gfvvWVh)（密码：xm5d）

Aurora 是以 MiKTeX 核心，**鱼（Aurora ）与熊掌（texlive）不可兼得**。

- [Aurora的安装和中文配置](http://www.voidcn.com/article/p-mpegyszs-nh.html)
- [Aurora 2.3 连接 office 2016 使用 LaTex](http://alwa.info/2016/05/04/Aurora-2-3-%E8%BF%9E%E6%8E%A5-office-2016-%E4%BD%BF%E7%94%A8-LaTex/)
- [在Word上无缝使用Latex](http://blog.yeates.cn/?p=952)


使用方法：  
（一）安装Micro-Miktex软件。  
（二）安装Aurora。在安装组件时不选择Micro-Miktex，或是在提示需下载、安装Micro-Miktex时，跳过。  
（三）使用Keygen直接进行对Aurora的自动破解注册。  
（四）Enjoy it !  

<div id="LaTeX2Word"></div>

## LaTeX2Word

- 开源的[LaTeX2Word-Equation](https://github.com/idf/LaTeX2Word-Equation)，还实现了[chrome插件](https://chrome.google.com/webstore/detail/latex2word-equation/oicdodhdflfciojjhbhnhpeenbpfipfg)。但只适合复制别人的MathML公式，使用范围有限。
- 选中要转换的区域，点击`MathType`的`ToggleTeX`按钮就转换完成了。这一转换`equation`环境，`align`环境等等是无法识别的，主要识别的是`\[\]`，一个是`$$`。
- 网络扩展[latex-para-word](http://engenharialivre.com/latex-para-word/)。

<div id="math-cross-reference"></div>

# 公式的编号与引用

> - [Equation Numbering in Office 2016](https://blogs.msdn.microsoft.com/murrays/2015/05/14/equation-numbering-in-office-2016/)  
> - [教你如何在 Word 2016 中插入带编号的公式](http://bbs.feng.com/read-htm-tid-9698249.html)

文章中公式展示的预期效果是：公式居中，尾端有编号，同时在文章中可以实现引用。

1. 设置公式和编号格式[^question/19689000]。
    - 首先要打开word里的标尺（视图-标尺）。
    - 新建样式，在弹出的对话框中输入样式名称，然后点修改。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729121436.png)
    - 设置样式属性，按照图中设置好属性，选择格式-> 制表符。设置公式居中对齐的标志，可以从word上的标尺上读取，本人的word水平中心对应的17字符，所以在制表位位置输入17字符，对齐方式选居中，前导符选无，点设置；设置公式序号的标志，就是最右边的位置，本人的word右边对应的是34字符，所以在制表位位置输入34字符，对齐方式选右对齐，前导符选无，点设置。最后点确认。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729121506.png)
    - 设置格式段落，选择格式-> 段落。缩进和间距中，行距为单倍行距，中文版式中，文本对齐方式设置为居中。
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/20190729121537.png)
1. 公式的编号。由于用“插入”->“引用”->“交叉引用”引用公式编号时。不管选择“整项题注”还是“只有标签和编号”，实际插入的都是公式和公式编号。解决方案：
    - 光标放在公式的那一行，点选工具栏里面“公式样式”。
	- **加一个Tab，输入公式，加一个Tab**。
    - **回车，在新行输入中文括号（）**，选择“插入”->“引用”->“题注”就可以插入公式编号，同[图片和表格的编号](#figure-autonumbers)。
    - 将光标移到公式行的行尾，按下`Ctrl+Alt+Enter`键插入一个样式分隔符。这时公式编号行会连到公式行的末尾。`Ctrl+Alt+Enter`键对应的命令是“InsertStyleSeparator”。可以通过自定义菜单将命令按钮放到工具栏上。可以把回车后的操作用录制宏记录下来，并指定到快捷键上。这样只要按一下快捷键就可以插入自动编号并可以正确引用的公式了。
1. 公式的交叉引用。同[图片和表格的交叉引用](#figure-cross-reference)，在需要引用公式的地方用“插入”->“引用”->“交叉引用”引用公式编号，可以选择“整项题注”引用公式编号行的所有内容。
1. 在插入和删除一个公式编号后，需要更新所有域。更新所有域的方法是全选（Ctrl+A）后按F9键。

[^question/19689000]: [如何在 Word 2010 中给公式自动编号？](https://www.zhihu.com/question/19689000)

> 在同一个段落，Word只支持一种样式。我把公式和编号放在同一行。在我插入题注时，这一行（包括公式）的样式就变成了题注。
在交叉引用时，Word根据“题注”样式选择要插入的文本。如果选择“整项题注”，就插入编号所在段落的所有“题注”样式的文本。 如果选择“只有标签和编号”，就插入编号以及编号前所有“题注”样式的文本。

# 代码块的插入

- 用`Notepad++`直接编辑代码文件，注意文件后缀。
    1. 选中需要的代码块（或者不选，默认对全文操作），使用“插件 -> NppExport”
    2. 然后直接粘贴到Word就行了。
    3. 行号、背景设置查阅[如何在Word中排出漂亮的代码](https://blog.csdn.net/code4101/article/details/41802715)
- [pygments](http://pygments.org/)提供了word中代码着色功能。
    1. 输入代码描述，选择语言，选择本地文件或者直接粘贴代码，点击右下角的Hilight按钮。
    1. 选择配色方案，点击Go。
    1. 复制到word当中。
- 在[代码框](http://www.planetb.ca/syntax-highlight-word)中粘贴代码，选择语言，点击Show Highlighted。复制生成的代码段[^79746616]。
    1. 在 Microsoft Word 选择“插入”选项卡，再点击对象
    2. 在弹出的窗口上选择“OpenDocument文本”
    3. 在新弹出的word窗口里之前生成的粘贴代码段
    4. 保存后关闭新弹出的word窗口即可看到代码被优雅的插入了


[^79746616]: [在 Microsoft Word 优雅的插入代码块](https://blog.csdn.net/qq_23599965/article/details/79746616)

# 批量修改图片

[word批量导入、修改图片大小和压缩图片](http://jingyan.baidu.com/article/fdbd4277145ebbb89e3f48d1.html)，但是也会变化公式的大小，谨慎使用。

# 批量替换

> [Word查找替换详细用法及通配符一览表](https://www.cnblogs.com/whchensir/p/5768030.html)

word 的通配符：

`^?`  任意字符； `^#`  任意数字； `^$`  任意字母； `^p`  段落标记； `^t`  格式标记； `^d`  域；`^w`  空白区 (空格、不间断空格、以及任意顺序的格式标记)；`^f`  脚注标记； `^e`  尾注标记；`^b`  分节符；`^&`  原查找内容； `^c`  剪贴板内容。

- 清除多个空行：用“替换”指令，将 `^p^p` 替换为 `^p` ，执行多次。
- 清除多个软回车：软回车是 `Shift + Enter` 产生的，在替换命令中表示为 `^l`。

<div id="domain-hotkeys"></div>  

# 域快捷键

每次在 Word 中进行域的相关操作都可能用到快捷键，因为有些操作很难通过点击鼠标来完成，特别是批量操作多个域的时候。

如果需要批量操作一大段里的域，就先选中这一大段内容，如果是全文，那当然是用 Ctrl+A 来全选了。

域操作的相关快捷键有：

**F9 键** —— 更新单个域，这个比较常用。

**Ctrl+Shift+F 9组合键** —— 把域固化为纯文本，编辑完文档发给别人的时候多半需要这么做。因为很多东西到了别人那里可能就会自动发生变化。

**Ctrl+F9 组合键** —— 快速插入域定义符“{ }”。这玩意儿不能用键盘直接输入花括号，不然就不是域了。倒是比较少用。

**Shift+F9 组合键** —— 显示或者隐藏**指定的域**代码。如果要针对文档中所有的域代码，则用下一个组合键。

**Alt+F9 组合键** —— 显示或者隐藏**文档中所有域**代码。

关于域的信息可参考微软 Office 官方文档：[Word 中的域代码](http://office.microsoft.com/zh-cn/word-help/HA102749146.aspx)。

<div id="word-reference"></div>  

# 参考文献

在使用Word写作时，建议使用文献管理工具如 Noteexpress、EndNote等插入和排版。如果有bibtex文献格式，则可以使用Bibtex4Word插件使用。

如想手工编辑，则建议使用[Word交叉引用功能](https://blog.csdn.net/weixin_43519707/article/details/105493375)，并结合 [参考文献在线生成器](http://www.citethisforme.com/zh) 或 [Free APA & MLA Citation Generator](http://www.studymode.com/citation-generator/) 或 [EasyBib: Free Bibliography Generator](https://www.easybib.com/) 或 [Reference Machine](http://www2.elc.polyu.edu.hk/CILL/referencemachine.htm)等工具生成规范的参考文献。

对于Word参考文献交叉引用的连续引用：

    - 方法一：选中引用的编号右键【切换域代码】，分别加入字符`”\#"[0"`和`\#"0]"`，右键域代码选择【更新域】，中间加破折号变为[1-3]。另存为PDF时需要取消域链接：`Ctrl+A`，`CTRL＋SHIFT＋F9`。
    - 方法二：选择 ：【字体】 -> 【隐藏】，然后在两个标注之间，添加逗号变为[1,2]。对于连续多个，如[1][2][3]，将不出现的部分，全部隐藏，然后添加“-”。全选（Ctrl+A），按F9更新域。

<div class="note info"><p>[参考文献的缩写](https://sli1989.github.io/reference-manage/#abbrev)</p></div>

<div id="Bibtex4Word"></div>

## Bibtex4Word

> [利用Bibtex4实现Latex在Word写作时参考文献的插入和排版](http://blog.csdn.net/zd0303/article/details/8054684)

对于熟悉和使用LaTeX写作方式的使用者而言，则可以被JabRef+Bibtex4Word替代，前者是管理bibtex格式参考文献的管理工具，后者则是一个用于Word写作中的宏，用于实现你选择的文献样式下的文档中插入文献的引用和排版。

准备工作：

1. 确保机器上已经安装有TeX软件，推荐使用[TEXLIVE](https://sli1989.github.io/tex/#texlive)。
3. 确保机器上已有管理bibtex形式的参考文献管理工具，推荐使用[JabRef](https://sli1989.github.io/reference-manage/#JabRef)。

以下以TEXLIVE设置介绍，MikTeX软件的设置教程查看[官网说明](http://www.ee.ic.ac.uk/hp/staff/dmb/perl/index.html)。

1. 下载[bibtex4word.zip](http://www.ee.ic.ac.uk/hp/staff/dmb/perl/bibtex4word.zip)并解压到任意文件夹A；
2. 将解压缩后的文件夹中的`bibtex4word.dot`文件，复制粘贴至Word的启动文件夹`...Microsoft\Word\STARTUP`，操作系统不同将导致该启动文件夹的路径不一样，推荐使用[everything软件](http://sli1989.github.io/windows-use/#search)查找。
4. 对于使用TEXLIVE，需要加入环境变量：
    - `BIBEXE = C:\texlive\2021\bin\win32\bibtex.exe`
    - `OPENOUT_ANY = r`
4. 重新启动Word后，Word的工具栏‘ 加载项-自定义工具栏 ’上将会出现`Bibtex4Word`的工具条。进入文件`Test4w.doc`进行测试即可。
    - 第一位：添加文献的bibkey（不能包含中文），英文逗号分隔。将光标放置在已经排版好的引用标记处，如[1-4]处，点击第一位图标即可出现含有原来bibtexkey的对话框，通过删减或增加新的bibtexkey即可更改引用文献。
    - 第二位：生成参考文献。尤其注意第一次点击这个图标时：最好在你想要生成参考文献列表的地方先点击左键，再点击这个图标。即可在光标处插入定制的文献排版样式。之后每次更新参考文献列表时会固定在这个地方生成，不可改变。
    - 第四位：设置引文格式
1. 中英文混合文献设置。
    - 下载[GBT7714-2005.bst](https://github.com/Haixing-Hu/GBT7714-2005-BibTeX-Style)，放入`..texmf-dist\bibtex\bst\gbt7714`文件夹内
	- 以管理员方式运行`TeX Live command-line`，输入texhash并回车
	- 设置引文格`gbt7714-2005/nsch^p`（加个p即可指定UTF-8编码，避免中文出现乱码，注意bib bst文件都需要utf-8）
1. 如果上述无法运行，需要进行如下设置：
    - 保证`C:\Windows\SysWOW64\Shell32.dll`存在；
    - 开始菜单输入cmd，并以管理员身份运行；
    - 进入文件夹`cd \windows\syswow64`，并运行`regsvr32 shell32.dll`，提示注册成功。
1. 如果还是不行，进入`word选项-自定义选项- 常用命令- 主选项卡`，勾选‘开发工具’，点击确定后退出。然后回到界面，进入‘开发工具-visual basic- 菜单栏- 引用’，确定`Microsoft Office xx.Object Library`是勾选的即可。

### 定义文献样式

Bibtex4Word是调用eX编译处理参考文献的引用和排版样式的，因此必须预先定义你自己使用的bst样式文件。详细查看[Bibligraphy Style](http://www.ee.ic.ac.uk/hp/staff/dmb/perl/index.html)。

- [符合国家标准《GB/T 7714-2005: 文后参考文献著录规则》的BibTeX样式文件](https://github.com/Haixing-Hu/GBT7714-2005-BibTeX-Style)

点击工具箱第四位设置引文格式，填写“GBT7714-2005NLang/nsch” ，斜杠前是你选用的参考文献样式名称，如：GBT7714-2005NLang，或 abbrvnat，或IEEEtran等等；斜杠后是你想在该样式文件中决定的参考文献引用的方式（上标？压缩引用？超链接？）。若采用顺序样式文献bst文件，我推荐填写“GBT7714-2005NLang/nsch”，采用著者年样式bst文件，我推荐填写“GBT7714-2005AYLang/(l2ysh”。

> - n，表示强制文后文献以数字顺序排列，不管选用的样式文件是著者年还是顺序方式的；
- s，表示“sort”，将顺序引用的标记[2,4,1,3]整理为[1,2,3,4]；
- c，表示“compress”，将顺序引用的标记[1,2,3,4]压缩为[1-4]；
- h，表示“hyperlink”，将引用标记与文后文献的对应条目之间建立超链接关系，按住“ctrl”键用鼠标左击标记即可跳转至对应的文献条目，返回则是按住“alt”键后按一下方向键中的“<—”键即可；
- ^，表示上标引用方式，即[4]样式；
- [，表示引用标记采用方括号样式，例如[4-9];
- (，表示引用标记采用圆括号样式，例如(Smith, 2000);

由于使用的文后文献数据库以及样式通常不变，因此可以设置环境变量来定义默认的文献数据库以及样式和属性。详情可参见Bibtex4Word网站的[默认设置说明](http://www.ee.ic.ac.uk/hp/staff/dmb/perl/index.html)。

- 右击“计算机”—属性—高级系统设置—高级—环境变量—用户变量—新建，在弹出的对话框中，“变量名”填写“BIBSTYLE”，“变量值”填写“GBT7714-2005NLang/nsch”或其它你选用的样式。
- 选用的bib数据库和bst文件必须编码相同，否则会出现乱码现象。
- 如果文章主要使用顺序上标样式但同时有行内引用标记，可以尝试本人的一个小技巧。首先点击图标，在弹出的对话框中填写“GBT7714-2005NLang/^nsch”，需要行内引用的标记，生成文献列表后变为“文[2]研究了……”，这时可以选中该标记“[2]”，然后点击工具栏中的上标按钮“x2”即可变成“文[2]研究了……”。
- 引用多条文献时，可以先用JabRef的推送功能，一次性推送多条bibtexkey到一空白的winedt文档，然后复制粘贴，可以提高效率。


# Excel

## Vlookup函数

> [Excel如何将两个表，根据有相同数据的一列数据，自动填写到另外一张表](https://www.zhihu.com/question/38606861/answer/77217718)  
> [如何用vlookup函数查找返回多个符合条件的结果](http://www.officezhushou.com/vlookup/5237.html)  
> [Vlookup函数实现多条结果查询](https://zhuanlan.zhihu.com/p/38038487)

- 如果数据源单元格和筛选的目标区域在同一个工作表，使用高级筛选即可满足。<font color=red>条件字段的顺序要与源表顺序一致，否则结果是错乱的。
</font>
    ![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/645f3b4dgy1g19i624jngj20k00e00u7.jpg)
- 跨表格查找数据求和：`=SUM(SUMIF(INDIRECT("sheet1D:D"),C4,INDIRECT("sheet!E:E")))`（搜索D列中C4，返回E列）
- 如果数据源单元格和筛选的目标区域不在同一个工作表，则使用Vlookup函数：vlookup(查找对象，查找区域，要返回查找区域的第几列，精确查找还是模糊查找），`=VLOOKUP($A1,'[2.XLS]1'!$A$7:$W$118,COLUMN(C1),FALSE)`。  
    - <font color=red>查找对象必须在查找区域的第一列</font>。因此，可以添加如下列为第一列：`=SUBSTITUTE(TRIM(F2)," ","")`（去掉多余空格）。如果存在重复名，可以考虑添加COUNTIF函数：`=SUBSTITUTE(TRIM(F2)," ","")&COUNTIF($F$2:F2,F2)`（计数）。
    - 使用Vlookup函数：`=IFERROR(VLOOKUP(F2&COUNTIF($F$2:F2,F2),'F:\文档位置\[文档名称.xls]表格名称'!$A$1:$Z$40,COLUMN($Q$5),FALSE),"")`。如果空值IFERROR函数返回空，也可以改为其他值。也可以用`=公式&""`实现。
        - 查找对象：`F2&COUNTIF($F$2:F2,F2)`
        - 查找区域：`'F:\文档位置\[文档名称.xls]表格名称'!$A$1:$Z$40`
        - 要返回查找区域的第几列象：`COLUMN($Q$5)`
    - 如果需要数值为0不显示，
        - 单击`OFFICE按钮`－`EXCEL选项`－`高级`－`此工作表的显示选项`—不勾选`在具有零值的单元格中显示零`。
        - 使用IF函数：`=if(公式=0,"",公式)`，如`=if(VLOOKUP($A1,'[2.XLS]1'!$A$7:$W$118,COLUMN(C1),FALSE)=0,"",VLOOKUP($A1,'[2.XLS]1'!$A$7:$W$118,COLUMN(C1),FALSE))`
    - 下拉或者右拉公式即可自动填充。
    - <font color=red>另存备份文档</font>，清除公式保留数据。
        - 按`ALT+F11`，打开`VBA编辑器`，`插入`——`模块`，复制下面代码
            ```
            Sub excel去掉公式()
            Dim sh As Worksheet
            For Each sh In Sheets
            sh.UsedRange = sh.UsedRange.Value
            Next
            End Sub
            ```
        - 按`F5`键运行即可去掉公式保留内容。
]]></content>
      <categories>
        <category>Software</category>
        <category>Office</category>
      </categories>
      <tags>
        <tag>Office</tag>
      </tags>
  </entry>
  <entry>
    <title>如何写综述</title>
    <url>/write-review/</url>
    <content><![CDATA[
综述是对学科中某个研究方向进行总结和展望的论文，一般是由对该领域有深刻理解的学者撰写。撰写综述需要阅读大量的文献，需要作者检索文献，筛选文献，从文献中提取重要的信息以及进行批判性的思考。写综述[^blog-1991755]，是新手入门的一个非常好的方式，也是对自己思路的一个整理，非常不错。文献综述需要解决如下三个问题：**研究背景、研究现状和亟待解决的问题**。

<!--more-->

> [撰写综述的十个原则](http://blog.sciencenet.cn/home.php?mod=space&uid=255662&do=blog&id=1099346)  
> [六步搞定文献综述](http://blog.sciencenet.cn/home.php?mod=space&uid=822310&do=blog&id=1144134)  
> [博士文献综述怎么写？国外专家来教你](http://blog.sciencenet.cn/home.php?mod=space&uid=3297845&do=blog&id=1175034)

文献综述除了梳理重要的研究进展外，很重要的一个内容是对相关研究进展评述，同时要对学科领域存在的问题（有争论的问题，甚至不同学者的研究之间相互矛盾的问题等）、未来的发展趋势等进行预测和展望，这需要作者具有一定的研究基础和学术功底。所以，很多期刊的综述文章采取约稿的方式，不接受自由投稿。

[^blog-1991755]: [如何写综述](http://blog.sciencenet.cn/blog-1991755-1006463.html)

综述综述[^uid=1953670]，显然要包括“综”与“述”两方面。
- 所谓“综”就是指作者必须对现有的大量素材进行归纳整理、综合分析，而使材料更加精炼、更加明确、更加层次分明、更有逻辑性。
- 所谓“述”就是评述（现状评述，发展前景预测，从一个更高的层面，从原理上、方法论上和系统性上加以评价），是对所写专题的比较全面、深入、系统的论述。

因而，综述要看大量文献，是对某一专题、某一领域的历史背景、前人工作、争论焦点、研究现状与发展前景等方面，进行归类提炼，找出共同点和不同点，优势和劣势，以作者自己的观点写成的严谨而系统的评论性、资料性科技论文（或一部分内容），对该领域有前瞻性作用。

[^uid=1953670]: [综述综述，就是要做到既“综”又“述”](http://blog.sciencenet.cn/home.php?mod=space&uid=1953670&do=blog&id=1109171)

好的文献综述应该至少起到如下几个作用[^p/31673429]：


- 指出在你的研究之前都已经发现了什么
- 用一定的逻辑把这些研究串联起来（对比、归类、比较、分析），方便读者看到一个全景，而不只是你的研究
- 指出此前研究的gap是什么, 哪些点还没研究到，为什么缺，为什么缺的这个重要
- 指出你的研究会弥补上这个literature中的gap
- 让你的文章”fit in the big conversation”（融入到更大的对话中去）.

[^p/31673429]: [写好文献综述的两个要点](https://zhuanlan.zhihu.com/p/31673429)

根据一些经验，罗列如下建议：

选题--情报检索（保证你研究课题的原创性）--历史，人物和观点--标志性的文献（了解这个行业的大牛）--具体化--过滤--再次过滤--提取文献精华--获得经验。

1. 确定你的研究范围，进行[情报检索](https://sli1989.github.io/information-search/)。对于文献检索部分重点看硕博士论文前言绪论及综述文章（文献要有代表性），以期形成整体框架，详细内容不懂的可以暂时搁置。也可以进行[文献引文分析](https://sli1989.github.io/information-search/#literature-analysis)，绘制出某个研究领域的发展脉络图。
1. 整理和写。首先是将硕博士论文中的绪论部分求同存异，都给粘到一起，然后按照自己的逻辑给编排一下。如总体概况，发展历程，方法分类，材料分类，体系分类，意义及前景等等。这个对于新人了解课题和打基础是非常有用的，而且还为以后自己毕业季发文章写前言绪论节省时间。尤其是对于新手，我建议都走走这一步。
1. 提出一个方向，缩小关注范围，去看文章。对于目前这个研究领域基础是有了，那么接下来就应该缩小范围，找到一个点，比如那些硕博士论文提到了四五种方法，那你就关注一种方法，他们关注了六七个体系，你就选择一个体系。至于选哪个方法，哪个体系，建议要结合实验室，课题组的实际情况考虑。
1. 在看完之后就要有自己的论文架构，各篇论文应该归到哪一类，我建议最好的一种方法是**表格分类阐述**，直观！前面基础已经有了，大方向也有了，大家都是在关注哪几个问题？怎么做的？他们之间的共同点是什么，差异是什么，关键性能指标是多少，一些原理和机理是什么。列出表格后，再对表格进行**分析总结**，注意这里的总结不要是文献的简单罗列，文献的罗列只是表明你看文献了，并不能称之为总结。**总结要分门别类，比如按照掺杂类型分，按照分析模型分，然后才能比较，才能得出你想做的**。这个基本就可以算是综述文献了，可以尝试发表了。
1. 针对某一个问题，分析文献。先前看的文献都是某一个方法或者某一个体系而言，并没有针对某个问题，某个细节（如某个关键相）进行分析。现在看文献要落实到一些较细的关键点去看文献，看看别人怎么说的，要进行统计和比较。要对零散的文献进行统计，要对别人的图有自己的分析，把这个图当成是自己的，对它进行重新分析。最后得出自己的结论，提出新的问题和方法。

这些工作慢慢来，一如看文献，文献不是一天看完的，有个积累的过程，那么这些工作也是慢慢积累，慢慢沉淀最后才能真的做好。
]]></content>
      <categories>
        <category>Research</category>
      </categories>
      <tags>
        <tag>Review</tag>
      </tags>
  </entry>
  <entry>
    <title>武汉骑行地图</title>
    <url>/wuhan-bicycle/</url>
    <content><![CDATA[
在慢跑和骑行，成为时下最酷炫的运动方式后，你一定要找个空闲时间，或是骑行，或是慢跑，或是一起看夕阳。

<!--more-->

# 东湖绿道

全长：已建28.7公里
景点：樱园，梅园，植物园，落雁景区
配套设施：
东湖绿道里至少有7处自行车租赁点，17处自行车临时停放点，以及公厕、饮水、小卖部。绿道沿线有24处规模不等的驿站，提供吃喝拉撒、跌打损伤的相关服务。
梨园广场/磨山北门/磨山南门/落霞归雁景点/枫多山有5个电瓶车站点。
重点推荐：
荧光跑道、山坡木栈道
交通指南：
自驾 导航至梨园广场（汉口、汉阳的童鞋推荐此入口）、东湖风光村、欢乐大道九女墩路、落雁景区门口、磨山景区、东湖隧道口、武汉植物园任意入口即可进入绿道。
公交 1.乘401、402、413、625路至终点武汉植物园，步行约1.2公里由磨山挹翠（磨山南门）进入绿道。
2.乘电8、411、578、605、601、573路至梨园广场，步行约500米可由西门户-湖光序曲进入绿道。
注：因绿道建设，原有公交线513路停运。

# 后官湖绿道

全长：60公里
景点：钟子期墓，白莲湖广场
配套设施：
武汉第一条郊野绿道、第一条城市观光绿道。在这里可以玩真人cs野战、长跑、竞走、骑行，还有航模和游艇。
重点推荐：
荧光跑道、山坡木栈道
交通指南：
自驾 走汉阳大道往蔡甸方向，然后上知音湖大道，经过马鞍山隧道，遇见一个十字路口，右拐直行约1公里，就会看到绿道的入口。
公交 去后官湖绿道白莲湖广场坐公交车266路么铺站下车，过马路过白莲湖大桥，即到。

# 环金银湖绿道

全长：70公里
景点：金银湖
配套设施：
沿线有服务驿站、超市、公厕以及自行车租赁点
重点推荐：
荧光跑道、山坡木栈道
交通指南：
自驾 驶入金山大道后定位“金银湖绿道”即可。
公交 市内乘坐207路、216路、589路到金山大道市妇女儿童中心站下可到。

# 狮子山绿道


全长：10.37公里
景点：南湖、狮子山
重点推荐：
绿道漫步可远眺南湖美景
交通指南：
自驾 从三环线进入文化大道立交桥，行驶580米进入珞狮南路，右转进入狮子山大道。
公交 地铁光谷广场站c出口乘坐590在南湖大道华中农大下车，步行1.2公里，到达华中农业大学。

# 墨水湖绿道

全长：21公里
景点：墨水湖、武汉动物园
重点推荐：
雨后观赏墨水湖更有一番风情
交通指南：
自驾 导航“墨水湖公园”骑行至绿道即可
公交 可在新华路马场角乘坐803路于芳草路高家咀下车

# 环月湖绿道

全长：12公里
景点：琴台大剧院、琴台音乐厅、古琴台、月湖公园
配套设施：
沿线设有12座公交站点，附近公园内有配套卫生间。绿道附近有多个公共自行车租赁点
重点推荐：
月湖水系生态网络保持良好，既有得天独厚的自然条件，又富有深厚的历史文化底蕴。
交通指南：
自驾 鹦鹉大道—琴台大道—月湖公园—环月湖绿道。
公交 乘坐轨道交通4号线至钟家村地铁站步行至环月湖绿道。



# 青山江滩绿道

全长：7.5公里
景点：红钢城红房子、江边教堂
重点推荐：
二期建设了许多新景点，方便市民嬉戏游玩
交通指南：
自驾 导航至”青山江滩“即可
公交 乘坐公交511、514、549、702、807路等到”和平大道建设一路”下车，步行至江滩。

# 江夏环山绿道

全长：30公里
景点：大花山、青龙山、八分山
重点推荐：
从大花山、青龙山到八分山，一条30公里长的环山绿道，步行6小时，骑行2小时，登山远眺，夏季绿树掩映，冬季层林尽染。绿道与山间水库相望，一路心旷神怡。
交通指南：
自驾 从汉口市区自驾约40分钟，定位目的地“座山”，江花大道上能看到“环山路东入口”的醒目标示
公交 光谷坐903路到江夏大道向阳村站下车，步行400米


# 张公堤绿道

全长：30公里
景点：园博园、江滩公园、极地海洋世界
配套设施：
沿线有服务驿站、超市、公厕以及自行车租赁点
重点推荐：
全程30公里，路面宽度可达6米，漫步或骑行在张公堤绿道都是一件极其惬意的事情。
交通指南：
自驾 东西湖方向从金山大道(绿道)到马城东路(绿道)，骑至张公堤绿道，全程无缝衔接。
公交 地铁金银潭站B2出口下车，乘坐216路于将军四路站下车，步行2公里到达。

# 黄埔大街绿道

全长：12.5公里
景点：兴业路游园
配套设施：
沿线有服务驿站、超市、公厕以及自行车租赁点
重点推荐：
沿线枫杨成排，桂花梧桐成荫。燥热的午后和傍晚，这里成为市民休闲漫步、享受自然的绝佳去处。
交通指南：
自驾 导航到“黄埔大街一六一医院”即可
公交 乘坐229、248、30、346、548、550、552、627、电车3路到“黄埔大街一六一医院”下车。



---
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>武汉</tag>
        <tag>骑行</tag>
      </tags>
  </entry>
  <entry>
    <title>武汉旅游攻略</title>
    <url>/wuhan-travel/</url>
    <content><![CDATA[
武汉是湖北省省会，也是华中地区最大都市及中心城市。李白诗句“黄鹤楼中吹玉笛，江城五月落梅花”赐给武汉“江城”之名，在此交汇的长江、汉江赋予武汉“江城”之实。作为我国水陆交通枢纽，武汉控长江中游之咽喉，扼南北交通之要冲，素有“九省通衢”之美誉。

<!--more-->

烂漫樱花、湖光江景、丰富美食、厚重历史都给武汉这座城市增添了独特魅力。

武大和磨山的樱花，盛放时节灿若烟霞，各地游人慕名而至。不论是湖上泛舟还是湖边漫步，都会被秀美的东湖吸引；不论是在桥上还是在船上，都能为两江的夜景沉醉。

武汉是名副其实的美食之都，汉味早点尤为诱人，一碗热干面或是一盒鸭脖子就能让人流连忘返。江汉路、黎黄陂路等街道记录了租界时代的屈辱，军政府、起义门等遗存见证了近代革命的豪情。

有人说武汉市民聊天像吵架，有人说武汉公交速度堪比F1赛车，这或许是抱怨，也可能是玩笑，但这就是实实在在的武汉——有市井气，讲江湖味，大雅又大俗，爽快不做作，每个过客，都像归人。这座历史上曾经辉煌也曾经苦难的城市，在新时代正迸发出强大耀眼的能量。


# 二月梅花

疏影横斜水清浅，暗香浮动月黄昏。梅花是中国十大名花之首，与兰花、竹子、菊花一起列为四君子，与松、竹并称为“岁寒三友”。在中国传统文化中，梅以它的高洁、坚强、谦虚的品格，给人以立志奋发的激励。在严寒中，梅开百花之先，独天下而春。

## 省内

### 东湖梅园

东湖梅园是武汉人最爱的赏梅地之一，也是我国江南四大梅园之一，园内共有梅花品种320余个，包括了许多珍贵品种，如“金钱绿萼”、“紫蒂白照水”、洒金梅等。
路线：乘402、413、515路公汽至东湖东路梅园站，下车即到。


### 沙湖生态公园

沙湖公园的梅花远远望去灿若云霞，美不胜收。共有粉红朱砂、小红朱砂、银红台阁、玉蝶、丰后梅等10余个品种。
路线：武昌区秦园东路，乘583、540、627、777路等可达。

### 中山公园

中山公园里的品种主要有蜡梅、红梅和美人梅。蜡梅花期为每年12月至次年2月，观赏区域集中在前区天鹅池附近。
路线：地铁2号线，726、721、716、291、526、548、522、1、808路等。

### 解放公园

路线：乘606、605、712、734路等可达。

### 青山公园
路线：乘坐511、514、542、551路等可达。

### 武汉植物园

路线：乘坐公交709、402路以及旅游专线车401可到武汉植物园

## 省外

### 杭州超山

这里是江南三大探梅胜地之一，培植梅花已有千年历史，以“古、广、奇”三绝而著名。
地址：浙江省杭州市余杭区区浙江余杭塘栖镇超山

### 北京红螺寺

红梅、绿梅、白梅、腊梅等300多株梅花竞相开放。寺庙里的香火、梅花的花香杂糅，不妨顺便在这里寄托个人生的夙愿吧！
地址：北京市怀柔区雁栖湖镇红螺山下

### 南京梅花山

梅花山以及山下的“万株梅园”占地400余亩，有230个品种，13000余株梅树，为四大梅园之一，每年春季举办“中国南京国际梅花节”。每当春季梅花盛开之时,梅花山的万株梅花层层叠叠，云蒸霞蔚,繁花满山，一片香海。
地址：南京玄武区明陵路植物园南路交叉口南


# 三月樱花

何处哀筝随急管，樱花永巷垂杨岸。两千多年前的秦汉时期，樱花已在中国宫苑内栽培。唐朝时樱花已普遍出现在私家庭院。樱花象征热烈、纯洁、高尚，被尊为日本国花。

## 省内

### 武汉大学

武汉大学的樱花主要分布于樱园和樱花大道。樱花大道位于老斋舍和老图书馆的下方，樱园就在旁边。樱园内品种很多，有早樱、晚樱、红垂樱等10多种。

不可错过的美景：樱花大道位于樱园老斋舍前，这里的樱花以日本樱花为主，花色丰富，绚丽多彩。樱花盛开时节，300米长的樱花大道洁白如雪，灿若云海。微风吹过，随风飘落的樱花纷纷洒洒，美不胜收。

TIPS：武大赏樱提示，从武汉大学正门进，是“国立武汉大学”牌坊，走进去就有到湖滨的校车，上车后到樱园下。从教二旁的鲲鹏广场开始，一直绵延到行政大楼附近，其中以樱顶老斋舍最佳。从八十八级台阶上去，可以高出观望樱花繁盛全景。

交通：413路、515路、519路、552路、564路、572路、587路、591路、608路、724路、806路、810路等。

### 东湖樱园

往年，樱花园大部分樱花的盛花期开始于3月24日左右，若按照目前天气回暖的趋势来看，预计今年樱花的盛花期有望提前至3月中旬。

武汉东湖磨山樱园与日本青森县的弘前樱花园、美国的华盛顿州樱花园并称为世界三大樱花之都。占地260亩，有樱花树10000株。

门票价格：成人票60元/人次，学生证（本科以下）、老年人（60-65周岁）半价。

交通：1、乘公交401路、403路、643路到鲁磨路梅园站下
         2、乘公交402路、413路、515路到东湖东路梅园站下

### 汉口江滩

除了武汉大学的樱花大道以外，还有一处幽静而又唯美的赏樱景点值得一去。这里的樱花品种比较多，但不是成排栽种的，散落的樱花树别有意境。

分布：江滩一期天津路闸口至粤汉码头路段，位于防洪墙内沿步道可观赏到百余株樱花。另外两处规模较小，一处位于江滩一期游泳池边，在园区内，可以从车站路闸口进入；另一处可从三阳路闸口进入江滩，在友谊林内。

TIPS：汉口江滩的樱园离大门有一段距离，好在公园里面有游园车，单行8元/人，双行15元/人，不喜欢走路的亲可以用代步车。

交通：30路、68路、402路、523路、527路、579路、601路、603路、606路、708路、721路

### 晴川阁旁边樱花

透过重重的樱花远望晴川阁，古砖墙、高楼牌、红圆柱仿佛被加了柔光，历史感顿时增强。

古雅的建筑、茂密的花朵，朵朵垂樱在旁衬托，真个似美人对镜点花黄，艳色无边，吸引许多游人前往赏花拍照。

交通：10路、30路、45路、61路、电1、电4、108路、206路、401路、532路、553路、559路、803路


### 清凉寨野生樱花

黄陂清凉寨樱花属本土性很强的野樱桃和山樱桃两类，其中山樱桃别名樱花、青肤樱。

清凉寨目前发现至少有短萼樱、重齿樱和崖樱三个以上品种的野樱花，原生态野生樱花十万余株，面积达三千余亩。

清凉寨赏樱最佳时间：早樱4月1日前后两天开放，中樱4月5日前后开放，晚樱4月10日前后开放，花期均在20天以上。

自驾指南：武汉城区—竹叶山—岱黄高速—黄陂城区—长岭—姚集（左转）—景区

### 堤角公园樱花

递角公园是武汉唯一一座类似“苏州园林”的公园，樱花就是这里的“园花”。

交通：509路、717路、211路、412路、212路

### 首义广场

首义广场位于武昌阅马场，有110度棵大树，是全国种树最多的广场。

樱花阵、梅花丛，粉团锦簇，花瓣密密匝匝，缀满枝头。

### 西北湖广场

据《樱大鉴》记载，日本早樱最早是从中国的喜马拉雅山脉传过去的，这里种植了近千株樱花树，可以说是汉口城心区最美丽、樱花密度最集中的赏樱胜地。

西北湖广场上的两个樱花品种都是日本早樱的基本品种，世界上野生早樱品种有五十多个，中国约有三十八个。

每逢樱花盛开时节，随处可见樱花浪漫的花姿。

### 武汉理工大学

分布：西苑大门口、逸夫楼旁

交通：556路、529路、777路、905路、908路、738路、571路

### 其他赏樱地

硚口区工业园区、汉西南路绿地等
竹叶海公园
宝岛公园湖心岛右侧
青山公园
解放公园2号门附近
光谷广场内
武汉植物园
洪山礼堂附近
东湖听涛景区
黄浦路立交桥下绿地、堤角机电路绿地
洪山区中南民大校园内
十堰郧阳区樱桃沟村

## 省外


### 无锡鼋头渚国际樱花节
作为“世界三大赏樱胜地” 之一，无锡鼋头渚樱花谷内有3万多株樱花树， 樱花节期间，樱花如云似霞、满树烂漫。
地址：江苏省无锡市滨湖区大浮镇鼋渚路1号

### 上方山国家森林公园
3月早樱、5月的晚樱，还伴随二月兰、油菜花、杜鹃、海棠，各种品种看得眼花缭乱。
地址：江苏省苏州市虎丘区吴中区吴越路旺山景区

# 三月桃花

桃花一簇开无主，可爱深红爱浅红。桃花是中国传统的园林花木，其树态优美，枝干扶疏，花朵丰腴，色彩艳丽，为早春重要观花树种之一。

## 省内

### 东西湖区新沟农场

位于武汉东西湖区107国道沿线的新沟农场、荷包湖农场、辛安渡农场。有5万多亩桃树，春暖花开时，成片的桃林极具观赏价值。桃花盛开的时候，好像一朵朵红云，绝对是拍照的好去处~

赏花路线：市内乘H88路到惠安大道新华大队站下；市内乘坐546、737、505、560、741、222到吴家山三秀路下车，再转乘“吴家山至新沟镇”的中巴至荷包湖下车，车票价3元。自驾可从吴家山出发走东吴大道、107国道20分钟至新沟桥头，左转沿106省道约两公里到桃花基地。
赏花门票：免费

### 武汉植物园

植物园的“桃花源”内种有1000余株桃树盆景，近百个品种，周末带小朋友去涨涨知识也是不错哒~桃花珍品有菊花桃、绛桃、千瓣红桃、红碧桃、垂枝碧桃等。品种多，环境好，而且市区内比较近，门票40元，团购更划算~

赏花路线：乘坐401路、402路、413路、625路可到达武汉植物园站。
赏花门票：40元

### 汤逊湖大湖第公园

大湖第公园内规划有儿童乐园、网球场、篮球场、小岛漫步道等观景娱乐设施，让你在赏花之余，还可以坐拥湖景，与家人享受悠闲的美好时光。

赏花路线：公交732华农楚天学院站、758栗庙路阳光100站即达。自驾可从关山大道向南转至汤逊湖北路,路标指示杨桥湖大道处右转,经藏龙一桥行至华农楚天学院。
赏花门票：免费

### 左岭周庄
路线：可从武昌坐25路公交车或者鄂101中巴直达左岭，转乘麻木或面的到周庄桃园。

### 孝感杨店
路线：汉口黄浦路口的立交桥下，有直达杨店的班车

### 枝江安福寺镇
路线：自驾武汉—枝江—安福寺镇

## 省外

### 香格里拉丙中洛
这里有一个光听名字就让人向往的桃花岛，它在当地被称作扎那桶村，但因每年二三月岛上一大片一大片粉红桃花，就像陶渊明笔下的桃花源，故名桃花岛。
地址：云南省怒江州贡山县

### 林芝
每年三四月，当粉色的桃花染遍林芝的山野，近处清澈透亮的溪流，远处矗立洁白的雪峰，森林、云海、蓝天、冰川、碧湖、雪山相映成趣，美成仙境。
地址：西藏自治区林芝县林芝镇真巴村

# 三月油菜花

凌寒冒雪几经霜,一沐春风万顷黄

每到阳春的三月，荆楚大地的油菜花竞相开放。每年油菜花期一般20余天，自3月中旬至4月上旬。油菜花色彩艳丽，整片花海更具有极强的视觉冲击力。

## 省内

### 新洲区新旧街

而武汉市新洲区油菜面积约45万亩。
赏花路线：坐长途巴士直抵新洲，再转巴士赴旧街，也有直达旧街的班车。自驾可以沿汉口堤角、武湖、施岗、汪即直达新旧街。
赏花门票：免费

### 荆门
三月的荆门春意盎然，广袤的田野里一片金黄，处处流金溢彩，清香沁人。
路线：从武汉每天有12趟火车到达荆门，车票最低的仅21元


### 蔡甸消泗乡
蔡甸的消泗乡，常年种植油菜花3万亩左右，3月开得正好。还可以乘直升飞机俯瞰整片花海和沉湖湿地。
路线：乘坐从汉阳火车站旁的客运站开往消泗的蓝色巴士


### 恩施利川
路线：每天有8趟火车前往恩施，8个小时左右的路程，41—92元的票价还是很方便的。


### 黄冈浠水
路线：从武汉出发过黄石大桥，左转上长江大堤，顺江堤一直走，可以到达兰溪镇，江堤路边都是油菜花。


### 南漳水镜湖
路线：南漳—三道河水库—水库大坝座船—尚范；或者南漳汽车站乘坐8路公交车到东木瓜园——龙川河——尚范

### 黄陂大余湾
路线：汉口竹叶山岱黄高速 ---- 黄陂转盘处 ---- 往木兰山大余湾方向直行约10公里至研子镇 ---- 右转 ---- 沿景区路牌行驶3公里即到

### 华农试验田
市区 ---- 庙山开发区 ---- 纸坊 ---- 往五里界方向走3公里，沿路即是

### 枝江问安
路线：从武汉出发进入三环线（2.4公里）----  进入汉蔡高速公路（34.5公里）----  进入汉宜高速公路（212.2公里）----  在枝江出/入口 ---- 前往问安

## 省外


### 云南罗平
20万亩的油菜花竞相绽放，连绵数里，开成了金色的海洋，美得让人心醉。
地址：云南省曲靖市罗平县


### 重庆潼南
千百年来，潼南油菜之花都以其磅礴之势为大地平添金色之美。
地址：重庆市潼南县


### 江西婺源
婺源的油菜花主要分为田园油菜花和江岭十万梯田油菜花。
地址：江西婺源

# 三月梨花

梨花淡白柳深青，柳絮飞时花满城

## 武汉汉南区

“巧笑解迎人，晴雪香堪惜”。每到3月，武汉市郊汉南地区成片梨树盛开，洁白如雪，香飘四溢。梨花花期一般为3-4月，仅有20来天。

赏花路线：王家湾乘坐5101、5102
赏花门票：免费

## 东湖梨园

东湖梨园在东湖西北岸,与对岸滩头相望.为东湖风景区主要园林之一。一年四季,繁花不断,沁人心脾,尤其梨花盛开时,酷似无数粉蝶满园飞舞,殊为壮观。

赏花路线：市内乘420、411、552、578、709路等
赏花门票：免费

## 老河口
路线：武汉火车前往襄樊，再转车去老河口。

## 枝江百里洲
路线：武汉到宜昌，再坐车沿高速路到枝江，然后乘船数十分钟到百里洲。


# 三月郁金香

郁金香花期并不长，时间是她致命伤


## 武汉植物园
路线：乘坐401路、413路、515路、36路公共汽车至东湖梅园转402路公共汽车，直达武汉植物园。 709路公共汽车终点站也是武汉植物园。

## 东西湖郁金香主题公园

武汉史上数量最多的郁金香也要盛开了！武汉东西湖郁金香主题公园内的150万株郁金香一开，梦幻般地变成五彩斑斓的花海。

地址：湖北武汉东西湖区吴新干线
赏花路线：坐轻轨至东吴大道站，下车，步行100米在七雄路车站乘坐H91路公交车，至吴新干线郁金香主题公园下车。


# 四月杜鹃花

蜀国曾闻子规鸟，宣城还见杜鹃花。中国是杜鹃花分布最多的国家，杜鹃花种类繁多，花色绚丽，花、叶兼美，地栽、盆栽皆宜，是中国十大传统名花之一。而湖北地区盛产杜鹃花，大多俗称为映山红。

## 省内


### 黄陂云雾山

武汉看大片的杜鹃花，黄陂云雾山是最近的。到三月末，黄陂云雾山景区位于山脚下的7000余个杜鹃花盆景就会全部开放，姹紫嫣红、婀娜多姿、风情万种，而山上海拔低处的野生杜鹃也已初现繁茂之势。云雾山景区拥有湖北省和武汉市最大面积的野生杜鹃花，面积达10平方公里


赏花门票：山脚赏花免费；登山门票80元。
路线：从汉口新华路客运站乘车直达或从汉口火车站乘292或295至黄陂汽车客运站转车直达，再转乘当地交通工具上山。


### 麻城龟峰山
最高海拔1320米。因其地形山势酷似一只昂首吞日的神龟而得名“龟山”。春季满山杜鹃似火，兰草花吐幽，是春游的好地方。
路线：汉口---岱黄高速----武汉外环----武麻高速----麻城市区 ----龟峰山风景区

### 东湖磨山
路线：赏花市民可乘坐401、402、403、413、515、643路车到东湖磨山站下即可。

### 神农架
路线：从宜昌中转，武汉到宜昌4个半小时，全程高速。 在宜昌长途车站，乘坐小车。

### 大别山薄刀锋
路线：武昌火车站对面的航海汽车站每天上午2班下午1班开往黄柏山所在地的河南商城县长竹园，3小时到达，再转车上景区的天池宾馆。

### 咸宁通城县黄龙林场
路线：武汉-三环线白沙洲-G107国道-青郑高速-上G4京港澳高速-咸宁北下-咸宁市-崇阳-G106通城县-S320麦市镇

## 省外


### 阿尔山
它春有漫山杜鹃花，夏有翠色林海，秋有绚丽山色，冬有百里雾凇，每一个季节它都美若童话。
地址：内蒙古自治区兴安盟阿尔山市


### 马耳山
快4月的时候，山腰上的杜鹃花与马缨花争相红遍，这下马耳山就真成了花的海洋了。
地址：云南省大理白族自治州鹤庆县

### 稻城亚丁
漫山遍野的杜鹃花点缀在一片绿色中，红的、白的、紫的，占据了从海拔2000米到4500米不同高度的坡地。
地址：四川省甘孜藏族自治州稻城县香格里拉镇亚丁村境内

#  四月槐花

春明草色迷牛首，秋老槐花上马蹄

## 省内


### 黄石国家矿山公园
路线：武汉-关豹高速公路-武黄高速公路-黄石

### 黄陂木兰山
路线：从汉口新华路长途客运站乘车直达或从黄陂汽车客运站转车直达。

### 锦里沟
路线：汉口火车站乘292到黄陂客运站转乘专线巴士可到达锦里沟

## 省外

### 九仙山
地址：山东省日照市五莲县与五莲山隔壑相峙

#  五月薰衣草

## 东西湖薰衣草庄园

薰衣草庄园目前种植面积150亩，目前种植的薰衣草有两种颜色，一是深紫色，二是偏淡紫色，薰衣草的花期可以长达四到六个月。

## 江夏五里新村薰衣草风情园

景区现已建设出包含香草长廊、香草湾、滨湖草坪、爱之语、婚纱摄影基地、精油小屋等诸多配套设施及景观，游客可一睹薰衣草风采赏梁子湖风光。


# 九月菊花展


每年九月在武汉街头都会有意外惊喜，一盆盆精心培育的菊花组成各式各样的造型，带给您不一样的惊喜。

# 十月红枫

## 武汉大学枫园

不要再单单迷恋粉黛满园的樱花顶，武大的的秋意早已静悄悄的来了，很浓很深。武大的枫园以枫香为主，三角枫、八角枫为辅，还有红叶李、紫叶桃等等，享誉中外。

## 文华学院

2014年的首届红枫节和红枫女神让这片安静美艳的红枫进入了大众的视野。

# 十月芦苇

## 江滩芦苇

每年十月上旬至十一月上旬是芦苇的赏花期，从长江二桥眺望汉口江滩，连绵6公里的芦苇荡，白茫茫的一片，花絮满天飞，空气中飘荡着浪漫和温柔的气息。

# 银杏

## 汉阳树

“晴川历历汉阳树，芳草萋萋鹦鹉洲”一颗坐落在武汉的540岁的汉阳树，也是最老的树。汉阳树位于武汉市汉阳区凤凰巷(现建桥街汉阳树巷)11号的一个小院内，是一棵古银杏树，高28米，是武汉市城区最老的树。

## 安陆钱冲银杏谷

银杏素有“活化石”之称，钱冲村有华中地区最大的古银杏群落：千年以上的古银杏48株，500年以上的1468株，百年以上的达4683株。被誉为“中华银杏第一村"。

## 随州洛阳镇银杏谷

据统计洛阳镇分布百年以上古银杏树共有1.7万株，同时也是全国乃至全世界分布最密集、保留最完好的一处古银杏树群落。

# 摘草莓

## 东西湖石榴红村

石榴红村草莓园是武汉最早成熟的草莓园了，大多数草莓园就集中在村旁，一条产业道路便可以逛到底。除了草莓外还有好多菜苔、萝卜、白菜等可以自采自买。想去摘草莓的朋友们，建议早上去，那时候的红红的草莓最多。

地址：武汉市东西湖区慈惠街
路线：在市内乘坐轻轨到东西湖后，转乘560路或222路到慈惠农场，再乘坐218路到终点站石榴红村景区。
门票：免费

## 东西湖农科所润心草莓基地

东西湖区农科所基地是东西湖区农业科学研究所下辖的集农技推广、科研、生产展示、育苗服务、科普及都市生态休闲旅游等公益性服务的二级单位，摘草莓项目也是近几年才开始的，除了草莓还有很多其它果蔬。

地址：武汉市东西湖区吴家山街二雅路237号
线路：
1、从额头湾直行至五环路口右转，上临空港大道至窑湾(此处有红绿灯)后左转行至杨湾红绿灯路口后，见现代农业都市园即到。
2、从金山大道行至五环大道路口后右转上临空港大道，后续路线同路线1一致。

## 凡华农业园

地址：武汉市江夏区郑店街劳七村九组
开车线路：
1、汉口，汉阳，光谷，青山方向请走三环线在白沙洲大道下沿107国道往咸宁方向走，过郑店街往前三公里路的左边既可看到湖北凡华生态农业园
2、武昌直接走白沙洲大道沿107国道往咸宁方向走，过郑店街往前三公里路的左边即可看到湖北凡华生态农业园

## 湖北工业大学

湖北工业大学这估计是距离市中心最近的草莓基地了。湖工大学门口到处是草莓地，这一块都属于南湖草莓基地，草莓地面积达到近1000亩，网络上的华农草莓地、华科武昌校区草莓地指的都是这里。比市场上的草莓要卫生安全得多，摘草莓的过程充满乐趣，自己动手，还能品尝美味。

地址：湖北工业大学校门附近
乘车路线：乘74，587，902和306到李纸路徐家墩站，一下车你就可以看到草莓园

## 南湖草莓大棚

地址：华中科技大学武昌分校对面　　
乘车路线：到74路，587路，902路和306路，317到武昌分校正门下。
自驾：从武昌丁字桥驱车10分钟，即到壕沟。　　

## 洪山板桥村

洪山区板桥村据说是武汉最早种植草莓的地方，板桥一带上千亩草莓地与华农草莓试验田相邻，生产无污染，还能便宜地从果农那买一钵观赏草莓回家，养上个把月再吃。

地址：洪山区板桥村
乘车路线：乘74、901、166路公交到板桥站下

## 兆丰草莓园

兆丰草莓园是是华中地区最大草莓观光园，这里的草莓个大又甜，还有极品草莓“晶瑶”。

地址：东西湖区柏泉兆丰草莓观光园
乘车路线：到吴家山的巴士或其它公交车，中商平价下车，对面农业银行广场乘坐到群力的中巴到兆丰草莓园
注意：兆丰有最低消费，进去每人50元的门票，可以在里面抵扣任意消费，摘圣女果是30元一斤。

## 柏泉生态园

柏泉生态园不仅仅可以摘草莓，也可以品尝其他各种时令蔬果，享受台式的餐饮服务，并且周边有始建于唐末的景德寺、柏泉古井、古村落等旅游景点，感受农家风情。

地址：东西湖区西正街19号柏泉生态园
乘车路线：市内游客乘轻轨1号线到吴家山后，乘坐到柏泉的巴士即可到达

## 新农姚家山草莓基地

姚家山草莓基地占地200亩，草莓成熟时，可现摘现吃最新鲜的生态草莓，每天产出的1000多公斤草莓都被周末慕名而来的市民采摘一空。

地址：蔡甸区新农姚家山
路线：在汉阳大道(麒麟路、十里铺、王家湾均有车)乘266到蔡甸姚家山站下(约15km)；在武汉经济技术开发区体育中心乘267到蔡甸姚家山

## 汉阳新农沿线

汉阳新农沿线马路边是一溜卖草莓的小摊，一顶顶大红伞绵延近一公里，任你挑选。沿汉阳十里铺、三眼桥直行约18公里，接近蔡甸城区时，有个地名叫幺铺，沿路有草莓大棚。走汉阳大街，过了蔡甸城区往玉笋山方向走，沿路也有很多草莓大棚。

地址：蔡甸区新农街附近一带
路线：汉阳十里铺——汉阳大街——玉笋山——草莓大棚

# 烧烤


## 马鞍山森林公园

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/7ccab52dgy1fd7h0f4zysj20ci1vaqda.jpg)

地址：武汉市洪山区珞瑜东路619号
门票：20元/人，大武汉年卡免费哦！
烧烤材料：自带
烧烤工具：公园提供的是100元一个，要押金，限时4小时！

## 东湖落雁景区

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/7ccab52dgy1fd7h0fgecqj20ci1cy45m.jpg)

## 九峰山森林公园

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/7ccab52dgy1fd7h0ft5i7j20ci18hn6o.jpg)

## 石榴红村

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/7ccab52dgy1fd7h0ge6zdj20ci1efk2c.jpg)

## 府河湿地

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/7ccab52dgy1fd7h0gtxmij20ci1gygsu.jpg)

## 后官湖湿地公园

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/7ccab52dgy1fd7h0h0rw4j20ci1e5air.jpg)

## 天兴洲

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/7ccab52dgy1fd7h0hetdjj20ci1kl46y.jpg)


## 梁子湖龙湾度假村



地址：江夏区五里界梁子湖大道特1号
门票：98元=沙滩浴场门票+自助烧烤2小时
烧烤材料：免费提供
烧烤工具：免费提供

## 木兰草原



地址：黄陂区王家河镇聂家岗
门 票：80元/人;1.2米—1.4米小童、学生、60—70岁老人门票40元/人；1.2米以下小童、现役军人、70以上老人凭本人身份证/老年证免景区大门票。10人以上团队提前预约60元
烧烤材料：自备
烧烤工具：90炉子/4小时，游客较多，建议自带

## 紫薇都市田园


地址：仓埠街丰乐寺村特1号(09省道)
门票：原价80元，大武汉旅游年卡免费哦！
烧烤材料：建议提前自备好
烧烤工具： 大烧烤炉租赁：50元/4小时，30元/2小时；赠送配套用具；小烧烤炉租赁：40元/4小时，20元/2小时；赠送配套用具；烧烤碳出售价格：30元一盒


## 农耕年华



地址：武湖农场农耕年华风情园内
门票：70元/人，大武汉年卡免费哦！
烧烤材料：自带（附近商贩有食材提供，但为了保证食品卫生，建议提前自备哦）
烧烤工具：灶台工具等可租用。旁边有洗手池，洗手、洗菜什么的很方便。

## 张公山寨

![](https://ghfast.top/https://raw.githubusercontent.com/sli1989/blogimg/master/img/7ccab52dgy1fd7h0hmw41j20ci1fg7dg.jpg)

地址：武汉市青山区白玉山街
门票：成人/90元；学生/50元；老人/65元（1.2米以下儿童免票）
烧烤材料：自带
烧烤工具：烧烤炉、夹子、刷子免费提供，食品自带，炭20元/袋，如自带炭，收炉子租金15元/个。

## 花海乐园



地址：木兰乡双泉村研梳路
门票：全票80元一张，烧烤78元/位，2小时自助
烧烤工具：免费
烧烤材料：免费

## 九真山


地址：武汉市蔡甸区永安街炉房村
门票：60元/人，免票政策：儿童1.2米以下免票；70岁以上老人凭老年证免票
烧烤工具：自带烧烤炉需缴纳30元/炉，场地、卫生管理费。木炭10元/包
烧烤食材：景区内有卖的，价格不贵，建议自带。


# 放风筝

## 西北湖广场



西北湖广场紧邻西北湖，修建有架空平台、喷泉、栈桥、迷宫、环湖路等，春天可赏梅花、樱花，夏天可观绿柳垂荫，非常适合休闲。

## 张公堤绿道



以前曾被人认为是“野位子”，随着城市的发展，现在成了城里人感受野趣的好地方。从姑嫂树到常青路中间一段，没有交叉路，也很少走车，比较适合放风筝。

## 塔子湖体育中心



作为全国最大的全民健身中心，位于后湖的塔子湖体育中心吸引了众多武汉人。除了在这里游泳、打球外，常有父母带着宝宝过来，在室外宽阔的场地上享受奔跑的乐趣。在这栋楼的大门前，有大片平整的水泥地面，很适合放风筝。

## 府河湿地公园

春天正是枯水季节，府河两岸水位较低，岸边长满了绿草红花，很适合野游。每年此时，都会有市民相约来此，沿着府河岸边找位置。看到合适的地方，支起烧烤炉、放好野餐垫，体验原始的野炊。带上风筝，在河堤边漫步；或带副扑克，以地为桌做游戏。

## 汉口江滩

汉口有着武汉最大片的江滩公园，阳春三月，温暖的春风从江边吹来，整个人都觉得暖洋洋的。江边有许多卖风筝的也有自己带来的，有很大一片广场足够放风筝，就连晚上都有不少放风筝的，特别热闹。

## 武昌江滩

“芳草青青树成荫，小径绵绵曲折行，江风阵阵送凉意，隔岸万家灯火明。”汉口江滩重在休闲，武昌江滩重在观景。大桥下的气魄和宏伟，开阔的视野和平台，都是放风筝的极佳场所。

## 青山江滩

停车免费、玩沙免费、赏花免费、享受草地阳光江风免费！一路无遮挡的一线江景，充满童趣的景观设计、大面积的草坪绿树红花、免费的临江儿童乐园、还有夕阳西下时的绝美景致，必定会让你流连忘返。

## 和平公园

和平公园是青山人民最喜欢的绿色苗圃，从公园大门走进去，就能看见一片开阔的草地，这里是风筝爱好者长期聚集的地方，他们一玩就玩一天。

## 汉水公园

汉水公园采用的是江南园林风格，假山、小桥、流水一应俱全，其中十二生肖园和奇石园里，都有大片草坪，可供放风筝。

## 莲花湖公园

钟家村片区的城市绿肺，晨练、遛娃绝佳去处，太白楼、瀑布亭、盆景园、奇石大观园、沿湖石林……美不胜收。大片的开阔绿地，很适合放风筝哦！

# 涨渡湖湿地公园

我大武汉原来有如此如梦如幻的仙境啊！位于武汉新洲区的涨渡湖，是世界自然基金会(WWF)认定的湿地自然保护区，并且是武汉市首个湿地森林公园.....


水上森林公园是这里最大的特色。一人环抱不住的大树都种在水里，湖中还养殖了很多鱼。由窄窄的木头搭成的栈桥，在上面观景非常的美，沿途还有摘草莓的地方，非常适合踏青。


许多的鱼儿在此嬉戏，鸟儿在天空中翱翔，一派欣欣向荣的春日景象。


冬天，水杉由翠绿变成了橘黄。在黄昏时刻，天地间都融为黄橙橙一片，耳边只有鸟儿的叫声，如此静谧，让人流连忘返。


◆门票：无
◆自驾：开车走阳逻走阳大路,在双柳挖沟前走刘大路,有行3公里,看到路旁边有水上森林公里,里面便是湿地公园

🚅地铁：轻轨1号线--堤角站A出口，步行5分钟到解放大道堤角路，乘坐2108路，到达陶家墩下，步行到达。

# 府河湿地

在武汉市的近郊，有这么一个鲜少人知道的好地方“府河湿地”，拍照、发呆、踏青......

湿地公园总面积5156公倾，地处府河及周边流域，水资源丰富，生态良好，生物多样性丰富。坐车从府河大桥上经过，眼前一望无际的绿，青的水，碧的草，堤岸边成排挺拔的白杨，垂下千万嫩绿的翠柳，无不令人心醉。

府河湿地冬季基本不结冰，尤其是府河外滩有着天然的鸟类越冬生活环境，每年10月至次年3月，就有数以十万计的野生天鹅、野鸭、大雁等候鸟从西伯利亚飞越到此越冬停歇，下港核心区每年冬天有大量天鹅在此聚集，从而成为名副其实的府河湿地“天鹅湖”。

驻足东西湖府河大堤上，远望众鸟齐飞、水天一色，耳闻欢快的嘎嘎吱吱声，远离尘嚣，享受自然。秋冬之时还可以观赏成片的芦苇。

◆门票：无

🚅地铁：2号线到金银潭站，A出口左走不到50米就到公交车站，乘坐339路车道环湖中路环湖三路下车，再向西北直走，等见到一排排整齐的杨树，就是东西湖大堤的位置了，堤坝外就是府河。

# 柏泉古镇

柏泉古镇，现为柏泉农场办事处。经过翻修，茅庙集已找不到旧日的痕迹。两边的仿古建筑漆色亮丽，新石板路或许还能踏出历史韵味。

月塘北古村落是这里仅存的明清古村落，空气清新宜人。武汉三大名寺之一的古寺景德寺也在这里，很多人将福袋挂在树上，祈求福气安康，心想事成。

◆门票：无
◆自驾：东西湖区柏泉农场

🚅地铁：地铁2号线终点站--金银潭A出口，前走约150米，在金银滩大道地铁金银潭站乘坐217路，在张柏公路茅庙集站下车前行约20米


# 天兴洲岛

天兴洲大家都不陌生，但是“江中宝地”的魅力你领略过吗？受够了人群吵闹的都市，可以来这里露营，看一次绝美夕阳。

空旷辽阔的天兴洲，视野开阔极目远眺，像不像到了大西北？

虽然岛上荒芜，村民生活朴质，但是这里已经开始建设农家乐等商业项目。虽然方便了游客，但难免破坏了小岛的风情。所以来要趁早哦~

◆自驾：青山区天兴洲岛
◆门票：无
🚅具体可先乘轨道交通4号线到工业四路，再步行至移民新村乘坐594路至终点站。
594路是定点班车，基本是一小时一班，从早上7：30到傍晚5：30，和轮渡的时间是相配合的。

轮渡时间表如下，也有汽渡，时间差不多。
　青山to天兴洲：05:50 06:50 07:50 08:50 10:50 11:50 13:50 15:50 16:50 18:00
　天兴洲to青山：06:00 07:00 08:00 09:00 11:00 12:00 14:00 16:00 17:00 18:00

# 武汉园博园

不出武汉，在园博园就能看到全国各地的优秀园林缩影。独具当地特色的园林，山、水、植物真是看得人眼花缭乱。

走在其中仿佛置身于园林深处。能在城市中感受到新鲜的空气，绿植，鲜花，何尝不是一件乐事？

除了白天，晚上的园博园也同样精彩，因为元宵花灯会来啦！这是园博园第二次办花灯会，样式比第一次更加新颖好看，而且还将高科技与传统相结合，让年味更加有趣好玩。

◆花灯展门票： 时间：2017.1.21~3.12 夜场时间17：00-22：00
 门票：夜场：50元（1.3米以下儿童及65岁以上老人免票）

◆平日门票：日场60元
◆自驾：汉飞大道—金山大道—金南一路—园博园北路停车场
🚅地铁：地铁6号线--园博园北B出口，步行约33分钟可到


# 张公山寨

张公山寨可谓是武汉市内的，农村颜值担当！有着丰富的历史典故，优美的生态环境，仿古的明清建筑，刺激的游玩项目。简直是在古代和现代来回穿越呢~

丰收的季节最大的乐趣就是摘桔子，看着沾着露水的橘子，手都痒痒的。抓住它，用尽全身的力气。虽然很累，但手捧着硕大的橘子，觉得一切都是值得的！

到了晚上，便开始了盛大的篝火晚会。与其他人手拉着手肩并着肩，载歌载舞，度过寒冷的冬夜。

◆门票：90元

◆自驾：青山区白玉山街张公山寨严西湖畔

🚅地铁：地铁4号线终点站--武汉火车站，转坐的士，或是乘坐525，到群里村下，转坐407，到张公山寨风景区下。


# 露营


## 九宫山

地址：湖北省通山县城东南
路线：武汉武昌宏基客运站40分钟/班票价43元（含1元人生意外保险）。发往通山县后，坐班车（时间90分钟）票价16元，直达九宫山风景名胜区。


## 天兴洲

地址：湖北省武汉市青山区青山镇、江岸区谌家矶所夹的长江段江心
路线：建议大家坐车到青山红钢城站，(201、719、511、542、555，807都有站)下车后问建设八路，然后沿建设八路往北笔直地走到长江边，可看到建八停车场，码头就在停车场内。(另：511终点总站在码头旁边，如坐511的话，在终点总站下车即到)。建议大家坐车过建设十路后，沿工人村路一直北走，到江边即可见天兴洲渡口，此线路N多巴士


## 八分山

地址：湖北省武汉江夏区纸坊附近
路线：从武昌火车站乘901路或903路到纸坊江夏客运中心下

## 木兰草原

地址：武汉黄陂区王家河街道聂家岗
路线：①G318-岱黄高速公路-火塔线-景区
②G318-火塔线-景区

## 院基寺水库

地址：武汉市黄陂区长轩岭镇境内西北山中
自驾路线：汉口黄浦大街—武汉大道—岱黄高速—黄陂大道—黄土公路—22公里后左转行驶近12公里—院基寺水库


## 赤龙湖

地址：湖北省蕲春县漕河镇、赤东镇、蕲州镇及赤东湖渔场、恒丰湖渔场境内
自驾路线：汉口—武黄高速—黄黄高速—八里湖—赤龙湖国家湿地公园


## 泥河水库

地址：武汉黄陂区李集街
自驾路线：汉口—武汉大道—岱黄高速—黄陂大道—黄土公路—左转到泥河水库大坝


## 竹山无名大草原

地址：湖北省十堰市竹山竹溪交界处海拔2500余米的山顶
路线：武汉坐火车直达十堰，在从十堰客运站转车至竹山；也可在付家坡车站乘坐直达竹山汽车

# 采摘

## 武汉金果园

采摘地址：武汉市黄陂区前川雷段村

采摘价格：20元的门票可以随意采摘品尝，但是如果需要购买桑葚价格是50元/篓（约2斤）

采摘路线：
1、自驾：驾车40分钟到黄陂木兰雕像转盘往孝感云雾山方向走3公里处，看到金果园招牌右转。
2、公交：在汉口火车站站乘292到黄陂汽车站打的10分钟即到。


![](http://mmbiz.qpic.cn/mmbiz_jpg/UcMdGta5Ye1Ng7ibSh4LE0fe5BnBIYWhmKOiatAzHqaBzlToDMaPjk5QlqYkib4fUR09OqRSc68UAHPP7BO5ibVftg/640?wx_fmt=jpeg&tp=webp&wxfrom=5&wx_lazy=1)


## 吉农田间超市

门票：无（入场需购买代金券。大人60元，小孩30元）

推荐项目：采摘桑葚、草莓、有机蔬菜、休闲垂钓、科普教育、生态餐厅(仅限午餐，须提前一天预约）、土地认养、自助厨房。

采摘地址：武汉市东西湖区柏泉农场吴新干线9.5公里处吉农田间超市

## 蔡甸景秀大地百果园


采摘地址：武汉市汉南区纱帽街周家河村

采摘路线：从汉阳王家湾沿104省道前行18公里到蔡甸转盘，左转继续沿104省道前行10公里即可看到葡萄采摘园指示牌。

## 喻万桥家庭农场

推荐玩法：烧烤、钓鱼、野炊、土灶。

采摘门票：10元/人

采摘价格：购买门票后进去随意采摘品尝。特别说明的是如果要采摘购买的话，是40元/篓，是不收取门票费的，这要到达目的地后跟老板事先说明。

采摘地址：武汉市汉南区纱帽街周家河村

采摘路线：从江城大道，直行进入武监高速公路，直行进入兴三路，进入汉南大道继续行驶，自驾大约需要一个小时左右。

## 桑葚

### 南湖桑葚园

采摘价格：据说要自己带着篮子去装，进去吃是不要钱的，但是带出来是需要购买的，购买价格20元/斤（不过，具体还是要以实际价格为准）

采摘地址：就在南湖大道，农科院对面，保利心语隔壁！

乘车路线：南湖马湖车站（72路/570路/817路等均可到）旁边，花木城往前点，对面公交站边上 ，车站后面围墙都可以看到桑叶。

### 黄陂木兰平海桑园

门票：20元

采摘价格：买了门票后就可以在里面岔着吃，但是如果要带走的话，就要花 60元买个小桶才能带走，算下来大概也是20元每斤，但是比较新鲜哦！

采摘地址：黄陂罗汉街邱皮村大刘湾
采摘路线：武汉出发，走岱黄高速到黄陂转盘后往木兰天池方向走9千米就到了。

### 玉红桑葚采摘园

采摘价格：采摘的价格比市场价格低。（参考往年，但具体以实际为准）

地址：武汉市汉南区东荆街阳光生态农业园武汉汉南区玉红天然桑葚采摘园

采摘路线：江城大道上汉洪高速，汉南出口下(该路段高速免费)，下高速马影河大道右拐，纱荆公路直走，达到东荆街，或者导航直达东荆街

## 樱桃采摘

### 湖北天迈农业培训中心

武湖现代农业展示中心，樱桃采摘周期很短，仅十天左右。除了樱桃外，5月份这里还有枇杷、桑葚，都是超级适合小朋友采摘的水果。

桑葚在五一前后基本都成熟了，采摘前老板会发给游客一个篮子（费用参考50元），摘的樱桃和桑葚就丢在里面不另外收费。所以一定要装的满满的哦！

推荐项目：采摘、棋牌、钓鱼、羽毛球、篮球
采摘水果：樱桃、桑葚、枇杷、无花果
地址：武汉市黄陂区武湖农场沙口分场
路线：二环、三环上天兴洲大桥第一个出口（新洲、阳逻方向）驶出—上汉施公路直走经过武湖街、“长江金属”、军民村加油站、过加油站前方100米右转（沿指示进入园区）

### 景秀大地

樱桃的采摘从四月份开始，后期还会有桑葚、玉米、甜瓜等香甜可口的蔬果。带上食材去烧烤，住住蒙古包，豪华版周边游就此开启。

约上一群小伙伴，采摘过后还可以进行真人CS大战。大人打棋牌，玩拓展游戏欢乐多多。

门票：30元（购票送30元采摘代金券）
采摘价格：樱桃30元/斤、桑葚30元/斤（去年价格，今年还未定价）
推荐项目：烧烤、钓鱼、采摘、骑行。
地址：湖北省武汉市蔡甸区玉贤镇松岭村
路线：导航搜索“景秀大地”到达导航所指目的地后，继续往前开，看到“景秀大地白果采摘园”指示牌，按指示牌进入即可。

### 木兰田园

木兰田园内种植的是车厘子，相比武汉其他地区的樱桃成熟季节更晚一些。桑葚一般都在五一期间成熟，这个时间去采，正适合。

木兰田园有儿童亲子乐园、农家体验探索、丛林烧烤体验、田园拓展设施、田园草地露营，玩法超多！孩子们都能在此找到乐趣。

采摘时间：5月末（车厘子）5月初（桑葚）
门票：80元
采摘价格：车厘子60元/斤、桑葚30元/斤（去年参考价格）
推荐项目：竹筏、烧烤、戏水、摸鱼、钓鱼
地址：武汉市黄陂区王家河街岗上熊村毕田塆木兰田园距离木兰草原5公里！
路线：汉口竹叶山----岱黄高速----黄陂城区（黄陂大道）----滠水桥----火塔公路----彭岗----木兰田园

### 宁智敏果园

采摘价格：20元入园免费吃，40元可以带一篮。（具体以实际价格为准）

采摘地址：咸宁咸通咸宁东收费站对面

采摘路线：武汉——京港澳高速公路——咸通高速


### 黄冈市罗田县

黄冈市罗田县大河岸镇滕家冲村樱桃种植已有近百年历史，有樱桃树280多株，其中树龄50年以上的有31株，30年以上的有20株。为有效发挥该地樱桃旅游资源优势，大河岸镇党委、政府经过多方调研、现场勘查后举办了樱桃节活动。

武汉自驾出发， 路况良好，无颠簸之苦，车程2.5半小时，路上用时不长，免得宝贝舟车劳顿，那旅途就没有意义了。

全家出动的话，可以去罗田的三里畈黑泥温泉放松一下，泡多了开发良好的温泉，去感受一下这种野温泉。

采摘价格：30元/斤（去年参考价格，今年尚未公布）
推荐项目：采摘、泡温泉
地址：黄冈市罗田县大河岸镇滕家冲村
路线：武汉出发，上三环朝武英高速方向行驶，右转上匝道，过汉施立交桥，直行约600米上新河大桥，过大桥直行约100公里，从罗田大别山口子右拐上匝道，直行7公里即到。

### 襄阳南漳水镜庄

南漳县城关镇榆树岭村，每年四五月份，漫山遍野的樱桃树结满了果实，一颗颗一串串晶莹剔透，甚是好看。

游客们或三五成群、或携家带口，在工作之余来这采摘，放松心情，尽情品尝自己亲手采摘的生态大樱桃。

这里的樱桃不施化肥、不打农药，完全原生态，樱桃色泽艳丽，晶莹美观，果肉柔软多汁，摘下无须清洗即可入口。

一个个红澄澄的，或者黄里透红的挂在绿叶中，晶莹剔透的像打了腊一般。沾染绿色的清香，往嘴里一放，满嘴的清甜滋味。


推荐项目：采摘、玩水划船
当地美食：襄阳豆腐面、襄阳大头菜
地址：襄阳市南漳县城关镇榆树岭村
路线：走麻竹高速，另有305，306省道横穿境内，焦枝、汉丹铁路与之毗邻，襄阳、老河口机场相距只有一百公里以内路程。

### 十堰郧县樱桃沟

樱桃沟村是湖北旅游名村，因盛产樱桃而得名。目前，该村樱桃和草莓种植面积2000多亩，基本上家家户户种有樱桃和草莓，形成了一道靓丽的乡村风景线。

除此之外，樱桃沟在三月到五月还有梅子花、山桃花、波斯菊和漫山遍野的野花，让你觉不虚此行。武汉自驾出发，高速和国道路况良好，无颠簸之苦，自助也很方便，就是车程稍长，建议两日游。

(樱桃沟原名鹰卧沟，在导航仪上设置时用后者更方便)

火车：历时在4-7个小时之间，动车二等座车票141元/人。

推荐项目：采摘、农家乐
当地美食：郧县三合汤  郧县酸浆面 郧县黄酒
地址：十堰市郧县樱桃沟
自驾方式：从武汉方向到樱桃沟可以沿汉十高速到十堰东出口出往郧县方向走郧十一级路，快到茶店镇时路左侧会看到樱桃沟村标和指路牌，左转两公里到达村委会广场，然后沿三条赏花线路分别欣赏其中美景。

### 宜昌文仙洞

宜昌文仙洞已经有了自己的樱桃品牌，文仙洞村于2009年成立了湖北省首家以樱桃种植、观赏、生产、包装、销售为一体的“仙女红樱桃”，樱桃的质量和口感都相当不错。

宜昌有众多的旅游景点和资源，采摘完樱桃，你完全可以根据宝贝的喜好和口味自由安排，逛逛仙境一般的三峡人家，乘船看看磅礴大气的两坝一峡都可以。

推荐项目：采摘、乘船、三峡人家
当地美食：萝卜饺子、凉虾、土家蒸肉
地址：宜昌文仙洞
路线：武汉上汉宜高速，在宜昌，沿下牢溪方向过桃花村风景区大概20米左右，在公路右手边有一村级公路，从那进去，然后见岔路口左转，大概车行10分钟左右即到。

# 漂流

## 通山太阳溪漂流  

太阳溪漂流位于湖北省通山县，武汉出城2小时，瞬间就能开启一场绝美刺激的大山深处原生态的峡谷漂流。

这里不仅仅有漂流越野，白天激流勇进、河滩越野；夜幕降临，多重乐趣的旅行才刚刚开始，篝火露营、露天电影、啤酒烧烤…

# 玻璃天桥

## 木兰天池玻璃天桥

华中唯一吊式跨山玻璃天桥位于黄陂区的木兰天池景区，狂拽酷炫的玻璃天桥18日已经正式面世啦，小伙伴是不是已经按耐不住内心的小激动，想要到玻璃天桥上蹦跶蹦跶了。

一座透明桥，横跨峡谷间。身处其间，极目远望，天池景色尽收眼底。远处是青山碧水，花香鸟语，身边是云雾微风，脚下是峡谷风情，无不带着别样韵味。木兰天池玻璃天桥全长168米，垂直高度100多米，据说有“一路发”的意思，约上情侣在玻璃天桥上走一走，说不定能一路发到头哦！整座桥都是玻璃为底，近百米的相对高度，在全透明玻璃的效果下，犹如深渊一般，纵横群山之间，恍若人间仙境。木兰天池玻璃天桥选用的特种夹胶玻璃，厚12mm*3，每块可承载350公斤。 共10根直径40mm的特种钢索，主索6跟、下索4根，拉力6吨/根。 桥墩基础2座、由500方混凝土浇灌而成，可承重上千吨的拉力。

## 丹江口太极峡玻璃桥

位于丹江口市太极峡景区，总长约150米。这座玻璃吊桥横跨青龙山、登龙山，上可观天池，下可览峡谷，行走其上彷如御风而行。它像一座“一夫当关，万夫莫开”的兵家胜地一样，脚下就是拥有“绝壁高耸，怪石嶙峋”的太极峡谷。走在桥上，透过全透明玻璃桥面，可以远望峡谷四周美景，也可以体验漫步高空的惊险刺激。

## 罗田玻璃栈道

罗田天堂寨景区玻璃栈道，是湖北省首条全透明玻璃栈道。行走栈道犹如凌空徒步，非常的惊险刺激。这里还有一条高达145米的垂直升降观光电梯，借助电梯和栈道，游客可以一分钟进入核心景区。

## 恩施狮子关水上栈道


恩施州宣恩县狮子关风景区内的漂浮式“水上栈道”长约500米，顺着蜿蜒的河道建设而成。行走在青山绿水间，感受山乡大自然的魅力。坐标：恩施土家族苗族自治州宣恩县狮子关风景区内

## 神农架飞云渡

神农架令人着迷的可不止有野人的传说，还有燕子垭山崖上的“云中天桥”。飞云渡是一座横亘燕子垭壑口上空的全钢结构的观景桥，横亘燕子垭壑口上，像悬挂在天空中的一道彩虹。坐标：湖北神农架燕天景区

## 宜昌绝壁栈道

仰头望是悬崖峭壁，俯瞰是绝壁深渊，清江方山绝壁栈道的建设者称之为“方山天路”。绝壁栈道的建成，把清江方山的奇峰、瀑布、山泉、怪石、洞穴、峡谷、盐道、道庙、亭阁等旖旎风光形成一线。坐标：湖北宜昌市长阳龙舟坪镇郑家榜村

## 五峰柴埠溪国家森林公园

一条清溪穿峡而过，峡谷两岸山石经过岁月的打磨，形成了众多奇峰异石。悬索吊桥的铁板是透视度高的钢化玻璃板，行走在上面，游客可以清楚的看见自己的倒影，透过玻璃还可以看见脚底下的万丈深渊。坐标：五峰县长乐坪蒿坪两乡交界处


# 蹦极

## 三峡蹦极

在这里蹦极可以验证一下本人是否拥有纵身一跃的勇气，还可以体验一次”投江而下“的悲壮！它的高度为61米，相当于二十多层楼的高度，是目前为止全国峡谷中的最高蹦极跳台。一旦跳下去，失重感和在高处飞翔的那种感觉，会让你心跳加速。坐标：宜昌长江三峡的西陵峡



---
]]></content>
      <categories>
        <category>Travel</category>
      </categories>
      <tags>
        <tag>Travel</tag>
        <tag>武汉</tag>
      </tags>
  </entry>
</search>
